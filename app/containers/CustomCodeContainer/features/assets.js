export const initialCode =
`// type your algorithm's logic code...
//
// variables you can use will appear as comments on top of
// this editor as you specify options from the right sidebar.`;

export const initialDescription =
'Add your algorithm\'s description here, you can use markdown';

export const initialPseudocode = [
	'# enter your algorithm\'s pseudo-code'
];

export const initialAlgName = 'Untitled Algorithm';

export const initialSaves = [{"name":"Custom Algorithm DFS Example","data":{"code":"// type your algorithm's logic code, variables you can use will appear as comments on top of\n// this editor as you specify options from the right sidebar. Below you see an example algorithm,\n// DFS, with a starting vertex option and 2 tables (called visiterd and recursion) added.\nconst { graph, startVertex: st } = input;\n\nconst vis2array = vis => Object.keys(vis)\n\t.map((k) => ((vis[k] !== true) ? -1 : k))\n\t.filter(v => (v !== -1));\n\nconst getNeighbors = (v) => graph.edges.map(o => {\n    if (o.source === v) {\n        return {\n            u: o.target,\n            edge: o.key\n        };\n    }\n    \n    if (o.undirected && o.target === v) {\n        return {\n            u: o.source,\n            edge: o.key\n        };\n    }\n}).filter(x => x);\n\nconst reclist = [];\nconst posEd = [];\nconst vis = graph.nodes.map(v => v.key).reduce((acc, v) => {\n\tacc[v] = false;\n\treturn acc;\n}, {});\n\n/**\n * snap is a normal function, but functions like this are very helpful, since manually typing\n * all algorithm things when you want to shoot a frame is very not DRY.\n *\n * at the end it calls 'frame' which shoots a frame.\n */\nconst snap = (a, b, c, d) => {\n    // these are kinda constants / or change according to a constant, no need for specific params for them\n\tAlgorithm.visited([Object.keys(vis), Object.keys(vis).map(k => vis[k].toString())]); // These two tables are added from the right sidebar, their names were specified there too\n\tAlgorithm.recursion([reclist]); // This is the other table, we are passing columns to it, you can see the API for detailed info\n\tAlgorithm.graph.setColor(0, vis2array(vis), posEd); // graph property is set, since the type is 'graph'\n\tAlgorithm.graph.setColor(1, reclist, []); // you can see its API for info\n\n\t// these change everytime, use params\n\tAlgorithm.code(a); // pseudo-code, a is the lines to highlight, [0, 1, ...]\n\tAlgorithm.explanation(b); // explanation is also in every algorithm, you must give a quick explanation; b is a string\n\tAlgorithm.graph.setColor(2, c, d);\n\tframe(); // when you are ready to make a frame, call the frame global.\n};\n\nconst dfs = v => {\n\tsnap([0], `Start DFS(${v})`, v); // we are shooting a frame here\n\tif (vis[v]) {\n\t\tsnap([1], `${v} is visited; return`, v); // here too\n\t\treturn;\n\t}\n\tvis[v] = true;\n\tsnap([2], `Mark ${v} visited`, v); // here too too :D\n\tgetNeighbors(v).forEach(({ u, edge }) => {\n\t\tsnap([3, 4], `For neighbour ${u} of ${v} do DFS`, v, edge);\n\t\treclist.push(u);\n\t\tdfs(u);\n\t\treclist.pop();\n\t\tposEd.push(edge);\n\t});\n\tsnap([5], `DFS(${v}) ended!`, v);\n};\nreclist.push(st);\nsnap([], undefined);\nsnap([7], `Starting main DFS from ${st}`, st);\ndfs(st);\nsnap([], `DFS from ${st} ended!`, st);\n\n// ps: the editor you are seeing here is ace, you can find it's default keyboard shortcuts here:\n// https://github.com/ajaxorg/ace/wiki/Default-Keyboard-Shortcuts","name":"Custom Algorithm DFS Example","type":"graph","typeFeatures":{"Starting Vertex":true},"pseudoCode":["DFS(v):","    if v is visited return","    mark v visited","    for every neighbour u of v:","        DFS(u)","    return","DFS(s)"],"description":"Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.\n\nA version of depth-first search was investigated in the 19th century by French mathematician Charles Pierre Tr√©maux as a strategy for solving mazes.","tables":[{"id":"recursion","columns":["Recursion"]},{"id":"visited","columns":["Nodes","Visited"]}],"debugConsole":[]}}]; // eslint-disable-line
