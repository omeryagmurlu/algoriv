!function(A){function e(t){if(n[t])return n[t].exports;var i=n[t]={i:t,l:!1,exports:{}};return A[t].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};e.m=A,e.c=n,e.i=function(A){return A},e.d=function(A,n,t){e.o(A,n)||Object.defineProperty(A,n,{configurable:!1,enumerable:!0,get:t})},e.n=function(A){var n=A&&A.__esModule?function(){return A.default}:function(){return A};return e.d(n,"a",n),n},e.o=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},e.p="dist/",e(e.s=272)}([function(A,e){A.exports=function(A){"undefined"!=typeof execScript?execScript(A):eval.call(null,A)}},function(A,e){A.exports=require("react")},function(A,e,n){"use strict";function t(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function i(A){var e=A.emptyCopy();return e.importNodes(A.exportNodes()),e.importEdges(A.exportUndirectedEdges()),A.directedEdges().forEach(function(n){var t=A.extremities(n),i=N(t,2),g=i[0],a=i[1];e.addDirectedEdgeWithKey(n,a,g,A.getAttributes(n))}),B(e.export())}n.d(e,"c",function(){return c}),e.m=i,n.d(e,"k",function(){return l}),n.d(e,"h",function(){return C}),n.d(e,"l",function(){return E}),n.d(e,"b",function(){return u}),n.d(e,"a",function(){return D}),n.d(e,"f",function(){return h}),n.d(e,"d",function(){return B}),n.d(e,"j",function(){return w}),n.d(e,"n",function(){return y}),n.d(e,"e",function(){return L}),n.d(e,"i",function(){return Q}),n.d(e,"g",function(){return p});var g=n(25),a=n.n(g),o=n(24),r=n.n(o),M=n(13),s=n.n(M),T=n(10),I=(n.n(T),n(241)),d=n.n(I),N=function(){function A(A,e){var n=[],t=!0,i=!1,g=void 0;try{for(var a,o=A[Symbol.iterator]();!(t=(a=o.next()).done)&&(n.push(a.value),!e||n.length!==e);t=!0);}catch(A){i=!0,g=A}finally{try{!t&&o.return&&o.return()}finally{if(i)throw g}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return A(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),c=function(A,e,n){return e.app.settings("options")("enabled-modules")(A).get()?n:null},l=function(A){return Object.keys(A).map(function(e){return!0!==A[e]?-1:e}).filter(function(A){return-1!==A})},C=function(A){return{Infinity:"âˆž"}[A.toString()]||A.toString()},E=d.a,u=function(A){return function(e){if(!T.themes[A][e])throw new ReferenceError(e+" is a non-existent style");return T.themes[A][e]}},D=function(A){if(!A)throw new ReferenceError("themedStyle: unknown style "+A);return function(e,n){var t=A[e+(n?"-"+n:"")]+(A[e]?" "+A[e]:"");if(!t)throw new ReferenceError("themedStyle: could'nt find: "+e+" in ["+Object.keys(A).join(" ,")+"]");return t}},x=function(){return!s.a.apply(void 0,arguments)},h={edgeKeyGenerator:function(A){return A.source+"->"+A.target+": "+m(0,1e5)}},B=function(A){var e=A.edges.find(function(A){return A.undirected})?"UndirectedGraph":"DirectedGraph",n=new r.a[e](h);return n.import(A),"undirected"===n.type&&(n.inNeighbors=n.outNeighbors=n.neighbors),n},w=function(A){return setTimeout(A,500)},y=function(A){return a()(A,function(A,e){return e.startsWith("on")})},m=function(A,e){return Math.random()*(e-A)+A},L=function(A,e){return Math.floor(Math.random()*(e-A))+A},Q=function A(e){return e.reduce(function(e,n){return e.concat(Array.isArray(n)?A(n):n)},[])},p=function A(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t(this,A),this.pushNode=function(n){return A.push(e.nodesList,[n])},this.pushNodes=function(n){return A.push(e.nodesList,n)},this.pushEdge=function(n){return A.push(e.edgesList,[n])},this.pushEdges=function(n){return A.push(e.edgesList,n)},this.setNode=function(n,t){return A.set(e.nodesList,t,[n])},this.setNodes=function(n,t){return A.set(e.nodesList,t,n)},this.setEdge=function(n,t){return A.set(e.edgesList,t,[n])},this.setEdges=function(n,t){return A.set(e.edgesList,t,n)},this.neededColorVariety=function(){return Math.max(e.edgesList.length,e.nodesList.length)},this.forEachEdge=function(n){return A.forEach(e.edgesList,n)},this.forEachNode=function(n){return A.forEach(e.nodesList,n)},this.nodesList=n,this.edgesList=i};p.revive=function(A){return new p(A.nodesList,A.edgesList)},p.push=function(A,e){return A.push(e.filter(x))},p.set=function(A,e,n){return A[e]=n.filter(x)},p.forEach=function(A,e){A.forEach(function(A,n){Array.isArray(A)&&A.forEach(function(A){return e(A,n)})})}},function(A,e){A.exports=require("prop-types")},function(A,e){function n(A,e){var n=A[1]||"",i=A[3];if(!i)return n;if(e&&"function"==typeof btoa){var g=t(i);return[n].concat(i.sources.map(function(A){return"/*# sourceURL="+i.sourceRoot+A+" */"})).concat([g]).join("\n")}return[n].join("\n")}function t(A){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(A))))+" */"}A.exports=function(A){var e=[];return e.toString=function(){return this.map(function(e){var t=n(e,A);return e[2]?"@media "+e[2]+"{"+t+"}":t}).join("")},e.i=function(A,n){"string"==typeof A&&(A=[[null,A,""]]);for(var t={},i=0;i<this.length;i++){var g=this[i][0];"number"==typeof g&&(t[g]=!0)}for(i=0;i<A.length;i++){var a=A[i];"number"==typeof a[0]&&t[a[0]]||(n&&!a[2]?a[2]=n:n&&(a[2]="("+a[2]+") and ("+n+")"),e.push(a))}},e}},function(A,e,n){function t(A,e){for(var n=0;n<A.length;n++){var t=A[n],i=N[t.id];if(i){i.refs++;for(var g=0;g<i.parts.length;g++)i.parts[g](t.parts[g]);for(;g<t.parts.length;g++)i.parts.push(s(t.parts[g],e))}else{for(var a=[],g=0;g<t.parts.length;g++)a.push(s(t.parts[g],e));N[t.id]={id:t.id,refs:1,parts:a}}}}function i(A){for(var e=[],n={},t=0;t<A.length;t++){var i=A[t],g=i[0],a=i[1],o=i[2],r=i[3],M={css:a,media:o,sourceMap:r};n[g]?n[g].parts.push(M):e.push(n[g]={id:g,parts:[M]})}return e}function g(A,e){var n=l(A.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var t=u[u.length-1];if("top"===A.insertAt)t?t.nextSibling?n.insertBefore(e,t.nextSibling):n.appendChild(e):n.insertBefore(e,n.firstChild),u.push(e);else{if("bottom"!==A.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(e)}}function a(A){A.parentNode.removeChild(A);var e=u.indexOf(A);e>=0&&u.splice(e,1)}function o(A){var e=document.createElement("style");return A.attrs.type="text/css",M(e,A.attrs),g(A,e),e}function r(A){var e=document.createElement("link");return A.attrs.type="text/css",A.attrs.rel="stylesheet",M(e,A.attrs),g(A,e),e}function M(A,e){Object.keys(e).forEach(function(n){A.setAttribute(n,e[n])})}function s(A,e){var n,t,i;if(e.singleton){var g=E++;n=C||(C=o(e)),t=T.bind(null,n,g,!1),i=T.bind(null,n,g,!0)}else A.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(n=r(e),t=d.bind(null,n,e),i=function(){a(n),n.href&&URL.revokeObjectURL(n.href)}):(n=o(e),t=I.bind(null,n),i=function(){a(n)});return t(A),function(e){if(e){if(e.css===A.css&&e.media===A.media&&e.sourceMap===A.sourceMap)return;t(A=e)}else i()}}function T(A,e,n,t){var i=n?"":t.css;if(A.styleSheet)A.styleSheet.cssText=x(e,i);else{var g=document.createTextNode(i),a=A.childNodes;a[e]&&A.removeChild(a[e]),a.length?A.insertBefore(g,a[e]):A.appendChild(g)}}function I(A,e){var n=e.css,t=e.media;if(t&&A.setAttribute("media",t),A.styleSheet)A.styleSheet.cssText=n;else{for(;A.firstChild;)A.removeChild(A.firstChild);A.appendChild(document.createTextNode(n))}}function d(A,e,n){var t=n.css,i=n.sourceMap,g=void 0===e.convertToAbsoluteUrls&&i;(e.convertToAbsoluteUrls||g)&&(t=D(t)),i&&(t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */");var a=new Blob([t],{type:"text/css"}),o=A.href;A.href=URL.createObjectURL(a),o&&URL.revokeObjectURL(o)}var N={},c=function(A){var e;return function(){return void 0===e&&(e=A.apply(this,arguments)),e}}(function(){return window&&document&&document.all&&!window.atob}),l=function(A){var e={};return function(n){return void 0===e[n]&&(e[n]=A.call(this,n)),e[n]}}(function(A){return document.querySelector(A)}),C=null,E=0,u=[],D=n(201);A.exports=function(A,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");e=e||{},e.attrs="object"==typeof e.attrs?e.attrs:{},void 0===e.singleton&&(e.singleton=c()),void 0===e.insertInto&&(e.insertInto="head"),void 0===e.insertAt&&(e.insertAt="bottom");var n=i(A);return t(n,e),function(A){for(var g=[],a=0;a<n.length;a++){var o=n[a],r=N[o.id];r.refs--,g.push(r)}if(A){t(i(A),e)}for(var a=0;a<g.length;a++){var r=g[a];if(0===r.refs){for(var M=0;M<r.parts.length;M++)r.parts[M]();delete N[r.id]}}}};var x=function(){var A=[];return function(e,n){return A[e]=n,A.filter(Boolean).join("\n")}}()},function(A,e,n){e=A.exports=n(4)(void 0),e.push([A.i,"@font-face{font-family:AnkaCoderC75Regular;src:url("+n(23)+");src:url("+n(23)+') format("embedded-opentype"),url('+n(224)+') format("woff2"),url('+n(223)+') format("woff"),url('+n(222)+') format("truetype"),url('+n(221)+'#AnkaCoderC75Regular) format("svg")}@font-face{font-family:Roboto;font-style:normal;font-weight:400;src:local("Roboto"),local("Roboto-Regular"),url('+n(230)+') format("woff2"),url('+n(229)+') format("woff")}@font-face{font-family:Slabo\\ 27px;font-style:normal;font-weight:400;src:local("Slabo 27px"),local("Slabo27px-Regular"),url('+n(232)+') format("woff2"),url('+n(231)+') format("woff")}@font-face{font-family:Raleway;font-style:normal;font-weight:400;src:local("Raleway"),local("Raleway-Regular"),url('+n(228)+') format("woff2"),url('+n(227)+') format("woff")}@font-face{font-family:Raleway;font-style:normal;font-weight:500;src:local("Raleway Medium"),local("Raleway-Medium"),url('+n(226)+') format("woff2"),url('+n(225)+') format("woff")}',""])},function(A,e,n){"use strict";function t(A){if(Array.isArray(A)){for(var e=0,n=Array(A.length);e<A.length;e++)n[e]=A[e];return n}return Array.from(A)}n.d(e,"a",function(){return M});var i=n(73),g=n(58),a=n(72),o=n(21),r=function(A,e){var t={create:function(){return n.i(g.a)(i)},set logic(A){i.logic=A},asView:function(){return{name:A,view:n.i(g.a)(i)}},algorithm:{}},i={info:{name:A},input:{},inputType:{},snap:function(){return r.reduce(function(A,e,n){return A[n]=e._internals.getSnap(),A},{})},modules:function(A){return r.reduce(function(e,n,t){return e[t]=n._internals.getModule(A),e},{})}},r=[],M=t.addInput=function(A,e,t){return i.input[A]=e,t&&(i.inputType[A]=i.inputType[A]||[],i.inputType[A].push(n.i(o.a)(t.description,t.invalid))),M},s=t.addModule=function(A){return r.push(A),A._internals.getInput(r.length-1).forEach(function(A){var e=A.id,n=A.inputType;i.inputType[e]=i.inputType[e]||[],i.inputType[e].push(n)}),s};return t.addDescription=function(A){s(C(A))},t.addCode=function(A){t.algorithm.code=d(A),s(t.algorithm.code)},t.addTable=function(A,e){t.algorithm[A]=c(e),s(t.algorithm[A])},t.addNodedTable=function(A,e){t.algorithm[A]=l(e),s(t.algorithm[A])},t.addText=function(A){t.algorithm[A]=N(),s(t.algorithm[A])},t.algorithm.explanation=N(),s(t.algorithm.explanation),"graph"===e&&(t.algorithm.graph=I([{id:"graph",input:"graph"},{id:"startVertex",input:"startNode"}])(),t.addStartingNodeInput=function(){M("startVertex","0",{description:"Starting Vertex",invalid:function(A,e){return!e.graph.hasNode(A)&&"node doesn't exist ("+A+")"}})},M("graph",n.i(a.a)(A).graph),s(t.algorithm.graph),s(E([{id:"graph"}])(n.i(a.b)(A)))),t},M={graph:[{name:"Starting Vertex",method:"addStartingNodeInput"}]},s=function(A){var e=A.mod,n=A.moduleArgs,g=A.shouldPassSettings,a=void 0!==g&&g,o=A.input,r=A.getSnaps,M=A.resetSnaps;return{getSnap:function(){var A,n=(A=i.a[e]).snap.apply(A,t(r()));return M(),n},getModule:function(A){var g;return(g=i.a[e]).module.apply(g,t(n).concat([a?A:void 0]))},getInput:function(A){return o.map(function(n){var t=n.id,g=n.input;return{id:t,inputType:g?i.a[e].input(A)[g]:i.a[e].input(A)}})}}},T=function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.shouldPassSettings;return function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return function(){for(var t=arguments.length,i=Array(t),g=0;g<t;g++)i[g]=arguments[g];var a=[],o=function(){for(var A=arguments.length,e=Array(A),n=0;n<A;n++)e[n]=arguments[n];a=e};return o._internals=s({mod:A,moduleArgs:i,shouldPassSettings:n,input:e,getSnaps:function(){return a},resetSnaps:function(){return a=[]}}),o}}},I=function(){var A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];var i=[[],[]];return{setColor:function(A,e,n){i[0][A]=e,i[1][A]=n},setGlyphs:function(A){i[2]=A},setOverrideGraph:function(A){i[3]=A},_internals:s({mod:"RefinedGraph",moduleArgs:n,input:A,getSnaps:function(){return i},resetSnaps:function(){return i=[[],[]]}})}}},d=T("Code")(),N=T("Text")(),c=T("Table")(),l=T("NodedTable")(),C=T("Description")(),E=T("ExampleGraphs",{shouldPassSettings:!0});e.b=r},function(A,e){A.exports=require("material-ui/FlatButton")},function(A,e,n){"use strict";n.d(e,"b",function(){return i}),n.d(e,"a",function(){return g});var t={},i=t.Graph={graph:"// these will be consumed by both algorithms and modules",startNode:"fdkljgsalfsjitnmjertiwoptjcvw8p9jwt3 83jp 84t greulg"},g=t.Examples="asddasfdsfgccafga541567t1b7yrba7eb176kitnlm7y80176p7687qwefga";e.c=t},function(A,e){A.exports={themes:{"giant-goldfish":{primary1Color:"#F38630",primary2Color:"#FA6900",accent1Color:"#009688",accent2Color:"#A7DBD8",textColor:"#434743",alternativeTextColor:"#E0E4CC",backgroundColor:"#E0E4CC"},dark:{primary1Color:"#946e58",primary2Color:"#D95B43",accent1Color:"#542437",accent2Color:"#ECD078",textColor:"#E0E4CC",alternativeTextColor:"#E0E4CC",backgroundColor:"#774F38"}}}},function(A,e){A.exports={drawerHandleWidth:"40px",footerHeight:"40px",headerHeight:"40px",viewportMargin:"60px",moduleMaxWidth:"300px",minWrapperWidth:"768px",uiFont:"'Raleway', 'Roboto', sans-serif",textFont:"'Slabo 27px', serif",monospaceFont:"'AnkaCoderC75Regular', monospace"}},function(A,e){A.exports=require("lodash.isequal")},function(A,e){A.exports=require("lodash.isnil")},function(A,e){A.exports=require("lodash.mapvalues")},function(A,e){A.exports=require("material-ui/IconButton")},function(A,e){A.exports=require("material-ui/MenuItem")},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(8),r=n.n(o),M=n(2),s=n(204),T=n.n(s),I=n(40),d=(n.n(I),Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A}),N=n.i(M.a)(T.a),c=function(A){return i.a.createElement("div",{className:N("container",A.theme),style:{width:"calc((100% - (("+I.margin+" * 2) * "+(A.cols-1)+")) / "+A.cols+")"}},i.a.createElement(r.a,d({label:"just to remove that warning"},n.i(M.n)(A))),i.a.createElement("div",{className:N("innerContainer")},i.a.createElement("div",d({className:N("primary",A.theme)},n.i(M.n)(A)),A.name),i.a.createElement("div",d({className:N("secondary",A.theme)},n.i(M.n)(A)),A.desc)))};c.defaultProps={cols:1,desc:null},c.propTypes={theme:a.a.string.isRequired,cols:a.a.number,name:a.a.string.isRequired,desc:a.a.string},e.a=c},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(250),r=n.n(o),M=n(15),s=n.n(M),T=n(16),I=n.n(T),d=n(264),N=n.n(d),c=n(2),l=n(206),C=n.n(l),E=n.i(c.a)(C.a),u=function(A,e,n,t){return i.a.createElement(I.a,{key:A,className:E("menu-item",n),rightIcon:i.a.createElement(e),onTouchTap:t},A)},D=function(A){return i.a.createElement(r.a,{anchorOrigin:{vertical:"center",horizontal:"middle"},iconButtonElement:i.a.createElement(s.a,{touch:!0},i.a.createElement(N.a,null)),menuStyle:{backgroundColor:n.i(c.b)(A.theme)("accent1Color")}},A.items.map(function(e){return u(e.name,e.icon,A.theme,e.onTouch)}))};a.a.defaultProps={items:[]},D.propTypes={theme:a.a.string.isRequired,items:a.a.arrayOf(a.a.shape({name:a.a.string.isRequired,icon:a.a.any.isRequired,onTouch:a.a.func.isRequired}))},e.a=D},function(A,e,n){"use strict";function t(A,e,n){return e in A?Object.defineProperty(A,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):A[e]=n,A}function i(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function g(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function a(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var o=n(1),r=n.n(o),M=n(3),s=n.n(M),T=n(243),I=n.n(T),d=n(2),N=n(8),c=n.n(N),l=n(262),C=n.n(l),E=n(261),u=n.n(E),D=n(207),x=n.n(D),h=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),B=n.i(d.a)(x.a),w=function(A){function e(A){i(this,e);var t=g(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return t.theme=function(A){return n.i(d.b)(t.props.theme)(A)},t.toggleActive=function(){t.setState(function(A){return A.active=!A.active,A})},t.state={active:!1},t}return a(e,A),h(e,[{key:"side",value:function(A,e){return"right"===this.props.side?A:e}},{key:"active",value:function(A,e){return this.state.active?e:A}},{key:"render",value:function(){var A;return r.a.createElement("aside",{className:I()((A={},t(A,B("par",this.props.theme),!0),t(A,this.side(B("right"),B("left")),!0),t(A,B("active"),this.state.active),A))},r.a.createElement("section",{className:B("container")},this.props.children),r.a.createElement("div",{className:B("handle")},r.a.createElement(c.a,{label:"just to remove that warning",onClick:this.toggleActive}),r.a.createElement(this.side(u.a,C.a),{className:B("handleIcon"),color:this.theme("alternativeTextColor")})))}}]),e}(o.Component);w.defaultProps={children:null},w.propTypes={theme:s.a.string.isRequired,side:s.a.oneOf(["right","left"]).isRequired,children:s.a.any},e.a=w},function(A,e,n){"use strict";var t=n(48),i=n(57),g=n(55),a=n(56),o=n(49),r=n(50),M={code:t.a,text:i.a,graph:g.a,table:a.a,description:o.a,examples:r.a};e.a=M},function(A,e,n){"use strict";n.d(e,"b",function(){return t}),n.d(e,"a",function(){return i});var t=function(A,e,n){return{type:"module",invalid:function(){return!1},data:{moduleName:A,targetModule:e,inputIdentifier:n}}},i=function(A){return{type:"init",invalid:arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){return!1},data:{description:A}}}},function(A,e,n){"use strict";n.d(e,"a",function(){return i}),n.d(e,"b",function(){return g});var t=n(2),i=function(A){return{listStyle:{backgroundColor:n.i(t.b)(A)("primary2Color")},floatingLabelStyle:{color:n.i(t.b)(A)("textColor")},underlineStyle:{display:"none"},iconStyle:{fill:n.i(t.b)(A)("textColor")}}},g=function(){return{style:{lineHeight:"36px"}}}},function(A,e){A.exports="data:application/vnd.ms-fontobject;base64,PgEBAFQAAQABAAIAAAAAAAILBQkCBQICAgQBAJABAAAAAExQ7wIAgOt5AAAAAAAAAAAAAJcAAEAAANbP45/HUwAAAAAAAAAAAAAAAAAAAAAAACYAQQBuAGsAYQBDAG8AZABlAHIAQwA3ADUAUgBlAGcAdQBsAGEAcgAAAA4AUgBlAGcAdQBsAGEAcgAAACAAVgBlAHIAcwBpAG8AbgAgADAAMAAxAC4AMQAwADAAIAAAADIAQQBuAGsAYQAvAEMAbwBkAGUAcgAgAE4AYQByAHIAbwB3ACAAUgBlAGcAdQBsAGEAcgAAAAAAAAEAAAARAQAABAAQQkFTRQAJAAQAAQAoAAAADkZGVE1oDdDWAAEAOAAAABxHREVGACcCcgABAAgAAAAeT1MvMvFyFigAAAGYAAAAYGNtYXCiSsBJAAAG2AAABLZjdnQgDSEVLgAADIAAAAAYZnBnbTJKZpgAAAuQAAAAx2dhc3AAGAAJAAD/+AAAABBnbHlmuBhQkgAAEXQAAI2YaGVhZPcVHfgAAAEcAAAANmhoZWEK9ADaAAABVAAAACRobXR4ilh/SQAAAfgAAATgbG9jYRce874AAAyYAAAE2m1heHAD3wJTAAABeAAAACBuYW1lgRbhDgAAnwwAAEz1cG9zdDnaGaIAAOwEAAAT83ByZXCaNsMhAAAMWAAAACgAAQAAAAEZmVPHn+NfDzz1AB8IAAAAAADHRuSOAAAAAMyu1jb/9P2ZA/gHBQAAAAgAAgAAAAAAAAABAAAHBf2ZAAADmv/0/6ID+AABAAAAAAAAAAAAAAAAAAAABAABAAACbAEiAEgA/gAeAAIAAQAAAAkAAAEAAC4AAgADAAQDmgGQAAMACAIpBM0AAAEbAikEzQAAA9EAZgISBQUCCwUJAgUCAgIEgAAC7wAAeesAAAAAAAAAAEFWTTEAwAAgJmsGZv5mAAAHBQJnQAAAl8/WAAAEAAV4AAAAIAABA5oARAAAAAADmgAAA5oAAAE3ABQAFQBAABEAQAEsARMAhwAnADIBJgAyAToAcAALAPAAfABrAFoAVABrAFoAawBrAToBJgBaADIAWgBrACUAWABrAGEAawBrAGsAYQBrAFoASwBsAGsAGgBrAGEAawBhAFkAQABGAGsAVgAaAF4AWgBaARMAcAC2AHgAWgDcAGsAawBrAGsAawBaAGsAawC2ANkAawC2AEMAawBhAGsAawBrAE0AWgBrAGQAHABhAFMAVwBaAYIAWgBDAAABNwBrADIAOwBaAYIAawBpAA4AWgBhADIA3gAOAOYAoQAyAQkAygD9AEYATQE6APsBOQBaAFYAAwADAAAAawBYAFgAWABYAFgAWAAQAGEAawBrAGsAaQBaAFoAWgBaACoAawBhAGEAYQBhAGEAdAALAGsAawBrAGkAWgBrAGsAawBrAGsAawBrAGsAGgBrAGsAawBrAGsAtgC2ALYAcgBrAGsAYQBhAGEAYQBhADIATwBrAGsAawBpAFMAawBTAFgAawBYAGsAWABrAGEAawBhAGsAYQBrAGEAawBrAA4AKgBrAGsAawBrAGsAawBrAGsAawBrAGsAYQBrAGEAawBhAGsAYQBrAGsAawA8ADwAWgB2AFoAtgBaALQAWgC2AFoAtgAoADgASwDZAGwAawBrAGsAtgBrALYAawBwAGsAcAAOAIYAawBrAGsAawBrAGv/9ABrAGsAYQBhAGEAYQAsABkAGgAaAFkAawBZAEAAWQBrAEAATQBAAE0AQABNAEAATQBGAFoARgBaAEYAWgBrAGsAawBrAGsAawBrAGsAOgBEAGsAawAaABwAWgBTAFoAWgBXAFoAVwBaAFcATQAZANkA2gDaAOoBJACrAVQA+wElAHr//gEkAOgAegBpAO4A2gD7AkcBWQE1AOgAWABrAGsAWQBrAFoAawBhAFoAbABUABoAawBrAGEAawBrAFoARgBaADYAXgBXAFoAWgBaAGEAawBrALYAaQBhAGsAaABrAGsAawBrAGEAtgBrAGgARgBkAGsAYQBaAGsAawBhAFoAawA5AFgAOQBDAGoAaQBhAGsAQwBrAGsA2QBrAGkARgBrAGEAQABaAFoASwA0ADoARgBsAGsAXABrAFgAawBrAGsALwBrACUAVwBrAGsAbABDABoAawBhAGsAawBhAEYAXAA2AF4AawBrADkAOQA8AE0AawCEADkAPwBrAGsAawBNAC8AawAVAGsAawBrAGsARwAbAGsAYQBrAGsAawBGAFMANgBhAGsAawBDAEMAPAA5AGsAbgBDADwAawBrAB4ATQB7AE0AtgB0ANkANgBDAAIAawBrAFMAawE2AUoBJgFAAIEAagBSAFoAWgEPAE0BLwBqAFoAWgBwAHYAnwA8AA8AJAAy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C7gL9AwuDFwMzgz0DQANDA0oDTwNdA2aDd4OGA5UDnQOwA7wDxYPKg9GD2QPjg+mD9wP6hAeEEoQShBUEJQQ+BFAEWoRfhHkEggSWBKiEsYS1hLkEz4TSBNwE5ATwhQAFBAUSBRmFHoUoBS0FOoVDhU+FYwV8BX6FgYWEhYeFioWNhZCFm4WehaGFpIWnhaqFrYWwhbOFtoXEhceFyoXNhdCF04XWhd2F34XiheWF6IXrhe6F94YJhgyGD4YShhWGGIYbhjEGNAY3BjoGPQZABkMGRgZJBkwGYAZjBmYGaQZsBm8GcgZ8hpCGk4aWhpmGnIafhqyGr4ayhrWGuIa7hr6GwYbEhseGyobNhtCG04bWhtmG3IbgBuIG8wb2BvkG/Ab/BwIHBQcIBwsHDgcRBxQHFwcaBx0HIAcjByYHKQcsBy8HOIdEB0cHSgdNB1AHUwdWB1kHXAdfB2QHbgdxB3QHdwd6B30HfweCB4WHiIeLh46HkYeUh5eHnwenB6oHrQewB7MHtge5B7wHyAfVB9gH2wfeB+EH5AfnB/YICQgMCA8IEggVCBgIGwgeCCEIJAgnCCoILQgwCDMINgg5CDwIPwhGiFQIVwhaCF0IYAhjCGYIaYhsiG+Icoh1iHiIe4h+iIGIhIiHiIqIjYiQiJOIloiZiJuIqgixiLaIuwi+iMKIyQjNiNUI3gjqiO4I8gj2CQKJC4kUiRkJIoklCSmJLAkuCTAJMgk0CTmJO4k9iT+JUIlSiVSJWQlbCV0JZoloiWqJbIlziXWJd4l5iXuJhwmWiZmJnImfiaKJpYmoiauJuYnMidKJ4on0CgWKDwogiiKKJIoqCiwKLgpECkYKUQpfim8KgQqKipYKpQqxCrwK0YrUiteK2ordiuCK4orkiuaK6YrsivoK/QsPixGLE4sWixiLJYsxiz2LQItDi0aLTItOi1kLWwtfC2mLa4t1C4aLjAuPC5ELmIuai5yLnoujC6ULpwupC7OLxYvHi84L1Ivai+IL7Qv4DAIME4wjDC4MMAxCjFAMY4xtjG+MeYyMjJIMlQycDKMMqgywDLIMtAy2DLgMvQy/DM8M0QzejOgM9o0IDRMNHo0pDTgNSY1VjViNW41rDW4NfA1+DYANgw2FDZONno2hjaSNp42qjbCNsw21jbgNv43DDcWNyQ3PDdgN3Y3qjeyN7o3wjfK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ACAATgBhAG0AZQAgAEEAbgBrAGEALwBDAG8AZABlAHIAIABOAGEAcgByAG8AdwAuAAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ACgBUAGgAZQAgAEEAbgBrAGEALwAqACAAYQByAGUAIABtAGUAbQBiAGUAcgBzACAAbwBmACAAQQBuAG4AYQAgAFMAaAB1AGcAbwBsACAAbgBhAG0AZQAgAGYAbwBuAHQAIABmAGEAbQBpAGwAeQA7ACAATQBhAHIAYwBoACAAMgAwADEAMAAAQ29weXJpZ2h0IChjKSAyMDEwLCBBbmRyZXkgTWFrYXJvdiAobWFrYXJvdkBibXN0dS5ydSwgbWthLWF0LW1haWxydUBtYWlsLnJ1KSwKd2l0aCBSZXNlcnZlZCBGb250IE5hbWUgQW5rYS9Db2RlciBOYXJyb3cuCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpUaGUgQW5rYS8qIGFyZSBtZW1iZXJzIG9mIEFubmEgU2h1Z29sIG5hbWUgZm9udCBmYW1pbHk7IE1hcmNoIDIwMTAAAEEAbgBrAGEAQwBvAGQAZQByAEMANwA1AFIAZQBnAHUAbABhAHIAAEFua2FDb2RlckM3NVJlZ3VsYXIAAFIAZQBnAHUAbABhAHIAAFJlZ3VsYXIAAEYAbwBuAHQARgBvAHIAZwBlACAAMgAuADAAIAA6ACAAQQBuAGsAYQAvAEMAbwBkAGUAcgAgAE4AYQByAHIAbwB3ACAAUgBlAGcAdQBsAGEAcgAgADoAIAAxADYALQA1AC0AMgAwADEANwAARm9udEZvcmdlIDIuMCA6IEFua2EvQ29kZXIgTmFycm93IFJlZ3VsYXIgOiAxNi01LTIwMTcAAEEAbgBrAGEALwBDAG8AZABlAHIAIABOAGEAcgByAG8AdwAgAFIAZQBnAHUAbABhAHIAAEFua2EvQ29kZXIgTmFycm93IFJlZ3VsYXIAAFYAZQByAHMAaQBvAG4AIAAwADAAMQAuADEAMAAwACAAAFZlcnNpb24gMDAxLjEwMCAAAEEAbgBrAGEAQwBvAGQAZQByAEMANwA1AFIAZQBnAHUAbABhAHIAAEFua2FDb2RlckM3NVJlZ3VsYXIAAEMAbwBwAHkAcgBpAGcAaAB0ACAAKABjACkAIAAyADAAMQAwACwAIABBAG4AZAByAGUAeQAgAE0AYQBrAGEAcgBvAHYAIAAoAG0AYQBrAGEAcgBvAHYAQABiAG0AcwB0AHUALgByAHUALAAgAG0AawBhAC0AYQB0AC0AbQBhAGkAbAByAHUAQABtAGEAaQBsAC4AcgB1ACkALAAKAHcAaQB0AGgAIABSAGUAcwBlAHIAdgBlAGQAIABGAG8AbgB0ACAATgBhAG0AZQAgAEEAbgBrAGEALwBDAG8AZABlAHIAIABOAGEAcgByAG8AdwAuAAoACgBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuAAoAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABjAG8AcABpAGUAZAAgAGIAZQBsAG8AdwAsACAAYQBuAGQAIABpAHMAIABhAGwAcwBvACAAYQB2AGEAaQBsAGEAYgBsAGUAIAB3AGkAdABoACAAYQAgAEYAQQBRACAAYQB0ADoACgBoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwACgAKAAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAAoAUwBJAEwAIABPAFAARQBOACAARgBPAE4AVAAgAEwASQBDAEUATgBTAEUAIABWAGUAcgBzAGkAbwBuACAAMQAuADEAIAAtACAAMgA2ACAARgBlAGIAcgB1AGEAcgB5ACAAMgAwADAANwAKAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAKAAoAUABSAEUAQQBNAEIATABFAAoAVABoAGUAIABnAG8AYQBsAHMAIABvAGYAIAB0AGgAZQAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAgACgATwBGAEwAKQAgAGEAcgBlACAAdABvACAAcwB0AGkAbQB1AGwAYQB0AGUAIAB3AG8AcgBsAGQAdwBpAGQAZQAKAGQAZQB2AGUAbABvAHAAbQBlAG4AdAAgAG8AZgAgAGMAbwBsAGwAYQBiAG8AcgBhAHQAaQB2AGUAIABmAG8AbgB0ACAAcAByAG8AagBlAGMAdABzACwAIAB0AG8AIABzAHUAcABwAG8AcgB0ACAAdABoAGUAIABmAG8AbgB0ACAAYwByAGUAYQB0AGkAbwBuAAoAZQBmAGYAbwByAHQAcwAgAG8AZgAgAGEAYwBhAGQAZQBtAGkAYwAgAGEAbgBkACAAbABpAG4AZwB1AGkAcwB0AGkAYwAgAGMAbwBtAG0AdQBuAGkAdABpAGUAcwAsACAAYQBuAGQAIAB0AG8AIABwAHIAbwB2AGkAZABlACAAYQAgAGYAcgBlAGUAIABhAG4AZAAKAG8AcABlAG4AIABmAHIAYQBtAGUAdwBvAHIAawAgAGkAbgAgAHcAaABpAGMAaAAgAGYAbwBuAHQAcwAgAG0AYQB5ACAAYgBlACAAcwBoAGEAcgBlAGQAIABhAG4AZAAgAGkAbQBwAHIAbwB2AGUAZAAgAGkAbgAgAHAAYQByAHQAbgBlAHIAcwBoAGkAcAAKAHcAaQB0AGgAIABvAHQAaABlAHIAcwAuAAoACgBUAGgAZQAgAE8ARgBMACAAYQBsAGwAbwB3AHMAIAB0AGgAZQAgAGwAaQBjAGUAbgBzAGUAZAAgAGYAbwBuAHQAcwAgAHQAbwAgAGIAZQAgAHUAcwBlAGQALAAgAHMAdAB1AGQAaQBlAGQALAAgAG0AbwBkAGkAZgBpAGUAZAAgAGEAbgBkAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGYAcgBlAGUAbAB5ACAAYQBzACAAbABvAG4AZwAgAGEAcwAgAHQAaABlAHkAIABhAHIAZQAgAG4AbwB0ACAAcwBvAGwAZAAgAGIAeQAgAHQAaABlAG0AcwBlAGwAdgBlAHMALgAgAFQAaABlAAoAZgBvAG4AdABzACwAIABpAG4AYwBsAHUAZABpAG4AZwAgAGEAbgB5ACAAZABlAHIAaQB2AGEAdABpAHYAZQAgAHcAbwByAGsAcwAsACAAYwBhAG4AIABiAGUAIABiAHUAbgBkAGwAZQBkACwAIABlAG0AYgBlAGQAZABlAGQALAAgAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGEAbgBkAC8AbwByACAAcwBvAGwAZAAgAHcAaQB0AGgAIABhAG4AeQAgAHMAbwBmAHQAdwBhAHIAZQAgAHAAcgBvAHYAaQBkAGUAZAAgAHQAaABhAHQAIABhAG4AeQAgAHIAZQBzAGUAcgB2AGUAZAAKAG4AYQBtAGUAcwAgAGEAcgBlACAAbgBvAHQAIAB1AHMAZQBkACAAYgB5ACAAZABlAHIAaQB2AGEAdABpAHYAZQAgAHcAbwByAGsAcwAuACAAVABoAGUAIABmAG8AbgB0AHMAIABhAG4AZAAgAGQAZQByAGkAdgBhAHQAaQB2AGUAcwAsAAoAaABvAHcAZQB2AGUAcgAsACAAYwBhAG4AbgBvAHQAIABiAGUAIAByAGUAbABlAGEAcwBlAGQAIAB1AG4AZABlAHIAIABhAG4AeQAgAG8AdABoAGUAcgAgAHQAeQBwAGUAIABvAGYAIABsAGkAYwBlAG4AcwBlAC4AIABUAGgAZQAKAHIAZQBxAHUAaQByAGUAbQBlAG4AdAAgAGYAbwByACAAZgBvAG4AdABzACAAdABvACAAcgBlAG0AYQBpAG4AIAB1AG4AZABlAHIAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGQAbwBlAHMAIABuAG8AdAAgAGEAcABwAGwAeQAKAHQAbwAgAGEAbgB5ACAAZABvAGMAdQBtAGUAbgB0ACAAYwByAGUAYQB0AGUAZAAgAHUAcwBpAG4AZwAgAHQAaABlACAAZgBvAG4AdABzACAAbwByACAAdABoAGUAaQByACAAZABlAHIAaQB2AGEAdABpAHYAZQBzAC4ACgAKAEQARQBGAEkATgBJAFQASQBPAE4AUwAKACIARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAiACAAcgBlAGYAZQByAHMAIAB0AG8AIAB0AGgAZQAgAHMAZQB0ACAAbwBmACAAZgBpAGwAZQBzACAAcgBlAGwAZQBhAHMAZQBkACAAYgB5ACAAdABoAGUAIABDAG8AcAB5AHIAaQBnAGgAdAAKAEgAbwBsAGQAZQByACgAcwApACAAdQBuAGQAZQByACAAdABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABhAG4AZAAgAGMAbABlAGEAcgBsAHkAIABtAGEAcgBrAGUAZAAgAGEAcwAgAHMAdQBjAGgALgAgAFQAaABpAHMAIABtAGEAeQAKAGkAbgBjAGwAdQBkAGUAIABzAG8AdQByAGMAZQAgAGYAaQBsAGUAcwAsACAAYgB1AGkAbABkACAAcwBjAHIAaQBwAHQAcwAgAGEAbgBkACAAZABvAGMAdQBtAGUAbgB0AGEAdABpAG8AbgAuAAoACgAiAFIAZQBzAGUAcgB2AGUAZAAgAEYAbwBuAHQAIABOAGEAbQBlACIAIAByAGUAZgBlAHIAcwAgAHQAbwAgAGEAbgB5ACAAbgBhAG0AZQBzACAAcwBwAGUAYwBpAGYAaQBlAGQAIABhAHMAIABzAHUAYwBoACAAYQBmAHQAZQByACAAdABoAGUACgBjAG8AcAB5AHIAaQBnAGgAdAAgAHMAdABhAHQAZQBtAGUAbgB0ACgAcwApAC4ACgAKACIATwByAGkAZwBpAG4AYQBsACAAVgBlAHIAcwBpAG8AbgAiACAAcgBlAGYAZQByAHMAIAB0AG8AIAB0AGgAZQAgAGMAbwBsAGwAZQBjAHQAaQBvAG4AIABvAGYAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAYwBvAG0AcABvAG4AZQBuAHQAcwAgAGEAcwAKAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGIAeQAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAuAAoACgAiAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AIgAgAHIAZQBmAGUAcgBzACAAdABvACAAYQBuAHkAIABkAGUAcgBpAHYAYQB0AGkAdgBlACAAbQBhAGQAZQAgAGIAeQAgAGEAZABkAGkAbgBnACAAdABvACwAIABkAGUAbABlAHQAaQBuAGcALAAKAG8AcgAgAHMAdQBiAHMAdABpAHQAdQB0AGkAbgBnACAALQAtACAAaQBuACAAcABhAHIAdAAgAG8AcgAgAGkAbgAgAHcAaABvAGwAZQAgAC0ALQAgAGEAbgB5ACAAbwBmACAAdABoAGUAIABjAG8AbQBwAG8AbgBlAG4AdABzACAAbwBmACAAdABoAGUACgBPAHIAaQBnAGkAbgBhAGwAIABWAGUAcgBzAGkAbwBuACwAIABiAHkAIABjAGgAYQBuAGcAaQBuAGcAIABmAG8AcgBtAGEAdABzACAAbwByACAAYgB5ACAAcABvAHIAdABpAG4AZwAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAHQAbwAgAGEACgBuAGUAdwAgAGUAbgB2AGkAcgBvAG4AbQBlAG4AdAAuAAoACgAiAEEAdQB0AGgAbwByACIAIAByAGUAZgBlAHIAcwAgAHQAbwAgAGEAbgB5ACAAZABlAHMAaQBnAG4AZQByACwAIABlAG4AZwBpAG4AZQBlAHIALAAgAHAAcgBvAGcAcgBhAG0AbQBlAHIALAAgAHQAZQBjAGgAbgBpAGMAYQBsAAoAdwByAGkAdABlAHIAIABvAHIAIABvAHQAaABlAHIAIABwAGUAcgBzAG8AbgAgAHcAaABvACAAYwBvAG4AdAByAGkAYgB1AHQAZQBkACAAdABvACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlAC4ACgAKAFAARQBSAE0ASQBTAFMASQBPAE4AIAAmACAAQwBPAE4ARABJAFQASQBPAE4AUwAKAFAAZQByAG0AaQBzAHMAaQBvAG4AIABpAHMAIABoAGUAcgBlAGIAeQAgAGcAcgBhAG4AdABlAGQALAAgAGYAcgBlAGUAIABvAGYAIABjAGgAYQByAGcAZQAsACAAdABvACAAYQBuAHkAIABwAGUAcgBzAG8AbgAgAG8AYgB0AGEAaQBuAGkAbgBnAAoAYQAgAGMAbwBwAHkAIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALAAgAHQAbwAgAHUAcwBlACwAIABzAHQAdQBkAHkALAAgAGMAbwBwAHkALAAgAG0AZQByAGcAZQAsACAAZQBtAGIAZQBkACwAIABtAG8AZABpAGYAeQAsAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUALAAgAGEAbgBkACAAcwBlAGwAbAAgAG0AbwBkAGkAZgBpAGUAZAAgAGEAbgBkACAAdQBuAG0AbwBkAGkAZgBpAGUAZAAgAGMAbwBwAGkAZQBzACAAbwBmACAAdABoAGUAIABGAG8AbgB0AAoAUwBvAGYAdAB3AGEAcgBlACwAIABzAHUAYgBqAGUAYwB0ACAAdABvACAAdABoAGUAIABmAG8AbABsAG8AdwBpAG4AZwAgAGMAbwBuAGQAaQB0AGkAbwBuAHMAOgAKAAoAMQApACAATgBlAGkAdABoAGUAcgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAG4AbwByACAAYQBuAHkAIABvAGYAIABpAHQAcwAgAGkAbgBkAGkAdgBpAGQAdQBhAGwAIABjAG8AbQBwAG8AbgBlAG4AdABzACwACgBpAG4AIABPAHIAaQBnAGkAbgBhAGwAIABvAHIAIABNAG8AZABpAGYAaQBlAGQAIABWAGUAcgBzAGkAbwBuAHMALAAgAG0AYQB5ACAAYgBlACAAcwBvAGwAZAAgAGIAeQAgAGkAdABzAGUAbABmAC4ACgAKADIAKQAgAE8AcgBpAGcAaQBuAGEAbAAgAG8AcgAgAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AcwAgAG8AZgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAG0AYQB5ACAAYgBlACAAYgB1AG4AZABsAGUAZAAsAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGEAbgBkAC8AbwByACAAcwBvAGwAZAAgAHcAaQB0AGgAIABhAG4AeQAgAHMAbwBmAHQAdwBhAHIAZQAsACAAcAByAG8AdgBpAGQAZQBkACAAdABoAGEAdAAgAGUAYQBjAGgAIABjAG8AcAB5AAoAYwBvAG4AdABhAGkAbgBzACAAdABoAGUAIABhAGIAbwB2AGUAIABjAG8AcAB5AHIAaQBnAGgAdAAgAG4AbwB0AGkAYwBlACAAYQBuAGQAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAuACAAVABoAGUAcwBlACAAYwBhAG4AIABiAGUACgBpAG4AYwBsAHUAZABlAGQAIABlAGkAdABoAGUAcgAgAGEAcwAgAHMAdABhAG4AZAAtAGEAbABvAG4AZQAgAHQAZQB4AHQAIABmAGkAbABlAHMALAAgAGgAdQBtAGEAbgAtAHIAZQBhAGQAYQBiAGwAZQAgAGgAZQBhAGQAZQByAHMAIABvAHIACgBpAG4AIAB0AGgAZQAgAGEAcABwAHIAbwBwAHIAaQBhAHQAZQAgAG0AYQBjAGgAaQBuAGUALQByAGUAYQBkAGEAYgBsAGUAIABtAGUAdABhAGQAYQB0AGEAIABmAGkAZQBsAGQAcwAgAHcAaQB0AGgAaQBuACAAdABlAHgAdAAgAG8AcgAKAGIAaQBuAGEAcgB5ACAAZgBpAGwAZQBzACAAYQBzACAAbABvAG4AZwAgAGEAcwAgAHQAaABvAHMAZQAgAGYAaQBlAGwAZABzACAAYwBhAG4AIABiAGUAIABlAGEAcwBpAGwAeQAgAHYAaQBlAHcAZQBkACAAYgB5ACAAdABoAGUAIAB1AHMAZQByAC4ACgAKADMAKQAgAE4AbwAgAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABtAGEAeQAgAHUAcwBlACAAdABoAGUAIABSAGUAcwBlAHIAdgBlAGQAIABGAG8AbgB0AAoATgBhAG0AZQAoAHMAKQAgAHUAbgBsAGUAcwBzACAAZQB4AHAAbABpAGMAaQB0ACAAdwByAGkAdAB0AGUAbgAgAHAAZQByAG0AaQBzAHMAaQBvAG4AIABpAHMAIABnAHIAYQBuAHQAZQBkACAAYgB5ACAAdABoAGUAIABjAG8AcgByAGUAcwBwAG8AbgBkAGkAbgBnAAoAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAuACAAVABoAGkAcwAgAHIAZQBzAHQAcgBpAGMAdABpAG8AbgAgAG8AbgBsAHkAIABhAHAAcABsAGkAZQBzACAAdABvACAAdABoAGUAIABwAHIAaQBtAGEAcgB5ACAAZgBvAG4AdAAgAG4AYQBtAGUAIABhAHMACgBwAHIAZQBzAGUAbgB0AGUAZAAgAHQAbwAgAHQAaABlACAAdQBzAGUAcgBzAC4ACgAKADQAKQAgAFQAaABlACAAbgBhAG0AZQAoAHMAKQAgAG8AZgAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAgAG8AcgAgAHQAaABlACAAQQB1AHQAaABvAHIAKABzACkAIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQACgBTAG8AZgB0AHcAYQByAGUAIABzAGgAYQBsAGwAIABuAG8AdAAgAGIAZQAgAHUAcwBlAGQAIAB0AG8AIABwAHIAbwBtAG8AdABlACwAIABlAG4AZABvAHIAcwBlACAAbwByACAAYQBkAHYAZQByAHQAaQBzAGUAIABhAG4AeQAKAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4ALAAgAGUAeABjAGUAcAB0ACAAdABvACAAYQBjAGsAbgBvAHcAbABlAGQAZwBlACAAdABoAGUAIABjAG8AbgB0AHIAaQBiAHUAdABpAG8AbgAoAHMAKQAgAG8AZgAgAHQAaABlAAoAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAgAGEAbgBkACAAdABoAGUAIABBAHUAdABoAG8AcgAoAHMAKQAgAG8AcgAgAHcAaQB0AGgAIAB0AGgAZQBpAHIAIABlAHgAcABsAGkAYwBpAHQAIAB3AHIAaQB0AHQAZQBuAAoAcABlAHIAbQBpAHMAcwBpAG8AbgAuAAoACgA1ACkAIABUAGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALAAgAG0AbwBkAGkAZgBpAGUAZAAgAG8AcgAgAHUAbgBtAG8AZABpAGYAaQBlAGQALAAgAGkAbgAgAHAAYQByAHQAIABvAHIAIABpAG4AIAB3AGgAbwBsAGUALAAKAG0AdQBzAHQAIABiAGUAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABlAG4AdABpAHIAZQBsAHkAIAB1AG4AZABlAHIAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAsACAAYQBuAGQAIABtAHUAcwB0ACAAbgBvAHQAIABiAGUACgBkAGkAcwB0AHIAaQBiAHUAdABlAGQAIAB1AG4AZABlAHIAIABhAG4AeQAgAG8AdABoAGUAcgAgAGwAaQBjAGUAbgBzAGUALgAgAFQAaABlACAAcgBlAHEAdQBpAHIAZQBtAGUAbgB0ACAAZgBvAHIAIABmAG8AbgB0AHMAIAB0AG8ACgByAGUAbQBhAGkAbgAgAHUAbgBkAGUAcgAgAHQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAZABvAGUAcwAgAG4AbwB0ACAAYQBwAHAAbAB5ACAAdABvACAAYQBuAHkAIABkAG8AYwB1AG0AZQBuAHQAIABjAHIAZQBhAHQAZQBkAAoAdQBzAGkAbgBnACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlAC4ACgAKAFQARQBSAE0ASQBOAEEAVABJAE8ATgAKAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAYgBlAGMAbwBtAGUAcwAgAG4AdQBsAGwAIABhAG4AZAAgAHYAbwBpAGQAIABpAGYAIABhAG4AeQAgAG8AZgAgAHQAaABlACAAYQBiAG8AdgBlACAAYwBvAG4AZABpAHQAaQBvAG4AcwAgAGEAcgBlAAoAbgBvAHQAIABtAGUAdAAuAAoACgBEAEkAUwBDAEwAQQBJAE0ARQBSAAoAVABIAEUAIABGAE8ATgBUACAAUwBPAEYAVABXAEEAUgBFACAASQBTACAAUABSAE8AVgBJAEQARQBEACAAIgBBAFMAIABJAFMAIgAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQAWQAgAE8ARgAgAEEATgBZACAASwBJAE4ARAAsAAoARQBYAFAAUgBFAFMAUwAgAE8AUgAgAEkATQBQAEwASQBFAEQALAAgAEkATgBDAEwAVQBEAEkATgBHACAAQgBVAFQAIABOAE8AVAAgAEwASQBNAEkAVABFAEQAIABUAE8AIABBAE4AWQAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAEYACgBNAEUAUgBDAEgAQQBOAFQAQQBCAEkATABJAFQAWQAsACAARgBJAFQATgBFAFMAUwAgAEYATwBSACAAQQAgAFAAQQBSAFQASQBDAFUATABBAFIAIABQAFUAUgBQAE8AUwBFACAAQQBOAEQAIABOAE8ATgBJAE4ARgBSAEkATgBHAEUATQBFAE4AVAAKAE8ARgAgAEMATwBQAFkAUgBJAEcASABUACwAIABQAEEAVABFAE4AVAAsACAAVABSAEEARABFAE0AQQBSAEsALAAgAE8AUgAgAE8AVABIAEUAUgAgAFIASQBHAEgAVAAuACAASQBOACAATgBPACAARQBWAEUATgBUACAAUwBIAEEATABMACAAVABIAEUACgBDAE8AUABZAFIASQBHAEgAVAAgAEgATwBMAEQARQBSACAAQgBFACAATABJAEEAQgBMAEUAIABGAE8AUgAgAEEATgBZACAAQwBMAEEASQBNACwAIABEAEEATQBBAEcARQBTACAATwBSACAATwBUAEgARQBSACAATABJAEEAQgBJAEwASQBUAFkALAAKAEkATgBDAEwAVQBEAEkATgBHACAAQQBOAFkAIABHAEUATgBFAFIAQQBMACwAIABTAFAARQBDAEkAQQBMACwAIABJAE4ARABJAFIARQBDAFQALAAgAEkATgBDAEkARABFAE4AVABBAEwALAAgAE8AUgAgAEMATwBOAFMARQBRAFUARQBOAFQASQBBAEwACgBEAEEATQBBAEcARQBTACwAIABXAEgARQBUAEgARQBSACAASQBOACAAQQBOACAAQQBDAFQASQBPAE4AIABPAEYAIABDAE8ATgBUAFIAQQBDAFQALAAgAFQATwBSAFQAIABPAFIAIABPAFQASABFAFIAVwBJAFMARQAsACAAQQBSAEkAUwBJAE4ARwAKAEYAUgBPAE0ALAAgAE8AVQBUACAATwBGACAAVABIAEUAIABVAFMARQAgAE8AUgAgAEkATgBBAEIASQBMAEkAVABZACAAVABPACAAVQBTAEUAIABUAEgARQAgAEYATwBOAFQAIABTAE8ARgBUAFcAQQBSAEUAIABPAFIAIABGAFIATwBNAAoATwBUAEgARQBSACAARABFAEEATABJAE4ARwBTACAASQBOACAAVABIAEUAIABGAE8ATgBUACAAUwBPAEYAVABXAEEAUgBFAC4AAENvcHlyaWdodCAoYykgMjAxMCwgQW5kcmV5IE1ha2Fyb3YgKG1ha2Fyb3ZAYm1zdHUucnUsIG1rYS1hdC1tYWlscnVAbWFpbC5ydSksCndpdGggUmVzZXJ2ZWQgRm9udCBOYW1lIEFua2EvQ29kZXIgTmFycm93LgoKVGhpcyBGb250IFNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBTSUwgT3BlbiBGb250IExpY2Vuc2UsIFZlcnNpb24gMS4xLgpUaGlzIGxpY2Vuc2UgaXMgY29waWVkIGJlbG93LCBhbmQgaXMgYWxzbyBhdmFpbGFibGUgd2l0aCBhIEZBUSBhdDoKaHR0cDovL3NjcmlwdHMuc2lsLm9yZy9PRkwKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpTSUwgT1BFTiBGT05UIExJQ0VOU0UgVmVyc2lvbiAxLjEgLSAyNiBGZWJydWFyeSAyMDA3Ci0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpQUkVBTUJMRQpUaGUgZ29hbHMgb2YgdGhlIE9wZW4gRm9udCBMaWNlbnNlIChPRkwpIGFyZSB0byBzdGltdWxhdGUgd29ybGR3aWRlCmRldmVsb3BtZW50IG9mIGNvbGxhYm9yYXRpdmUgZm9udCBwcm9qZWN0cywgdG8gc3VwcG9ydCB0aGUgZm9udCBjcmVhdGlvbgplZmZvcnRzIG9mIGFjYWRlbWljIGFuZCBsaW5ndWlzdGljIGNvbW11bml0aWVzLCBhbmQgdG8gcHJvdmlkZSBhIGZyZWUgYW5kCm9wZW4gZnJhbWV3b3JrIGluIHdoaWNoIGZvbnRzIG1heSBiZSBzaGFyZWQgYW5kIGltcHJvdmVkIGluIHBhcnRuZXJzaGlwCndpdGggb3RoZXJzLgoKVGhlIE9GTCBhbGxvd3MgdGhlIGxpY2Vuc2VkIGZvbnRzIHRvIGJlIHVzZWQsIHN0dWRpZWQsIG1vZGlmaWVkIGFuZApyZWRpc3RyaWJ1dGVkIGZyZWVseSBhcyBsb25nIGFzIHRoZXkgYXJlIG5vdCBzb2xkIGJ5IHRoZW1zZWx2ZXMuIFRoZQpmb250cywgaW5jbHVkaW5nIGFueSBkZXJpdmF0aXZlIHdvcmtzLCBjYW4gYmUgYnVuZGxlZCwgZW1iZWRkZWQsIApyZWRpc3RyaWJ1dGVkIGFuZC9vciBzb2xkIHdpdGggYW55IHNvZnR3YXJlIHByb3ZpZGVkIHRoYXQgYW55IHJlc2VydmVkCm5hbWVzIGFyZSBub3QgdXNlZCBieSBkZXJpdmF0aXZlIHdvcmtzLiBUaGUgZm9udHMgYW5kIGRlcml2YXRpdmVzLApob3dldmVyLCBjYW5ub3QgYmUgcmVsZWFzZWQgdW5kZXIgYW55IG90aGVyIHR5cGUgb2YgbGljZW5zZS4gVGhlCnJlcXVpcmVtZW50IGZvciBmb250cyB0byByZW1haW4gdW5kZXIgdGhpcyBsaWNlbnNlIGRvZXMgbm90IGFwcGx5CnRvIGFueSBkb2N1bWVudCBjcmVhdGVkIHVzaW5nIHRoZSBmb250cyBvciB0aGVpciBkZXJpdmF0aXZlcy4KCkRFRklOSVRJT05TCiJGb250IFNvZnR3YXJlIiByZWZlcnMgdG8gdGhlIHNldCBvZiBmaWxlcyByZWxlYXNlZCBieSB0aGUgQ29weXJpZ2h0CkhvbGRlcihzKSB1bmRlciB0aGlzIGxpY2Vuc2UgYW5kIGNsZWFybHkgbWFya2VkIGFzIHN1Y2guIFRoaXMgbWF5CmluY2x1ZGUgc291cmNlIGZpbGVzLCBidWlsZCBzY3JpcHRzIGFuZCBkb2N1bWVudGF0aW9uLgoKIlJlc2VydmVkIEZvbnQgTmFtZSIgcmVmZXJzIHRvIGFueSBuYW1lcyBzcGVjaWZpZWQgYXMgc3VjaCBhZnRlciB0aGUKY29weXJpZ2h0IHN0YXRlbWVudChzKS4KCiJPcmlnaW5hbCBWZXJzaW9uIiByZWZlcnMgdG8gdGhlIGNvbGxlY3Rpb24gb2YgRm9udCBTb2Z0d2FyZSBjb21wb25lbnRzIGFzCmRpc3RyaWJ1dGVkIGJ5IHRoZSBDb3B5cmlnaHQgSG9sZGVyKHMpLgoKIk1vZGlmaWVkIFZlcnNpb24iIHJlZmVycyB0byBhbnkgZGVyaXZhdGl2ZSBtYWRlIGJ5IGFkZGluZyB0bywgZGVsZXRpbmcsCm9yIHN1YnN0aXR1dGluZyAtLSBpbiBwYXJ0IG9yIGluIHdob2xlIC0tIGFueSBvZiB0aGUgY29tcG9uZW50cyBvZiB0aGUKT3JpZ2luYWwgVmVyc2lvbiwgYnkgY2hhbmdpbmcgZm9ybWF0cyBvciBieSBwb3J0aW5nIHRoZSBGb250IFNvZnR3YXJlIHRvIGEKbmV3IGVudmlyb25tZW50LgoKIkF1dGhvciIgcmVmZXJzIHRvIGFueSBkZXNpZ25lciwgZW5naW5lZXIsIHByb2dyYW1tZXIsIHRlY2huaWNhbAp3cml0ZXIgb3Igb3RoZXIgcGVyc29uIHdobyBjb250cmlidXRlZCB0byB0aGUgRm9udCBTb2Z0d2FyZS4KClBFUk1JU1NJT04gJiBDT05ESVRJT05TClBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZwphIGNvcHkgb2YgdGhlIEZvbnQgU29mdHdhcmUsIHRvIHVzZSwgc3R1ZHksIGNvcHksIG1lcmdlLCBlbWJlZCwgbW9kaWZ5LApyZWRpc3RyaWJ1dGUsIGFuZCBzZWxsIG1vZGlmaWVkIGFuZCB1bm1vZGlmaWVkIGNvcGllcyBvZiB0aGUgRm9udApTb2Z0d2FyZSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CgoxKSBOZWl0aGVyIHRoZSBGb250IFNvZnR3YXJlIG5vciBhbnkgb2YgaXRzIGluZGl2aWR1YWwgY29tcG9uZW50cywKaW4gT3JpZ2luYWwgb3IgTW9kaWZpZWQgVmVyc2lvbnMsIG1heSBiZSBzb2xkIGJ5IGl0c2VsZi4KCjIpIE9yaWdpbmFsIG9yIE1vZGlmaWVkIFZlcnNpb25zIG9mIHRoZSBGb250IFNvZnR3YXJlIG1heSBiZSBidW5kbGVkLApyZWRpc3RyaWJ1dGVkIGFuZC9vciBzb2xkIHdpdGggYW55IHNvZnR3YXJlLCBwcm92aWRlZCB0aGF0IGVhY2ggY29weQpjb250YWlucyB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBsaWNlbnNlLiBUaGVzZSBjYW4gYmUKaW5jbHVkZWQgZWl0aGVyIGFzIHN0YW5kLWFsb25lIHRleHQgZmlsZXMsIGh1bWFuLXJlYWRhYmxlIGhlYWRlcnMgb3IKaW4gdGhlIGFwcHJvcHJpYXRlIG1hY2hpbmUtcmVhZGFibGUgbWV0YWRhdGEgZmllbGRzIHdpdGhpbiB0ZXh0IG9yCmJpbmFyeSBmaWxlcyBhcyBsb25nIGFzIHRob3NlIGZpZWxkcyBjYW4gYmUgZWFzaWx5IHZpZXdlZCBieSB0aGUgdXNlci4KCjMpIE5vIE1vZGlmaWVkIFZlcnNpb24gb2YgdGhlIEZvbnQgU29mdHdhcmUgbWF5IHVzZSB0aGUgUmVzZXJ2ZWQgRm9udApOYW1lKHMpIHVubGVzcyBleHBsaWNpdCB3cml0dGVuIHBlcm1pc3Npb24gaXMgZ3JhbnRlZCBieSB0aGUgY29ycmVzcG9uZGluZwpDb3B5cmlnaHQgSG9sZGVyLiBUaGlzIHJlc3RyaWN0aW9uIG9ubHkgYXBwbGllcyB0byB0aGUgcHJpbWFyeSBmb250IG5hbWUgYXMKcHJlc2VudGVkIHRvIHRoZSB1c2Vycy4KCjQpIFRoZSBuYW1lKHMpIG9mIHRoZSBDb3B5cmlnaHQgSG9sZGVyKHMpIG9yIHRoZSBBdXRob3Iocykgb2YgdGhlIEZvbnQKU29mdHdhcmUgc2hhbGwgbm90IGJlIHVzZWQgdG8gcHJvbW90ZSwgZW5kb3JzZSBvciBhZHZlcnRpc2UgYW55Ck1vZGlmaWVkIFZlcnNpb24sIGV4Y2VwdCB0byBhY2tub3dsZWRnZSB0aGUgY29udHJpYnV0aW9uKHMpIG9mIHRoZQpDb3B5cmlnaHQgSG9sZGVyKHMpIGFuZCB0aGUgQXV0aG9yKHMpIG9yIHdpdGggdGhlaXIgZXhwbGljaXQgd3JpdHRlbgpwZXJtaXNzaW9uLgoKNSkgVGhlIEZvbnQgU29mdHdhcmUsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQsIGluIHBhcnQgb3IgaW4gd2hvbGUsCm11c3QgYmUgZGlzdHJpYnV0ZWQgZW50aXJlbHkgdW5kZXIgdGhpcyBsaWNlbnNlLCBhbmQgbXVzdCBub3QgYmUKZGlzdHJpYnV0ZWQgdW5kZXIgYW55IG90aGVyIGxpY2Vuc2UuIFRoZSByZXF1aXJlbWVudCBmb3IgZm9udHMgdG8KcmVtYWluIHVuZGVyIHRoaXMgbGljZW5zZSBkb2VzIG5vdCBhcHBseSB0byBhbnkgZG9jdW1lbnQgY3JlYXRlZAp1c2luZyB0aGUgRm9udCBTb2Z0d2FyZS4KClRFUk1JTkFUSU9OClRoaXMgbGljZW5zZSBiZWNvbWVzIG51bGwgYW5kIHZvaWQgaWYgYW55IG9mIHRoZSBhYm92ZSBjb25kaXRpb25zIGFyZQpub3QgbWV0LgoKRElTQ0xBSU1FUgpUSEUgRk9OVCBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELApFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gQU5ZIFdBUlJBTlRJRVMgT0YKTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5UCk9GIENPUFlSSUdIVCwgUEFURU5ULCBUUkFERU1BUkssIE9SIE9USEVSIFJJR0hULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUKQ09QWVJJR0hUIEhPTERFUiBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksCklOQ0xVRElORyBBTlkgR0VORVJBTCwgU1BFQ0lBTCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIE9SIENPTlNFUVVFTlRJQUwKREFNQUdFUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HCkZST00sIE9VVCBPRiBUSEUgVVNFIE9SIElOQUJJTElUWSBUTyBVU0UgVEhFIEZPTlQgU09GVFdBUkUgT1IgRlJPTQpPVEhFUiBERUFMSU5HUyBJTiBUSEUgRk9OVCBTT0ZUV0FSRS4AAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAAAaHR0cDovL3NjcmlwdHMuc2lsLm9yZy9PRkwAAEEAbgBuAGEAIABTAGgAdQBnAG8AbAAgAG4AYQBtAGUAIABmAG8AbgB0ACAAZgBhAGMAZQA7AAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ACgBUAGgAZQAgAHEAdQBpAGMAawAgAGIAcgBvAHcAbgAgAGYAbwB4ACAAagB1AG0AcABzACAAbwB2AGUAcgAgAHQAaABlACAAbABhAHoAeQAgAGQAbwBnAC4ACgAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAKACMAaQBmACAAKABQAEwAQQBUAEYATwBSAE0AIAAmACAAKABQAEwAQQBUAEYATwBSAE0AXwBNAFMAQwB8AFAATABBAFQARgBPAFIATQBfAEEAUwBNAF8ASQBOAFQARQBMACkAKQA9AD0AKABQAEwAQQBUAEYATwBSAE0AXwBNAFMAQwB8AFAATABBAFQARgBPAFIATQBfAEEAUwBNAF8ASQBOAFQARQBMACkACgAJAC8AKgAgAGMAbwBtAHAAaQBsAGUAcgAgAGIAYQByAHIAaQBlAHIAIABwAHIAZQB2AGUAbgB0AHMAIABvAHAAdABpAG0AaQB6AGUAcgAgAGYAcgBvAG0AIABtAG8AdgBpAG4AZwAgAGMAbwBkAGUAIABsAGkAbgBlAHMAIABvAHYAZQByACAAdABoAGkAcwAgAGIAYQByAHIAaQBlAHIAIAAqAC8ACgAJACMAZABlAGYAaQBuAGUAIABDAEIAKAApAAkACQAJAAkAXwBfAGEAcwBtACAAewB9AAoACQAvACoAIABtAGUAbQBvAHIAeQAgAGIAYQByAHIAaQBlAHIAIABlAG4AZgBvAHIAYwBlAHMAIABhAGwAbAAgAHAAcgBvAGMAZQBzAHMAbwByACAAbABvAGEAZAAgAG8AcABlAHIAYQB0AGkAbwBuAHMAIAB0AG8AIABiAGUAIABlAG4AZABlAGQAIABiAGUAZgBvAHIAZQAgAHQAaABpAHMAIABsAGkAbgBlACAAKgAvAAoACQAjAGQAZQBmAGkAbgBlACAATQBCACgAKQAJAAkACQAJAF8AXwBhAHMAbQAgAGwAbwBjAGsAIABhAGQAZAAgAHEAdwBvAHIAZAAgAHAAdAByACAAWwByAHMAcABdACwAIAAwADsACgAKAAkAXwBfAGYAbwByAGMAZQBpAG4AbABpAG4AZQAgAGMAaABhAHIAIABpAG4AbABpAG4AZQBfAGUAeABjAGgAZwBfAG8AbgBlACgAdgBvAGwAYQB0AGkAbABlACAAYwBoAGEAcgAqACAAcAByAHYAKQAKAAkAewAKAAkACQBfAF8AYQBzAG0AIAB7AAoACQAJAAkAbQBvAHYACQAJAF8AXwBQAG8AaQBuAHQAZQByAFIARQBHAF8AXwAsACAAcAByAHYACgAJAAkACQBtAG8AdgAJAAkAYQBsACwAIAAxAAoACQAJAAkAbABvAGMAawAgAHgAYwBoAGcACQBbAF8AXwBQAG8AaQBuAHQAZQByAFIARQBHAF8AXwBdACwAIABhAGwACgAJAAkAfQAKAAkAfQAKACMAZQBsAGkAZgAgACgAUABMAEEAVABGAE8AUgBNACAAJgAgACgAUABMAEEAVABGAE8AUgBNAF8ARwBDAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEEAVABUACkAKQA9AD0AKABQAEwAQQBUAEYATwBSAE0AXwBHAEMAQwB8AFAATABBAFQARgBPAFIATQBfAEEAUwBNAF8AQQBUAFQAKQAKAAkAIwBkAGUAZgBpAG4AZQAgAEMAQgAoACkACQAJAAkACQBhAHMAbQAgAHYAbwBsAGEAdABpAGwAZQAoACIAIgA6ADoAOgAiAG0AZQBtAG8AcgB5ACIAKQAKAAkAIwBkAGUAZgBpAG4AZQAgAE0AQgAoACkACQAJAAkACQBhAHMAbQAgAHYAbwBsAGEAdABpAGwAZQAoACIAbABvAGMAawAgAGEAZABkAHEAXAB0ACQAMAAsACAAKAAlAHIAcwBwACkAIgA6ADoAOgAiAG0AZQBtAG8AcgB5ACIAKQAKAAkAIwBkAGUAZgBpAG4AZQAgAG0AYQBjAHIAbwBfAHMAbQBwAF8AZQB4AGMAaABnAF8AMQAoAHIAdgApAAkACQAoAHsAdAB5AHAAZQBvAGYAKAByAHYAKQAgAHQAbQBwADsAIABcAAoACQAJAGEAcwBtACAAdgBvAGwAYQB0AGkAbABlACgAIgBtAG8AdgBcAHQAJAAxACwAIAAlADAAXABuAFwAdABsAG8AYwBrACAAeABjAGgAZwAgACUAMAAsACAAKAAlADIAKQAiADoAIgA9AHIAIgAoAHQAbQBwACkAOgAiADAAIgAoAHQAbQBwACkALAAiAHIAIgAoACYAKAByAHYAKQApADoAIgAwACIAKQA7ACAAXAAKAAkACQB0AG0AcAA7AH0AKQAKACMAZQBuAGQAaQBmAABBbm5hIFNodWdvbCBuYW1lIGZvbnQgZmFjZTsKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tClRoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojaWYgKFBMQVRGT1JNICYgKFBMQVRGT1JNX01TQ3xQTEFURk9STV9BU01fSU5URUwpKT09KFBMQVRGT1JNX01TQ3xQTEFURk9STV9BU01fSU5URUwpCgkvKiBjb21waWxlciBiYXJyaWVyIHByZXZlbnRzIG9wdGltaXplciBmcm9tIG1vdmluZyBjb2RlIGxpbmVzIG92ZXIgdGhpcyBiYXJyaWVyICovCgkjZGVmaW5lIENCKCkJCQkJX19hc20ge30KCS8qIG1lbW9yeSBiYXJyaWVyIGVuZm9yY2VzIGFsbCBwcm9jZXNzb3IgbG9hZCBvcGVyYXRpb25zIHRvIGJlIGVuZGVkIGJlZm9yZSB0aGlzIGxpbmUgKi8KCSNkZWZpbmUgTUIoKQkJCQlfX2FzbSBsb2NrIGFkZCBxd29yZCBwdHIgW3JzcF0sIDA7CgoJX19mb3JjZWlubGluZSBjaGFyIGlubGluZV9leGNoZ19vbmUodm9sYXRpbGUgY2hhciogcHJ2KQoJewoJCV9fYXNtIHsKCQkJbW92CQlfX1BvaW50ZXJSRUdfXywgcHJ2CgkJCW1vdgkJYWwsIDEKCQkJbG9jayB4Y2hnCVtfX1BvaW50ZXJSRUdfX10sIGFsCgkJfQoJfQojZWxpZiAoUExBVEZPUk0gJiAoUExBVEZPUk1fR0NDfFBMQVRGT1JNX0FTTV9BVFQpKT09KFBMQVRGT1JNX0dDQ3xQTEFURk9STV9BU01fQVRUKQoJI2RlZmluZSBDQigpCQkJCWFzbSB2b2xhdGlsZSgiIjo6OiJtZW1vcnkiKQoJI2RlZmluZSBNQigpCQkJCWFzbSB2b2xhdGlsZSgibG9jayBhZGRxXHQkMCwgKCVyc3ApIjo6OiJtZW1vcnkiKQoJI2RlZmluZSBtYWNyb19zbXBfZXhjaGdfMShydikJCSh7dHlwZW9mKHJ2KSB0bXA7IFwKCQlhc20gdm9sYXRpbGUoIm1vdlx0JDEsICUwXG5cdGxvY2sgeGNoZyAlMCwgKCUyKSI6Ij1yIih0bXApOiIwIih0bXApLCJyIigmKHJ2KSk6IjAiKTsgXAoJCXRtcDt9KQojZW5kaWYABBMEQARDBD8EPwQwACAESARABDgERARCBD4EMgAgBDgEPAQ1BD0EOAAgBBAEPQQ9BEsAIAQoBEMEMwQ+BDsETAA7AAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ACgQoBDgEQAQ+BDoEMARPACAETQQ7BDUEOgRCBEAEOAREBDgEOgQwBEYEOARPACAETgQ2BD0ESwRFACAEMwRDBDEENQRABD0EOAQ5ACAENAQwBEEEQgAgBDwEPgRJBD0ESwQ5ACAEQgQ+BDsERwQ+BDoAIAQ/BD4ENARKBFEEPARDACAEQQQ1BDsETARBBDoEPgQzBD4AIARFBD4ENwRPBDkEQQRCBDIEMAAuAAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ACgAjAGkAZgAgACgAUABMAEEAVABGAE8AUgBNACAAJgAgACgAUABMAEEAVABGAE8AUgBNAF8ATQBTAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEkATgBUAEUATAApACkAPQA9ACgAUABMAEEAVABGAE8AUgBNAF8ATQBTAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEkATgBUAEUATAApAAoACQAvACoAIABjAG8AbQBwAGkAbABlAHIAIABiAGEAcgByAGkAZQByACAAcAByAGUAdgBlAG4AdABzACAAbwBwAHQAaQBtAGkAegBlAHIAIABmAHIAbwBtACAAbQBvAHYAaQBuAGcAIABjAG8AZABlACAAbABpAG4AZQBzACAAbwB2AGUAcgAgAHQAaABpAHMAIABiAGEAcgByAGkAZQByACAAKgAvAAoACQAjAGQAZQBmAGkAbgBlACAAQwBCACgAKQAJAAkACQAJAF8AXwBhAHMAbQAgAHsAfQAKAAkALwAqACAAbQBlAG0AbwByAHkAIABiAGEAcgByAGkAZQByACAAZQBuAGYAbwByAGMAZQBzACAAYQBsAGwAIABwAHIAbwBjAGUAcwBzAG8AcgAgAGwAbwBhAGQAIABvAHAAZQByAGEAdABpAG8AbgBzACAAdABvACAAYgBlACAAZQBuAGQAZQBkACAAYgBlAGYAbwByAGUAIAB0AGgAaQBzACAAbABpAG4AZQAgACoALwAKAAkAIwBkAGUAZgBpAG4AZQAgAE0AQgAoACkACQAJAAkACQBfAF8AYQBzAG0AIABsAG8AYwBrACAAYQBkAGQAIABxAHcAbwByAGQAIABwAHQAcgAgAFsAcgBzAHAAXQAsACAAMAA7AAoACgAJAF8AXwBmAG8AcgBjAGUAaQBuAGwAaQBuAGUAIABjAGgAYQByACAAaQBuAGwAaQBuAGUAXwBlAHgAYwBoAGcAXwBvAG4AZQAoAHYAbwBsAGEAdABpAGwAZQAgAGMAaABhAHIAKgAgAHAAcgB2ACkACgAJAHsACgAJAAkAXwBfAGEAcwBtACAAewAKAAkACQAJAG0AbwB2AAkACQBfAF8AUABvAGkAbgB0AGUAcgBSAEUARwBfAF8ALAAgAHAAcgB2AAoACQAJAAkAbQBvAHYACQAJAGEAbAAsACAAMQAKAAkACQAJAGwAbwBjAGsAIAB4AGMAaABnAAkAWwBfAF8AUABvAGkAbgB0AGUAcgBSAEUARwBfAF8AXQAsACAAYQBsAAoACQAJAH0ACgAJAH0ACgAjAGUAbABpAGYAIAAoAFAATABBAFQARgBPAFIATQAgACYAIAAoAFAATABBAFQARgBPAFIATQBfAEcAQwBDAHwAUABMAEEAVABGAE8AUgBNAF8AQQBTAE0AXwBBAFQAVAApACkAPQA9ACgAUABMAEEAVABGAE8AUgBNAF8ARwBDAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEEAVABUACkACgAJACMAZABlAGYAaQBuAGUAIABDAEIAKAApAAkACQAJAAkAYQBzAG0AIAB2AG8AbABhAHQAaQBsAGUAKAAiACIAOgA6ADoAIgBtAGUAbQBvAHIAeQAiACkACgAJACMAZABlAGYAaQBuAGUAIABNAEIAKAApAAkACQAJAAkAYQBzAG0AIAB2AG8AbABhAHQAaQBsAGUAKAAiAGwAbwBjAGsAIABhAGQAZABxAFwAdAAkADAALAAgACgAJQByAHMAcAApACIAOgA6ADoAIgBtAGUAbQBvAHIAeQAiACkACgAJACMAZABlAGYAaQBuAGUAIABtAGEAYwByAG8AXwBzAG0AcABfAGUAeABjAGgAZwBfADEAKAByAHYAKQAJAAkAKAB7AHQAeQBwAGUAbwBmACgAcgB2ACkAIAB0AG0AcAA7ACAAXAAKAAkACQBhAHMAbQAgAHYAbwBsAGEAdABpAGwAZQAoACIAbQBvAHYAXAB0ACQAMQAsACAAJQAwAFwAbgBcAHQAbABvAGMAawAgAHgAYwBoAGcAIAAlADAALAAgACgAJQAyACkAIgA6ACIAPQByACIAKAB0AG0AcAApADoAIgAwACIAKAB0AG0AcAApACwAIgByACIAKAAmACgAcgB2ACkAKQA6ACIAMAAiACkAOwAgAFwACgAJAAkAdABtAHAAOwB9ACkACgAjAGUAbgBkAGkAZgAAAAAAAAIAAAAAAAD9+wCWAAAAAQAAAAAAAAAAAAAAAAAAAAACbAAAAAEAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEArACjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAECAIoA2gCDAJMA8gDzAI0BAwCIAMMA3gDxAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAM8AzADNAM4A6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBBAEFAQYBBwEIAQkA/QD+AQoBCwEMAQ0A/wEAAQ4BDwEQAQEBEQESARMBFAEVARYBFwEYARkBGgEbARwA+AD5AR0BHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwA+gDXAS0BLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7AOIA4wE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgCwALEBSwFMAU0BTgFPAVABUQFSAVMBVAD7APwA5ADlAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoAuwFrAWwBbQFuAOYA5wFvAKYBcADYAOEBcQFyANsA3ADdAOAA2QDfAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgACoAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMAnwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQCXAaYBpwGoAJsBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZALYAtwDEAhoAtAC1AMUAggDCAIcAqwIbAhwAvgC/ALwCHQIeAh8CIACMAiECIgIjAiQCJQImAicA7wIoAKUAkgIpAioCKwCUAJUCLAItAi4CLwIwAjECMgIzAjQCNQI2AjcCOAI5AjoCOwI8Aj0CPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAC5AmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngKc29mdGh5cGhlbgVtaWNybwdBbWFjcm9uB2FtYWNyb24GQWJyZXZlBmFicmV2ZQdBb2dvbmVrB2FvZ29uZWsLQ2NpcmN1bWZsZXgLY2NpcmN1bWZsZXgKQ2RvdGFjY2VudApjZG90YWNjZW50BkRjYXJvbgZkY2Fyb24GRGNyb2F0B0VtYWNyb24HZW1hY3JvbgZFYnJldmUGZWJyZXZlCkVkb3RhY2NlbnQKZWRvdGFjY2VudAdFb2dvbmVrB2VvZ29uZWsGRWNhcm9uBmVjYXJvbgtHY2lyY3VtZmxleAtnY2lyY3VtZmxleApHZG90YWNjZW50Cmdkb3RhY2NlbnQIR2NlZGlsbGEIZ2NlZGlsbGELSGNpcmN1bWZsZXgLaGNpcmN1bWZsZXgESGJhcgRoYmFyBkl0aWxkZQZpdGlsZGUHSW1hY3JvbgdpbWFjcm9uBklicmV2ZQZpYnJldmUHSW9nb25lawdpb2dvbmVrAklKAmlqC0pjaXJjdW1mbGV4C2pjaXJjdW1mbGV4CEtjZWRpbGxhCGtjZWRpbGxhDGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlCExjZWRpbGxhCGxjZWRpbGxhBkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUITmNlZGlsbGEIbmNlZGlsbGEGTmNhcm9uBm5jYXJvbgtuYXBvc3Ryb3BoZQNFbmcDZW5nB09tYWNyb24Hb21hY3JvbgZPYnJldmUGb2JyZXZlDU9odW5nYXJ1bWxhdXQNb2h1bmdhcnVtbGF1dAZSYWN1dGUGcmFjdXRlCFJjZWRpbGxhCHJjZWRpbGxhBlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAhUY2VkaWxsYQh0Y2VkaWxsYQZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50BHpkb3QFc2xvbmcIZG90bGVzc2oObWFjcm9ubW9kaWZpZXINZ3JhdmVtb2RpZmllcglncmF2ZWNvbWIJYWN1dGVjb21iCXRpbGRlY29tYgtkaWVyZXNpc2NtYg1ob29rYWJvdmVjb21iCWNhcm9uY29tYhNjb21tYXR1cm5lZGFib3ZlY21iEmNvbW1hYWJvdmVyaWdodGNtYgxkb3RiZWxvd2NvbWIMY29tbWFzdWJub3NwBXRvbm9zBUFscGhhBEJldGEFR2FtbWEHRXBzaWxvbgRaZXRhA0V0YQVUaGV0YQRJb3RhBUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQxJb3RhZGllcmVzaXMPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGECbnUCeGkHb21pY3JvbgNyaG8Kc2lnbWFmaW5hbAVzaWdtYQN0YXUHdXBzaWxvbgNwaGkDY2hpA3BzaQVvbWVnYQxpb3RhZGllcmVzaXMPdXBzaWxvbmRpZXJlc2lzDG9taWNyb250b25vcwx1cHNpbG9udG9ub3MKb21lZ2F0b25vcwdEaWdhbW1hC3NpZ21hbHVuYXRlCHlvdGdyZWVrCk5hbWVNZS40MzIKSW9jeXJpbGxpYwtEamVjeXJpbGxpYwtHamVjeXJpbGxpYwlFY3lyaWxsaWMLRHplY3lyaWxsaWMJSWN5cmlsbGljCllpY3lyaWxsaWMKSmVjeXJpbGxpYwtMamVjeXJpbGxpYwtOamVjeXJpbGxpYwxUc2hlY3lyaWxsaWMLS2plY3lyaWxsaWMYSWljeXJpbGxpY19ncmF2ZW1vZGlmaWVyDlVzaG9ydGN5cmlsbGljDER6aGVjeXJpbGxpYwlBY3lyaWxsaWMKQmVjeXJpbGxpYwpWZWN5cmlsbGljCkdlY3lyaWxsaWMKRGVjeXJpbGxpYwpJZWN5cmlsbGljC1poZWN5cmlsbGljClplY3lyaWxsaWMKSWljeXJpbGxpYw9JaXNob3J0Y3lyaWxsaWMKS2FjeXJpbGxpYwpFbGN5cmlsbGljCkVtY3lyaWxsaWMKRW5jeXJpbGxpYwlPY3lyaWxsaWMKUGVjeXJpbGxpYwpFcmN5cmlsbGljCkVzY3lyaWxsaWMKVGVjeXJpbGxpYwlVY3lyaWxsaWMKRWZjeXJpbGxpYwtLaGFjeXJpbGxpYwtUc2VjeXJpbGxpYwtDaGVjeXJpbGxpYwtTaGFjeXJpbGxpYw1TaGNoYWN5cmlsbGljEEhhcmRzaWduY3lyaWxsaWMMWWVyaWN5cmlsbGljEFNvZnRzaWduY3lyaWxsaWMRRXJldmVyc2VkY3lyaWxsaWMKSVVjeXJpbGxpYwpJQWN5cmlsbGljCWFjeXJpbGxpYwpiZWN5cmlsbGljCnZlY3lyaWxsaWMKZ2VjeXJpbGxpYwpkZWN5cmlsbGljCmllY3lyaWxsaWMLemhlY3lyaWxsaWMKemVjeXJpbGxpYwppaWN5cmlsbGljD2lpc2hvcnRjeXJpbGxpYwprYWN5cmlsbGljCmVsY3lyaWxsaWMKZW1jeXJpbGxpYwplbmN5cmlsbGljCW9jeXJpbGxpYwpwZWN5cmlsbGljCmVyY3lyaWxsaWMKZXNjeXJpbGxpYwp0ZWN5cmlsbGljCXVjeXJpbGxpYwplZmN5cmlsbGljC2toYWN5cmlsbGljC3RzZWN5cmlsbGljC2NoZWN5cmlsbGljC3NoYWN5cmlsbGljDXNoY2hhY3lyaWxsaWMQaGFyZHNpZ25jeXJpbGxpYwx5ZXJpY3lyaWxsaWMQc29mdHNpZ25jeXJpbGxpYxFlcmV2ZXJzZWRjeXJpbGxpYwppdWN5cmlsbGljCmlhY3lyaWxsaWMKTmFtZU1lLjUxMgppb2N5cmlsbGljC2RqZWN5cmlsbGljC2dqZWN5cmlsbGljCWVjeXJpbGxpYwtkemVjeXJpbGxpYwlpY3lyaWxsaWMKeWljeXJpbGxpYwpqZWN5cmlsbGljC2xqZWN5cmlsbGljC25qZWN5cmlsbGljDHRzaGVjeXJpbGxpYwtramVjeXJpbGxpYxhpaWN5cmlsbGljX2dyYXZlbW9kaWZpZXIOdXNob3J0Y3lyaWxsaWMMZHpoZWN5cmlsbGljEWFwb3N0cm9waGVyZXZlcnNlBm1pbnV0ZQZzZWNvbmQHdW5pMjA3NAluc3VwZXJpb3IEZXVybwZudW1lcm8JYXJyb3dsZWZ0B3VwYXJyb3cKYXJyb3dyaWdodAlkb3duYXJyb3cJYXJyb3dib3RoCmFycm93Ym90aHYOdXBkb3duYXJyb3diYXIOYnVsbGV0b3BlcmF0b3IMaW50ZXJzZWN0aW9uC2FsbW9zdGVxdWFsC2VxdWl2YWxlbmNlDXJldmxvZ2ljYWxub3QKaW50ZWdyYWx0cAppbnRlZ3JhbGJ0DHNwYWNlb3BlbmJveAtsdGhvcml6Zm9ybQpsdHZlcnRmb3JtDHJpZ2h0YW5nbGVudwxyaWdodGFuZ2xlbmUMcmlnaHRhbmdsZXN3DHJpZ2h0YW5nbGVzZQ9sdHZlcnRyaWdodGZvcm0ObHR2ZXJ0bGVmdGZvcm0NbHRkbmhvcml6Zm9ybQ1sdHVwaG9yaXpmb3JtD2x0dmVydGhvcml6Zm9ybQtob3JpemRibGJhcgp2ZXJ0ZGJsYmFyC2RucnRkYmxmb3JtC2RuZGJscnRmb3JtC2RibGRucnRmb3JtDWRubGVmdGRibGZvcm0NZG5kYmxsZWZ0Zm9ybQ1kYmxkbmxlZnRmb3JtC3VwcnRkYmxmb3JtC3VwZGJscnRmb3JtC2RibHVwcnRmb3JtDXVwbGVmdGRibGZvcm0NdXBkYmxsZWZ0Zm9ybQ1kYmx1cGxlZnRmb3JtDXZlcnRydGRibGZvcm0NdmVydGRibHJ0Zm9ybQ1kYmx2ZXJ0cnRmb3JtD3ZlcnRsZWZ0ZGJsZm9ybQ92ZXJ0ZGJsbGVmdGZvcm0PZGJsdmVydGxlZnRmb3JtDmRuaG9yaXpkYmxmb3JtDmRuZGJsaG9yaXpmb3JtDmRibGRuaG9yaXpmb3JtDnVwaG9yaXpkYmxmb3JtDnVwZGJsaG9yaXpmb3JtDmRibHVwaG9yaXpmb3JtEHZlcnRob3JpemRibGZvcm0QdmVydGRibGhvcml6Zm9ybRBkYmx2ZXJ0aG9yaXpmb3JtB3VwYmxvY2sHZG5ibG9jawVibG9jawdsZmJsb2NrB3J0YmxvY2sKc2hhZGVsaWdodAtzaGFkZW1lZGl1bQlzaGFkZWRhcmsLYmxhY2tzcXVhcmULd2hpdGVzcXVhcmUQYmxhY2tzbWFsbHNxdWFyZRB3aGl0ZXNtYWxsc3F1YXJlDmJsYWNrcmVjdGFuZ2xlB3RyaWFndXAHdHJpYWdydAd0cmlhZ2RuB3RyaWFnbGYLd2hpdGVjaXJjbGULYmxhY2tjaXJjbGUNYnVsbGV0aW52ZXJzZRJ3aGl0ZWNpcmNsZWludmVyc2ULd2hpdGVidWxsZXQJc21pbGVmYWNlDGludnNtaWxlZmFjZQdjb21wYXNzBmZlbWFsZQRtYWxlBXNwYWRlBGNsdWIFaGVhcnQHZGlhbW9uZAttdXNpY2Fsbm90ZQ5tdXNpY2Fsbm90ZWRibAAAAAADAAgAAgARAAH//wADAAEAAAAMAAAAFgAAAAIAAQABAmsAAQAEAAAAAgAAAAAAAQAAAAgAAAAAAAQAAAAAAAAAAQAAAADUGBYRAAAAAMdG5I4AAAAAzK7WNg=="},function(A,e){A.exports=require("graphology")},function(A,e){A.exports=require("lodash.pickby")},function(A,e){A.exports=require("material-ui/Checkbox")},function(A,e){A.exports=require("material-ui/List")},function(A,e){A.exports=require("material-ui/SelectField")},function(A,e){A.exports=require("material-ui/Slider")},function(A,e){A.exports=require("material-ui/Subheader")},function(A,e){A.exports=require("material-ui/TextField")},function(A,e){A.exports=require("material-ui/styles/MuiThemeProvider")},function(A,e){A.exports=require("material-ui/styles/getMuiTheme")},function(A,e){A.exports=require("material-ui/svg-icons/action/delete")},function(A,e){A.exports=require("material-ui/svg-icons/content/add")},function(A,e){A.exports=require("material-ui/svg-icons/content/create")},function(A,e){A.exports=require("material-ui/svg-icons/content/send")},function(A,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var t=n(1),i=n.n(t),g=n(269),a=n.n(g),o=n(271),r=n.n(o),M=n(270),s=(n.n(M),n(61));r()();var T=function(A){a.a.render(i.a.createElement(M.AppContainer,null,i.a.createElement(A,null)),document.getElementById("react-binding"))};T(s.a)},function(A,e){A.exports={sliderWidth:"100px"}},function(A,e){A.exports={margin:"10px",fontSize:"22px"}},function(A,e){A.exports={labelSize:20,curvedEdges:!1}},function(A,e,n){"use strict";function t(A,e){var n={};for(var t in A)e.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(A,t)&&(n[t]=A[t]);return n}var i=n(1),g=n.n(i),a=n(3),o=n.n(a),r=n(14),M=n.n(r),s=n(2),T=n(19),I=n(245),d=n.n(I),N=n(20),c=n(202),l=n.n(c),C=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},E=n.i(s.a)(l.a),u=function(A){var e=A.animationDirectives,n=A.algorithmStatic,i=A.input,a=t(A,["animationDirectives","algorithmStatic","input"]),o=M()({main:0,right:0,left:0},function(A,t){var o=Object.keys(n).filter(function(A){return n[A].layout.location===t});return o.sort(function(A,e){return n[e].layout.order-n[A].layout.order}),o.map(function(A){return g.a.createElement(N.a[n[A].type],C({},a,{id:A,key:A,input:(i.find(function(e){return e.data.targetModule===A})||i.filter(function(e){return e.data.moduleName===n[A].type})).reduce(function(A,e){return A[e.data.inputIdentifier]=d()(e,["value","update"]),A},{})},n[A].data,e[A]))})});return g.a.createElement("section",{className:E("top")},g.a.createElement("section",{className:E("main")},o.main),g.a.createElement(T.a,{side:"left",theme:A.theme},o.left),g.a.createElement(T.a,{side:"right",theme:A.theme},o.right))};u.propTypes={animationDirectives:o.a.object.isRequired,algorithmStatic:o.a.object.isRequired,input:o.a.arrayOf(o.a.object).isRequired,theme:o.a.string.isRequired},e.a=u},function(A,e,n){"use strict";function t(A,e){var n={};for(var t in A)e.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(A,t)&&(n[t]=A[t]);return n}var i=n(1),g=n.n(i),a=n(3),o=n.n(a),r=n(32),M=n.n(r),s=n(33),T=n.n(s),I=n(29),d=n.n(I),N=n(251),c=n.n(N),l=n(8),C=n.n(l),E=n(260),u=n.n(E),D=n(256),x=n.n(D),h=n(258),B=n.n(h),w=n(257),y=n.n(w),m=n(265),L=n.n(m),Q=n(255),p=n.n(Q),j=n(259),b=n.n(j),z=n(37),f=n.n(z),U=n(2),Y=n(45),S=n(11),G=n.n(S),k=n(39),O=(n.n(k),n(203)),v=n.n(O),Z=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},W=n.i(U.a)(v.a),V=function(A,e){return g.a.createElement(A,{color:n.i(U.b)(e.theme)("alternativeTextColor"),hoverColor:n.i(U.b)(e.theme)("accent1Color")})},H=function(A){return g.a.createElement("div",{className:W("container",A.theme)},g.a.createElement("div",{className:W("upper")},g.a.createElement(M.a,{muiTheme:T()({slider:{handleFillColor:n.i(U.b)(A.theme)("accent1Color"),selectionColor:n.i(U.b)(A.theme)("alternativeTextColor"),rippleColor:n.i(U.b)(A.theme)("accent1Color")}})},g.a.createElement(d.a,{max:100,min:1,step:1,value:A.animationSpeed,defaultValue:A.animationSpeed,onChange:function(e,n){return A.onAnimationChangeSpeed(n)},onDragStop:function(){return A.onAnimationChangeSpeed(null,!0)},style:{flexGrow:1,maxWidth:k.sliderWidth},sliderStyle:{margin:0}})),g.a.createElement("div",{className:W("buttons")},g.a.createElement(C.a,{icon:V(u.a,A),onTouchTap:A.onAnimationToBegin}),g.a.createElement(C.a,{icon:V(x.a,A),onTouchTap:A.onAnimationStepBackward}),g.a.createElement(Y.a,{activeIcon:V(f.a,A),passiveIcon:V(100===A.animationProgress?L.a:A.animationIsPaused?B.a:y.a,A),demandCondition:0===A.animationProgress,demandings:A.input.map(function(A){var e=A.data.description,n=A.update,i=t(A,["data","update"]);return Z({text:e,handler:n},i)}),resolve:A.onAnimationPauseRestart}),g.a.createElement(C.a,{icon:V(p.a,A),onTouchTap:A.onAnimationStepForward}),g.a.createElement(C.a,{icon:V(b.a,A),onTouchTap:A.onAnimationToEnd}))),g.a.createElement(c.a,{value:A.animationProgress,mode:"determinate",color:n.i(U.b)(A.theme)("accent1Color"),style:{height:G.a.footerHeight,position:"absolute",bottom:0,backgroundColor:n.i(U.b)(A.theme)("primary1Color"),zIndex:-1}}))};H.defaultProps={input:[]},H.propTypes={animationSpeed:o.a.number.isRequired,animationProgress:o.a.number.isRequired,animationIsPaused:o.a.bool.isRequired,onAnimationChangeSpeed:o.a.func.isRequired,onAnimationToBegin:o.a.func.isRequired,onAnimationStepForward:o.a.func.isRequired,onAnimationPauseRestart:o.a.func.isRequired,onAnimationStepBackward:o.a.func.isRequired,onAnimationToEnd:o.a.func.isRequired,input:o.a.arrayOf(o.a.shape({data:o.a.shape({description:o.a.string.isRequired}).isRequired,update:o.a.func.isRequired})),theme:o.a.string.isRequired},e.a=H},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(8),r=n.n(o),M=n(2),s=n(263),T=n.n(s),I=n(205),d=n.n(I),N=n.i(M.a)(d.a),c=function(A){return!A.disabled&&i.a.createElement("header",{className:N("container",A.app.theme)},A.back&&i.a.createElement(r.a,{icon:i.a.createElement(T.a,{color:n.i(M.b)(A.app.theme)("alternativeTextColor")}),label:""+A.back.name,onTouchTap:function(){return A.app.goBack()},labelStyle:{color:n.i(M.b)(A.app.theme)("alternativeTextColor")}}),i.a.createElement("nav",{className:N("nav")},A.routes.map(function(e){return i.a.createElement(r.a,{label:e.name,onTouchTap:function(){return A.app.changeView(e)}})})),i.a.createElement("h1",{className:N("header")},A.current.name.toUpperCase()))};c.defaultProps={routes:[],back:null,current:{name:""}},c.propTypes={app:a.a.shape({theme:a.a.string.isRequired,goBack:a.a.func.isRequired}).isRequired,back:a.a.shape({name:a.a.string.isRequired}),current:a.a.shape({name:a.a.string.isRequired}),routes:a.a.array},e.a=c},function(A,e,n){"use strict";function t(A,e){var n={};for(var t in A)e.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(A,t)&&(n[t]=A[t]);return n}function i(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function g(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function a(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var o=n(1),r=n.n(o),M=n(3),s=n.n(M),T=n(8),I=n.n(T),d=n(2),N=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},c=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),l=function(A){function e(A){i(this,e);var t=g(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return t.canBeShown=function(){return t.props.demandCondition&&0!==t.props.demandings.length},t.isOpened=function(){return t.canBeShown()&&t.state.opened},t.passiveHandler=function(){t.canBeShown()?n.i(d.j)(function(){return t.setState({opened:!0})}):t.props.resolve()},t.activeHandler=function(){var A=t.props.demandings.length;t.props.demandings.forEach(function(e,n){e.handler(t.state.inputs[n],function(){0===--A&&t.setState({opened:!1},function(){return t.props.resolve()})})})},t.inputHandler=function(A,e){return function(A){var n=A.target.value;t.setState(function(A){return A.inputs[e]=n,A})}},t.isButtonDisabled=function(){return t.state.inputs.reduce(function(A,e,n){return A||!t.props.demandings[n].validate(e)},!1)},t.state={opened:!1,inputs:t.props.demandings.map(function(A){return A.value})},t}return a(e,A),c(e,[{key:"componentWillReceiveProps",value:function(A){this.setState({inputs:A.demandings.map(function(A){return A.value})})}},{key:"render",value:function(){var A=this,e=this.props,n=(e.demandCondition,e.demandings),i=(e.resolve,e.formatter,e.activeIcon),g=e.passiveIcon,a=t(e,["demandCondition","demandings","resolve","formatter","activeIcon","passiveIcon"]),o=this.isOpened()&&n.map(function(e,n){return r.a.createElement("input",{key:e.text,placeholder:e.text,value:A.state.inputs[n],onChange:A.inputHandler(e,n)})});return r.a.createElement("div",{style:{display:"inline-flex",alignItems:"center"}},o,r.a.createElement(I.a,N({},a,{disabled:this.isButtonDisabled(),onTouchTap:this.isOpened()?this.activeHandler:this.passiveHandler,icon:this.isOpened()?i:g})))}}]),e}(o.Component);l.defaultProps={formatter:function(A){return A},demandings:[],demandCondition:!1},l.propTypes={demandCondition:s.a.bool,demandings:s.a.arrayOf(s.a.shape({text:s.a.string.isRequired,validate:s.a.func.isRequired,handler:s.a.func.isRequired,value:s.a.string.isRequired})),formatter:s.a.func,activeIcon:s.a.element.isRequired,passiveIcon:s.a.element.isRequired,resolve:s.a.func.isRequired},e.a=l},function(A,e,n){"use strict";function t(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function i(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function g(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var a=n(1),o=n.n(a),r=n(8),M=n.n(r),s=n(31),T=n.n(s),I=n(37),d=n.n(I),N=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),c=function(A){function e(A){t(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return n.onInputChange=function(A){return n.setState({value:A.target.value})},n.onButtonClick=function(){return n.props.send(n.state.value)},n.state={value:""},n}return g(e,A),N(e,[{key:"render",value:function(){return o.a.createElement("div",{style:{display:"flex",justifyContent:"flex-end",alignItems:"center"}},o.a.createElement(T.a,{id:"prompt-text",hintText:this.props.hintText,value:this.state.value,onChange:this.onInputChange,underlineFocusStyle:this.props.underlineFocusStyle,underlineStyle:this.props.underlineStyle,underlineShow:this.props.underlineShow}),o.a.createElement(M.a,{icon:o.a.createElement(d.a,null),onTouchTap:this.onButtonClick}))}}]),e}(a.Component);e.a=c},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},r=function(A){return i.a.createElement("div",{style:o({position:"relative",height:"100%"},A.style),className:A.className},A.children)};r.defaultProps={style:{},className:""},r.propTypes={children:a.a.any.isRequired,style:a.a.object,className:a.a.string},e.a=r},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(2),r=n(208),M=n.n(r),s=n.i(o.a)(M.a),T=function(A){var e=Array(A.code.length).fill("");A.highlights.forEach(function(A){return e[A]=s("active")});var t=A.code.map(function(A,n){return i.a.createElement("p",{key:A+n,className:e[n]},A)});return n.i(o.c)("code",A,i.a.createElement("div",{className:s("code",A.theme)},t))};T.defaultProps={highlights:[]},T.propTypes={code:a.a.arrayOf(a.a.string).isRequired,theme:a.a.string.isRequired,highlights:a.a.arrayOf(a.a.number)},e.a=T},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(2),r=n(209),M=(n.n(r),function(A){return n.i(o.c)("description",A,A.text&&i.a.createElement("div",{className:r.container},A.text)||null)});M.propTypes={text:a.a.string},M.defaultProps={text:""},e.a=M},function(A,e,n){"use strict";function t(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function i(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function g(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var a=n(1),o=n.n(a),r=n(3),M=n.n(r),s=n(27),T=(n.n(s),n(15)),I=n.n(T),d=n(18),N=n(34),c=n.n(N),l=n(35),C=n.n(l),E=n(36),u=n.n(E),D=n(9),x=n(2),h=n(210),B=n.n(h),w=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),y=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},m=n.i(x.a)(B.a),L=function(A,e,n){var t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:function(){return{}},g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;return o.a.createElement(s.ListItem,y({key:JSON.stringify(A),primaryText:e+" "+n.props.exampleGroup+"s",primaryTogglesNestedList:!0,autoGenerateNestedIndicator:!1,open:n.state["open"+e],onNestedListToggle:function(){return n.setState(function(A){return A["open"+e]=!A["open"+e],A})}},t,{nestedItems:A.map(function(A){return o.a.createElement(s.ListItem,y({key:A.name,primaryText:A.name,onTouchTap:function(){return n.props.input[D.a].update(A.data)}},i(A)))}).concat(g)}))},Q=function(A){function e(A){t(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return n.state={openExample:!0,openCustom:!1},n}return g(e,A),w(e,[{key:"render",value:function(){var A=this,e=function(e){for(var n=e;A.props.customs.map(function(A){return A.name}).includes(n);)n+="!";return n};return n.i(x.c)("examples",this.props,o.a.createElement("div",{className:m("container",this.props.theme)},o.a.createElement(s.List,null,L(this.props.examples,"Example",this),L(this.props.customs,"Custom",this,{rightIconButton:o.a.createElement(I.a,{touch:!0,onTouchTap:function(){A.props.app.prompt("Enter Name",function(n){return A.props.addCustom(e(n),A.props.input[D.a].value)})}},o.a.createElement(C.a,null))},function(t){return{rightIconButton:n.i(d.a)({theme:A.props.app.theme,items:[{name:"Rename",icon:u.a,onTouch:function(){return A.props.app.prompt("Enter New Name",function(n){return A.props.renameCustom(t.name,e(n))})}},{name:"Delete",icon:c.a,onTouch:function(){return A.props.deleteCustom(t.name)}}]})}}))))}}]),e}(a.Component);Q.propTypes={theme:M.a.string.isRequired,examples:M.a.arrayOf(M.a.shape({name:M.a.string.isRequired,data:M.a.any.isRequired})).isRequired,customs:M.a.arrayOf(M.a.shape({name:M.a.string.isRequired,data:M.a.any.isRequired})).isRequired},e.a=Q},function(A,e,n){"use strict";var t=n(242),i=n.n(t),g=n(14),a=n.n(g),o=n(2),r=i.a.scale(),M=function(A){var e={edges:{},nodes:{}},t=function(A,n,t,i){e[A][n]=e[A][n]||{},e[A][n][t]=i},g=function(){e={edges:{},nodes:{}}},M=[],s=function(){for(;0!==M.length;)M.pop()()},T={},I=function(e){return A.props.app.settings("options")("grayscale-visualizations").get()?r(1-i()(e).luminance()).hex():e},d=function(e){return n.i(o.b)(A.props.theme)(e)},N={default:d("primary1Color"),text:d("textColor")},c=d("backgroundColor"),l=i()(N.default).saturate(2),C={},E=function(A){return C[A]?C[A]:C[A]=Array(A).fill(1).map(function(e,n){return l.set("hsl.h","+"+360/(A+1)*(n+1)).hex()})},u=a()(N,I),D=function(){return E.apply(void 0,arguments).map(I)},x=function(A,e,n){t(n,A,"col",e),M.push(function(){return t(n,A,"col",u.default)})},h=function(A,e,n){t(n,A,"lab",e),M.push(function(){return t(n,A,"lab",-1)})},B=function(){var n={},t={};Object.keys(e).forEach(function(i){return Object.keys(e[i]).forEach(function(g){if(A.sigma.graph[i](g)&&(e[i][g].col&&(A.props.app.animationsEnabled?w({scaleCache:n,eachTimeCache:t,firstCol:A.sigma.graph[i](g).color,secCol:e[i][g].col,callback:function(e){A.sigma.graph[i](g).color=e,A.sigma.refresh({skipIndexation:!0})}}):(A.sigma.graph[i](g).color=e[i][g].col,A.sigma.refresh({skipIndexation:!0}))),e[i][g].lab)){var a=A.sigma.graph[i](g);a.glyphs[0].content=e[i][g].lab,-1===e[i][g].lab?a.glyphs[0].draw=!1:a.glyphs[0].draw=!0,A.sigma.refresh({skipIndexation:!0})}})}),g()},w=function(e){var n=e.firstCol,t=e.secCol,g=e.eachTimeCache,a=void 0===g?{}:g,o=e.scaleCache,r=void 0===o?{}:o,M=e.callback;if(i()(t).hex()!==i()(n).hex()){var s=function(){return A.props.animationNextFrameTime},I=function(){return Math.floor(.5*s()/50)},d=function(A){return a[A*s()]||(a[A*s()]=Math.floor(.5*s()/A))},N=function(A){return r[A+".."+n+"."+t]||(r[A+".."+n+"."+t]=i.a.scale([n,t]).mode("lch").domain([0,A-1]))},c=function(A){var e=setTimeout(function(){T[e]=null,A()},d(I()));T[e]={clear:function(){return clearTimeout(e)},fastforward:function(){return M(t)}}};c(function A(e){return function(){e>=I()||(M(N(I())(e).hex()),c(A(e+1)))}}(0))}},y=function(A,e){var n=o.g.revive(A);s(),Object.keys(e).forEach(function(A){h(A,e[A],"nodes")}),n.forEachEdge(function(A,e){x(A,D(n.neededColorVariety())[e],"edges")}),n.forEachNode(function(A,e){x(A,D(n.neededColorVariety())[e],"nodes")}),B()},m=function(){Object.keys(T).forEach(function(A){T[A]&&(T[A].clear(),T[A].fastforward())}),T={}};return{updateAppearence:y,resetAppearence:function(){s(),B()},killAppearenceAnimations:m,defaultColor:u.default,textColor:u.text,backgroundColor:c}};e.a=M},function(A,e){!function(){"use strict";sigma.utils.pkg("sigma.canvas.edges");var A=function(A,e,n,t){if(t){var i=A*e/n;return{y:i||Number.POSITIVE_INFINITY}}var g=A/(e/2),i=A-g*n;return{y:i?1/i:e}};sigma.canvas.edges.autoCurve=function(e){var n,t=e.settings("autoCurveSortByDirection"),i=e.settings("defaultEdgeType"),g=e.graph.edges(),a={key:function(A){var e=A.source+","+A.target;return this[e]?e:!t&&(e=A.target+","+A.source,this[e])?e:(t&&this[A.target+","+A.source]?this[e]={i:1,n:1}:this[e]={i:0,n:0},e)},inc:function(A){this[this.key(A)].n++}};g.forEach(function(A){a.inc(A)}),g.forEach(function(e){n=a.key(e),a[n].n>1||a[n].i>0?(e.cc||("arrow"===e.type||"arrow"===i?(e.cc_prev_type||(e.cc_prev_type=e.type),e.type="curvedArrow"):(e.cc_prev_type||(e.cc_prev_type=e.type),e.type="curve")),e.cc=A(100,a[n].n,a[n].i++,t)):e.cc&&(e.type=e.cc_prev_type,e.cc_prev_type=void 0,e.cc=void 0)})}}()},function(A,e,n){"use strict";var t=n(9),i=n(2),g=function(A,e){var g=function(e){return A.props.input[t.b.graph].update(e)},a=function(e){return function(n){if(n.data.captor.ctrlKey)return e(n,A.graph)}},o={handlerClickNode:a(function(e,n){if(e.data.captor.altKey){if(A.props.input[t.b.startNode]&&e.data.node.id===A.props.input[t.b.startNode].value)return void A.props.app.alert(1,"Cannot remove starting node");n.dropNode(e.data.node.id),A.sigma.graph.dropNode(e.data.node.id),A.layout(),g(n)}}),get bind(){var e=this;return function(){return A.sigma.bind("clickNode",e.handlerClickNode)}},get unbind(){var e=this;return function(){return A.sigma.unbind("clickNode",e.handlerClickNode)}}},r={handlerClickStage:a(function(e,t){if(!e.data.captor.altKey){for(var a=t.order;t.hasNode(a);)if(++a>1e3)throw new Error("Sictin");var o=t.addNode(a);A.sigma.graph.addNode(A.node(o,n.i(i.e)(0,50),n.i(i.e)(0,50))),A.layout(),g(t)}}),get bind(){var e=this;return function(){return A.sigma.bind("clickStage",e.handlerClickStage)}},get unbind(){var e=this;return function(){return A.sigma.unbind("clickStage",e.handlerClickStage)}}},M=null,s={handlerClickNode:a(function(e,n){if(!e.data.captor.altKey){if(null!==M&&n.hasNode(M)){var t=M,a=e.data.node.id;if(!n.hasEdge(t,a)){var o=function(e){var o=n.addEdgeWithKey(i.f.edgeKeyGenerator(t,a),t,a,{weight:e});A.sigma.graph.addEdge(A.edge(o,n,n.getEdgeAttribute(o,"weight"))),A.layout(),g(n)};n.edges().find(function(A){return n.getEdgeAttribute(A,"weight")})?A.props.app.prompt("Enter Weight",function(A){return o(parseInt(A,10))}):o()}return void(M=null)}M=e.data.node.id}}),get bind(){var e=this;return M=null,function(){return A.sigma.bind("clickNode",e.handlerClickNode)}},get unbind(){var e=this;return M=null,function(){return A.sigma.unbind("clickNode",e.handlerClickNode)}}};return{attachEvents:function(){r.bind(),o.bind(),s.bind()},detachEvents:function(){r.unbind(),o.unbind(),s.unbind()}}};e.a=g},function(A,e,n){"use strict";var t=n(12),i=n.n(t),g=function(A){var e=function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};A.sigma.graph.nodes().forEach(function(e,n){e.ananx=100*Math.cos(2*n*Math.PI/A.graph.order),e.anany=100*Math.sin(2*n*Math.PI/A.graph.order)}),sigma.plugins.animate(A.sigma,{x:"ananx",y:"anany"},{easing:"cubicInOut",onComplete:function(){t(),A.graph=e,A.createGraph(),n()}})};return{updateGraphSoft:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};i()(e.exportNodes(),A.graph.exportNodes())&&!i()(e.exportEdges(),A.graph.exportEdges())&&(A.sigma.graph.edges().forEach(function(e){var n=e.id;return A.sigma.graph.dropEdge(n)}),A.sigma.graph.read({edges:A.readGraph(e).edges})),t(),A.graph=e,A.layout(),n()},updateGraphHard:e}};e.a=g},function(A,e,n){"use strict";function t(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function i(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function g(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var a=n(198),o=(n.n(a),n(164)),r=(n.n(o),n(200)),M=(n.n(r),n(199)),s=(n.n(M),n(160)),T=(n.n(s),n(159)),I=(n.n(T),n(162)),d=(n.n(I),n(158)),N=(n.n(d),n(163)),c=(n.n(N),n(161)),l=(n.n(c),n(156)),C=(n.n(l),n(157)),E=(n.n(C),n(183)),u=(n.n(E),n(186)),D=(n.n(u),n(185)),x=(n.n(D),n(184)),h=(n.n(x),n(196)),B=(n.n(h),n(197)),w=(n.n(B),n(194)),y=(n.n(w),n(195)),m=(n.n(y),n(193)),L=(n.n(m),n(181)),Q=(n.n(L),n(180)),p=(n.n(Q),n(182)),j=(n.n(p),n(178)),b=(n.n(j),n(176)),z=(n.n(b),n(175)),f=(n.n(z),n(177)),U=(n.n(f),n(174)),Y=(n.n(U),n(172)),S=(n.n(Y),n(171)),G=(n.n(S),n(173)),k=(n.n(G),n(179)),O=(n.n(k),n(192)),v=(n.n(O),n(191)),Z=(n.n(v),n(188)),W=(n.n(Z),n(187)),V=(n.n(W),n(190)),H=(n.n(V),n(189)),R=(n.n(H),n(166)),F=(n.n(R),n(165)),X=(n.n(F),n(167)),J=(n.n(X),n(169)),P=(n.n(J),n(168)),K=(n.n(P),n(170)),q=(n.n(K),n(154)),_=(n.n(q),n(155)),$=(n.n(_),n(1)),AA=n.n($),eA=n(3),nA=n.n(eA),tA=n(12),iA=n.n(tA),gA=n(13),aA=n.n(gA),oA=n(9),rA=n(2),MA=n(11),sA=(n.n(MA),n(153)),TA=(n.n(sA),n(52)),IA=(n.n(TA),n(152)),dA=(n.n(IA),n(51)),NA=n(53),cA=n(54),lA=n(211),CA=(n.n(lA),n(41)),EA=n.n(CA),uA=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},DA=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),xA=function(A){function e(A){t(this,e);var g=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return hA.call(g),g.graphId="graph"+g.props.id,g.graph=e.parseGraph(g.props),Object.assign(g,n.i(dA.a)(g,e),n.i(NA.a)(g,e),n.i(cA.a)(g,e)),g}return g(e,A),DA(e,[{key:"componentDidMount",value:function(){var A=this;this.sigma=new sigma({renderer:{container:this.graphId,type:"canvas"},graph:this.readGraph(this.graph)}),sigma.utils.zoomTo(this.sigma.cameras[0],0,0,1.2),this.sigma.renderers[0].glyphs(),this.sigma.renderers[0].bind("render",function(){return A.sigma.renderers[0].glyphs()}),this.attachEvents(),this.createGraph()}},{key:"componentWillReceiveProps",value:function(A){var n=this,t=e.parseGraph(A),i=function(){n.updateAppearence(A.colors,A.customLabels)},g=function(){n.killAppearenceAnimations()};this.killAppearenceAnimations(),iA()(t,this.graph)?iA()(t.export(),this.graph.export())?i():this.updateGraphSoft(t,i,g):(this.resetAppearence(),this.updateGraphHard(t,i,g))}},{key:"componentWillUnmount",value:function(){this.killAppearenceAnimations(),this.detachEvents(),this.sigma.kill()}},{key:"createGraph",value:function(){var A=this.graph;this.sigma.graph.clear(),this.sigma.settings(uA({zoomMin:.3,zoomMax:5.5,minArrowSize:6,maxEdgeSize:5,minNodeSize:15,maxNodeSize:15,defaultLabelSize:EA.a.labelSize,font:MA.uiFont,edgeLabelSize:"proportional",defaultLabelColor:this.textColor,defaultEdgeLabelColor:this.textColor,doubleClickEnabled:!1,enableHovering:!1,edgeLabelSizePowRatio:1.1,glyphScale:.7,glyphLineWidth:5,glyphFontScale:1.5,glyphThreshold:6,glyphFillColor:this.backgroundColor,glyphTextColor:this.textColor,animationsTime:this.props.app.animationsEnabled?400:0,autoCurveRatio:10},e.typeOptions[A.type])),this.sigma.graph.read(this.readGraph(A)),this.layout()}},{key:"layout",value:function(){sigma.canvas.edges.autoCurve(this.sigma),sigma.layouts.killForceLink(this.sigma),sigma.layouts.startForceLink(this.sigma,{worker:!0,gravity:1.5,scalingRatio:10,autoStop:!0,background:!0,easing:"cubicInOut",alignNodeSiblings:!0})}},{key:"render",value:function(){return AA.a.createElement("div",{id:this.graphId,className:lA.style,style:{display:n.i(rA.c)("graph",this.props,!0)?"block":"none"}})}}]),e}($.Component);xA.parseGraph=function(A){return n.i(rA.d)(JSON.parse(JSON.stringify(A.optGraph||A.input[oA.b.graph].value)))},xA.typeOptions={directed:{defaultEdgeType:EA.a.curvedEdges?"curvedArrow":"arrow"},undirected:{defaultEdgeType:EA.a.curvedEdges?"curvedLine":"line"},mixed:{}};var hA=function(){var A=this;this.shouldComponentUpdate=function(){return!1},this.node=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return{id:e,label:""+e,size:1,color:A.defaultColor,x:n,y:t,glyphs:[{position:"top-left",strokeColor:function(){return this.color},content:void 0,draw:!1}]}},this.edge=function(e,n,t){return{id:e,source:n.source(e),target:n.target(e),label:!aA()(t)&&""+t,color:A.defaultColor,size:1}},this.readGraph=function(e){return{nodes:e.nodes().map(function(n,t){return A.node(n,100*Math.cos(2*t*Math.PI/e.order),100*Math.sin(2*t*Math.PI/e.order))}),edges:e.edges().map(function(n){return A.edge(n,e,e.getEdgeAttribute(n,"weight"))})}}};xA.defaultProps={optGraph:null,customLabels:{}},xA.propTypes={id:nA.a.string.isRequired,optGraph:nA.a.object,customLabels:nA.a.object,input:nA.a.objectOf(nA.a.shape({update:nA.a.func.isRequired,value:nA.a.any.isRequired})).isRequired,theme:nA.a.string.isRequired,animationNextFrameTime:nA.a.number.isRequired},e.a=xA},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(254),r=(n.n(o),n(2)),M=n(212),s=n.n(M),T=n.i(r.a)(s.a),I=function(A){return n.i(r.c)("table",A,A.data.length>0&&i.a.createElement("div",{className:T("container",A.theme)},i.a.createElement(o.Table,null,i.a.createElement(o.TableHeader,{adjustForCheckbox:!1,displaySelectAll:!1},i.a.createElement(o.TableRow,null,A.columns.map(function(A){return i.a.createElement(o.TableHeaderColumn,{key:A,style:{textAlign:"center"}},A)}))),i.a.createElement(o.TableBody,{displayRowCheckbox:!1,style:{maxHeight:A.width+"px"}},A.data.map(function(e,n){return i.a.createElement(o.TableRow,{key:"row"+n+JSON.stringify(e),hoverable:!0},e.map(function(e,n){return i.a.createElement(o.TableRowColumn,{key:"v"+A.columns[n]+e,style:{textAlign:"center"}},e)}))}))))||null)};I.propTypes={width:a.a.number.isRequired,columns:a.a.arrayOf(a.a.string).isRequired,data:a.a.array.isRequired,theme:a.a.string.isRequired},e.a=I},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(2),r=n(213),M=(n.n(r),function(A){return n.i(o.c)("text",A,i.a.createElement("div",{className:r.style},A.text))});M.propTypes={text:a.a.string},M.defaultProps={text:""},e.a=M},function(A,e,n){"use strict";function t(A,e,n){return e in A?Object.defineProperty(A,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):A[e]=n,A}function i(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function g(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function a(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var o=n(1),r=n.n(o),M=n(25),s=n.n(M),T=n(60),I=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},d=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),N=function(A,e){A.push(JSON.parse(JSON.stringify(e)))},c=function(A,e){return function(){return N(A,e.apply(void 0,arguments))}},l=function(A,e){return s()(A,function(A,n){return void 0!==e[n]})},C=function(A){var e=A.logic,n=A.snap,M=A.input,s=A.inputType,N=A.info,C=A.modules;return function(A){var s,E,u=A.revampedAlgInputType;return E=s=function(A){function e(A){i(this,e);var n=g(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return n.getInput=function(){return l(n.state,M)},n.inputs=function(){return u.map(function(A){var e=A.inputName,i=A.inputType,g=i.type,a=i.invalid;return{type:g,data:i.data,value:n.getInput()[e],validate:function(A){return!a(A,n.getInput())},update:function(A){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){},g=a(A,n.getInput());return g?i(g):n.inputHandler(t({},e,A),i)}}})},n.state=I({},M),n.state.frames=e.logic(M),n}return a(e,A),d(e,[{key:"inputHandler",value:function(A,n){this.setState(function(n){var t=I({},n,A);return t.frames=e.logic(l(t,M)),t},n)}},{key:"render",value:function(){return r.a.createElement(T.a,I({},this.props,{frames:this.state.frames,algorithmInfo:N,algorithmStatic:"function"==typeof C?C(this.props.app.settings):C,algorithmInput:this.inputs()}))}}]),e}(o.Component),s.logic=function(A){var t=[];return e(A,c(t,n)),t},s.selectInput=function(A){return u.filter(function(e){return e.inputType.type===A})},E}({revampedAlgInputType:Object.keys(s).reduce(function(A,e){return A.concat((Array.isArray(s[e])?s[e]:[s[e]]).map(function(A){return{inputName:e,inputType:A}}))},[])})};e.a=C},function(A,e,n){"use strict";function t(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}var i=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),g=function(){function A(e,n,i){var g=this,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;t(this,A),this.getSpeed=function(){return g.speed},this.getProgress=function(){return g.progress},this.getDirectives=function(){return g.directives},this.getIsPaused=function(){return g.isPaused},this.getNextFrameTime=function(){return g.nextFrameTime},this.toBegin=function(){return g.advanceTo(0)},this.toEnd=function(){return g.advanceTo(g.frames.length-1)},this.stepForward=function(){return g.advance(1)},this.stepBackward=function(){return g.advance(-1)},this.pauseRestart=function(){return g.isPaused=!g.isPaused,g.didEnd?(g.didEnd=!1,g.toBegin()):g.changeHandler()},this.changeSpeed=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:50;if(arguments[1])return void g.setting()("speed").set(g.speed);var n=e;e>=100&&(n=100),e<=0&&(n=0),g.speed=n,g.internalSpeed=A.calcInternalSpeed(n),g.changeHandler()},this.mount=function(){var A=function(A){return setTimeout(A,g.nextFrameTime)},e=function e(){g.nextFrameTime=Math.floor(g.frameTime*g.internalSpeed*1e3),g.tick(),g.timer=A(e)};g.timer=A(e)},this.unmount=function(){clearTimeout(g.timer)},Object.assign(this,{frames:e,setting:n,changeHandler:i,frameTime:a}),this._init()}return i(A,[{key:"_init",value:function(){this.setting()("speed").default(50),this.speed=this.setting()("speed").get(),this.progress=0,this.directives=this.frames[0],this.isPaused=!0,this.nextFrameTime=1e3*this.frameTime,this.frameIndex=0,this.internalSpeed=A.calcInternalSpeed(this.speed),this.didEnd=!1}},{key:"refresh",value:function(A){this.frames=A,this._init(),this.changeHandler()}},{key:"tick",value:function(){this.isPaused||this.advance()}},{key:"advance",value:function(){var A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return this.advanceTo(this.frameIndex+A)}},{key:"advanceTo",value:function(A){if(this.didEnd=!1,A>this.frames.length-1)return this.didEnd=!0,this.isPaused=!0,void(A===this.frames.length&&this.changeHandler());this.directives=A>0?this.frames[A]:this.frames[0],this.frameIndex=A>0?A:0,this.calculateProgress(),this.changeHandler()}},{key:"calculateProgress",value:function(){this.progress=Math.round(this.frameIndex/(this.frames.length-1)*100)}}]),A}();g.calcInternalSpeed=function(A){var e=A,n=void 0;return e-=50,e/=10,0===e?n=1:e<0?n=-1*e+1:e>0&&(n=1/(e+1)),n},e.a=g},function(A,e,n){"use strict";function t(A,e){var n={};for(var t in A)e.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(A,t)&&(n[t]=A[t]);return n}function i(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function g(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function a(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var o=n(1),r=n.n(o),M=n(3),s=n.n(M),T=n(76),I=n(59),d=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},N=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),c=function(A){function e(A){i(this,e);var n=g(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return n.handleAnimatorChange=function(){n.setState({animationDirectives:n.animator.getDirectives(),speed:n.animator.getSpeed(),progress:n.animator.getProgress(),isPaused:n.animator.getIsPaused(),nextFrameTime:n.animator.getNextFrameTime()})},n.animator=new I.a(A.frames,function(){return A.app.settings("options")("animation")},n.handleAnimatorChange),n.state={animationDirectives:n.animator.getDirectives(),speed:n.animator.getSpeed(),progress:n.animator.getProgress(),isPaused:n.animator.getIsPaused(),nextFrameTime:n.animator.getNextFrameTime()},n}return a(e,A),N(e,[{key:"componentDidMount",value:function(){this.animator.mount()}},{key:"componentWillReceiveProps",value:function(A){A.frames!==this.props.frames&&this.animator.refresh(A.frames)}},{key:"componentWillUnmount",value:function(){this.animator.unmount()}},{key:"render",value:function(){var A=this.props,e=(A.frames,t(A,["frames"]));return r.a.createElement(T.a,d({},e,{animationDirectives:this.state.animationDirectives,animationSpeed:this.state.speed,animationProgress:this.state.progress,animationIsPaused:this.state.isPaused,animationNextFrameTime:this.state.nextFrameTime,onAnimationChangeSpeed:this.animator.changeSpeed,onAnimationToBegin:this.animator.toBegin,onAnimationStepForward:this.animator.stepForward,onAnimationPauseRestart:this.animator.pauseRestart,onAnimationStepBackward:this.animator.stepBackward,onAnimationToEnd:this.animator.toEnd}))}}]),e}(o.Component);c.propTypes={frames:s.a.array.isRequired},e.a=c},function(A,e,n){"use strict";function t(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function i(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function g(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var a=n(1),o=n.n(a),r=n(32),M=n.n(r),s=n(33),T=n.n(s),I=n(82),d=n(20),N=n(79),c=n(77),l=n(74),C=n(10),E=(n.n(C),n(11)),u=(n.n(E),function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}()),D=new I.a,x={view:N.a,name:"Main"},h=function(A){function e(A){t(this,e);var g=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return g._topHistory=function(){var A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return g.history[g.history.length-(1+A)]||null},g._getThemeColors=function(){return{palette:C.themes[g.settings("options")("theme").get()],fontFamily:E.uiFont}},g._getBack=function(){return g._topHistory(1)},g._setView=function(){g.setState({view:g._topHistory()||x,back:g._getBack()})},g.prompt=function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){};g.setState({modal:{type:"prompt",message:A,exitStrategy:function(){return g.setState({modal:{}})},options:{continuation:e}}})},g.alert=function(A,e){g.setState({modal:{type:"alert",message:e,exitStrategy:function(A){return"timeout"===A&&g.setState({modal:{}})},durationModifier:A+1}})},g.updateHeader=function(A,e){g.setState({headerRoutes:A},e)},g.goBack=function(){g.history.pop(),g._setView()},g.changeView=function(A){A.name!==g._topHistory().name&&(g.history.push(A),g._setView())},g.state={view:x,back:null,headerRoutes:[],modal:{},rawSettings:""},g.settings=n.i(l.a)(D,function(){g.setState({rawSettings:g.settings().get()})}),g.settings("options")("theme").default("giant-goldfish"),g.settings("options")("grayscale-visualizations").default(!1),g.settings("options")("animations-enabled").default(!0),Object.keys(d.a).forEach(function(A){g.settings("options")("enabled-modules")(A).default(!0)}),g.settings("custom-code")("saves").default([]),g.history=[x],g}return g(e,A),u(e,[{key:"componentDidMount",value:function(){requestAnimationFrame(function(){return setTimeout(function(){document.documentElement.removeAttribute("data-preload")},0)})}},{key:"render",value:function(){return document.documentElement.setAttribute("data-theme",this.settings("options")("theme").get()),document.documentElement.setAttribute("data-animations-enabled",this.settings("options")("animations-enabled").get()),o.a.createElement(M.a,{muiTheme:T()(this._getThemeColors())},o.a.createElement(c.a,{view:this.state.view,modal:this.state.modal,backData:this.state.back,goBack:this.goBack,headerRoutes:this.state.headerRoutes,theme:this.settings("options")("theme").get(),animationsEnabled:this.settings("options")("animations-enabled").get(),settings:this.settings,prompt:this.prompt,alert:this.alert,updateHeader:this.updateHeader,changeView:this.changeView}))}}]),e}(a.Component);e.a=h},function(A,e,n){"use strict";function t(A,e,n){return e in A?Object.defineProperty(A,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):A[e]=n,A}function i(A,e){if(!(A instanceof e))throw new TypeError("Cannot call a class as a function")}function g(A,e){if(!A)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?A:e}function a(A,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(A,e):A.__proto__=e)}var o=n(1),r=n.n(o),M=n(3),s=n.n(M),T=n(7),I=n(78),d=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},N=function(){function A(A,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(A,t.key,t)}}return function(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),e}}(),c=function(A,e){return{value:A,set:e}},l=function(A){function e(A){i(this,e);var n=g(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,A));return n.onCodeChange=function(A){n.addToState("code",A),n.evaluateCode()},n.onSelectSave=function(A){n.addToState("code",A.code),n.evaluateCode()},n.renameSave=function(A,e){n.saves().set(function(n){return n.find(function(e){return e.name===A.name}).name=e,n})},n.deleteSave=function(A){n.saves().set(function(e){return e.splice(e.findIndex(function(e){return e.name===A.name}),1),e})},n.addSave=function(A){n.saves().set(function(e){return e.push({name:A,code:n.state.code}),e})},n.visualize=function(){console.log(n.state),console.log("implement visualizating here")},n.addToState=function(A,e){n.setState(t({},A,e))},n.algName=function(){return c(n.state.name,function(A){return n.addToState("name",A)})},n.algType=function(){return c({current:n.state.type,possible:Object.keys(T.a)},function(A){n.addToState("type",A),n.addToState("typeFeatures",{})})},n.algTypeFeatures=function(){return c((T.a[n.state.type]||[]).map(function(A){return{name:A.name,enabled:n.state.typeFeatures[A.name]||!1}}),function(A,e){return n.setState(function(n){return n.typeFeatures[A]=e,n})})},n.state={code:"// type your code",name:"Untitled Algorithm",type:"graph",typeFeatures:{}},n.saves=function(){return n.props.app.settings("custom-code")("saves")},n}return a(e,A),N(e,[{key:"evaluateCode",value:function(){console.log("evaluateCode")}},{key:"render",value:function(){return r.a.createElement(I.a,d({},this.props,{onCodeChange:this.onCodeChange,code:this.state.code,savedCodes:this.saves().get(),onSelectSave:this.onSelectSave,renameSave:this.renameSave,deleteSave:this.deleteSave,addSave:this.addSave,visualize:this.visualize,algName:this.algName(),algType:this.algType(),algTypeFeatures:this.algTypeFeatures()}))}}]),e}(o.Component);l.propTypes={app:s.a.any.isRequired},e.a=l},function(A,e,n){"use strict";var t=n(7),i=n(2),g=n.i(t.b)("BFS","graph");g.addStartingNodeInput(),g.addDescription("\nBreadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.\n\nBFS was invented in the late 1950s by E. F. Moore, who used it to find the shortest path out of a maze, and discovered independently by C. Y. Lee as a wire routing algorithm (published 1961).\n"),g.addCode(["BFS(s):","    Q = {s}; // FIFO","    while Q is not empty","        v = Q.front(); Q.pop();","        if v is visited already, continue;","        mark v visited","        for each neighbour u of v:","            if u is visited already, continue;","            else, Q.push(u);"]),g.addTable("queue",["Queue"]),g.addNodedTable("visited","Visited"),g.logic=function(A,e){var t=A.startVertex,a=A.graph,o=g.algorithm,r=[],M=[],s=[],T=a.nodes().reduce(function(A,e){return A[e]=!1,A},{}),I=function(A,t,g,a){o.visited(T),o.queue([r]),o.graph.setColor(0,n.i(i.k)(T),s),o.graph.setColor(1,r,[]),o.code(A),o.explanation(t),o.graph.setColor(2,g,a),e()};I([],void 0),r.push(t),M.push(void 0),I([0,1],"Run BFS from vertex "+t,t);for(;0!==r.length;){(function(){var A=r.shift(),e=M.shift();if(I([3],"Processing vertex "+A,A),T[A])return I([4],"Vertex "+A+" is visited",A),"continue";T[A]=!0,e&&s.push(a.edge(e,A)),I([5],"Mark vertex "+A+" visited"),a.outNeighbors(A).forEach(function(e){if(T[e])return void I([7],"Vertex "+e+" is visited",A,a.edge(A,e));r.push(e),M.push(A),I([8],"Vertex "+e+" is not visited, push to queue",A,a.edge(A,e))})})()}I([],"BFS("+t+") completed")},e.a=g.create()},function(A,e,n){"use strict";var t=n(7),i=n(2),g=n.i(t.b)("DFS","graph");g.addStartingNodeInput(),g.addDescription("\nDepth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.\n\nA version of depth-first search was investigated in the 19th century by French mathematician Charles Pierre TrÃ©maux as a strategy for solving mazes.\n"),g.addCode(["DFS(v):","    if v is visited return","    mark v visited","    for every neighbour u of v:","        DFS(u)","    return"," ","DFS(s)"]),g.addTable("recursion",["Recursion Stack"]),g.addNodedTable("visited","Visited"),g.logic=function(A,e){var t=A.startVertex,a=A.graph,o=g.algorithm,r=[],M=[],s=a.nodes().reduce(function(A,e){return A[e]=!1,A},{}),T=function(A,t,g,a){o.visited(s),o.recursion([r]),o.graph.setColor(0,n.i(i.k)(s),M),o.graph.setColor(1,r,[]),o.code(A),o.explanation(t),o.graph.setColor(2,g,a),e()};r.push(t),T([],void 0),T([7],"Starting main DFS from "+t,t),function A(e){if(T([0],"Start DFS("+e+")",e),s[e])return void T([1],e+" is visited; return",e);s[e]=!0,T([2],"Mark "+e+" visited",e),a.outNeighbors(e).forEach(function(n){T([3,4],"For neighbour "+n+" of "+e+" do DFS",e,a.edge(e,n)),r.push(n),A(n),r.pop(),M.push(a.edge(e,n))}),T([5],"DFS("+e+") ended!",e)}(t),T([],"DFS from "+t+" ended!",t)},e.a=g.create()},function(A,e,n){"use strict";var t=n(7),i=n(2),g=n.i(t.b)("Djikstra","graph");g.addStartingNodeInput(),g.addDescription("\nDijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.\n\nThe algorithm exists in many variants; Dijkstra's original variant found the shortest path between two nodes, but a more common variant fixes a single node as the \"source\" node and finds shortest paths from the source to all other nodes in the graph, producing a shortest-path tree.\n\nThe algorithm only works as long as we do not have edges with negative weights. Otherwise, there is noguarantee that when we pick u as the closest vertex, dist[v] for some other vertex v will not becomesmaller than dist[u] at some time in the future.\n"),g.addCode(["Djikstra(s):","    enqueue pair(s, 0) // Min-PriorityQueue","    while pq is not empty","         retrieve node v and distance d -> dequeue","         if v is visited continue","         else mark node visited","         for every neighbor u of v","             enqueue pair(u, d + weight)"]),g.addNodedTable("shortest","Distance"),g.addNodedTable("visited","Visited"),g.logic=function(A,e){var t=A.startVertex,a=A.graph,o=g.algorithm,r=function(A,e,n){return{id:A,distance:e,parent:n}},M=[],s=a.nodes().reduce(function(A,e){return A[e]=1/0,A},{}),T=a.nodes().reduce(function(A,e){return A[e]=!1,A},{}),I=function(A,t,g,a){o.visited(T),o.graph.setColor(0,n.i(i.k)(T),M),o.graph.setGlyphs(s),o.shortest(s),o.code(A),o.explanation(t),o.graph.setColor(1,g,a),e()},d=new i.l.PriorityQueue(function(A,e){return A.distance>e.distance?-1:A.distance<e.distance?1:0});I([],void 0),I([0],"Starting Djikstra from node "+t,t),d.enqueue(r(t,0)),I([1],"Enqueue the starting node "+t+" with the distance 0",t);for(;!d.isEmpty();){(function(){var A=d.dequeue(),e=A.distance,n=A.id,t=A.parent;if(I([2,3],"Dequeued node "+n+" with distance "+e,n),T[n])return I([4],"Node "+n+" is visited, continue",n),"continue";s[n]=e,T[n]=!0,t&&M.push(a.edge(t,n)),I([5],"Mark "+n+" visited"),a.outNeighbors(n).forEach(function(A){var t=a.getEdgeAttribute(n,A,"weight");I([6,7],"Enqueue neighbor "+A+" with distance "+(t+e)+" (= weight "+t+" + v's distance "+e+")",A,a.edge(n,A)),d.enqueue(r(A,t+e,n))})})()}I([],"Djikstra from "+t+" completed")},e.a=g.create()},function(A,e,n){"use strict";var t=n(7),i=n(2),g=n(12),a=n.n(g),o=n(248),r=n.n(o),M=n(247),s=n.n(M),T=n.i(t.b)("Kruskal","graph");T.addDescription("\nA minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. That is, it is a spanning tree whose sum of edge weights is as small as possible. Directed graph equivalent of a MST is a minimum spanning arborescence.\n\nThe algorithm initializes a forest consisting of trees with single nodes. The edges are sorted in a queue based on their weights. In each round an edge is removed from the queue. If the edge's endpoints belong to different trees then the trees are merged using the edge. The process continues until all the nodes are in the same tree or the edge-queue is empty.\n"),T.addCode(["Kruskal(s):","    map each vertex v -> makeset v","    sort edges by increasing weight -> E","    while E is not empty","         pop e from E","         if both extremities of e are from different sets","             union both sets","             add e to mst"]),T.addText("sum"),T.logic=function(A,e){var t=A.graph,g=T.algorithm,o=0,M=[],I=t.nodes().reduce(function(A,e){return A[e]=!1,A},{}),d=function(A,t,a,r,s,T,d,N){g.code(A),g.graph.setColor(0,n.i(i.k)(I),M),g.graph.setColor(1,s,d),g.graph.setColor(2,T,N),g.graph.setColor(3,a,r),g.explanation(t),g.sum("MST Cost: "+o),e()};d([],void 0),d([0],"Starting MST-Kruskal");var N=t.nodes().map(function(A){return[A]});d([1],"Make a set for every node, that initially only contains that node",t.nodes());var c=t.edges();c.sort(function(A,e){return t.getEdgeAttribute(e,"weight")-t.getEdgeAttribute(A,"weight")}),d([2],"Sort edges by increasing weight:\n"+c.map(function(A){return t.extremities(A).join("-")}).join(", "),t.nodes()),c.reverse(),c.forEach(function(A){var e=t.extremities(A),n=t.getEdgeAttribute(A,"weight");d([3,4],"Pop edge "+t.extremities(A).join("-")+" with connection cost "+n,e,A);var i=e.map(function(A){return N.find(function(e){return e.includes(A)})});if(!a()(i[0],i[1])){var g=i.map(function(A){for(var e=[],n=0;n<A.length;n++)for(var i=n+1;i<A.length;i++)e.push(t.edge(A[n],A[i]));return e}).filter(function(A){return A});d([5],"Vertex "+e[0]+" and vertex "+e[1]+" are from different sets",null,A,i[0],i[1],g[0],g[1]),N=r()(N,i[0],i[1]),N.push(s()(i[0],i[1])),M.push(A),e.forEach(function(A){return I[A]=!0}),o+=n,d([6,7],"Union both sets")}}),d([],"MST-Kruskal completed, MST is "+o)},e.a=T.create()},function(A,e,n){"use strict";var t=n(7),i=n(2),g=n.i(t.b)("Prim","graph");g.addStartingNodeInput(),g.addDescription("\nA minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. That is, it is a spanning tree whose sum of edge weights is as small as possible. Directed equivalent of a MST is a minimum spanning arborescence.\n\nPrim's algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex.\n\nThe algorithm was developed in 1930 by Czech mathematician VojtÄ›ch JarnÃ­k and later rediscovered and republished by computer scientists Robert C. Prim in 1957 and Edsger W. Dijkstra in 1959.\n"),g.addCode(["Prim(s):","    enqueue pair(s, 0) // Min-PriorityQueue","    while pq is not empty","         retrieve node v and connection cost -> dequeue","         if v is visited continue","         else add cost to sum and mark node visited","         for every neighbor u of v","             enqueue pair(u, weight of edge v -> u)"]),g.addText("sum"),g.addNodedTable("visited","Visited"),g.logic=function(A,e){var t=A.startVertex,a=A.graph,o=g.algorithm,r=function(A,e,n){return{id:A,weight:e,parent:n}},M=0,s=[],T=a.nodes().reduce(function(A,e){return A[e]=1/0,A},{}),I=a.nodes().reduce(function(A,e){return A[e]=!1,A},{}),d=function(A,t,g,a){o.code(A),o.graph.setColor(0,n.i(i.k)(I),s),o.graph.setColor(1,g,a),o.graph.setGlyphs(T),o.explanation(t),o.sum("MST Cost: "+M),o.visited(I),e()},N=new i.l.PriorityQueue(function(A,e){return A.weight>e.weight?-1:A.weight<e.weight?1:0});d([],void 0),d([0],"Starting MST-Prim from node "+t,t),N.enqueue(r(t,0)),d([1],"Enqueue the starting node "+t+" with connection cost 0",t);for(;!N.isEmpty();){(function(){var A=N.dequeue(),e=A.weight,n=A.id,t=A.parent;if(d([2,3],"Dequeued node "+n+" with connection cost "+e,n),I[n])return d([4],"Node "+n+" is visited, continue",n),"continue";M+=e,T[n]=e,I[n]=!0,t&&s.push(a.edge(t,n)),d([5],"Add cost "+e+" to sum and mark vertex "+n+" visited"),a.outNeighbors(n).forEach(function(A){var e=a.getEdgeAttribute(n,A,"weight");d([6,7],"Enqueue neighbor "+A+" with connection cost "+e,A,a.edge(n,A)),N.enqueue(r(A,e,n))})})()}d([],"MST-Prim from "+t+" completed, MST is "+M)},e.a=g.create()},function(A,e,n){"use strict";var t=n(7),i=n(2),g=n.i(t.b)("SCC","graph");g.addStartingNodeInput(),g.addDescription("\nIn the mathematical theory of directed graphs, a graph is said to be strongly connected or diconnected if every vertex is reachable from every other vertex. The strongly connected components or diconnected components of an arbitrary directed graph form a partition into subgraphs that are themselves strongly connected.\n\nKosaraju's algorithm uses two passes of depth first search. The first, in the original graph, is used to choose the order in which the outer loop of the second depth first search tests vertices for having been visited already and recursively explores them if not. The second depth first search is on the transpose graph of the original graph, and each recursive exploration finds a single new strongly connected component. It is named after S. Rao Kosaraju, who described it (but did not publish his results) in 1978; Micha Sharir later published it in 1981."),g.addCode(["SCC(s):","    computeFinishOrders(v):","        if v visited return","        else mark v visited","        for every neighbor u of v","            if u visited continue","            else computeFinishOrders(u)","        save finish time of v"," ","    for every node v","        if v visited continue","        else computeFinishOrders(v)","    reset visited map"," ","    reverse graph","    let SCCID be 0"," ","    traverseConnectedComponent(v):","        if v visited return","        else mark v visited","        node v belongs to SCC SCCID","        for every neighbor u of v in reversed graph","            if u visited continue","            else traverseConnectedComponent(u)"," ","    while finishTimesList is not empty","        pop v from finishTimesList","        if v visited continue","        else traverseConnectedComponent(v)","        increase SCCID by one"]),g.addTable("f1",["Nodes","Finish Times"]),g.addTable("scc",["SCCs"]),g.logic=function(A,e){var t=A.startVertex,a=A.graph,o=g.algorithm,r=function(A,e){return{fi:A,se:e}},M=void 0,s=void 0,T=void 0,I=void 0,d=function(){M=a.nodes().reduce(function(A,e){return A[e]=!1,A},{}),T=[],I=[],s=[]};d();var N=[],c=[],l=[],C=function(A,t,g,a){var r=[N.map(function(A){return A.fi.toString()}),N.map(function(A){return A.se.toString()})];o.code(A);var d=c.length;o.graph.setColor(0,n.i(i.k)(M),s),Array(d).fill(1).map(function(A,e){return e+1}).forEach(function(A,e){o.graph.setColor(A,c[e],l[e])}),o.graph.setColor(d+1,T,I),o.graph.setColor(d+2,g,a),o.graph.setGlyphs(r[1].reduce(function(A,e,n){return A[e]=r[0][n],A},{})),o.f1([r[1],r[0]]),o.scc([c.map(function(A){return A.join(", ")})]),o.explanation(t),e()},E=function(){o.graph.setOverrideGraph(a),C.apply(void 0,arguments)};E([],void 0),E([],"Starting SCC from node "+t,t);var u=0,D=function A(e){M[e]||(T.push(e),E([3],"Traverse node "+e,e),M[e]=!0,a.outNeighbors(e).forEach(function(n){M[n]||(E([4,6],"Extend to neighbour "+n+" of "+e,[e,n],a.edge(e,n)),I.push(a.edge(e,n)),A(n),I.pop(),T.pop(),s.push(a.edge(e,n)))}),N.push(r(++u,e)),E([7],"Finish time of node "+e+" is "+u,e))};a.nodes().forEach(function(A){M[A]||(E([1,9,11],"computeFinishOrders("+A+")",A),D(A),T.pop())}),d(),E([12],"Computation of finish orders finished, reset vars");var x=n.i(i.m)(a);(E=function(){o.graph.setOverrideGraph(x),C.apply(void 0,arguments)})([14],"Reverse the graph");for(var h=0,B=[];N.length>0;){var w=N.pop().se;if(!M[w]){E([17,28],"Traversing SCC "+h+" starting with node "+w,w),B[h]=[],function A(e){M[e]||(T.push(e),M[e]=!0,B[h].push(e),E([19],"Node "+e+" belongs to SCC "+h,e),x.outNeighbors(e).forEach(function(n){M[n]||(E([21,22],"Extend to neighbour "+n+" of "+e,e,x.edge(e,n)),I.push(x.edge(e,n)),A(n),I.pop(),T.pop(),s.push(x.edge(e,n)))}))}(w),T.pop();var y=function(A){return B.map(function(A){for(var e=[],n=0;n<A.length;n++)for(var t=0;t<A.length;t++)e.push(x.edge(A[n],A[t]));return e.filter(function(A){return A})}).filter(function(A){return A})[A]}(h);E([29],"Traversal of SCC "+h+" completed, it includes nodes:\n"+B[h],B[h],y),l[h]=y,c[h]=B[h],h++}}(E=function(){o.graph.setOverrideGraph(a),C.apply(void 0,arguments)})([],"SCC from "+t+" completed "+h)},e.a=g.create()},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=function(A){return i.a.createElement("div",{className:"TopologicalDFS"}," ")};e.a=g},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=function(A){return i.a.createElement("div",{className:"TopologicalIndegree"}," ")};e.a=g},function(A,e,n){"use strict";n.d(e,"a",function(){return I});var t=n(65),i=n(63),g=n(64),a=n(68),o=n(67),r=n(66),M=n(69),s=n(70),T={Djikstra:{name:"Djikstra",desc:"Visualise Djikstra's Single Source Shortest Path Algorithm",view:t.a},BFS:{name:"BFS",desc:"Visualise Breadth-First Search Algorithm",view:i.a},DFS:{name:"DFS",desc:"Visualise Depth-First Search Algorithm",view:g.a},SCC:{name:"Strongly Connected Components",desc:"Visualise Kosaraju's Algorithm to find Strongly Connected Components",view:a.a},Prim:{name:"Prim's MST",desc:"Find a Minimum Spanning Tree using Prim's MST Algorithm",view:o.a},Kruskal:{name:"Kruskal's MST",desc:"Find a Minimum Spanning Tree using Kruskal's MST Algorithm",view:r.a},TopologicalDFS:{name:"Topological Sort (DFS)",desc:"Sort topologically using DFS",view:M.a},TopologicalIndegree:{name:"Topological Sort (Indegree Array)",desc:"Sort topologically using Indegree Array",view:s.a}},I=[{title:"Graph Algorithms",algorithms:[T.Djikstra,T.BFS,T.DFS,T.SCC,T.Prim,T.Kruskal,T.TopologicalDFS,T.TopologicalIndegree]}]},function(A,e,n){"use strict";function t(A){if(Array.isArray(A)){for(var e=0,n=Array(A.length);e<A.length;e++)n[e]=A[e];return n}return Array.from(A)}n.d(e,"b",function(){return N}),n.d(e,"a",function(){return c});var i=n(246),g=n.n(i),a=n(2),o=n(24),r=n.n(o),M=function(A,e){var n=new r.a[A](a.f);return e(n),"undirected"===n.type&&(n.inNeighbors=n.outNeighbors=n.neighbors),n},s=function(A,e){return M(A,function(A){var n=Math.max.apply(Math,t(e.map(function(A){return Math.max.apply(Math,t(A.map(function(A){return Array.isArray(A)?A[0]:A})))})));A.addNodesFrom(Array(n+1).fill(1).map(function(A,e){return e})),e.forEach(function(e,n){return e.forEach(function(e){var t=Array.isArray(e)?e[0]:e,i=Array.isArray(e)?e[1]:null;A.addEdgeWithKey(a.f.edgeKeyGenerator({source:n,target:t}),n,t,Array.isArray(e)&&{weight:i})})})})},T=[{suits:["BFS","DFS"],graphs:[{name:"Undirected Cyclic",graph:s("UndirectedGraph",[[1,2,4],[3],[3],[4],[5]])},{name:"Undirected Acyclic",graph:s("UndirectedGraph",[[1,2,3,4],[5],[6],[7],[8],[9,10,11],[12,13,14],[15,16,17],[18,19,20]])},{name:"Dengesiz Binary Tree",graph:s("DirectedGraph",[[1,2],[3,4],[],[5,6],[],[7,8],[],[9,10]])}]},{suits:["Djikstra","BFS","DFS"],graphs:[{name:"Dengesiz Binary Tree Weighted",graph:s("DirectedGraph",[[[1,18],[2,3]],[[3,10],[4,6]],[],[[5,24],[6,3]],[],[[7,11],[8,15]],[],[[9,8],[10,10]]])},{name:"Directed Cyclic Weighted",graph:s("DirectedGraph",[[[1,5],[3,10]],[[2,1],[3,3]],[[3,2]],[[1,4]]])}]},{suits:["Prim","Djikstra","Kruskal","BFS","DFS"],graphs:[{name:"Undirected Cyclic Weighted",graph:s("UndirectedGraph",[[[1,4],[7,8]],[[2,8],[7,11]],[[3,7],[5,4],[8,2]],[[4,9],[5,14]],[[5,10]],[[6,2]],[[7,1],[8,6]],[[8,7]]])},{name:"Undirected Cyclic Weighted 2",graph:s("UndirectedGraph",[[[1,6],[2,3]],[[3,8],[4,1]],[[4,2]],[[4,10]]])},{name:"Undirected Big Numbers",graph:s("UndirectedGraph",[[[2,8447],[4,1922]],[[1,6144],[2,5366]],[[4,1677]]])}]},{suits:["BFS","DFS","SCC"],graphs:[{name:"Directed Cyclic 4 SCCs",graph:s("DirectedGraph",[[1,9],[2,8],[3,7],[4,5,6,7],[5],[4],[5],[2,4],[0,7],[8]])},{name:"Directed Cyclic 5 SCCs",graph:s("DirectedGraph",[[1,9],[2,8],[3,7,11],[4,5,6,7,14],[5],[4],[5,12],[2,4],[0,7],[8],[2],[10],[13],[6],[15],[16],[14,5]])}]}],I=function(A,e){return e.includes(A)},d=n.i(a.i)(T.map(function(A){return A.graphs})),N=function(A){return n.i(a.i)(T.map(function(e){return I(A,e.suits)?e.graphs:[]}))},c=function(){var A=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return A?g()(N(A)):g()(d)}},function(A,e,n){"use strict";var t=n(14),i=n.n(t),g=n(2),a=n(21),o=n(9),r=function(A,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return{type:A,layout:"string"==typeof e?{location:e,order:0}:e,data:n}},M=function(A,e,n){return{snap:A,module:e,input:n}},s={},T=s.Graph=M(function(A,e,n){return{colors:A,customLabels:e,optGraph:n}},function(A){return r("graph","main",{options:A})},function(A){return i()(o.c.Graph,function(e){return n.i(a.b)("graph",A,e)})}),I=s.Table=M(function(A){return{data:Array(A.reduce(function(A,e){return Math.max(A,e.length)},0)).fill(1).map(function(e,n){return A.reduce(function(A,e){return A.push(e[n]),A},[])})}},function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:150;return r("table","right",{width:e,columns:A})}),d=(s.Text=M(function(A){return{text:A}},function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"right";return r("text",e,{text:A})}),s.Examples=M(function(){return{}},function(A,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(A){return A},t=arguments[3];return r("examples",{location:"left",order:-100},{exampleGroup:A,examples:e,customs:(t("examples")(A).get()||[]).map(function(A){var e=A.data;return{name:A.name,data:n(e)}}),addCustom:function(e,n){return t("examples")(A).set(function(){var A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return A.push({name:e,data:n}),A})},deleteCustom:function(e){return t("examples")(A).set(function(A){return A.splice(A.map(function(A){return A.name}).indexOf(e),1),A})},renameCustom:function(e,n){return t("examples")(A).set(function(A){return A[A.map(function(A){return A.name}).indexOf(e)].name=n,A})}})},function(A){return n.i(a.b)("examples",A,o.c.Examples)}));s.Code=M(function(A){return{highlights:A}},function(A){return r("code",{location:"right",order:100},{code:A})}),s.ExampleGraphs=M(d.snap,function(A){for(var e=arguments.length,n=Array(e>1?e-1:0),t=1;t<e;t++)n[t-1]=arguments[t];return d.module.apply(d,["Graph",A.map(function(A){return{name:A.name,data:A.graph}}),g.d].concat(n))},d.input),s.Description=M(function(){return{}},function(A){return r("description","left",{text:A})}),s.RefinedGraph=M(function(A,e){for(var n=arguments.length,t=Array(n>3?n-3:0),a=3;a<n;a++)t[a-3]=arguments[a];var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=new g.g;return A.forEach(function(A){return r.pushNodes(Array.isArray(A)?A:[A])}),e.forEach(function(A){return r.pushEdges(Array.isArray(A)?A:[A])}),T.snap.apply(T,[r,i()(o,g.h)].concat(t))},function(){return T.module.apply(T,arguments)},function(){return T.input.apply(T,arguments)}),s.NodedTable=M(function(){var A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return I.snap([Object.keys(A),Object.keys(A).map(function(e){return A[e].toString()})])},function(A){return I.module(["Node",A],200)});e.a=s},function(A,e,n){"use strict";var t=n(13),i=n.n(t),g=function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){},n=function(){return JSON.parse(A.getItem("settings")||"{}")},t=function(n){A.setItem("settings",JSON.stringify(n)),e()},g=function A(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n(),a=arguments[2],o=a||g,r=function(n){var t=void 0;return t=g[e]?g[e]:g[e]={},A(n,t,o)};return r.set=function(A){var n="function"==typeof A?A:function(){return A};g[e]=n(g[e]),t(o)},r.default=function(A){var n="function"==typeof A?A:function(){return A};i()(g[e])&&(g[e]=n(g[e]),t(o))},r},a=function A(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n(),g=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=t;e&&(i()(t[e])?g=!0:a=t[e]);var o=function e(n){return g||i()(e.ctx[n])?A(!1,{},!0):A(!1,e.ctx[n])};return o.get=function(){var A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0;return g?A:a},g||(o.ctx=a),o};return function A(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];e&&n.push(e);var t=function(e){return A(e,n)};return t.get=function(){var A,e=a(n[0]);return n.slice(1).forEach(function(A){return e=e(A)}),(A=e).get.apply(A,arguments)},t.set=function(){var A,e=g(n[0]);return n.slice(1).forEach(function(A){return e=e(A)}),(A=e).set.apply(A,arguments)},t.default=function(){var A,e=g(n[0]);return n.slice(1).forEach(function(A){return e=e(A)}),(A=e).default.apply(A,arguments)},t}};e.a=g},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(71),r=n(17),M=n(214),s=(n.n(M),function(A){return i.a.createElement("div",{className:M.pageView},o.a.map(function(e){return i.a.createElement("nav",{key:e.title},i.a.createElement("h1",null,e.title),i.a.createElement("div",{className:M.container},e.algorithms.map(function(e){return i.a.createElement(r.a,{name:e.name,key:e.name,desc:e.desc,cols:2,onTouchTap:function(){return A.app.changeView(e)},theme:A.app.theme})})))}))});s.propTypes={app:a.a.shape({theme:a.a.string.isRequired}).isRequired},e.a=s},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(42),r=n(43),M=n(47),s=n(215),T=(n.n(s),Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A}),I=["algorithmInput","animationSpeed","animationIsPaused","onAnimationChangeSpeed","onAnimationToBegin","onAnimationToEnd","onAnimationStepBackward","onAnimationPauseRestart","onAnimationStepForward"],d=function(A){return i.a.createElement(M.a,null,i.a.createElement("section",{className:s.section},i.a.createElement(o.a,T({},Object.keys(A).filter(function(A){return!I.includes(A)}).reduce(function(e,n){return e[n]=A[n],e},{}),{input:A.algorithmInput.filter(function(A){return"module"===A.type}),theme:A.app.theme}))),i.a.createElement("footer",{className:s.footer},i.a.createElement(r.a,T({},A,{input:A.algorithmInput.filter(function(A){return"init"===A.type}),theme:A.app.theme}))))};d.propTypes={app:a.a.any.isRequired,algorithmInput:a.a.arrayOf(a.a.shape({type:a.a.string.isRequired})).isRequired},e.a=d},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(249),r=n.n(o),M=n(253),s=n.n(M),T=n(44),I=n(46),d=n(2),N=n(216),c=n.n(N),l=n.i(d.a)(c.a),C=function(A){return Object.keys(A).filter(function(A){return!["view","backData","headerRoutes","modal"].includes(A)}).reduce(function(e,n){return e[n]=A[n],e},{})},E=function(A){return i.a.createElement("div",null,i.a.createElement(r.a,{open:0!==Object.keys(A.modal).length&&["prompt"].includes(A.modal.type),title:A.modal.message,actions:function(){switch(A.modal.type){case"prompt":return[i.a.createElement(I.a,{send:function(){var e;(e=A.modal.options).continuation.apply(e,arguments),A.modal.exitStrategy()},underlineFocusStyle:{borderColor:n.i(d.b)(A.theme)("primary2Color")},underlineStyle:{borderColor:n.i(d.b)(A.theme)("primary1Color")}})];default:return[]}}(),onRequestClose:A.modal.exitStrategy,overlayClassName:l("overlay",A.theme),contentClassName:l("content",A.theme),actionsContainerClassName:l("actions-container",A.theme),titleClassName:l("title",A.theme)}),i.a.createElement(s.a,{open:0!==Object.keys(A.modal).length&&["alert"].includes(A.modal.type),message:A.modal.message||"",autoHideDuration:1500*(A.modal.durationModifier||1),onRequestClose:A.modal.exitStrategy,className:l("snackbar",A.theme)}))},u=function(A){return i.a.createElement("div",{className:l("container",A.theme)},E(A),i.a.createElement(T.a,{disabled:!A.backData,current:A.view,back:A.backData,routes:A.headerRoutes,app:C(A)}),i.a.createElement("div",{className:l("main")},i.a.createElement(A.view.view,{app:C(A)})))};u.defaultProps={backData:null},u.propTypes={view:a.a.object.isRequired,theme:a.a.string.isRequired,backData:a.a.any,headerRoutes:a.a.any.isRequired},e.a=u},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(19),r=n(27),M=(n.n(r),n(15)),s=n.n(M),T=n(18),I=n(252),d=n.n(I),N=n(31),c=n.n(N),l=n(28),C=n.n(l),E=n(16),u=n.n(E),D=n(30),x=n.n(D),h=n(26),B=n.n(h),w=n(268),y=n.n(w),m=n(34),L=n.n(m),Q=n(35),p=n.n(Q),j=n(36),b=n.n(j),z=n(2),f=n(22),U=n(233),Y=(n.n(U),n(234)),S=(n.n(Y),n(235)),G=(n.n(S),n(236)),k=(n.n(G),n(237)),O=(n.n(k),n(238)),v=(n.n(O),n(240)),Z=(n.n(v),n(239)),W=(n.n(Z),n(217)),V=n.n(W),H=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},R=n.i(z.a)(V.a),F={dark:"tomorrow_night_eighties","giant-goldfish":"solarized_light"},X=function(A){return i.a.createElement("div",{className:R("container",A.app.theme)},i.a.createElement(y.a,{className:R("ace-editor",A.app.theme),mode:"javascript",theme:F[A.app.theme]||"monokai",name:"text-editor-logic-code",onChange:A.onCodeChange,showPrintMargin:!1,showGutter:!0,highlightActiveLine:!0,value:A.code,tabSize:4,enableBasicAutocompletion:!0,enableLiveAutocompletion:!0,setOptions:{enableSnippets:!1,showLineNumbers:!0},editorProps:{$blockScrolling:1/0}}),i.a.createElement(o.a,{side:"left",theme:A.app.theme},i.a.createElement(r.List,null,i.a.createElement(r.ListItem,{primaryText:"Saved Codes",disabled:!0,primaryTogglesNestedList:!0,autoGenerateNestedIndicator:!1,open:!0,rightIconButton:i.a.createElement(s.a,{touch:!0,onTouchTap:function(){A.app.prompt("Enter Name",function(e){return A.addSave(e)})}},i.a.createElement(p.a,null)),nestedItems:A.savedCodes.map(function(e){return i.a.createElement(r.ListItem,{key:e.name,primaryText:e.name,onTouchTap:function(){return A.onSelectSave(e)},rightIconButton:n.i(T.a)({theme:A.app.theme,items:[{name:"Rename",icon:b.a,onTouch:function(){return A.app.prompt("Enter New Name",function(n){return A.renameSave(e,n)})}},{name:"Delete",icon:L.a,onTouch:function(){return A.deleteSave(e)}}]})})})}))),i.a.createElement(o.a,{side:"right",theme:A.app.theme},i.a.createElement(c.a,{floatingLabelText:"Algorithm/Code Name",value:A.algName.value,onChange:function(e){return A.algName.set(e.target.value)}}),i.a.createElement(C.a,H({floatingLabelText:"Algorithm Type",value:A.algType.value.current,onChange:function(e,n,t){return A.algType.set(t)}},n.i(f.a)(A.app.theme)),A.algType.value.possible.map(function(A){return i.a.createElement(u.a,{key:A,value:A,primaryText:A})})),i.a.createElement("div",null,i.a.createElement(x.a,n.i(f.b)(),"Type Specific Features"),A.algTypeFeatures.value.map(function(e){var n=e.name,t=e.enabled;return i.a.createElement(B.a,{label:n,checked:t,onCheck:function(e,t){return A.algTypeFeatures.set(n,t)}})})),i.a.createElement(d.a,{label:"Visualize",onTouchTap:A.visualize})))};X.defaultProps={code:"// type your code...",savedCodes:[]};var J=a.a.shape({set:a.a.func.isRequired,value:a.a.any.isRequired});X.propTypes={app:a.a.any.isRequired,onCodeChange:a.a.func.isRequired,code:a.a.string,savedCodes:a.a.arrayOf(a.a.shape({name:a.a.string,code:a.a.string})),onSelectSave:a.a.func.isRequired,renameSave:a.a.func.isRequired,deleteSave:a.a.func.isRequired,addSave:a.a.func.isRequired,visualize:a.a.func.isRequired,algName:J.isRequired,algType:J.isRequired,algTypeFeatures:J.isRequired,algPseudoCode:J.isRequired,algDescription:J.isRequired},e.a=X},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(17),r=n(75),M=n(62),s=n(81),T=n(80),I=n(102),d=n.n(I),N=n(218),c=(n.n(N),function(A){return i.a.createElement("div",{className:N.mainView},i.a.createElement("div",{className:N.container},l.map(function(e){return i.a.createElement(o.a,{name:e.name,key:e.name,desc:e.desc,onTouchTap:function(){return A.app.changeView(e)},theme:A.app.theme})})))}),l=[{view:r.a,name:"Algorithms",desc:"Choose from numerous algorithms to visualize"},{view:M.a,name:"Custom Code",desc:"Visualize your own code with algoriv"},{view:T.a,name:"Options"},{view:n.i(s.a)(d.a),name:"Usage"}];c.propTypes={app:a.a.shape({theme:a.a.any.isRequired,changeView:a.a.func.isRequired}).isRequired},e.a=c},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(28),r=n.n(o),M=n(16),s=n.n(M),T=n(26),I=n.n(T),d=n(29),N=n.n(d),c=n(30),l=n.n(c),C=n(8),E=n.n(C),u=n(2),D=n(10),x=(n.n(D),n(22)),h=n(219),B=n.n(h),w=Object.assign||function(A){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(A[t]=n[t])}return A},y=Object.keys(D.themes),m=n.i(u.a)(B.a),L=function(A){return function(e){var t=e.name,g=e.option,a=e.possib;return i.a.createElement("div",{className:m("control")},i.a.createElement(r.a,w({floatingLabelText:t,fullWidth:!0,value:g().get(),onChange:function(A,e,n){return g().set(n)}},n.i(x.a)(A)),a.map(function(A){return i.a.createElement(s.a,{key:A,value:A,primaryText:A})})))}},Q=function(){return function(A){var e=A.name,n=A.option;return i.a.createElement("div",{className:m("control")},i.a.createElement(I.a,{label:e,checked:n().get(),onCheck:function(A,e){return n().set(e)}}))}},p=function(){return function(A){var e=A.name,t=A.option,g=A.min,a=A.max;return i.a.createElement("div",{className:m("control")},i.a.createElement(l.a,n.i(x.b)(),e),i.a.createElement(N.a,{min:g,max:a,value:t().get(),onChange:function(A,e){return t().set(e)},sliderStyle:{margin:0}}))}},j=function(A){return function(e){var t=e.name,g=e.action;return i.a.createElement("div",{className:m("control")},i.a.createElement(E.a,{label:t,onTouchTap:g,backgroundColor:n.i(u.b)(A)("primary1Color"),hoverColor:n.i(u.b)(A)("accent1Color"),style:{color:n.i(u.b)(A)("alternativeTextColor")},fullWidth:!0}))}},b=function(A){var e=function(){return A.app.settings("options")},n=L(A.app.theme),t=Q(A.app.theme),g=p(A.app.theme),a=j(A.app.theme);return i.a.createElement("div",{className:m("container")},i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h1",null,"Core Options"),i.a.createElement("span",null,"These options are ","application's"," core settings which affect behaviour unrelated to modules and algorithms.")),n({name:"Theme",option:function(){return e()("theme")},possib:y}),t({name:"Minimal Colored Visualizations",option:function(){return e()("grayscale-visualizations")}}),t({name:"Animations",option:function(){return e()("animations-enabled")}}),g({name:"Animation Speed",option:function(){return e()("animation")("speed")},min:1,max:100})),i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h1",null,"Module Options"),i.a.createElement("span",null,"These options are specific to modules which only affect their behaviour.")),i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h2",null,"Code Module"),i.a.createElement("span",null,"Options for the Code module.")),t({name:"Enabled",option:function(){return e()("enabled-modules")("code")}})),i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h2",null,"Description Module"),i.a.createElement("span",null,"Options for the Description module.")),t({name:"Enabled",option:function(){return e()("enabled-modules")("description")}})),i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h2",null,"Graph Module"),i.a.createElement("span",null,"Options for the Graph module.")),t({name:"Enabled",option:function(){return e()("enabled-modules")("graph")}})),i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h2",null,"Table Module"),i.a.createElement("span",null,"Options for the Table module.")),t({name:"Enabled",option:function(){return e()("enabled-modules")("table")}})),i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h2",null,"Text Module"),i.a.createElement("span",null,"Options for the Text module.")),t({name:"Enabled",option:function(){return e()("enabled-modules")("text")}})),i.a.createElement("div",{className:m("control-group")},i.a.createElement("header",null,i.a.createElement("h2",null,"Examples Module"),i.a.createElement("span",null,"Options for the Examples module.")),t({name:"Enabled",option:function(){return e()("enabled-modules")("examples")}}),a({name:"Purge Custom Inputs",action:function(){return A.app.settings("examples").set({})}}))))};b.propTypes={app:a.a.shape({theme:a.a.any.isRequired,settings:a.a.func.isRequired}).isRequired},e.a=b},function(A,e,n){"use strict";var t=n(1),i=n.n(t),g=n(3),a=n.n(g),o=n(2),r=n(220),M=n.n(r),s=n.i(o.a)(M.a),T=function(A){var e=function(e){return i.a.createElement("div",{className:s("container",e.app.theme),dangerouslySetInnerHTML:{__html:A}})};return e.propTypes={app:a.a.shape({theme:a.a.string.isRequired}).isRequired},e};e.a=T},function(A,e,n){"use strict";function t(){return new M(g.a.join(o.getPath("userData"),"./storage.json"))}e.a=t;var i=n(267),g=n.n(i),a=n(244),o=a.remote.app,r=n(266),M=r.LocalStorage},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-AlgorithmInner-style__top--DNYik{display:flex;position:relative;justify-content:space-between;height:100%}.app-components-AlgorithmInner-style__top--DNYik .app-components-AlgorithmInner-style__main--20W4G{position:relative;margin-right:auto;margin-left:auto;width:calc(100% - 80px)}",""]),e.locals={top:"app-components-AlgorithmInner-style__top--DNYik",main:"app-components-AlgorithmInner-style__main--20W4G"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-AnimationControls-style__container-dark--3-hkM{display:flex;flex-direction:column;height:100%}.app-components-AnimationControls-style__container-dark--3-hkM .app-components-AnimationControls-style__upper--3M59d{justify-content:center;width:100%;height:100%;overflow:hidden}.app-components-AnimationControls-style__container-dark--3-hkM .app-components-AnimationControls-style__upper--3M59d>*{margin:0 20px}.app-components-AnimationControls-style__container-dark--3-hkM .app-components-AnimationControls-style__buttons--3cq2X{order:-1}.app-components-AnimationControls-style__container-giant-goldfish--Vu2-N{display:flex;flex-direction:column;height:100%}.app-components-AnimationControls-style__container-giant-goldfish--Vu2-N .app-components-AnimationControls-style__upper--3M59d{justify-content:center;width:100%;height:100%;overflow:hidden}.app-components-AnimationControls-style__container-giant-goldfish--Vu2-N .app-components-AnimationControls-style__upper--3M59d>*{margin:0 20px}.app-components-AnimationControls-style__container-giant-goldfish--Vu2-N .app-components-AnimationControls-style__buttons--3cq2X{order:-1}.app-components-AnimationControls-style__buttons--3cq2X,.app-components-AnimationControls-style__upper--3M59d{display:flex;align-items:center}",""]),e.locals={"container-dark":"app-components-AnimationControls-style__container-dark--3-hkM",containerDark:"app-components-AnimationControls-style__container-dark--3-hkM",upper:"app-components-AnimationControls-style__upper--3M59d",buttons:"app-components-AnimationControls-style__buttons--3cq2X","container-giant-goldfish":"app-components-AnimationControls-style__container-giant-goldfish--Vu2-N",containerGiantGoldfish:"app-components-AnimationControls-style__container-giant-goldfish--Vu2-N"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-BigButton-style__container-dark--2Kh24{display:inline-flex;position:relative;flex-flow:column;justify-content:center;margin:10px 0;background:#946e58;overflow:hidden;text-decoration:none;font-family:Raleway,Roboto,sans-serif}.app-components-BigButton-style__container-dark--2Kh24>button{position:absolute!important;width:100%!important;height:100%!important;min-width:unset!important}.app-components-BigButton-style__container-dark--2Kh24>button>*{display:none!important}.app-components-BigButton-style__container-dark--2Kh24 .app-components-BigButton-style__inner-container--29Kfw{padding:20px}.app-components-BigButton-style__container-dark--2Kh24 .app-components-BigButton-style__primary-dark--1NjB1,.app-components-BigButton-style__container-dark--2Kh24 .app-components-BigButton-style__secondary-dark--1fAGR{overflow:hidden;font-weight:500;text-overflow:ellipsis;white-space:nowrap;color:#e0e4cc}.app-components-BigButton-style__container-dark--2Kh24 .app-components-BigButton-style__primary-dark--1NjB1{margin:2.2px 0;font-size:22px}.app-components-BigButton-style__container-dark--2Kh24 .app-components-BigButton-style__secondary-dark--1fAGR{font-size:12.22222px}.app-components-BigButton-style__container-giant-goldfish--1tTX2{display:inline-flex;position:relative;flex-flow:column;justify-content:center;margin:10px 0;background:#f38630;overflow:hidden;text-decoration:none;font-family:Raleway,Roboto,sans-serif}.app-components-BigButton-style__container-giant-goldfish--1tTX2>button{position:absolute!important;width:100%!important;height:100%!important;min-width:unset!important}.app-components-BigButton-style__container-giant-goldfish--1tTX2>button>*{display:none!important}.app-components-BigButton-style__container-giant-goldfish--1tTX2 .app-components-BigButton-style__inner-container--29Kfw{padding:20px}.app-components-BigButton-style__container-giant-goldfish--1tTX2 .app-components-BigButton-style__primary-giant-goldfish--1DlmD,.app-components-BigButton-style__container-giant-goldfish--1tTX2 .app-components-BigButton-style__secondary-giant-goldfish--_EcH3{overflow:hidden;font-weight:500;text-overflow:ellipsis;white-space:nowrap;color:#e0e4cc}.app-components-BigButton-style__container-giant-goldfish--1tTX2 .app-components-BigButton-style__primary-giant-goldfish--1DlmD{margin:2.2px 0;font-size:22px}.app-components-BigButton-style__container-giant-goldfish--1tTX2 .app-components-BigButton-style__secondary-giant-goldfish--_EcH3{font-size:12.22222px}",""]),e.locals={"container-dark":"app-components-BigButton-style__container-dark--2Kh24",containerDark:"app-components-BigButton-style__container-dark--2Kh24","inner-container":"app-components-BigButton-style__inner-container--29Kfw",innerContainer:"app-components-BigButton-style__inner-container--29Kfw","primary-dark":"app-components-BigButton-style__primary-dark--1NjB1",primaryDark:"app-components-BigButton-style__primary-dark--1NjB1","secondary-dark":"app-components-BigButton-style__secondary-dark--1fAGR",secondaryDark:"app-components-BigButton-style__secondary-dark--1fAGR","container-giant-goldfish":"app-components-BigButton-style__container-giant-goldfish--1tTX2",containerGiantGoldfish:"app-components-BigButton-style__container-giant-goldfish--1tTX2","primary-giant-goldfish":"app-components-BigButton-style__primary-giant-goldfish--1DlmD",primaryGiantGoldfish:"app-components-BigButton-style__primary-giant-goldfish--1DlmD","secondary-giant-goldfish":"app-components-BigButton-style__secondary-giant-goldfish--_EcH3",secondaryGiantGoldfish:"app-components-BigButton-style__secondary-giant-goldfish--_EcH3"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-Header-style__container-dark--vzFEz{transition:background .5s;display:flex;align-items:center;justify-content:space-between;background:#946e58;height:40px}.app-components-Header-style__container-dark--vzFEz .app-components-Header-style__nav--2JA8P{display:block}.app-components-Header-style__container-dark--vzFEz .app-components-Header-style__header--33Bx3{display:block;margin:0 40px;color:#e0e4cc;font-family:Slabo\\ 27px,serif;font-size:18pt;font-weight:400}.app-components-Header-style__container-giant-goldfish--3btEW{transition:background .5s;display:flex;align-items:center;justify-content:space-between;background:#f38630;height:40px}.app-components-Header-style__container-giant-goldfish--3btEW .app-components-Header-style__nav--2JA8P{display:block}.app-components-Header-style__container-giant-goldfish--3btEW .app-components-Header-style__header--33Bx3{display:block;margin:0 40px;color:#e0e4cc;font-family:Slabo\\ 27px,serif;font-size:18pt;font-weight:400}",""]),e.locals={"container-dark":"app-components-Header-style__container-dark--vzFEz",containerDark:"app-components-Header-style__container-dark--vzFEz",nav:"app-components-Header-style__nav--2JA8P",header:"app-components-Header-style__header--33Bx3","container-giant-goldfish":"app-components-Header-style__container-giant-goldfish--3btEW",containerGiantGoldfish:"app-components-Header-style__container-giant-goldfish--3btEW"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-IconMenu-style__menu-item-dark--3nDjn{color:#e0e4cc!important}.app-components-IconMenu-style__menu-item-dark--3nDjn svg{fill:#e0e4cc!important}.app-components-IconMenu-style__menu-item-giant-goldfish--3Kf6s{color:#e0e4cc!important}.app-components-IconMenu-style__menu-item-giant-goldfish--3Kf6s svg{fill:#e0e4cc!important}",""]),e.locals={"menu-item-dark":"app-components-IconMenu-style__menu-item-dark--3nDjn",menuItemDark:"app-components-IconMenu-style__menu-item-dark--3nDjn","menu-item-giant-goldfish":"app-components-IconMenu-style__menu-item-giant-goldfish--3Kf6s",menuItemGiantGoldfish:"app-components-IconMenu-style__menu-item-giant-goldfish--3Kf6s"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-SideDrawer-style__par-dark--34AQA .app-components-SideDrawer-style__handle--38pQC{background-color:#946e58}.app-components-SideDrawer-style__par-dark--34AQA .app-components-SideDrawer-style__container--2e5Uz{background:#774f38}.app-components-SideDrawer-style__par-giant-goldfish--XAZlq .app-components-SideDrawer-style__handle--38pQC{background-color:#f38630}.app-components-SideDrawer-style__par-giant-goldfish--XAZlq .app-components-SideDrawer-style__container--2e5Uz{background:#e0e4cc}.app-components-SideDrawer-style__par--1s8iK{display:flex;position:absolute;top:0;bottom:0;z-index:1000}.app-components-SideDrawer-style__par--1s8iK .app-components-SideDrawer-style__handle--38pQC{display:flex;position:relative;align-items:center;justify-content:center;transition:all .5s cubic-bezier(.23,1,.32,1) 0ms;width:40px;height:100%}.app-components-SideDrawer-style__par--1s8iK .app-components-SideDrawer-style__handle--38pQC>button{position:absolute!important;width:100%!important;height:100%!important;min-width:unset!important}.app-components-SideDrawer-style__par--1s8iK .app-components-SideDrawer-style__handle--38pQC>button>*{display:none!important}.app-components-SideDrawer-style__par--1s8iK .app-components-SideDrawer-style__handle--38pQC .app-components-SideDrawer-style__handle-icon--2BJwb{transition:all .5s cubic-bezier(.23,1,.32,1) 0ms;width:40px!important;height:40px!important}.app-components-SideDrawer-style__par--1s8iK.app-components-SideDrawer-style__right--1aiWG{right:0;flex-direction:row-reverse}.app-components-SideDrawer-style__par--1s8iK.app-components-SideDrawer-style__left--3Vycx{left:0;flex-direction:row}.app-components-SideDrawer-style__par--1s8iK.app-components-SideDrawer-style__left--3Vycx .app-components-SideDrawer-style__container--2e5Uz{direction:rtl}.app-components-SideDrawer-style__par--1s8iK.app-components-SideDrawer-style__left--3Vycx .app-components-SideDrawer-style__container--2e5Uz>*{direction:ltr}.app-components-SideDrawer-style__par--1s8iK.app-components-SideDrawer-style__active--3djnY .app-components-SideDrawer-style__container--2e5Uz{padding:40px;max-width:100vw}.app-components-SideDrawer-style__par--1s8iK.app-components-SideDrawer-style__active--3djnY .app-components-SideDrawer-style__handle--38pQC{width:20px}.app-components-SideDrawer-style__par--1s8iK.app-components-SideDrawer-style__active--3djnY .app-components-SideDrawer-style__handle--38pQC .app-components-SideDrawer-style__handle-icon--2BJwb{transform:rotateY(-180deg);width:20px!important;height:20px!important}.app-components-SideDrawer-style__container--2e5Uz{display:flex;position:relative;flex-direction:column;align-items:center;justify-content:space-between;padding:40px 0;max-width:0;overflow:scroll;overflow-x:hidden;overflow-y:auto;transition-duration:.5s}.app-components-SideDrawer-style__container--2e5Uz>*{position:relative;margin-bottom:40px}.app-components-SideDrawer-style__container--2e5Uz>:last-child{margin-bottom:0}",""]),e.locals={"par-dark":"app-components-SideDrawer-style__par-dark--34AQA",parDark:"app-components-SideDrawer-style__par-dark--34AQA",handle:"app-components-SideDrawer-style__handle--38pQC",container:"app-components-SideDrawer-style__container--2e5Uz",par:"app-components-SideDrawer-style__par--1s8iK","handle-icon":"app-components-SideDrawer-style__handle-icon--2BJwb",handleIcon:"app-components-SideDrawer-style__handle-icon--2BJwb",right:"app-components-SideDrawer-style__right--1aiWG",left:"app-components-SideDrawer-style__left--3Vycx",active:"app-components-SideDrawer-style__active--3djnY","par-giant-goldfish":"app-components-SideDrawer-style__par-giant-goldfish--XAZlq",parGiantGoldfish:"app-components-SideDrawer-style__par-giant-goldfish--XAZlq"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-modules-code-module-style__code-dark--2wOkZ p{color:#e0e4cc}.app-components-modules-code-module-style__code-dark--2wOkZ p.app-components-modules-code-module-style__active--28DRM{background-color:#542437;color:#e0e4cc}.app-components-modules-code-module-style__code-giant-goldfish--3xli- p{color:#434743}.app-components-modules-code-module-style__code-giant-goldfish--3xli- p.app-components-modules-code-module-style__active--28DRM{background-color:#009688;color:#e0e4cc}.app-components-modules-code-module-style__code--2KQjM p{margin:0;white-space:pre;font-family:AnkaCoderC75Regular,monospace;transition-duration:.5s}",""]),e.locals={"code-dark":"app-components-modules-code-module-style__code-dark--2wOkZ",codeDark:"app-components-modules-code-module-style__code-dark--2wOkZ",active:"app-components-modules-code-module-style__active--28DRM",code:"app-components-modules-code-module-style__code--2KQjM","code-giant-goldfish":"app-components-modules-code-module-style__code-giant-goldfish--3xli-",codeGiantGoldfish:"app-components-modules-code-module-style__code-giant-goldfish--3xli-"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-modules-description-module-style__container--1mIsd{width:300px;white-space:pre-line;font-family:Slabo\\ 27px,serif}.app-components-modules-description-module-style__header--DlGIJ{font-weight:700}",""]),e.locals={container:"app-components-modules-description-module-style__container--1mIsd",header:"app-components-modules-description-module-style__header--DlGIJ"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-modules-examples-module-style__container-dark--39Ocs svg{color:#542437!important;fill:#542437!important}.app-components-modules-examples-module-style__container-giant-goldfish--2Szbm svg{color:#009688!important;fill:#009688!important}.app-components-modules-examples-module-style__container--2LqRy{width:300px}",""]),e.locals={"container-dark":"app-components-modules-examples-module-style__container-dark--39Ocs",containerDark:"app-components-modules-examples-module-style__container-dark--39Ocs","container-giant-goldfish":"app-components-modules-examples-module-style__container-giant-goldfish--2Szbm",containerGiantGoldfish:"app-components-modules-examples-module-style__container-giant-goldfish--2Szbm",container:"app-components-modules-examples-module-style__container--2LqRy"}},function(A,e,n){e=A.exports=n(4)(void 0),e.push([A.i,".app-components-modules-graph-module-style__style--3q_gd{width:100%;height:100%}",""]),e.locals={style:"app-components-modules-graph-module-style__style--3q_gd"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-modules-table-module-style__container-dark--2HqSa{width:300px}.app-components-modules-table-module-style__container-dark--2HqSa thead,.app-components-modules-table-module-style__container-dark--2HqSa tr{display:table;border-bottom:0!important;background:#774f38!important;width:100%;table-layout:fixed}.app-components-modules-table-module-style__container-dark--2HqSa tbody{display:block}.app-components-modules-table-module-style__container-giant-goldfish--1rBlo{width:300px}.app-components-modules-table-module-style__container-giant-goldfish--1rBlo thead,.app-components-modules-table-module-style__container-giant-goldfish--1rBlo tr{display:table;border-bottom:0!important;background:#e0e4cc!important;width:100%;table-layout:fixed}.app-components-modules-table-module-style__container-giant-goldfish--1rBlo tbody{display:block}",""]),e.locals={"container-dark":"app-components-modules-table-module-style__container-dark--2HqSa",containerDark:"app-components-modules-table-module-style__container-dark--2HqSa","container-giant-goldfish":"app-components-modules-table-module-style__container-giant-goldfish--1rBlo",containerGiantGoldfish:"app-components-modules-table-module-style__container-giant-goldfish--1rBlo"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-components-modules-text-module-style__style--22abm{display:inline-block;text-align:center;font-family:Slabo\\ 27px,serif;font-weight:700;width:300px}.app-components-modules-text-module-style__style--22abm:empty{display:none}",""]),e.locals={style:"app-components-modules-text-module-style__style--22abm"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-views-AlgorithmPageView-style__page-view--3dTUh{position:relative;margin:auto;padding-top:4vh;width:70vw;box-sizing:border-box;min-width:768px}@media (max-width:768px){.app-views-AlgorithmPageView-style__page-view--3dTUh{width:100vw;min-width:0}}.app-views-AlgorithmPageView-style__container--zmtLh{display:flex;flex-flow:row wrap;justify-content:space-between}",""]),e.locals={"page-view":"app-views-AlgorithmPageView-style__page-view--3dTUh",pageView:"app-views-AlgorithmPageView-style__page-view--3dTUh",container:"app-views-AlgorithmPageView-style__container--zmtLh"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-views-AlgorithmView-style__section--O2RpE{position:relative;height:calc(100% - 40px)}.app-views-AlgorithmView-style__footer--37KDy{position:relative;height:40px}",""]),e.locals={section:"app-views-AlgorithmView-style__section--O2RpE",footer:"app-views-AlgorithmView-style__footer--37KDy"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,'.app-views-AppView-style__container-dark--3Ucyj{color:#e0e4cc;font-family:Raleway,Roboto,sans-serif;user-select:none}.app-views-AppView-style__actions-container-dark--101Fk svg{fill:#e0e4cc!important}.app-views-AppView-style__content-dark--17bFy>div{background-color:#542437!important}.app-views-AppView-style__title-dark--iYvuS{color:#e0e4cc!important}.app-views-AppView-style__overlay-dark--11LhC{background-color:rgba(0,0,0,.5)!important}.app-views-AppView-style__snackbar-dark--44ZUd>div{background-color:#542437!important}[data-theme=dark] body{background:#774f38}[data-theme=dark] ::-webkit-scrollbar{background:#774f38}[data-theme=dark] ::-webkit-scrollbar-thumb{background-color:rgba(217,91,67,.4)!important}[data-theme=dark] ::-webkit-scrollbar-thumb:hover{background-color:rgba(217,91,67,.8)!important}[data-theme=dark] ::-webkit-scrollbar-thumb:active{background-color:rgba(217,91,67,.6)!important}[data-theme=dark] [data-reactroot][style*="background-color: rgb(255, 255, 255);"]{background:#542437!important}.app-views-AppView-style__container-giant-goldfish--1FudJ{color:#434743;font-family:Raleway,Roboto,sans-serif;user-select:none}.app-views-AppView-style__actions-container-giant-goldfish--2_3av svg{fill:#e0e4cc!important}.app-views-AppView-style__content-giant-goldfish--1xwhR>div{background-color:#009688!important}.app-views-AppView-style__title-giant-goldfish--1Ui7c{color:#e0e4cc!important}.app-views-AppView-style__overlay-giant-goldfish--35-AT{background-color:rgba(0,23,20,.5)!important}.app-views-AppView-style__snackbar-giant-goldfish--2cM-G>div{background-color:#009688!important}[data-theme=giant-goldfish] body{background:#e0e4cc}[data-theme=giant-goldfish] ::-webkit-scrollbar{background:#e0e4cc}[data-theme=giant-goldfish] ::-webkit-scrollbar-thumb{background-color:rgba(250,105,0,.4)!important}[data-theme=giant-goldfish] ::-webkit-scrollbar-thumb:hover{background-color:rgba(250,105,0,.8)!important}[data-theme=giant-goldfish] ::-webkit-scrollbar-thumb:active{background-color:rgba(250,105,0,.6)!important}[data-theme=giant-goldfish] [data-reactroot][style*="background-color: rgb(255, 255, 255);"]{background:#009688!important}.app-views-AppView-style__main--204PJ{position:relative;height:calc(100vh - 40px)}.app-views-AppView-style__content--2ED8l{display:flex;justify-content:center}.app-views-AppView-style__content--2ED8l>div{padding:24px}.app-views-AppView-style__content--2ED8l>div>:empty{display:none}.app-views-AppView-style__actions-container--MN41k{padding:8px 0 0!important}.app-views-AppView-style__title--2SHTG{padding:0 0 8px!important}::-webkit-scrollbar{width:9px!important;height:9px!important}::-webkit-scrollbar-button:end:increment,::-webkit-scrollbar-button:start:decrement{display:none;width:0;height:0}::-webkit-scrollbar-track-piece{margin:1px;background:transparent!important;padding:0;width:6px!important;height:5px!important}::-webkit-scrollbar-thumb{z-index:2147483647;margin:1px!important;border:2px solid transparent!important;border-radius:12px;background-clip:content-box;width:1px!important}::-webkit-scrollbar-corner{border:1px solid transparent;background:transparent!important}[data-animations-enabled=false] *,[data-preload] *{transition:none!important;animation:none!important}body{transition:background .5s;margin:0}',""]),e.locals={"container-dark":"app-views-AppView-style__container-dark--3Ucyj",containerDark:"app-views-AppView-style__container-dark--3Ucyj","actions-container-dark":"app-views-AppView-style__actions-container-dark--101Fk",actionsContainerDark:"app-views-AppView-style__actions-container-dark--101Fk","content-dark":"app-views-AppView-style__content-dark--17bFy",contentDark:"app-views-AppView-style__content-dark--17bFy","title-dark":"app-views-AppView-style__title-dark--iYvuS",titleDark:"app-views-AppView-style__title-dark--iYvuS","overlay-dark":"app-views-AppView-style__overlay-dark--11LhC",overlayDark:"app-views-AppView-style__overlay-dark--11LhC","snackbar-dark":"app-views-AppView-style__snackbar-dark--44ZUd",snackbarDark:"app-views-AppView-style__snackbar-dark--44ZUd","container-giant-goldfish":"app-views-AppView-style__container-giant-goldfish--1FudJ",containerGiantGoldfish:"app-views-AppView-style__container-giant-goldfish--1FudJ","actions-container-giant-goldfish":"app-views-AppView-style__actions-container-giant-goldfish--2_3av",actionsContainerGiantGoldfish:"app-views-AppView-style__actions-container-giant-goldfish--2_3av","content-giant-goldfish":"app-views-AppView-style__content-giant-goldfish--1xwhR",contentGiantGoldfish:"app-views-AppView-style__content-giant-goldfish--1xwhR","title-giant-goldfish":"app-views-AppView-style__title-giant-goldfish--1Ui7c",titleGiantGoldfish:"app-views-AppView-style__title-giant-goldfish--1Ui7c","overlay-giant-goldfish":"app-views-AppView-style__overlay-giant-goldfish--35-AT",overlayGiantGoldfish:"app-views-AppView-style__overlay-giant-goldfish--35-AT","snackbar-giant-goldfish":"app-views-AppView-style__snackbar-giant-goldfish--2cM-G",snackbarGiantGoldfish:"app-views-AppView-style__snackbar-giant-goldfish--2cM-G",main:"app-views-AppView-style__main--204PJ",content:"app-views-AppView-style__content--2ED8l","actions-container":"app-views-AppView-style__actions-container--MN41k",actionsContainer:"app-views-AppView-style__actions-container--MN41k",title:"app-views-AppView-style__title--2SHTG"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-views-CustomCodeView-style__container--7vg-A{margin:auto;width:calc(100vw - 80px);height:100%;overflow:hidden}.app-views-CustomCodeView-style__container--7vg-A>div{margin:auto;height:100%}.app-views-CustomCodeView-style__ace-editor--25nKn{width:100%!important;height:100%!important;font-family:AnkaCoderC75Regular,monospace;font-size:15pt!important}",""]),e.locals={container:"app-views-CustomCodeView-style__container--7vg-A","ace-editor":"app-views-CustomCodeView-style__ace-editor--25nKn",aceEditor:"app-views-CustomCodeView-style__ace-editor--25nKn"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-views-MainView-style__main-view--3gou5{position:relative;margin:auto;padding-top:4vh;width:70vw;box-sizing:border-box;min-width:768px;height:100%}@media (max-width:768px){.app-views-MainView-style__main-view--3gou5{width:100vw;min-width:0}}.app-views-MainView-style__container--1BJYC{position:relative;top:50%;transform:translateY(-50%);display:flex;flex-flow:row wrap;justify-content:space-between}",""]),e.locals={"main-view":"app-views-MainView-style__main-view--3gou5",mainView:"app-views-MainView-style__main-view--3gou5",container:"app-views-MainView-style__container--1BJYC"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-views-OptionsView-style__container--142vA{position:relative;margin:auto;padding-top:4vh;width:70vw;box-sizing:border-box;min-width:768px}@media (max-width:768px){.app-views-OptionsView-style__container--142vA{width:100vw;min-width:0}}.app-views-OptionsView-style__control--KzVft{margin:10px 0}",""]),e.locals={container:"app-views-OptionsView-style__container--142vA",control:"app-views-OptionsView-style__control--KzVft"}},function(A,e,n){e=A.exports=n(4)(void 0),e.i(n(6),""),e.push([A.i,".app-views-PageViewFactory-style__container--1vkHR{position:relative;margin:auto;padding-top:4vh;width:70vw;box-sizing:border-box;min-width:568px;font-family:Slabo\\ 27px,serif}@media (max-width:568px){.app-views-PageViewFactory-style__container--1vkHR{width:100vw;min-width:0}}",""]),e.locals={container:"app-views-PageViewFactory-style__container--1vkHR"}},function(A,e){A.exports="<h1 id=usage-manual>Usage Manual</h1> <p>There is a main visualization area, 2 sidebars and some controls in the algorithm views. Clicking on their handles opens sidebars. Animation controls consist of: back-to-beginning, one-step-back, pause/start/restart, one-step-forward, to-end and a speed slider to control animation speed. Necessary input is to be supplied upon clicking on the start button, which prompts for these inputs. Main area and sidebars consist of modules, which can be customized or toggled on/off in settings. The app has multiple themes to choose from.</p> <h2 id=usage-of-modules>Usage of modules</h2> <p>Most modules are static, meaning that they don&#39;t support interactions, they are only visual. Interactive modules are:</p> <ul> <li>Graph module</li> <li>Examples module</li> </ul> <h3 id=graph-module>Graph module</h3> <p>Graph used in the visualization can be changed by ctrl-clicking on the graph. To add an edge ctrl-click on two nodes consequently. To add a node ctrl-click on the stage, to remove one ctrl-alt-click. If the graph is weighted, then a modal asks for weight when you add an edge. If a node/edge cannot be removed/added because of reasons, an info message pops up, informing the user of these reasons. Graph module, by default, features colors and animations to visualize graphs better.</p> <h3 id=examples-module>Examples module</h3> <p>Examples and Custom Input module is found by default on the left sidebar. Users have the ability to select from multiple examples which are fine tuned for the algorithm, or can save their own customized input and use it. Users can later delete or rename these inputs. Custom inputs are persistent and will stay after application exits.</p> <p>Options for this module:</p> <ul> <li>Purge custom inputs: removes all custom inputs</li> </ul> <h2 id=options>Options</h2> <ul> <li>Theme</li> <li>Algorithm speed</li> <li>Minimal Colored Visualizations: whether or not to use color in Visualizations</li> <li>Animations: are animations enabled</li> </ul> "},function(A,e){A.exports='/**\n * @license\n * Copyright (c) [2014] [Linkurious]\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (undefined) {\n  "use strict";\n  function Supervisor(t, e) {\n    _root.URL = _root.URL || _root.webkitURL, e = e || {}, this.sigInst = t, this.graph = this.sigInst.graph, this.ppn = 10, this.ppe = 3, this.config = {}, this.worker = null, this.shouldUseWorker = null, this.workerUrl = null, this.runOnBackground = null, this.easing = null, this.randomize = null, this.configure(e), this.started = !1, this.running = !1, this.initWorker();\n  }if ("undefined" == typeof sigma) throw new Error("sigma is not declared");sigma.utils.pkg("sigma.layouts");var _root = this,\n      webWorkers = "Worker" in _root,\n      eventEmitter = {};sigma.classes.dispatcher.extend(eventEmitter), Supervisor.prototype.makeBlob = function (t) {\n    var e;try {\n      e = new Blob([t], { type: "application/javascript" });\n    } catch (r) {\n      _root.BlobBuilder = _root.BlobBuilder || _root.WebKitBlobBuilder || _root.MozBlobBuilder, e = new BlobBuilder(), e.append(t), e = e.getBlob();\n    }return e;\n  }, Supervisor.prototype.graphToByteArrays = function () {\n    var t,\n        e,\n        r,\n        s = this.graph.nodes(),\n        n = this.graph.edges(),\n        i = s.length * this.ppn,\n        o = n.length * this.ppe,\n        a = {};for (this.nodesByteArray = new Float32Array(i), this.edgesByteArray = new Float32Array(o), t = e = 0, r = s.length; r > t; t++) {\n      a[s[t].id] = e, this.nodesByteArray[e] = this.randomize(s[t].x), this.nodesByteArray[e + 1] = this.randomize(s[t].y), this.nodesByteArray[e + 2] = 0, this.nodesByteArray[e + 3] = 0, this.nodesByteArray[e + 4] = 0, this.nodesByteArray[e + 5] = 0, this.nodesByteArray[e + 6] = 1 + this.graph.degree(s[t].id), this.nodesByteArray[e + 7] = 1, this.nodesByteArray[e + 8] = s[t].size, this.nodesByteArray[e + 9] = s[t].fixed || 0, e += this.ppn;\n    }for (t = e = 0, r = n.length; r > t; t++) {\n      this.edgesByteArray[e] = a[n[t].source], this.edgesByteArray[e + 1] = a[n[t].target], this.edgesByteArray[e + 2] = n[t].weight || 0, e += this.ppe;\n    }\n  }, Supervisor.prototype.applyLayoutChanges = function (t) {\n    for (var e = this.graph.nodes(), r = 0, s = 0, n = this.nodesByteArray.length; n > s; s += this.ppn) {\n      e[r].fixed || (t ? (e[r].fa2_x = this.nodesByteArray[s], e[r].fa2_y = this.nodesByteArray[s + 1]) : (e[r].x = this.nodesByteArray[s], e[r].y = this.nodesByteArray[s + 1])), r++;\n    }\n  }, Supervisor.prototype.sendByteArrayToWorker = function (t) {\n    var e = { action: t || "loop", nodes: this.nodesByteArray.buffer },\n        r = [this.nodesByteArray.buffer];"start" === t && (e.config = this.config || {}, e.edges = this.edgesByteArray.buffer, r.push(this.edgesByteArray.buffer)), this.shouldUseWorker ? this.worker.postMessage(e, r) : _root.postMessage(e, "*");\n  }, Supervisor.prototype.start = function () {\n    this.running || (this.running = !0, this.started ? this.sendByteArrayToWorker() : (this.sendByteArrayToWorker("start"), this.started = !0, eventEmitter.dispatchEvent("start")));\n  }, Supervisor.prototype.stop = function () {\n    this.running && (this.running = !1, eventEmitter.dispatchEvent("stop"));\n  }, Supervisor.prototype.initWorker = function () {\n    var _this = this,\n        workerFn = sigma.layouts.getForceLinkWorker();if (this.shouldUseWorker) {\n      if (this.workerUrl) this.worker = new Worker(this.workerUrl);else {\n        var blob = this.makeBlob(workerFn);this.worker = new Worker(URL.createObjectURL(blob));\n      }this.worker.postMessage = this.worker.webkitPostMessage || this.worker.postMessage;\n    } else eval(workerFn);this.msgName = this.worker ? "message" : "newCoords", this.listener = function (t) {\n      _this.nodesByteArray = new Float32Array(t.data.nodes), _this.running && (_this.applyLayoutChanges(_this.runOnBackground), _this.sendByteArrayToWorker(), _this.runOnBackground || _this.sigInst.refresh({ skipIndexation: !0 })), t.data.converged && (_this.running = !1), _this.running || (_this.killWorker(), _this.runOnBackground && _this.easing ? (_this.applyLayoutChanges(!0), eventEmitter.dispatchEvent("interpolate"), _this.graph.nodes().filter(function (t) {\n        return t.fixed;\n      }).forEach(function (t) {\n        t.fa2_x = t.x, t.fa2_y = t.y;\n      }), sigma.plugins.animate(_this.sigInst, { x: "fa2_x", y: "fa2_y" }, { easing: _this.easing, onComplete: function onComplete() {\n          _this.sigInst.refresh(), eventEmitter.dispatchEvent("stop");\n        } })) : (_this.applyLayoutChanges(!1), _this.sigInst.refresh(), eventEmitter.dispatchEvent("stop")));\n    }, (this.worker || document).addEventListener(this.msgName, this.listener), this.graphToByteArrays(), _this.sigInst.bind("kill", function () {\n      sigma.layouts.killForceLink();\n    });\n  }, Supervisor.prototype.killWorker = function () {\n    this.worker ? this.worker.terminate() : (_root.postMessage({ action: "kill" }, "*"), document.removeEventListener(this.msgName, this.listener));\n  }, Supervisor.prototype.configure = function (t) {\n    switch (this.config = t, this.shouldUseWorker = t.worker === !1 ? !1 : webWorkers, this.workerUrl = t.workerUrl, this.runOnBackground = t.background ? !0 : !1, this.easing = t.easing, t.randomize) {case "globally":\n        this.randomize = function (e) {\n          return Math.random() * (t.randomizeFactor || 1);\n        };break;case "locally":\n        this.randomize = function (e) {\n          return e + Math.random() * (t.randomizeFactor || 1);\n        };break;default:\n        this.randomize = function (t) {\n          return t;\n        };}if (this.started) {\n      var e = { action: "config", config: this.config };this.shouldUseWorker ? this.worker.postMessage(e) : _root.postMessage(e, "*");\n    }\n  };var supervisor = null;sigma.layouts.startForceLink = function (t, e) {\n    return supervisor ? supervisor.running || (supervisor.killWorker(), supervisor.initWorker(), supervisor.started = !1) : supervisor = new Supervisor(t, e), e && supervisor.configure(e), supervisor.start(), eventEmitter;\n  }, sigma.layouts.stopForceLink = function () {\n    return supervisor ? (supervisor.stop(), supervisor) : void 0;\n  }, sigma.layouts.killForceLink = function () {\n    supervisor && (supervisor.stop(), supervisor.killWorker(), supervisor = null, eventEmitter = {}, sigma.classes.dispatcher.extend(eventEmitter));\n  }, sigma.layouts.configForceLink = function (t, e) {\n    return supervisor ? supervisor.running || (supervisor.killWorker(), supervisor.initWorker(), supervisor.started = !1) : supervisor = new Supervisor(t, e), supervisor.configure(e), eventEmitter;\n  }, sigma.layouts.isForceLinkRunning = function () {\n    return !!supervisor && supervisor.running;\n  };\n}).call(this), function (undefined) {\n  "use strict";\n  function no_crush(t) {\n    var e,\n        r,\n        s,\n        n = ["x", "y", "dx", "dy", "old_dx", "old_dy", "mass", "convergence", "size", "fixed"],\n        i = ["source", "target", "weight"],\n        o = ["node", "centerX", "centerY", "size", "nextSibling", "firstChild", "mass", "massCenterX", "massCenterY"];for (r = 0, s = o.length; s > r; r++) {\n      e = new RegExp("rp\\\\(([^,]*), \'" + o[r] + "\'\\\\)", "g"), t = t.replace(e, 0 === r ? "$1" : "$1 + " + r);\n    }for (r = 0, s = n.length; s > r; r++) {\n      e = new RegExp("np\\\\(([^,]*), \'" + n[r] + "\'\\\\)", "g"), t = t.replace(e, 0 === r ? "$1" : "$1 + " + r);\n    }for (r = 0, s = i.length; s > r; r++) {\n      e = new RegExp("ep\\\\(([^,]*), \'" + i[r] + "\'\\\\)", "g"), t = t.replace(e, 0 === r ? "$1" : "$1 + " + r);\n    }return t;\n  }function getWorkerFn() {\n    var t = crush ? crush(Worker.toString()) : Worker.toString();return ";(" + t + ").call(this);";\n  }if ("undefined" == typeof sigma) throw new Error("sigma is not declared");sigma.utils.pkg("sigma.layouts");var _root = this,\n      inWebWorker = !("document" in _root),\n      Worker = function Worker(t) {\n    function e() {\n      var t,\n          e,\n          r = {},\n          s = arguments.length;for (t = s - 1; t >= 0; t--) {\n        for (e in arguments[t]) {\n          r[e] = arguments[t][e];\n        }\n      }return r;\n    }function r(t) {\n      var e;for (e in t) {\n        "hasOwnProperty" in t && !t.hasOwnProperty(e) || delete t[e];\n      }return t;\n    }function s(t, e, r, s) {\n      return Math.sqrt((r - t) * (r - t) + (s - e) * (s - e));\n    }function n(t, e, r, s, n) {\n      return (n - s) * (t - e) / (r - e) + s;\n    }function i(t) {\n      return Math.acos(t.x / Math.sqrt(t.x * t.x + t.y * t.y));\n    }function o(t, e, r, s) {\n      return { xi: -(s - e), yi: r - t, xi_prime: s - e, yi_prime: -(r - t) };\n    }function a(t, e) {\n      return { x: (t.xi_prime - t.xi) / e, y: (t.yi_prime - t.yi) / e };\n    }function h(t, e, r, s, n) {\n      return { x: t + (r - t) * n, y: e + (s - e) * n };\n    }function g(t, e, r) {\n      r = r || {};l = t, c = e, v.nodesLength = l.length, v.edgesLength = c.length, u(r);\n    }function u(t) {\n      v.settings = e(t, v.settings);\n    }function p() {\n      var t,\n          e,\n          r,\n          g,\n          u,\n          p,\n          d,\n          y,\n          k,\n          m,\n          b,\n          w,\n          M,\n          B,\n          _,\n          A,\n          x,\n          L = v.settings.minNodeDistance;for (r = 0; r < v.nodesLength; r += v.ppn) {\n        l[r + 4] = l[r + 2], l[r + 5] = l[r + 3], l[r + 2] = 0, l[r + 3] = 0;\n      }if (v.settings.outboundAttractionDistribution) {\n        for (k = 0, r = 0; r < v.nodesLength; r += v.ppn) {\n          k += l[r + 6];\n        }k /= v.nodesLength;\n      }if (v.settings.barnesHutOptimize) {\n        var S,\n            W,\n            E = 1 / 0,\n            F = -(1 / 0),\n            I = 1 / 0,\n            z = -(1 / 0);for (f = [], r = 0; r < v.nodesLength; r += v.ppn) {\n          E = Math.min(E, l[r]), F = Math.max(F, l[r]), I = Math.min(I, l[r + 1]), z = Math.max(z, l[r + 1]);\n        }for (f[0] = -1, f[1] = (E + F) / 2, f[2] = (I + z) / 2, f[3] = Math.max(F - E, z - I), f[4] = -1, f[5] = -1, f[6] = 0, f[7] = 0, f[8] = 0, t = 1, r = 0; r < v.nodesLength; r += v.ppn) {\n          for (e = 0;;) {\n            if (f[e + 5] >= 0) S = l[r] < f[e + 1] ? l[r + 1] < f[e + 2] ? f[e + 5] : f[e + 5] + v.ppr : l[r + 1] < f[e + 2] ? f[e + 5] + 2 * v.ppr : f[e + 5] + 3 * v.ppr, f[e + 7] = (f[e + 7] * f[e + 6] + l[r] * l[r + 6]) / (f[e + 6] + l[r + 6]), f[e + 8] = (f[e + 8] * f[e + 6] + l[r + 1] * l[r + 6]) / (f[e + 6] + l[r + 6]), f[e + 6] += l[r + 6], e = S;else {\n              if (f[e] < 0) {\n                f[e] = r;break;\n              }if (f[e + 5] = t * v.ppr, d = f[e + 3] / 2, y = f[e + 5], f[y] = -1, f[y + 1] = f[e + 1] - d, f[y + 2] = f[e + 2] - d, f[y + 3] = d, f[y + 4] = y + v.ppr, f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, y += v.ppr, f[y] = -1, f[y + 1] = f[e + 1] - d, f[y + 2] = f[e + 2] + d, f[y + 3] = d, f[y + 4] = y + v.ppr, f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, y += v.ppr, f[y] = -1, f[y + 1] = f[e + 1] + d, f[y + 2] = f[e + 2] - d, f[y + 3] = d, f[y + 4] = y + v.ppr, f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, y += v.ppr, f[y] = -1, f[y + 1] = f[e + 1] + d, f[y + 2] = f[e + 2] + d, f[y + 3] = d, f[y + 4] = f[e + 4], f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, t += 4, S = l[f[e]] < f[e + 1] ? l[f[e] + 1] < f[e + 2] ? f[e + 5] : f[e + 5] + v.ppr : l[f[e] + 1] < f[e + 2] ? f[e + 5] + 2 * v.ppr : f[e + 5] + 3 * v.ppr, f[e + 6] = l[f[e] + 6], f[e + 7] = l[f[e]], f[e + 8] = l[f[e] + 1], f[S] = f[e], f[e] = -1, W = l[r] < f[e + 1] ? l[r + 1] < f[e + 2] ? f[e + 5] : f[e + 5] + v.ppr : l[r + 1] < f[e + 2] ? f[e + 5] + 2 * v.ppr : f[e + 5] + 3 * v.ppr, S !== W) {\n                f[W] = r;break;\n              }e = S;\n            }\n          }\n        }\n      }if (v.settings.barnesHutOptimize) for (m = v.settings.scalingRatio, r = 0; r < v.nodesLength; r += v.ppn) {\n        for (e = 0;;) {\n          if (f[e + 5] >= 0) {\n            if (A = Math.sqrt((l[r] - f[e + 7]) * (l[r] - f[e + 7]) + (l[r + 1] - f[e + 8]) * (l[r + 1] - f[e + 8])), 2 * f[e + 3] / A < v.settings.barnesHutTheta) {\n              if (b = l[r] - f[e + 7], w = l[r + 1] - f[e + 8], v.settings.adjustSizes ? A > 0 ? (x = m * l[r + 6] * f[e + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x) : 0 > A && (x = -m * l[r + 6] * f[e + 6] / A, l[r + 2] += b * x, l[r + 3] += w * x) : A > 0 && (x = m * l[r + 6] * f[e + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x), f[e + 4] < 0) break;e = f[e + 4];continue;\n            }e = f[e + 5];\n          } else {\n            if (f[e] >= 0 && f[e] !== r && (b = l[r] - l[f[e]], w = l[r + 1] - l[f[e] + 1], A = Math.sqrt(b * b + w * w), v.settings.adjustSizes ? A > 0 ? (x = m * l[r + 6] * l[f[e] + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x) : 0 > A && (x = -m * l[r + 6] * l[f[e] + 6] / A, l[r + 2] += b * x, l[r + 3] += w * x) : A > 0 && (x = m * l[r + 6] * l[f[e] + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x)), f[e + 4] < 0) break;e = f[e + 4];\n          }\n        }\n      } else for (m = v.settings.scalingRatio, g = 0; g < v.nodesLength; g += v.ppn) {\n        for (u = 0; g > u; u += v.ppn) {\n          b = l[g] - l[u], w = l[g + 1] - l[u + 1], v.settings.adjustSizes ? (A = Math.sqrt(b * b + w * w) - l[g + 8] - l[u + 8], A > 0 ? (x = m * l[g + 6] * l[u + 6] / A / A, l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] += b * x, l[u + 3] += w * x) : 0 > A && (x = 100 * m * l[g + 6] * l[u + 6], l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] -= b * x, l[u + 3] -= w * x)) : (A = Math.sqrt(b * b + w * w), A > 0 && (x = m * l[g + 6] * l[u + 6] / A / A, l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] -= b * x, l[u + 3] -= w * x));\n        }\n      }for (y = v.settings.gravity / v.settings.scalingRatio, m = v.settings.scalingRatio, r = 0; r < v.nodesLength; r += v.ppn) {\n        x = 0, b = l[r], w = l[r + 1], A = Math.sqrt(b * b + w * w), v.settings.strongGravityMode ? A > 0 && (x = m * l[r + 6] * y) : A > 0 && (x = m * l[r + 6] * y / A), l[r + 2] -= b * x, l[r + 3] -= w * x;\n      }for (m = 1 * (v.settings.outboundAttractionDistribution ? k : 1), p = 0; p < v.edgesLength; p += v.ppe) {\n        g = c[p], u = c[p + 1], d = c[p + 2], _ = Math.pow(d, v.settings.edgeWeightInfluence), b = l[g] - l[u], w = l[g + 1] - l[u + 1], v.settings.adjustSizes ? (A = Math.sqrt(b * b + w * w - l[g + 8] - l[u + 8]) - L, v.settings.linLogMode ? v.settings.outboundAttractionDistribution ? A > 0 && (x = -m * _ * Math.log(1 + A) / A / l[g + 6]) : A > 0 && (x = -m * _ * Math.log(1 + A) / A) : v.settings.outboundAttractionDistribution ? A > 0 && (x = -m * _ / l[g + 6]) : A > 0 && (x = -m * _)) : (A = Math.sqrt(b * b + w * w) - L, v.settings.linLogMode ? v.settings.outboundAttractionDistribution ? A > 0 && (x = -m * _ * Math.log(1 + A) / A / l[g + 6]) : A > 0 && (x = -m * _ * Math.log(1 + A) / A) : v.settings.outboundAttractionDistribution ? (A = 1, x = -m * _ / l[g + 6]) : (A = 1, x = -m * _)), A > 0 && (l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] -= b * x, l[u + 3] -= w * x);\n      }var q,\n          O,\n          D,\n          R,\n          U = 0;if (v.settings.adjustSizes) for (r = 0; r < v.nodesLength; r += v.ppn) {\n        l[r + 9] || (q = Math.sqrt(l[r + 2] * l[r + 2] + l[r + 3] * l[r + 3]), q > v.maxForce && (l[r + 2] = l[r + 2] * v.maxForce / q, l[r + 3] = l[r + 3] * v.maxForce / q), O = l[r + 6] * Math.sqrt((l[r + 4] - l[r + 2]) * (l[r + 4] - l[r + 2]) + (l[r + 5] - l[r + 3]) * (l[r + 5] - l[r + 3])), D = Math.sqrt((l[r + 4] + l[r + 2]) * (l[r + 4] + l[r + 2]) + (l[r + 5] + l[r + 3]) * (l[r + 5] + l[r + 3])) / 2, R = .1 * Math.log(1 + D) / (1 + Math.sqrt(O)), M = l[r], B = l[r + 1], l[r] = l[r] + l[r + 2] * (R / v.settings.slowDown), l[r + 1] = l[r + 1] + l[r + 3] * (R / v.settings.slowDown), b = l[r], w = l[r + 1], A = Math.sqrt((b - M) * (b - M) + (w - B) * (w - B)), U += A);\n      } else for (r = 0; r < v.nodesLength; r += v.ppn) {\n        l[r + 9] || (O = l[r + 6] * Math.sqrt((l[r + 4] - l[r + 2]) * (l[r + 4] - l[r + 2]) + (l[r + 5] - l[r + 3]) * (l[r + 5] - l[r + 3])), D = Math.sqrt((l[r + 4] + l[r + 2]) * (l[r + 4] + l[r + 2]) + (l[r + 5] + l[r + 3]) * (l[r + 5] + l[r + 3])) / 2, R = l[r + 7] * Math.log(1 + D) / (1 + Math.sqrt(O)), l[r + 7] = Math.min(1, Math.sqrt(R * (l[r + 2] * l[r + 2] + l[r + 3] * l[r + 3]) / (1 + Math.sqrt(O)))), M = l[r], B = l[r + 1], l[r] = l[r] + l[r + 2] * (R / v.settings.slowDown), l[r + 1] = l[r + 1] + l[r + 3] * (R / v.settings.slowDown), b = l[r], w = l[r + 1], A = Math.sqrt((b - M) * (b - M) + (w - B) * (w - B)), U += A);\n      }if (v.iterations++, v.settings.autoStop && (v.converged = v.iterations > v.settings.maxIterations || U / v.nodesLength < v.settings.avgDistanceThreshold, v.converged && v.settings.alignNodeSiblings)) {\n        var j,\n            P,\n            C = {},\n            T = {};for (p = 0; p < v.edgesLength; p += v.ppe) {\n          g = c[p], u = c[p + 1], g !== u && (C[g] = C[g] || {}, C[u] = C[u] || {}, C[g][u] = !0, C[u][g] = !0);\n        }Object.keys(C).forEach(function (t) {\n          t = ~~t, P = Object.keys(C[t]), 2 == P.length && (j = P[0] + ";" + P[1], j in T ? T[j].push(t) : (j = P[1] + ";" + P[0], T[j] || (T[j] = [~~P[1], ~~P[0]]), T[j].push(t)));\n        });var N,\n            $,\n            H,\n            G,\n            X,\n            Y,\n            K,\n            J,\n            Q,\n            V,\n            Z,\n            tt,\n            et,\n            rt,\n            st,\n            nt = v.settings.nodeSiblingsAngleMin;Object.keys(T).forEach(function (t) {\n          if ($ = T[t].shift(), H = T[t].shift(), N = T[t].filter(function (t) {\n            return !l[t + 9];\n          }), 1 != N.length) {\n            if (Y = l[$], K = l[$ + 1], J = l[H], Q = l[H + 1], G = Object.keys(C[$]).length, X = Object.keys(C[H]).length, V = n(G / (G + X), 0, 1, .25, .75), tt = h(Y, K, J, Q, V), et = o(Y, K, J, Q), Z = s(Y, K, J, Q), rt = a(et, Z), st = i(rt), 2 * nt > Math.PI) throw new Error("ForceLink.Worker - Invalid parameter: angleMin must be smaller than 2 PI.");nt > 0 && (nt > st || st > Math.PI - nt && st <= Math.PI ? rt = { x: 2 * Math.cos(Math.PI - nt), y: 2 * Math.sin(Math.PI - nt) } : (st > 2 * Math.PI - nt || st >= Math.PI && st < Math.PI + nt) && (rt = { x: 2 * Math.cos(nt), y: 2 * Math.sin(nt) }));var e = 0,\n                r = 1,\n                g = 1;N.length % 2 == 1 && (g = 0, e = 1);for (var u = 0; u < N.length; u++) {\n              l[N[u]] = tt.x + r * rt.x * g * (e || u >= 2 ? v.settings.nodeSiblingsScale : 2 * v.settings.nodeSiblingsScale / 3), l[N[u] + 1] = tt.y + r * rt.y * g * (e || u >= 2 ? v.settings.nodeSiblingsScale : 2 * v.settings.nodeSiblingsScale / 3), r = -r, g += (u + e) % 2;\n            }\n          }\n        });\n      }\n    }function d(t) {\n      for (var e = 0; t > e; e++) {\n        p();\n      }y();\n    }var l,\n        c,\n        f,\n        y,\n        v = { ppn: 10, ppe: 3, ppr: 9, maxForce: 10, iterations: 0, converged: !1, settings: { linLogMode: !1, outboundAttractionDistribution: !1, adjustSizes: !1, edgeWeightInfluence: 0, scalingRatio: 1, strongGravityMode: !1, gravity: 1, slowDown: 1, barnesHutOptimize: !1, barnesHutTheta: .5, startingIterations: 1, iterationsPerRender: 1, maxIterations: 1e3, avgDistanceThreshold: .01, autoStop: !1, alignNodeSiblings: !1, nodeSiblingsScale: 1, nodeSiblingsAngleMin: 0, minNodeDistance: 0 } };y = "undefined" != typeof window && window.document ? function () {\n      if (!v.autoStop || v.converged) {\n        var t;document.createEvent ? (t = document.createEvent("Event"), t.initEvent("newCoords", !0, !1)) : (t = document.createEventObject(), t.eventType = "newCoords"), t.eventName = "newCoords", t.data = { nodes: l.buffer, converged: v.converged }, requestAnimationFrame(function () {\n          document.dispatchEvent(t);\n        });\n      }\n    } : function () {\n      (!v.autoStop || v.converged) && self.postMessage({ nodes: l.buffer, converged: v.converged }, [l.buffer]);\n    };var k = function k(t) {\n      switch (t.data.action) {case "start":\n          g(new Float32Array(t.data.nodes), new Float32Array(t.data.edges), t.data.config), d(v.settings.startingIterations);break;case "loop":\n          l = new Float32Array(t.data.nodes), d(v.settings.iterationsPerRender);break;case "config":\n          u(t.data.config);break;case "kill":\n          r(v), l = null, c = null, f = null, self.removeEventListener("message", k);}\n    };self.addEventListener("message", k);\n  },\n      crush = null;if (inWebWorker) eval(getWorkerFn());else {\n    if ("undefined" == typeof sigma) throw new Error("sigma is not declared");sigma.layouts.getForceLinkWorker = getWorkerFn;\n  }\n}.call(this);'},function(A,e){A.exports='/**\n * @license\n * Copyright (c) [2014] [Linkurious]\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (a) {\n  "use strict";\n  if ("undefined" == typeof sigma) throw "sigma.renderers.glyphs: sigma not in scope.";sigma.utils.pkg("sigma.settings");var b = { glyphScale: .5, glyphFillColor: "white", glyphTextColor: "black", glyphStrokeColor: "black", glyphLineWidth: 2, glyphFont: "Arial", glyphFontStyle: "normal", glyphFontScale: 1, glyphTextThreshold: 7, glyphStrokeIfText: !1, glyphThreshold: 1, drawGlyphs: !0 };sigma.settings = sigma.utils.extend(sigma.settings || {}, b);\n}).call(this), function (a) {\n  "use strict";\n  function b(a) {\n    return a * Math.PI / 180;\n  }function c(a, b) {\n    return "function" == typeof a ? a.call(b) : a;\n  }function d(a) {\n    function d(a, b) {\n      if (a.draw && a.x && a.y && a.radius > a.threshold) {\n        var c = a.x,\n            d = a.y;switch (a.position) {case "top-right":\n            c += a.nodeSize * A, d += a.nodeSize * B;break;case "top-left":\n            c += a.nodeSize * y, d += a.nodeSize * z;break;case "bottom-left":\n            c += a.nodeSize * w, d += a.nodeSize * x;break;case "bottom-right":\n            c += a.nodeSize * u, d += a.nodeSize * v;}if (b.fillStyle = a.fillColor, a.strokeColor !== b.strokeStyle && (b.strokeStyle = a.strokeColor), b.beginPath(), b.arc(c, d, a.radius, 2 * Math.PI, !1), b.closePath(), (!a.strokeIfText || a.radius > a.textThreshold) && b.stroke(), b.fill(), a.radius > a.textThreshold) {\n          var e = Math.round(a.fontScale * a.radius),\n              f = a.fontStyle + " " + e + "px " + a.font;f !== b.font && (b.font = f), b.fillStyle = a.textColor, b.fillText(a.content, c, d);\n        }\n      }\n    }a = a || {};var e = a.font || this.settings("glyphFont"),\n        f = a.fontStyle || this.settings("glyphFontStyle"),\n        g = a.fontScale || this.settings("glyphFontScale"),\n        h = a.strokeColor || this.settings("glyphStrokeColor"),\n        i = a.lineWidth || this.settings("glyphLineWidth"),\n        j = a.fillColor || this.settings("glyphFillColor"),\n        k = a.scale || this.settings("glyphScale"),\n        l = a.textColor || this.settings("glyphTextColor"),\n        m = a.textThreshold || this.settings("glyphTextThreshold"),\n        n = "strokeIfText" in a ? a.strokeIfText : this.settings("glyphStrokeIfText"),\n        o = a.threshold || this.settings("glyphThreshold"),\n        p = "draw" in a ? a.draw : this.settings("drawGlyphs");if (p) {\n      this.domElements.glyphs || (this.initDOM("canvas", "glyphs"), this.domElements.glyphs.width = this.container.offsetWidth, this.domElements.glyphs.height = this.container.offsetHeight, this.container.insertBefore(this.domElements.glyphs, this.domElements.mouse)), this.drawingContext = this.domElements.glyphs.getContext("2d"), this.drawingContext.textAlign = "center", this.drawingContext.textBaseline = "middle", this.drawingContext.lineWidth = i, this.drawingContext.strokeStyle = h;var q,\n          r = this,\n          s = this.nodesOnScreen || [],\n          t = this.options.prefix || "",\n          u = Math.cos(b(45)),\n          v = Math.sin(b(45)),\n          w = Math.cos(b(135)),\n          x = Math.sin(b(135)),\n          y = Math.cos(b(225)),\n          z = Math.sin(b(225)),\n          A = Math.cos(b(315)),\n          B = Math.sin(b(315));s.forEach(function (a) {\n        a.glyphs && a.glyphs.forEach(function (b) {\n          q = !a.hidden, q && "draw" in b && (q = b.draw), d({ x: a[t + "x"], y: a[t + "y"], nodeSize: a[t + "size"] || 0, position: b.position, radius: b.size || a[t + "size"] * k, content: (b.content || "").toString() || "", lineWidth: b.lineWidth || i, fillColor: c(b.fillColor, a) || j, textColor: c(b.textColor, a) || l, strokeColor: c(b.strokeColor, a) || h, strokeIfText: "strokeIfText" in b ? b.strokeIfText : n, fontStyle: b.fontStyle || f, font: b.font || e, fontScale: b.fontScale || g, threshold: b.threshold || o, textThreshold: b.textThreshold || m, draw: q }, r.drawingContext);\n        });\n      });\n    }\n  }if ("undefined" == typeof sigma) throw "sigma is not declared";sigma.renderers.canvas.prototype.glyphs = d;\n}.call(this);\n//# sourceMappingURL=sigma.renderers.glyphs.min.js.map'},function(A,e){A.exports='(function(){"use strict";function a(a){if(d[a])return d[a];var b=[0,0,0];return a.match(/^#/)?(a=(a||"").replace(/^#/,""),b=3===a.length?[parseInt(a.charAt(0)+a.charAt(0),16),parseInt(a.charAt(1)+a.charAt(1),16),parseInt(a.charAt(2)+a.charAt(2),16)]:[parseInt(a.charAt(0)+a.charAt(1),16),parseInt(a.charAt(2)+a.charAt(3),16),parseInt(a.charAt(4)+a.charAt(5),16)]):a.match(/^ *rgba? *\\(/)&&(a=a.match(/^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/),b=[+a[1],+a[2],+a[3]]),d[a]={r:b[0],g:b[1],b:b[2]},d[a]}function b(b,c,d){b=a(b),c=a(c);var e={r:b.r*(1-d)+c.r*d,g:b.g*(1-d)+c.g*d,b:b.b*(1-d)+c.b*d};return"rgb("+[0|e.r,0|e.g,0|e.b].join(",")+")"}if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.plugins");var c=0,d={};sigma.plugins.animate=function(a,d,e){function f(){var c=(sigma.utils.dateNow()-m)/k;if(c>=1){g.forEach(function(a){for(var b in d)b in d&&(a[b]=a[d[b]])});var e,n;for(e in a.cameras)n=a.cameras[e],n.edgequadtree._enabled=!0;a.refresh(),"function"==typeof i.onComplete&&i.onComplete()}else c=l(c),g.forEach(function(a){for(var e in d)e in d&&(e.match(/color$/)?a[e]=b(h[a.id][e],a[d[e]],c):a[e]=a[d[e]]*c+h[a.id][e]*(1-c))}),a.refresh(),a.animations[j]=requestAnimationFrame(f)}var g,h,i=e||{},j=++c,k=i.duration||a.settings("animationsTime"),l="string"==typeof i.easing?sigma.utils.easings[i.easing]:"function"==typeof i.easing?i.easing:sigma.utils.easings.quadraticInOut,m=sigma.utils.dateNow();g=i.nodes&&i.nodes.length?"object"==typeof i.nodes[0]?i.nodes:a.graph.nodes(i.nodes):a.graph.nodes(),h=g.reduce(function(a,b){var c;a[b.id]={};for(c in d)c in b&&(a[b.id][c]=b[c]);return a},{}),a.animations=a.animations||Object.create({}),sigma.plugins.kill(a);var n,o;for(n in a.cameras)o=a.cameras[n],o.edgequadtree._enabled=!1;f()},sigma.plugins.kill=function(a){for(var b in a.animations||{})cancelAnimationFrame(a.animations[b]);var b,c;for(b in a.cameras)c=a.cameras[b],c.edgequadtree._enabled=!0}}).call(window);'},function(A,e){A.exports='(function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.settings");var b={defaultEdgeLabelColor:"#000",defaultEdgeLabelActiveColor:"#000",defaultEdgeLabelSize:10,edgeLabelSize:"fixed",edgeLabelSizePowRatio:1,edgeLabelThreshold:1};sigma.settings=sigma.utils.extend(sigma.settings||{},b),sigma.settings.drawEdgeLabels=!0}).call(this),function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.canvas.edges.labels"),sigma.canvas.edges.labels.curve=function(a,b,c,d,e){if("string"==typeof a.label){var f=e("prefix")||"",g=a[f+"size"]||1;if(!(g<e("edgeLabelThreshold"))){var h,i,j,k=b[f+"size"],l=b[f+"x"],m=b[f+"y"],n=c[f+"x"],o=c[f+"y"],p=n-l,q=o-m,r=l<n?1:-1,s={},t=.5;b.id===c.id?(s=sigma.utils.getSelfLoopControlPoints(l,m,k),i=sigma.utils.getPointOnBezierCurve(t,l,m,n,o,s.x1,s.y1,s.x2,s.y2),j=Math.atan2(1,1)):(s=sigma.utils.getQuadraticControlPoint(l,m,n,o),i=sigma.utils.getPointOnQuadraticCurve(t,l,m,n,o,s.x,s.y),j=Math.atan2(q*r,p*r)),h="fixed"===e("edgeLabelSize")?e("defaultEdgeLabelSize"):e("defaultEdgeLabelSize")*g*Math.pow(g,-1/e("edgeLabelSizePowRatio")),d.save(),a.active?(d.font=[e("activeFontStyle"),h+"px",e("activeFont")||e("font")].join(" "),d.fillStyle="edge"===e("edgeActiveColor")?a.active_color||e("defaultEdgeActiveColor"):e("defaultEdgeLabelActiveColor")):(d.font=[e("fontStyle"),h+"px",e("font")].join(" "),d.fillStyle="edge"===e("edgeLabelColor")?a.color||e("defaultEdgeColor"):e("defaultEdgeLabelColor")),d.textAlign="center",d.textBaseline="alphabetic",d.translate(i.x,i.y),d.rotate(j),d.fillText(a.label,0,-g/2-3),d.restore()}}}}.call(this),function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.canvas.edges.labels"),sigma.canvas.edges.labels.curvedArrow=function(a,b,c,d,e){sigma.canvas.edges.labels.curve(a,b,c,d,e)}}.call(this),function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.canvas.edges.labels"),sigma.canvas.edges.labels.def=function(a,b,c,d,e){if("string"==typeof a.label&&b!=c){var f=e("prefix")||"",g=a[f+"size"]||1;if(!(g<e("edgeLabelThreshold"))){if(0===e("edgeLabelSizePowRatio"))throw\'"edgeLabelSizePowRatio" must not be 0.\';var h,i=(b[f+"x"]+c[f+"x"])/2,j=(b[f+"y"]+c[f+"y"])/2,k=c[f+"x"]-b[f+"x"],l=c[f+"y"]-b[f+"y"],m=b[f+"x"]<c[f+"x"]?1:-1,n=Math.atan2(l*m,k*m);h="fixed"===e("edgeLabelSize")?e("defaultEdgeLabelSize"):e("defaultEdgeLabelSize")*g*Math.pow(g,-1/e("edgeLabelSizePowRatio")),d.save(),a.active?(d.font=[e("activeFontStyle"),h+"px",e("activeFont")||e("font")].join(" "),d.fillStyle="edge"===e("edgeActiveColor")?a.active_color||e("defaultEdgeActiveColor"):e("defaultEdgeLabelActiveColor")):(d.font=[e("fontStyle"),h+"px",e("font")].join(" "),d.fillStyle="edge"===e("edgeLabelColor")?a.color||e("defaultEdgeColor"):e("defaultEdgeLabelColor")),d.textAlign="center",d.textBaseline="alphabetic",d.translate(i,j),d.rotate(n),d.fillText(a.label,0,-g/2-3),d.restore()}}}}.call(this);'},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.mouse = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // MOUSE MANAGEMENT:\n        // *****************\n        // The mouse position when the user starts dragging:\n        _startMouseX,\n        _startMouseY,\n\n        _isMouseDown,\n        _isMoving,\n        _hasDragged,\n        _downStartTime,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);\n    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);\n    _target.addEventListener('mousewheel', _wheelHandler, false);\n    _target.addEventListener('mousemove', _moveHandler, false);\n    _target.addEventListener('mousedown', _downHandler, false);\n    _target.addEventListener('click', _clickHandler, false);\n    _target.addEventListener('mouseout', _outHandler, false);\n    document.addEventListener('mouseup', _upHandler, false);\n\n\n\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'click');\n      _target.removeEventListener('DOMMouseScroll', _wheelHandler);\n      _target.removeEventListener('mousewheel', _wheelHandler);\n      _target.removeEventListener('mousemove', _moveHandler);\n      _target.removeEventListener('mousedown', _downHandler);\n      _target.removeEventListener('click', _clickHandler);\n      _target.removeEventListener('mouseout', _outHandler);\n      document.removeEventListener('mouseup', _upHandler);\n    };\n\n\n\n\n    // MOUSE EVENTS:\n    // *************\n\n    /**\n     * The handler listening to the 'move' mouse event. It will effectively\n     * drag the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _moveHandler(e) {\n      var x,\n          y,\n          pos;\n\n      // Dispatch event:\n      if (_settings('mouseEnabled')) {\n        _self.dispatchEvent('mousemove',\n          sigma.utils.mouseCoords(e));\n\n        if (_isMouseDown) {\n          _isMoving = true;\n          _hasDragged = true;\n\n          if (_movingTimeoutId)\n            clearTimeout(_movingTimeoutId);\n\n          _movingTimeoutId = setTimeout(function() {\n            _isMoving = false;\n          }, _settings('dragTimeout'));\n\n          sigma.misc.animation.killAll(_camera);\n\n          _camera.isMoving = true;\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - _startMouseX,\n            sigma.utils.getY(e) - _startMouseY,\n            true\n          );\n\n          x = _startCameraX - pos.x;\n          y = _startCameraY - pos.y;\n\n          if (x !== _camera.x || y !== _camera.y) {\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _camera.goTo({\n              x: x,\n              y: y\n            });\n          }\n\n          if (e.preventDefault)\n            e.preventDefault();\n          else\n            e.returnValue = false;\n\n          e.stopPropagation();\n          return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'up' mouse event. It will stop dragging the\n     * graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _upHandler(e) {\n      if (_settings('mouseEnabled') && _isMouseDown) {\n        _isMouseDown = false;\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _camera.isMoving = false;\n\n        var x = sigma.utils.getX(e),\n            y = sigma.utils.getY(e);\n\n        if (_isMoving) {\n          sigma.misc.animation.killAll(_camera);\n          sigma.misc.animation.camera(\n            _camera,\n            {\n              x: _camera.x +\n                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),\n              y: _camera.y +\n                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)\n            },\n            {\n              easing: 'quadraticOut',\n              duration: _settings('mouseInertiaDuration')\n            }\n          );\n        } else if (\n          _startMouseX !== x ||\n          _startMouseY !== y\n        )\n          _camera.goTo({\n            x: _camera.x,\n            y: _camera.y\n          });\n\n        _self.dispatchEvent('mouseup',\n          sigma.utils.mouseCoords(e));\n\n        // Update _isMoving flag:\n        _isMoving = false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'down' mouse event. It will start observing\n     * the mouse position for dragging the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _downHandler(e) {\n      if (_settings('mouseEnabled')) {\n        _startCameraX = _camera.x;\n        _startCameraY = _camera.y;\n\n        _lastCameraX = _camera.x;\n        _lastCameraY = _camera.y;\n\n        _startMouseX = sigma.utils.getX(e);\n        _startMouseY = sigma.utils.getY(e);\n\n        _hasDragged = false;\n        _downStartTime = (new Date()).getTime();\n\n        switch (e.which) {\n          case 2:\n            // Middle mouse button pressed\n            // Do nothing.\n            break;\n          case 3:\n            // Right mouse button pressed\n            _self.dispatchEvent('rightclick',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n            break;\n          // case 1:\n          default:\n            // Left mouse button pressed\n            _isMouseDown = true;\n\n            _self.dispatchEvent('mousedown',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'out' mouse event. It will just redispatch\n     * the event.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _outHandler(e) {\n      if (_settings('mouseEnabled'))\n        _self.dispatchEvent('mouseout');\n    }\n\n    /**\n     * The handler listening to the 'click' mouse event. It will redispatch the\n     * click event, but with normalized X and Y coordinates.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _clickHandler(e) {\n      if (_settings('mouseEnabled')) {\n        var event = sigma.utils.mouseCoords(e);\n        event.isDragging =\n          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;\n        _self.dispatchEvent('click', event);\n      }\n\n      if (e.preventDefault)\n        e.preventDefault();\n      else\n        e.returnValue = false;\n\n      e.stopPropagation();\n      return false;\n    }\n\n    /**\n     * The handler listening to the double click custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _doubleClickHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (_settings('mouseEnabled')) {\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        _self.dispatchEvent('doubleclick',\n            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration')\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'wheel' mouse event. It will basically zoom\n     * in or not into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _wheelHandler(e) {\n      var pos,\n          ratio,\n          animation,\n          wheelDelta = sigma.utils.getDelta(e);\n\n      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {\n        ratio = wheelDelta > 0 ?\n          1 / _settings('zoomingRatio') :\n          _settings('zoomingRatio');\n\n        pos = _camera.cameraPosition(\n          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n          true\n        );\n\n        animation = {\n          duration: _settings('mouseZoomDuration')\n        };\n\n        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.touch = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        _startCameraRatio,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // TOUCH MANAGEMENT:\n        // *****************\n        // Touches that are down:\n        _downTouches = [],\n\n        _startTouchX0,\n        _startTouchY0,\n        _startTouchX1,\n        _startTouchY1,\n        _startTouchAngle,\n        _startTouchDistance,\n\n        _touchMode,\n\n        _isMoving,\n        _doubleTap,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);\n    _target.addEventListener('touchstart', _handleStart, false);\n    _target.addEventListener('touchend', _handleLeave, false);\n    _target.addEventListener('touchcancel', _handleLeave, false);\n    _target.addEventListener('touchleave', _handleLeave, false);\n    _target.addEventListener('touchmove', _handleMove, false);\n\n    function position(e) {\n      var offset = sigma.utils.getOffset(_target);\n\n      return {\n        x: e.pageX - offset.left,\n        y: e.pageY - offset.top\n      };\n    }\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'touchstart');\n      _target.addEventListener('touchstart', _handleStart);\n      _target.addEventListener('touchend', _handleLeave);\n      _target.addEventListener('touchcancel', _handleLeave);\n      _target.addEventListener('touchleave', _handleLeave);\n      _target.addEventListener('touchmove', _handleMove);\n    };\n\n    // TOUCH EVENTS:\n    // *************\n    /**\n     * The handler listening to the 'touchstart' event. It will set the touch\n     * mode (\"_touchMode\") and start observing the user touch moves.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleStart(e) {\n      if (_settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            pos0,\n            pos1;\n\n        _downTouches = e.touches;\n\n        switch (_downTouches.length) {\n          case 1:\n            _camera.isMoving = true;\n            _touchMode = 1;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            pos0 = position(_downTouches[0]);\n            _startTouchX0 = pos0.x;\n            _startTouchY0 = pos0.y;\n\n            break;\n          case 2:\n            _camera.isMoving = true;\n            _touchMode = 2;\n\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _startCameraAngle = _camera.angle;\n            _startCameraRatio = _camera.ratio;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _startTouchX0 = x0;\n            _startTouchY0 = y0;\n            _startTouchX1 = x1;\n            _startTouchY1 = y1;\n\n            _startTouchAngle = Math.atan2(\n              _startTouchY1 - _startTouchY0,\n              _startTouchX1 - _startTouchX0\n            );\n            _startTouchDistance = Math.sqrt(\n              (_startTouchY1 - _startTouchY0) *\n                (_startTouchY1 - _startTouchY0) +\n              (_startTouchX1 - _startTouchX0) *\n                (_startTouchX1 - _startTouchX0)\n            );\n\n            e.preventDefault();\n            return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'\n     * event. It will update the touch mode if there are still at least one\n     * finger, and stop dragging else.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleLeave(e) {\n      if (_settings('touchEnabled')) {\n        _downTouches = e.touches;\n        var inertiaRatio = _settings('touchInertiaRatio');\n\n        if (_movingTimeoutId) {\n          _isMoving = false;\n          clearTimeout(_movingTimeoutId);\n        }\n\n        switch (_touchMode) {\n          case 2:\n            if (e.touches.length === 1) {\n              _handleStart(e);\n\n              e.preventDefault();\n              break;\n            }\n            /* falls through */\n          case 1:\n            _camera.isMoving = false;\n            _self.dispatchEvent('stopDrag');\n\n            if (_isMoving) {\n              _doubleTap = false;\n              sigma.misc.animation.camera(\n                _camera,\n                {\n                  x: _camera.x +\n                    inertiaRatio * (_camera.x - _lastCameraX),\n                  y: _camera.y +\n                    inertiaRatio * (_camera.y - _lastCameraY)\n                },\n                {\n                  easing: 'quadraticOut',\n                  duration: _settings('touchInertiaDuration')\n                }\n              );\n            }\n\n            _isMoving = false;\n            _touchMode = 0;\n            break;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchmove' event. It will effectively drag\n     * the graph, and eventually zooms and turn it if the user is using two\n     * fingers.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleMove(e) {\n      if (!_doubleTap && _settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            cos,\n            sin,\n            end,\n            pos0,\n            pos1,\n            diff,\n            start,\n            dAngle,\n            dRatio,\n            newStageX,\n            newStageY,\n            newStageRatio,\n            newStageAngle;\n\n        _downTouches = e.touches;\n        _isMoving = true;\n\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _movingTimeoutId = setTimeout(function() {\n          _isMoving = false;\n        }, _settings('dragTimeout'));\n\n        switch (_touchMode) {\n          case 1:\n            pos0 = position(_downTouches[0]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n\n            diff = _camera.cameraPosition(\n              x0 - _startTouchX0,\n              y0 - _startTouchY0,\n              true\n            );\n\n            newStageX = _startCameraX - diff.x;\n            newStageY = _startCameraY - diff.y;\n\n            if (newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY\n              });\n\n              _self.dispatchEvent('mousemove',\n                sigma.utils.mouseCoords(e, pos0.x, pos0.y));\n\n              _self.dispatchEvent('drag');\n            }\n            break;\n          case 2:\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            start = _camera.cameraPosition(\n              (_startTouchX0 + _startTouchX1) / 2 -\n                sigma.utils.getCenter(e).x,\n              (_startTouchY0 + _startTouchY1) / 2 -\n                sigma.utils.getCenter(e).y,\n              true\n            );\n            end = _camera.cameraPosition(\n              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,\n              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,\n              true\n            );\n\n            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;\n            dRatio = Math.sqrt(\n              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)\n            ) / _startTouchDistance;\n\n            // Translation:\n            x0 = start.x;\n            y0 = start.y;\n\n            // Homothetic transformation:\n            newStageRatio = _startCameraRatio / dRatio;\n            x0 = x0 * dRatio;\n            y0 = y0 * dRatio;\n\n            // Rotation:\n            newStageAngle = _startCameraAngle - dAngle;\n            cos = Math.cos(-dAngle);\n            sin = Math.sin(-dAngle);\n            x1 = x0 * cos + y0 * sin;\n            y1 = y0 * cos - x0 * sin;\n            x0 = x1;\n            y0 = y1;\n\n            // Finalize:\n            newStageX = x0 - end.x + _startCameraX;\n            newStageY = y0 - end.y + _startCameraY;\n\n            if (\n              newStageRatio !== _camera.ratio ||\n              newStageAngle !== _camera.angle ||\n              newStageX !== _camera.x ||\n              newStageY !== _camera.y\n            ) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n              _lastCameraAngle = _camera.angle;\n              _lastCameraRatio = _camera.ratio;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY,\n                angle: newStageAngle,\n                ratio: newStageRatio\n              });\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n        }\n\n        e.preventDefault();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the double tap custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A touch event.\n     */\n    function _doubleTapHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {\n        _doubleTap = true;\n\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        pos = position(e.touches[0]);\n        _self.dispatchEvent('doubleclick',\n          sigma.utils.mouseCoords(e, pos.x, pos.y));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            pos.x - sigma.utils.getCenter(e).x,\n            pos.y - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration'),\n            onComplete: function() {\n              _doubleTap = false;\n            }\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.classes');\n\n  /**\n   * The camera constructor. It just initializes its attributes and methods.\n   *\n   * @param  {string}       id       The id.\n   * @param  {sigma.classes.graph}  graph    The graph.\n   * @param  {configurable} settings The settings function.\n   * @param  {?object}      options  Eventually some overriding options.\n   * @return {camera}                Returns the fresh new camera instance.\n   */\n  sigma.classes.camera = function(id, graph, settings, options) {\n    sigma.classes.dispatcher.extend(this);\n\n    Object.defineProperty(this, 'graph', {\n      value: graph\n    });\n    Object.defineProperty(this, 'id', {\n      value: id\n    });\n    Object.defineProperty(this, 'readPrefix', {\n      value: 'read_cam' + id + ':'\n    });\n    Object.defineProperty(this, 'prefix', {\n      value: 'cam' + id + ':'\n    });\n\n    this.x = 0;\n    this.y = 0;\n    this.ratio = 1;\n    this.angle = 0;\n    this.isAnimated = false;\n    this.settings = (typeof options === 'object' && options) ?\n      settings.embedObject(options) :\n      settings;\n  };\n\n  /**\n   * Updates the camera position.\n   *\n   * @param  {object} coordinates The new coordinates object.\n   * @return {camera}             Returns the camera.\n   */\n  sigma.classes.camera.prototype.goTo = function(coordinates) {\n    if (!this.settings('enableCamera'))\n      return this;\n\n    var i,\n        l,\n        c = coordinates || {},\n        keys = ['x', 'y', 'ratio', 'angle'];\n\n    for (i = 0, l = keys.length; i < l; i++)\n      if (c[keys[i]] !== undefined) {\n        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))\n          this[keys[i]] = c[keys[i]];\n        else\n          throw 'Value for \"' + keys[i] + '\" is not a number.';\n      }\n\n    this.dispatchEvent('coordinatesUpdated');\n    return this;\n  };\n\n  /**\n   * This method takes a graph and computes for each node and edges its\n   * coordinates relatively to the center of the camera. Basically, it will\n   * compute the coordinates that will be used by the graphic renderers.\n   *\n   * Since it should be possible to use different cameras and different\n   * renderers, it is possible to specify a prefix to put before the new\n   * coordinates (to get something like \"node.camera1_x\")\n   *\n   * @param  {?string} read    The prefix of the coordinates to read.\n   * @param  {?string} write   The prefix of the coordinates to write.\n   * @param  {?object} options Eventually an object of options. Those can be:\n   *                           - A restricted nodes array.\n   *                           - A restricted edges array.\n   *                           - A width.\n   *                           - A height.\n   * @return {camera}        Returns the camera.\n   */\n  sigma.classes.camera.prototype.applyView = function(read, write, options) {\n    options = options || {};\n    write = write !== undefined ? write : this.prefix;\n    read = read !== undefined ? read : this.readPrefix;\n\n    var nodes = options.nodes || this.graph.nodes(),\n        edges = options.edges || this.graph.edges();\n\n    var i,\n        l,\n        node,\n        relCos = Math.cos(this.angle) / this.ratio,\n        relSin = Math.sin(this.angle) / this.ratio,\n        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),\n        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),\n        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,\n        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      node[write + 'x'] =\n        (node[read + 'x'] || 0) * relCos +\n        (node[read + 'y'] || 0) * relSin +\n        xOffset;\n      node[write + 'y'] =\n        (node[read + 'y'] || 0) * relCos -\n        (node[read + 'x'] || 0) * relSin +\n        yOffset;\n      node[write + 'size'] =\n        (node[read + 'size'] || 0) /\n        nodeRatio;\n    }\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      edges[i][write + 'size'] =\n        (edges[i][read + 'size'] || 0) /\n        edgeRatio;\n    }\n\n    return this;\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * camera to the frame of the graph.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    camera.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    camera.\n   * @return {object}   The point coordinates in the frame of the graph.\n   */\n  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: (x * cos + y * sin) / this.ratio + X,\n      y: (y * cos - x * sin) / this.ratio + Y\n    };\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * graph to the frame of the camera.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    graph.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    graph.\n   * @return {object}   The point coordinates in the frame of the camera.\n   */\n  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,\n      y: ((y - Y) * cos + (x - X) * sin) * this.ratio\n    };\n  };\n\n  /**\n   * This method returns the transformation matrix of the camera. This is\n   * especially useful to apply the camera view directly in shaders, in case of\n   * WebGL rendering.\n   *\n   * @return {array} The transformation matrix.\n   */\n  sigma.classes.camera.prototype.getMatrix = function() {\n    var scale = sigma.utils.matrices.scale(1 / this.ratio),\n        rotation = sigma.utils.matrices.rotation(this.angle),\n        translation = sigma.utils.matrices.translation(-this.x, -this.y),\n        matrix = sigma.utils.matrices.multiply(\n          translation,\n          sigma.utils.matrices.multiply(\n            rotation,\n            scale\n          )\n        );\n\n    return matrix;\n  };\n\n  /**\n   * Taking a width and a height as parameters, this method returns the\n   * coordinates of the rectangle representing the camera on screen, in the\n   * graph's referentiel.\n   *\n   * To keep displaying labels of nodes going out of the screen, the method\n   * keeps a margin around the screen in the returned rectangle.\n   *\n   * @param  {number} width  The width of the screen.\n   * @param  {number} height The height of the screen.\n   * @return {object}        The rectangle as x1, y1, x2 and y2, representing\n   *                         two opposite points.\n   */\n  sigma.classes.camera.prototype.getRectangle = function(width, height) {\n    var widthVect = this.cameraPosition(width, 0, true),\n        heightVect = this.cameraPosition(0, height, true),\n        centerVect = this.cameraPosition(width / 2, height / 2, true),\n        marginX = this.cameraPosition(width / 4, 0, true).x,\n        marginY = this.cameraPosition(0, height / 4, true).y;\n\n    return {\n      x1: this.x - centerVect.x - marginX,\n      y1: this.y - centerVect.y - marginY,\n      x2: this.x - centerVect.x + marginX + widthVect.x,\n      y2: this.y - centerVect.y - marginY + widthVect.y,\n      height: Math.sqrt(\n        Math.pow(heightVect.x, 2) +\n        Math.pow(heightVect.y + 2 * marginY, 2)\n      )\n    };\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  /**\n   * This utils aims to facilitate the manipulation of each instance setting.\n   * Using a function instead of an object brings two main advantages: First,\n   * it will be easier in the future to catch settings updates through a\n   * function than an object. Second, giving it a full object will \"merge\" it\n   * to the settings object properly, keeping us to have to always add a loop.\n   *\n   * @return {configurable} The \"settings\" function.\n   */\n  var configurable = function() {\n    var i,\n        l,\n        data = {},\n        datas = Array.prototype.slice.call(arguments, 0);\n\n    /**\n     * The method to use to set or get any property of this instance.\n     *\n     * @param  {string|object}    a1 If it is a string and if a2 is undefined,\n     *                               then it will return the corresponding\n     *                               property. If it is a string and if a2 is\n     *                               set, then it will set a2 as the property\n     *                               corresponding to a1, and return this. If\n     *                               it is an object, then each pair string +\n     *                               object(or any other type) will be set as a\n     *                               property.\n     * @param  {*?}               a2 The new property corresponding to a1 if a1\n     *                               is a string.\n     * @return {*|configurable}      Returns itself or the corresponding\n     *                               property.\n     *\n     * Polymorphism:\n     * *************\n     * Here are some basic use examples:\n     *\n     *  > settings = new configurable();\n     *  > settings('mySetting', 42);\n     *  > settings('mySetting'); // Logs: 42\n     *  > settings('mySetting', 123);\n     *  > settings('mySetting'); // Logs: 123\n     *  > settings({mySetting: 456});\n     *  > settings('mySetting'); // Logs: 456\n     *\n     * Also, it is possible to use the function as a fallback:\n     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'\n     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456\n     */\n    var settings = function(a1, a2) {\n      var o,\n          i,\n          l,\n          k;\n\n      if (arguments.length === 1 && typeof a1 === 'string') {\n        if (data[a1] !== undefined)\n          return data[a1];\n        for (i = 0, l = datas.length; i < l; i++)\n          if (datas[i][a1] !== undefined)\n            return datas[i][a1];\n        return undefined;\n      } else if (typeof a1 === 'object' && typeof a2 === 'string') {\n        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);\n      } else {\n        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};\n\n        if (typeof a1 === 'string')\n          o[a1] = a2;\n\n        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)\n          data[k[i]] = o[k[i]];\n\n        return this;\n      }\n    };\n\n    /**\n     * This method returns a new configurable function, with new objects\n     *\n     * @param  {object*}  Any number of objects to search in.\n     * @return {function} Returns the function. Check its documentation to know\n     *                    more about how it works.\n     */\n    settings.embedObjects = function() {\n      var args = datas.concat(\n        data\n      ).concat(\n        Array.prototype.splice.call(arguments, 0)\n      );\n\n      return configurable.apply({}, args);\n    };\n\n    // Initialize\n    for (i = 0, l = arguments.length; i < l; i++)\n      settings(arguments[i]);\n\n    return settings;\n  };\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.configurable = configurable;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = configurable;\n    exports.configurable = configurable;\n  } else\n    this.configurable = configurable;\n}).call(this);\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  /**\n   * Dispatcher constructor.\n   *\n   * @return {dispatcher} The new dispatcher instance.\n   */\n  var dispatcher = function() {\n    Object.defineProperty(this, '_handlers', {\n      value: {}\n    });\n  };\n\n\n\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string}           events  The name of the event (or the events\n   *                                    separated by spaces).\n   * @param  {function(Object)} handler The handler to bind.\n   * @return {dispatcher}               Returns the instance itself.\n   */\n  dispatcher.prototype.bind = function(events, handler) {\n    var i,\n        l,\n        event,\n        eArray;\n\n    if (\n      arguments.length === 1 &&\n      typeof arguments[0] === 'object'\n    )\n      for (events in arguments[0])\n        this.bind(events, arguments[0][events]);\n    else if (\n      arguments.length === 2 &&\n      typeof arguments[1] === 'function'\n    ) {\n      eArray = typeof events === 'string' ? events.split(' ') : events;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i];\n\n        // Check that event is not '':\n        if (!event)\n          continue;\n\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        this._handlers[event].push({\n          handler: handler\n        });\n      }\n    } else\n      throw 'bind: Wrong arguments.';\n\n    return this;\n  };\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {dispatcher}                Returns the instance itself.\n   */\n  dispatcher.prototype.unbind = function(events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    if (!arguments.length) {\n      for (k in this._handlers)\n        delete this._handlers[k];\n      return this;\n    }\n\n    if (handler) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n        if (this._handlers[event]) {\n          a = [];\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)\n            if (this._handlers[event][j].handler !== handler)\n              a.push(this._handlers[event][j]);\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0)\n          delete this._handlers[event];\n      }\n    } else\n      for (i = 0, n = eArray.length; i !== n; i += 1)\n        delete this._handlers[eArray[i]];\n\n    return this;\n  };\n\n  /**\n   * Executes each handler bound to the event\n   *\n   * @param  {string}     events The name of the event (or the events separated\n   *                             by spaces).\n   * @param  {?object}    data   The content of the event (optional).\n   * @return {dispatcher}        Returns the instance itself.\n   */\n  dispatcher.prototype.dispatchEvent = function(events, data) {\n    var i,\n        n,\n        j,\n        m,\n        a,\n        event,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n\n      if (this._handlers[eventName]) {\n        event = self.getEvent(eventName, data);\n        a = [];\n\n        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {\n          this._handlers[eventName][j].handler(event);\n          if (!this._handlers[eventName][j].one)\n            a.push(this._handlers[eventName][j]);\n        }\n\n        this._handlers[eventName] = a;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Return an event object.\n   *\n   * @param  {string}  events The name of the event.\n   * @param  {?object} data   The content of the event (optional).\n   * @return {object}         Returns the instance itself.\n   */\n  dispatcher.prototype.getEvent = function(event, data) {\n    return {\n      type: event,\n      data: data || {},\n      target: this\n    };\n  };\n\n  /**\n   * A useful function to deal with inheritance. It will make the target\n   * inherit the prototype of the class dispatcher as well as its constructor.\n   *\n   * @param {object} target The target.\n   */\n  dispatcher.extend = function(target, args) {\n    var k;\n\n    for (k in dispatcher.prototype)\n      if (dispatcher.prototype.hasOwnProperty(k))\n        target[k] = dispatcher.prototype[k];\n\n    dispatcher.apply(target, args);\n  };\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.dispatcher = dispatcher;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = dispatcher;\n    exports.dispatcher = dispatcher;\n  } else\n    this.dispatcher = dispatcher;\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module for edges\n   * ===============================\n   *\n   * Author: SÃ©bastien Heymann,\n   *   from the quad of Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge with x1, y1, x2, y2 and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph edge with at least two points\n     *                  (x1, y1), (x2, y2) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    lineToSquare: function(e) {\n      if (e.y1 < e.y2) {\n        // (e.x1, e.y1) on top\n        if (e.x1 < e.x2) {\n          // (e.x1, e.y1) on left\n          return {\n            x1: e.x1 - e.size,\n            y1: e.y1 - e.size,\n            x2: e.x2 + e.size,\n            y2: e.y1 - e.size,\n            height: e.y2 - e.y1 + e.size * 2\n          };\n        }\n        // (e.x1, e.y1) on right\n        return {\n          x1: e.x2 - e.size,\n          y1: e.y1 - e.size,\n          x2: e.x1 + e.size,\n          y2: e.y1 - e.size,\n          height: e.y2 - e.y1 + e.size * 2\n        };\n      }\n\n      // (e.x2, e.y2) on top\n      if (e.x1 < e.x2) {\n        // (e.x1, e.y1) on left\n        return {\n          x1: e.x1 - e.size,\n          y1: e.y2 - e.size,\n          x2: e.x2 + e.size,\n          y2: e.y2 - e.size,\n          height: e.y1 - e.y2 + e.size * 2\n        };\n      }\n      // (e.x2, e.y2) on right\n      return {\n        x1: e.x2 - e.size,\n        y1: e.y2 - e.size,\n        x2: e.x1 + e.size,\n        y2: e.y2 - e.size,\n        height: e.y1 - e.y2 + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,\n     * control point and size into an axis-aligned square.\n     *\n     * @param  {object} e  A graph edge with at least two points\n     *                     (x1, y1), (x2, y2) and a size.\n     * @param  {object} cp A control point (x,y).\n     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.\n     */\n    quadraticCurveToSquare: function(e, cp) {\n      var pt = sigma.utils.getPointOnQuadraticCurve(\n        0.5,\n        e.x1,\n        e.y1,\n        e.x2,\n        e.y2,\n        cp.x,\n        cp.y\n      );\n\n      // Bounding box of the two points and the point at the middle of the\n      // curve:\n      var minX = Math.min(e.x1, e.x2, pt.x),\n          maxX = Math.max(e.x1, e.x2, pt.x),\n          minY = Math.min(e.y1, e.y2, pt.y),\n          maxY = Math.max(e.y1, e.y2, pt.y);\n\n      return {\n        x1: minX - e.size,\n        y1: minY - e.size,\n        x2: maxX + e.size,\n        y2: minY - e.size,\n        height: maxY - minY + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph self loop into an axis-aligned square.\n     *\n     * @param  {object} n A graph node with a point (x, y) and a size.\n     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.\n     */\n    selfLoopToSquare: function(n) {\n      // Fitting to the curve is too costly, we compute a larger bounding box\n      // using the control points:\n      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);\n\n      // Bounding box of the point and the two control points:\n      var minX = Math.min(n.x, cp.x1, cp.x2),\n          maxX = Math.max(n.x, cp.x1, cp.x2),\n          minY = Math.min(n.y, cp.y1, cp.y2),\n          maxY = Math.max(n.y, cp.y1, cp.y2);\n\n      return {\n        x1: minX - n.size,\n        y1: minY - n.size,\n        x2: maxX + n.size,\n        y2: minY - n.size,\n        height: maxY - minY + n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 40,\n      maxLevel: maxLevel || 8,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The edgequad API as exposed to sigma.\n   */\n\n  /**\n   * The edgequad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree     Property holding the quadtree object.\n   * property {object} _geom     Exposition of the _geom namespace for testing.\n   * property {object} _cache    Cache for the area method.\n   * property {boolean} _enabled Can index and retreive elements.\n   */\n  var edgequad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n    this._enabled = true;\n  };\n\n  /**\n   * Index a graph by inserting its edges into the quadtree.\n   *\n   * @param  {object} graph   A graph instance.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for edge geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  edgequad.prototype.index = function(graph, params) {\n    if (!this._enabled)\n      return this._tree;\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.edgequad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '',\n        cp,\n        source,\n        target,\n        n,\n        e;\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    var edges = graph.edges();\n\n    // Inserting graph edges into the tree\n    for (var i = 0, l = edges.length; i < l; i++) {\n      source = graph.nodes(edges[i].source);\n      target = graph.nodes(edges[i].target);\n      e = {\n        x1: source[prefix + 'x'],\n        y1: source[prefix + 'y'],\n        x2: target[prefix + 'x'],\n        y2: target[prefix + 'y'],\n        size: edges[i][prefix + 'size'] || 0\n      };\n\n      // Inserting edge\n      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {\n        if (source.id === target.id) {\n          n = {\n            x: source[prefix + 'x'],\n            y: source[prefix + 'y'],\n            size: source[prefix + 'size'] || 0\n          };\n          _quadInsert(\n            edges[i],\n            _geom.selfLoopToSquare(n),\n            this._tree);\n        }\n        else {\n          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);\n          _quadInsert(\n            edges[i],\n            _geom.quadraticCurveToSquare(e, cp),\n            this._tree);\n        }\n      }\n      else {\n        _quadInsert(\n          edges[i],\n          _geom.lineToSquare(e),\n          this._tree);\n      }\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph edges held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.point = function(x, y) {\n    if (!this._enabled)\n      return [];\n\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph edges within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.area = function(rect) {\n    if (!this._enabled)\n      return [];\n\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving edges\n    var edges = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var edgesArray = [];\n    for (var i in edges)\n      edgesArray.push(edges[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = edgesArray;\n\n    return edgesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.edgequad = edgequad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = edgequad;\n    exports.edgequad = edgequad;\n  } else\n    this.edgequad = edgequad;\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  var _methods = Object.create(null),\n      _indexes = Object.create(null),\n      _initBindings = Object.create(null),\n      _methodBindings = Object.create(null),\n      _methodBeforeBindings = Object.create(null),\n      _defaultSettings = {\n        immutable: true,\n        clone: true\n      },\n      _defaultSettingsFunction = function(key) {\n        return _defaultSettings[key];\n      };\n\n  /**\n   * The graph constructor. It initializes the data and the indexes, and binds\n   * the custom indexes and methods to its own scope.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {boolean} clone     Indicates if the data have to be cloned in methods\n   *                       to add nodes or edges.\n   *   {boolean} immutable Indicates if nodes \"id\" values and edges \"id\",\n   *                       \"source\" and \"target\" values must be set as\n   *                       immutable.\n   *\n   * @param  {?configurable} settings Eventually a settings function.\n   * @return {graph}                  The new graph instance.\n   */\n  var graph = function(settings) {\n    var k,\n        fn,\n        data;\n\n    /**\n     * DATA:\n     * *****\n     * Every data that is callable from graph methods are stored in this \"data\"\n     * object. This object will be served as context for all these methods,\n     * and it is possible to add other type of data in it.\n     */\n    data = {\n      /**\n       * SETTINGS FUNCTION:\n       * ******************\n       */\n      settings: settings || _defaultSettingsFunction,\n\n      /**\n       * MAIN DATA:\n       * **********\n       */\n      nodesArray: [],\n      edgesArray: [],\n\n      /**\n       * GLOBAL INDEXES:\n       * ***************\n       * These indexes just index data by ids.\n       */\n      nodesIndex: Object.create(null),\n      edgesIndex: Object.create(null),\n\n      /**\n       * LOCAL INDEXES:\n       * **************\n       * These indexes refer from node to nodes. Each key is an id, and each\n       * value is the array of the ids of related nodes.\n       */\n      inNeighborsIndex: Object.create(null),\n      outNeighborsIndex: Object.create(null),\n      allNeighborsIndex: Object.create(null),\n\n      inNeighborsCount: Object.create(null),\n      outNeighborsCount: Object.create(null),\n      allNeighborsCount: Object.create(null)\n    };\n\n    // Execute bindings:\n    for (k in _initBindings)\n      _initBindings[k].call(data);\n\n    // Add methods to both the scope and the data objects:\n    for (k in _methods) {\n      fn = __bindGraphMethod(k, data, _methods[k]);\n      this[k] = fn;\n      data[k] = fn;\n    }\n  };\n\n\n\n\n  /**\n   * A custom tool to bind methods such that function that are bound to it will\n   * be executed anytime the method is called.\n   *\n   * @param  {string}   methodName The name of the method to bind.\n   * @param  {object}   scope      The scope where the method must be executed.\n   * @param  {function} fn         The method itself.\n   * @return {function}            The new method.\n   */\n  function __bindGraphMethod(methodName, scope, fn) {\n    var result = function() {\n      var k,\n          res;\n\n      // Execute \"before\" bound functions:\n      for (k in _methodBeforeBindings[methodName])\n        _methodBeforeBindings[methodName][k].apply(scope, arguments);\n\n      // Apply the method:\n      res = fn.apply(scope, arguments);\n\n      // Execute bound functions:\n      for (k in _methodBindings[methodName])\n        _methodBindings[methodName][k].apply(scope, arguments);\n\n      // Return res:\n      return res;\n    };\n\n    return result;\n  }\n\n  /**\n   * This custom tool function removes every pair key/value from an hash. The\n   * goal is to avoid creating a new object while some other references are\n   * still hanging in some scopes...\n   *\n   * @param  {object} obj The object to empty.\n   * @return {object}     The empty object.\n   */\n  function __emptyObject(obj) {\n    var k;\n\n    for (k in obj)\n      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))\n        delete obj[k];\n\n    return obj;\n  }\n\n\n\n\n  /**\n   * This global method adds a method that will be bound to the futurly created\n   * graph instances.\n   *\n   * Since these methods will be bound to their scope when the instances are\n   * created, it does not use the prototype. Because of that, methods have to\n   * be added before instances are created to make them available.\n   *\n   * Here is an example:\n   *\n   *  > graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesArray.length;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *\n   * @param  {string}   methodName The name of the method.\n   * @param  {function} fn         The method itself.\n   * @return {object}              The global graph constructor.\n   */\n  graph.addMethod = function(methodName, fn) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length !== 2\n    )\n      throw 'addMethod: Wrong arguments.';\n\n    if (_methods[methodName] || graph[methodName])\n      throw 'The method \"' + methodName + '\" already exists.';\n\n    _methods[methodName] = fn;\n    _methodBindings[methodName] = Object.create(null);\n    _methodBeforeBindings[methodName] = Object.create(null);\n\n    return this;\n  };\n\n  /**\n   * This global method returns true if the method has already been added, and\n   * false else.\n   *\n   * Here are some examples:\n   *\n   *  > graph.hasMethod('addNode'); // returns true\n   *  > graph.hasMethod('hasMethod'); // returns true\n   *  > graph.hasMethod('unexistingMethod'); // returns false\n   *\n   * @param  {string}  methodName The name of the method.\n   * @return {boolean}            The result.\n   */\n  graph.hasMethod = function(methodName) {\n    return !!(_methods[methodName] || graph[methodName]);\n  };\n\n  /**\n   * This global methods attaches a function to a method. Anytime the specified\n   * method is called, the attached function is called right after, with the\n   * same arguments and in the same scope. The attached function is called\n   * right before if the last argument is true, unless the method is the graph\n   * constructor.\n   *\n   * To attach a function to the graph constructor, use 'constructor' as the\n   * method name (first argument).\n   *\n   * The main idea is to have a clean way to keep custom indexes up to date,\n   * for instance:\n   *\n   *  > var timesAddNodeCalled = 0;\n   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {\n   *  >   timesAddNodeCalled++;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(timesAddNodeCalled); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(timesAddNodeCalled); // outputs 2\n   *\n   * The idea for calling a function before is to provide pre-processors, for\n   * instance:\n   *\n   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };\n   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {\n   *  >   n.color = colorPalette[n.category];\n   *  > }, true);\n   *  >\n   *  > var myGraph = new graph();\n   *  > myGraph.addNode({ id: 'n0', category: 'Person' });\n   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'\n   *\n   * @param  {string}   methodName The name of the related method or\n   *                               \"constructor\".\n   * @param  {string}   key        The key to identify the function to attach.\n   * @param  {function} fn         The function to bind.\n   * @param  {boolean}  before     If true the function is called right before.\n   * @return {object}              The global graph constructor.\n   */\n  graph.attach = function(methodName, key, fn, before) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof key !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length < 3 ||\n      arguments.length > 4\n    )\n      throw 'attach: Wrong arguments.';\n\n    var bindings;\n\n    if (methodName === 'constructor')\n      bindings = _initBindings;\n    else {\n      if (before) {\n        if (!_methodBeforeBindings[methodName])\n        throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBeforeBindings[methodName];\n      }\n      else {\n        if (!_methodBindings[methodName])\n          throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBindings[methodName];\n      }\n    }\n\n    if (bindings[key])\n      throw 'A function \"' + key + '\" is already attached ' +\n            'to the method \"' + methodName + '\".';\n\n    bindings[key] = fn;\n\n    return this;\n  };\n\n  /**\n   * Alias of attach(methodName, key, fn, true).\n   */\n  graph.attachBefore = function(methodName, key, fn) {\n    return this.attach(methodName, key, fn, true);\n  };\n\n  /**\n   * This methods is just an helper to deal with custom indexes. It takes as\n   * arguments the name of the index and an object containing all the different\n   * functions to bind to the methods.\n   *\n   * Here is a basic example, that creates an index to keep the number of nodes\n   * in the current graph. It also adds a method to provide a getter on that\n   * new index:\n   *\n   *  > sigma.classes.graph.addIndex('nodesCount', {\n   *  >   constructor: function() {\n   *  >     this.nodesCount = 0;\n   *  >   },\n   *  >   addNode: function() {\n   *  >     this.nodesCount++;\n   *  >   },\n   *  >   dropNode: function() {\n   *  >     this.nodesCount--;\n   *  >   }\n   *  > });\n   *  >\n   *  > sigma.classes.graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesCount;\n   *  > });\n   *  >\n   *  > var myGraph = new sigma.classes.graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(myGraph.getNodesCount()); // outputs 2\n   *\n   * @param  {string} name     The name of the index.\n   * @param  {object} bindings The object containing the functions to bind.\n   * @return {object}          The global graph constructor.\n   */\n  graph.addIndex = function(name, bindings) {\n    if (\n      typeof name !== 'string' ||\n      Object(bindings) !== bindings ||\n      arguments.length !== 2\n    )\n      throw 'addIndex: Wrong arguments.';\n\n    if (_indexes[name])\n      throw 'The index \"' + name + '\" already exists.';\n\n    var k;\n\n    // Store the bindings:\n    _indexes[name] = bindings;\n\n    // Attach the bindings:\n    for (k in bindings)\n      if (typeof bindings[k] !== 'function')\n        throw 'The bindings must be functions.';\n      else\n        graph.attach(k, name, bindings[k]);\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method adds a node to the graph. The node must be an object, with a\n   * string under the key \"id\". Except for this, it is possible to add any\n   * other attribute, that will be preserved all along the manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the node will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id will be defined as immutable.\n   *\n   * @param  {object} node The node to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addNode', function(node) {\n    // Check that the node is an object and has an id:\n    if (Object(node) !== node || arguments.length !== 1)\n      throw 'addNode: Wrong arguments.';\n\n    if (typeof node.id !== 'string' && typeof node.id !== 'number')\n      throw 'The node must have a string or number id.';\n\n    if (this.nodesIndex[node.id])\n      throw 'The node \"' + node.id + '\" already exists.';\n\n    var k,\n        id = node.id,\n        validNode = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in node)\n        if (k !== 'id')\n          validNode[k] = node[k];\n    } else\n      validNode = node;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable'))\n      Object.defineProperty(validNode, 'id', {\n        value: id,\n        enumerable: true\n      });\n    else\n      validNode.id = id;\n\n    // Add empty containers for edges indexes:\n    this.inNeighborsIndex[id] = Object.create(null);\n    this.outNeighborsIndex[id] = Object.create(null);\n    this.allNeighborsIndex[id] = Object.create(null);\n\n    this.inNeighborsCount[id] = 0;\n    this.outNeighborsCount[id] = 0;\n    this.allNeighborsCount[id] = 0;\n\n    // Add the node to indexes:\n    this.nodesArray.push(validNode);\n    this.nodesIndex[validNode.id] = validNode;\n\n    // Return the current instance:\n    return this;\n  });\n\n  /**\n   * This method adds an edge to the graph. The edge must be an object, with a\n   * string under the key \"id\", and strings under the keys \"source\" and\n   * \"target\" that design existing nodes. Except for this, it is possible to\n   * add any other attribute, that will be preserved all along the\n   * manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the edge will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id, source and target will be defined as immutable.\n   *\n   * @param  {object} edge The edge to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addEdge', function(edge) {\n    // Check that the edge is an object and has an id:\n    if (Object(edge) !== edge || arguments.length !== 1)\n      throw 'addEdge: Wrong arguments.';\n\n    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')\n      throw 'The edge must have a string or number id.';\n\n    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||\n        !this.nodesIndex[edge.source])\n      throw 'The edge source must have an existing node id.';\n\n    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||\n        !this.nodesIndex[edge.target])\n      throw 'The edge target must have an existing node id.';\n\n    if (this.edgesIndex[edge.id])\n      throw 'The edge \"' + edge.id + '\" already exists.';\n\n    var k,\n        validEdge = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in edge)\n        if (k !== 'id' && k !== 'source' && k !== 'target')\n          validEdge[k] = edge[k];\n    } else\n      validEdge = edge;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable')) {\n      Object.defineProperty(validEdge, 'id', {\n        value: edge.id,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'source', {\n        value: edge.source,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'target', {\n        value: edge.target,\n        enumerable: true\n      });\n    } else {\n      validEdge.id = edge.id;\n      validEdge.source = edge.source;\n      validEdge.target = edge.target;\n    }\n\n    // Add the edge to indexes:\n    this.edgesArray.push(validEdge);\n    this.edgesIndex[validEdge.id] = validEdge;\n\n    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])\n      this.inNeighborsIndex[validEdge.target][validEdge.source] =\n        Object.create(null);\n    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n      validEdge;\n\n    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])\n      this.outNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])\n      this.allNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (validEdge.target !== validEdge.source) {\n      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])\n        this.allNeighborsIndex[validEdge.target][validEdge.source] =\n          Object.create(null);\n      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n        validEdge;\n    }\n\n    // Keep counts up to date:\n    this.inNeighborsCount[validEdge.target]++;\n    this.outNeighborsCount[validEdge.source]++;\n    this.allNeighborsCount[validEdge.target]++;\n    this.allNeighborsCount[validEdge.source]++;\n\n    return this;\n  });\n\n  /**\n   * This method drops a node from the graph. It also removes each edge that is\n   * bound to it, through the dropEdge method. An error is thrown if the node\n   * does not exist.\n   *\n   * @param  {string} id The node id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropNode', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropNode: Wrong arguments.';\n\n    if (!this.nodesIndex[id])\n      throw 'The node \"' + id + '\" does not exist.';\n\n    var i, k, l;\n\n    // Remove the node from indexes:\n    delete this.nodesIndex[id];\n    for (i = 0, l = this.nodesArray.length; i < l; i++)\n      if (this.nodesArray[i].id === id) {\n        this.nodesArray.splice(i, 1);\n        break;\n      }\n\n    // Remove related edges:\n    for (i = this.edgesArray.length - 1; i >= 0; i--)\n      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)\n        this.dropEdge(this.edgesArray[i].id);\n\n    // Remove related edge indexes:\n    delete this.inNeighborsIndex[id];\n    delete this.outNeighborsIndex[id];\n    delete this.allNeighborsIndex[id];\n\n    delete this.inNeighborsCount[id];\n    delete this.outNeighborsCount[id];\n    delete this.allNeighborsCount[id];\n\n    for (k in this.nodesIndex) {\n      delete this.inNeighborsIndex[k][id];\n      delete this.outNeighborsIndex[k][id];\n      delete this.allNeighborsIndex[k][id];\n    }\n\n    return this;\n  });\n\n  /**\n   * This method drops an edge from the graph. An error is thrown if the edge\n   * does not exist.\n   *\n   * @param  {string} id The edge id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropEdge', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropEdge: Wrong arguments.';\n\n    if (!this.edgesIndex[id])\n      throw 'The edge \"' + id + '\" does not exist.';\n\n    var i, l, edge;\n\n    // Remove the edge from indexes:\n    edge = this.edgesIndex[id];\n    delete this.edgesIndex[id];\n    for (i = 0, l = this.edgesArray.length; i < l; i++)\n      if (this.edgesArray[i].id === id) {\n        this.edgesArray.splice(i, 1);\n        break;\n      }\n\n    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];\n    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)\n      delete this.inNeighborsIndex[edge.target][edge.source];\n\n    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)\n      delete this.outNeighborsIndex[edge.source][edge.target];\n\n    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)\n      delete this.allNeighborsIndex[edge.source][edge.target];\n\n    if (edge.target !== edge.source) {\n      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];\n      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)\n        delete this.allNeighborsIndex[edge.target][edge.source];\n    }\n\n    this.inNeighborsCount[edge.target]--;\n    this.outNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.target]--;\n\n    return this;\n  });\n\n  /**\n   * This method destroys the current instance. It basically empties each index\n   * and methods attached to the graph.\n   */\n  graph.addMethod('kill', function() {\n    // Delete arrays:\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n    delete this.nodesArray;\n    delete this.edgesArray;\n\n    // Delete indexes:\n    delete this.nodesIndex;\n    delete this.edgesIndex;\n    delete this.inNeighborsIndex;\n    delete this.outNeighborsIndex;\n    delete this.allNeighborsIndex;\n    delete this.inNeighborsCount;\n    delete this.outNeighborsCount;\n    delete this.allNeighborsCount;\n  });\n\n  /**\n   * This method empties the nodes and edges arrays, as well as the different\n   * indexes.\n   *\n   * @return {object} The graph instance.\n   */\n  graph.addMethod('clear', function() {\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n\n    // Due to GC issues, I prefer not to create new object. These objects are\n    // only available from the methods and attached functions, but still, it is\n    // better to prevent ghost references to unrelevant data...\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.edgesIndex);\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.inNeighborsIndex);\n    __emptyObject(this.outNeighborsIndex);\n    __emptyObject(this.allNeighborsIndex);\n    __emptyObject(this.inNeighborsCount);\n    __emptyObject(this.outNeighborsCount);\n    __emptyObject(this.allNeighborsCount);\n\n    return this;\n  });\n\n  /**\n   * This method reads an object and adds the nodes and edges, through the\n   * proper methods \"addNode\" and \"addEdge\".\n   *\n   * Here is an example:\n   *\n   *  > var myGraph = new graph();\n   *  > myGraph.read({\n   *  >   nodes: [\n   *  >     { id: 'n0' },\n   *  >     { id: 'n1' }\n   *  >   ],\n   *  >   edges: [\n   *  >     {\n   *  >       id: 'e0',\n   *  >       source: 'n0',\n   *  >       target: 'n1'\n   *  >     }\n   *  >   ]\n   *  > });\n   *  >\n   *  > console.log(\n   *  >   myGraph.nodes().length,\n   *  >   myGraph.edges().length\n   *  > ); // outputs 2 1\n   *\n   * @param  {object} g The graph object.\n   * @return {object}   The graph instance.\n   */\n  graph.addMethod('read', function(g) {\n    var i,\n        a,\n        l;\n\n    a = g.nodes || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addNode(a[i]);\n\n    a = g.edges || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addEdge(a[i]);\n\n    return this;\n  });\n\n  /**\n   * This methods returns one or several nodes, depending on how it is called.\n   *\n   * To get the array of nodes, call \"nodes\" without argument. To get a\n   * specific node, call it with the id of the node. The get multiple node,\n   * call it with an array of ids, and it will return the array of nodes, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related node or array of nodes.\n   */\n  graph.addMethod('nodes', function(v) {\n    // Clone the array of nodes and return it:\n    if (!arguments.length)\n      return this.nodesArray.slice(0);\n\n    // Return the related node:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.nodesIndex[v];\n\n    // Return an array of the related node:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.nodesIndex[v[i]]);\n        else\n          throw 'nodes: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'nodes: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns the degree of one or several nodes, depending on how\n   * it is called. It is also possible to get incoming or outcoming degrees\n   * instead by specifying 'in' or 'out' as a second argument.\n   *\n   * @param  {string|array} v     One id, an array of ids.\n   * @param  {?string}      which Which degree is required. Values are 'in',\n   *                              'out', and by default the normal degree.\n   * @return {number|array}       The related degree or array of degrees.\n   */\n  graph.addMethod('degree', function(v, which) {\n    // Check which degree is required:\n    which = {\n      'in': this.inNeighborsCount,\n      'out': this.outNeighborsCount\n    }[which || ''] || this.allNeighborsCount;\n\n    // Return the related node:\n    if (typeof v === 'string' || typeof v === 'number')\n      return which[v];\n\n    // Return an array of the related node:\n    if (Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(which[v[i]]);\n        else\n          throw 'degree: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'degree: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns one or several edges, depending on how it is called.\n   *\n   * To get the array of edges, call \"edges\" without argument. To get a\n   * specific edge, call it with the id of the edge. The get multiple edge,\n   * call it with an array of ids, and it will return the array of edges, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related edge or array of edges.\n   */\n  graph.addMethod('edges', function(v) {\n    // Clone the array of edges and return it:\n    if (!arguments.length)\n      return this.edgesArray.slice(0);\n\n    // Return the related edge:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.edgesIndex[v];\n\n    // Return an array of the related edge:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.edgesIndex[v[i]]);\n        else\n          throw 'edges: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'edges: Wrong arguments.';\n  });\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof sigma !== 'undefined') {\n    sigma.classes = sigma.classes || Object.create(null);\n    sigma.classes.graph = graph;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = graph;\n    exports.graph = graph;\n  } else\n    this.graph = graph;\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module\n   * =====================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 20,\n      maxLevel: maxLevel || 4,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The quad API as exposed to sigma.\n   */\n\n  /**\n   * The quad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree  Property holding the quadtree object.\n   * property {object} _geom  Exposition of the _geom namespace for testing.\n   * property {object} _cache Cache for the area method.\n   */\n  var quad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n  };\n\n  /**\n   * Index a graph by inserting its nodes into the quadtree.\n   *\n   * @param  {array}  nodes   An array of nodes to index.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for node geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  quad.prototype.index = function(nodes, params) {\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.quad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '';\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    // Inserting graph nodes into the tree\n    for (var i = 0, l = nodes.length; i < l; i++) {\n\n      // Inserting node\n      _quadInsert(\n        nodes[i],\n        _geom.pointToSquare({\n          x: nodes[i][prefix + 'x'],\n          y: nodes[i][prefix + 'y'],\n          size: nodes[i][prefix + 'size']\n        }),\n        this._tree\n      );\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph nodes held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.point = function(x, y) {\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph nodes within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.area = function(rect) {\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving nodes\n    var nodes = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var nodesArray = [];\n    for (var i in nodes)\n      nodesArray.push(nodes[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = nodesArray;\n\n    return nodesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.quad = quad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = quad;\n    exports.quad = quad;\n  } else\n    this.quad = quad;\n}).call(this);\n"},function(A,e){A.exports="/**\n * conrad.js is a tiny JavaScript jobs scheduler,\n *\n * Version: 0.1.0\n * Sources: http://github.com/jacomyal/conrad.js\n * Doc:     http://github.com/jacomyal/conrad.js#readme\n *\n * License:\n * --------\n * Copyright Â© 2013 Alexis Jacomy, Sciences-Po mÃ©dialab\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n(function(global) {\n  'use strict';\n\n  // Check that conrad.js has not been loaded yet:\n  if (global.conrad)\n    throw new Error('conrad already exists');\n\n\n  /**\n   * PRIVATE VARIABLES:\n   * ******************\n   */\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Number}\n   */\n  var _lastFrameTime;\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Boolean}\n   */\n  var _isRunning = false;\n\n  /**\n   * The hash of registered jobs. Each job must at least have a unique ID\n   * under the key \"id\" and a function under the key \"job\". This hash\n   * contains each running job and each waiting job.\n   *\n   * @type {Object}\n   */\n  var _jobs = {};\n\n  /**\n   * The hash of currently running jobs.\n   *\n   * @type {Object}\n   */\n  var _runningJobs = {};\n\n  /**\n   * The array of currently running jobs, sorted by priority.\n   *\n   * @type {Array}\n   */\n  var _sortedByPriorityJobs = [];\n\n  /**\n   * The array of currently waiting jobs.\n   *\n   * @type {Object}\n   */\n  var _waitingJobs = {};\n\n  /**\n   * The array of finished jobs. They are stored in an array, since two jobs\n   * with the same \"id\" can happen at two different times.\n   *\n   * @type {Array}\n   */\n  var _doneJobs = [];\n\n  /**\n   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called\n   * with several jobs, conrad must be started only at the end. This flag keeps\n   * me from duplicating the code that effectively adds a job.\n   *\n   * @type {Boolean}\n   */\n  var _noStart = false;\n\n  /**\n   * An hash containing some global settings about how conrad.js should\n   * behave.\n   *\n   * @type {Object}\n   */\n  var _parameters = {\n    frameDuration: 20,\n    history: true\n  };\n\n  /**\n   * This object contains every handlers bound to conrad events. It does not\n   * requirea any DOM implementation, since the events are all JavaScript.\n   *\n   * @type {Object}\n   */\n  var _handlers = Object.create(null);\n\n\n  /**\n   * PRIVATE FUNCTIONS:\n   * ******************\n   */\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string|array|object} events  The name of the event (or the events\n   *                                       separated by spaces).\n   * @param  {function(Object)}    handler The handler to bind.\n   * @return {Object}                      Returns conrad.\n   */\n  function _bind(events, handler) {\n    var i,\n        i_end,\n        event,\n        eArray;\n\n    if (!arguments.length)\n      return;\n    else if (\n      arguments.length === 1 &&\n      Object(arguments[0]) === arguments[0]\n    )\n      for (events in arguments[0])\n        _bind(events, arguments[0][events]);\n    else if (arguments.length > 1) {\n      eArray =\n        Array.isArray(events) ?\n          events :\n          events.split(/ /);\n\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n\n        if (!_handlers[event])\n          _handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        _handlers[event].push({\n          handler: handler\n        });\n      }\n    }\n  }\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(Object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {Object}            Returns conrad.\n   */\n  function _unbind(events, handler) {\n    var i,\n        i_end,\n        j,\n        j_end,\n        a,\n        event,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    if (!arguments.length)\n      _handlers = Object.create(null);\n    else if (handler) {\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n        if (_handlers[event]) {\n          a = [];\n          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)\n            if (_handlers[event][j].handler !== handler)\n              a.push(_handlers[event][j]);\n\n          _handlers[event] = a;\n        }\n\n        if (_handlers[event] && _handlers[event].length === 0)\n          delete _handlers[event];\n      }\n    } else\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)\n        delete _handlers[eArray[i]];\n  }\n\n  /**\n   * Executes each handler bound to the event.\n   *\n   * @param  {string}  events The name of the event (or the events separated\n   *                          by spaces).\n   * @param  {?Object} data   The content of the event (optional).\n   * @return {Object}         Returns conrad.\n   */\n  function _dispatch(events, data) {\n    var i,\n        j,\n        i_end,\n        j_end,\n        event,\n        eventName,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      eventName = eArray[i];\n\n      if (_handlers[eventName]) {\n        event = {\n          type: eventName,\n          data: data || {}\n        };\n\n        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)\n          try {\n            _handlers[eventName][j].handler(event);\n          } catch (e) {}\n      }\n    }\n  }\n\n  /**\n   * Executes the most prioritary job once, and deals with filling the stats\n   * (done, time, averageTime, currentTime, etc...).\n   *\n   * @return {?Object} Returns the job object if it has to be killed, null else.\n   */\n  function _executeFirstJob() {\n    var i,\n        l,\n        test,\n        kill,\n        pushed = false,\n        time = __dateNow(),\n        job = _sortedByPriorityJobs.shift();\n\n    // Execute the job and look at the result:\n    test = job.job();\n\n    // Deal with stats:\n    time = __dateNow() - time;\n    job.done++;\n    job.time += time;\n    job.currentTime += time;\n    job.weightTime = job.currentTime / (job.weight || 1);\n    job.averageTime = job.time / job.done;\n\n    // Check if the job has to be killed:\n    kill = job.count ? (job.count <= job.done) : !test;\n\n    // Reset priorities:\n    if (!kill) {\n      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)\n        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {\n          _sortedByPriorityJobs.splice(i, 0, job);\n          pushed = true;\n          break;\n        }\n\n      if (!pushed)\n        _sortedByPriorityJobs.push(job);\n    }\n\n    return kill ? job : null;\n  }\n\n  /**\n   * Activates a job, by adding it to the _runningJobs object and the\n   * _sortedByPriorityJobs array. It also initializes its currentTime value.\n   *\n   * @param  {Object} job The job to activate.\n   */\n  function _activateJob(job) {\n    var l = _sortedByPriorityJobs.length;\n\n    // Add the job to the running jobs:\n    _runningJobs[job.id] = job;\n    job.status = 'running';\n\n    // Add the job to the priorities:\n    if (l) {\n      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;\n      job.currentTime = job.weightTime * (job.weight || 1);\n    }\n\n    // Initialize the job and dispatch:\n    job.startTime = __dateNow();\n    _dispatch('jobStarted', __clone(job));\n\n    _sortedByPriorityJobs.push(job);\n  }\n\n  /**\n   * The main loop of conrad.js:\n   *  . It executes job such that they all occupate the same processing time.\n   *  . It stops jobs that do not need to be executed anymore.\n   *  . It triggers callbacks when it is relevant.\n   *  . It starts waiting jobs when they need to be started.\n   *  . It injects frames to keep a constant frapes per second ratio.\n   *  . It stops itself when there are no more jobs to execute.\n   */\n  function _loop() {\n    var k,\n        o,\n        l,\n        job,\n        time,\n        deadJob;\n\n    // Deal with the newly added jobs (the _jobs object):\n    for (k in _jobs) {\n      job = _jobs[k];\n\n      if (job.after)\n        _waitingJobs[k] = job;\n      else\n        _activateJob(job);\n\n      delete _jobs[k];\n    }\n\n    // Set the _isRunning flag to false if there are no running job:\n    _isRunning = !!_sortedByPriorityJobs.length;\n\n    // Deal with the running jobs (the _runningJobs object):\n    while (\n      _sortedByPriorityJobs.length &&\n      __dateNow() - _lastFrameTime < _parameters.frameDuration\n    ) {\n      deadJob = _executeFirstJob();\n\n      // Deal with the case where the job has ended:\n      if (deadJob) {\n        _killJob(deadJob.id);\n\n        // Check for waiting jobs:\n        for (k in _waitingJobs)\n          if (_waitingJobs[k].after === deadJob.id) {\n            _activateJob(_waitingJobs[k]);\n            delete _waitingJobs[k];\n          }\n      }\n    }\n\n    // Check if conrad still has jobs to deal with, and kill it if not:\n    if (_isRunning) {\n      // Update the _lastFrameTime:\n      _lastFrameTime = __dateNow();\n\n      _dispatch('enterFrame');\n      setTimeout(_loop, 0);\n    } else\n      _dispatch('stop');\n  }\n\n  /**\n   * Adds one or more jobs, and starts the loop if no job was running before. A\n   * job is at least a unique string \"id\" and a function, and there are some\n   * parameters that you can specify for each job to modify the way conrad will\n   * execute it. If a job is added with the \"id\" of another job that is waiting\n   * or still running, an error will be thrown.\n   *\n   * When a job is added, it is referenced in the _jobs object, by its id.\n   * Then, if it has to be executed right now, it will be also referenced in\n   * the _runningJobs object. If it has to wait, then it will be added into the\n   * _waitingJobs object, until it can start.\n   *\n   * Keep reading this documentation to see how to call this method.\n   *\n   * @return {Object} Returns conrad.\n   *\n   * Adding one job:\n   * ***************\n   * Basically, a job is defined by its string id and a function (the job). It\n   * is also possible to add some parameters:\n   *\n   *  > conrad.addJob('myJobId', myJobFunction);\n   *  > conrad.addJob('myJobId', {\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   id: 'myJobId',\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *\n   * Adding several jobs:\n   * ********************\n   * When adding several jobs at the same time, it is possible to specify\n   * parameters for each one individually or for all:\n   *\n   *  > conrad.addJob([\n   *  >   {\n   *  >     id: 'myJobId1',\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   {\n   *  >     id: 'myJobId2',\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > ], {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: {,\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   myJobId2: {,\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: myJobFunction1,\n   *  >   myJobId2: myJobFunction2\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *\n   *  Recognized parameters:\n   *  **********************\n   *  Here is the exhaustive list of every accepted parameters:\n   *\n   *    {?Function} end      A callback to execute when the job is ended. It is\n   *                         not executed if the job is killed instead of ended\n   *                         \"naturally\".\n   *    {?Integer}  count    The number of time the job has to be executed.\n   *    {?Number}   weight   If specified, the job will be executed as it was\n   *                         added \"weight\" times.\n   *    {?String}   after    The id of another job (eventually not added yet).\n   *                         If specified, this job will start only when the\n   *                         specified \"after\" job is ended.\n   */\n  function _addJob(v1, v2) {\n    var i,\n        l,\n        o;\n\n    // Array of jobs:\n    if (Array.isArray(v1)) {\n      // Keep conrad to start until the last job is added:\n      _noStart = true;\n\n      for (i = 0, l = v1.length; i < l; i++)\n        _addJob(v1[i].id, __extend(v1[i], v2));\n\n      _noStart = false;\n      if (!_isRunning) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n    } else if (typeof v1 === 'object') {\n      // One job (object):\n      if (typeof v1.id === 'string')\n        _addJob(v1.id, v1);\n\n      // Hash of jobs:\n      else {\n        // Keep conrad to start until the last job is added:\n        _noStart = true;\n\n        for (i in v1)\n          if (typeof v1[i] === 'function')\n            _addJob(i, __extend({\n              job: v1[i]\n            }, v2));\n          else\n            _addJob(i, __extend(v1[i], v2));\n\n        _noStart = false;\n        if (!_isRunning) {\n          // Update the _lastFrameTime:\n          _lastFrameTime = __dateNow();\n\n          _dispatch('start');\n          _loop();\n        }\n      }\n\n    // One job (string, *):\n    } else if (typeof v1 === 'string') {\n      if (_hasJob(v1))\n        throw new Error(\n          '[conrad.addJob] Job with id \"' + v1 + '\" already exists.'\n        );\n\n      // One job (string, function):\n      if (typeof v2 === 'function') {\n        o = {\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0,\n          job: v2\n        };\n\n      // One job (string, object):\n      } else if (typeof v2 === 'object') {\n        o = __extend(\n          {\n            id: v1,\n            done: 0,\n            time: 0,\n            status: 'waiting',\n            currentTime: 0,\n            averageTime: 0,\n            weightTime: 0\n          },\n          v2\n        );\n\n      // If none of those cases, throw an error:\n      } else\n        throw new Error('[conrad.addJob] Wrong arguments.');\n\n      // Effectively add the job:\n      _jobs[v1] = o;\n      _dispatch('jobAdded', __clone(o));\n\n      // Check if the loop has to be started:\n      if (!_isRunning && !_noStart) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.addJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills one or more jobs, indicated by their ids. It is only possible to\n   * kill running jobs or waiting jobs. If you try to kill a job that does not\n   * exist or that is already killed, a warning will be thrown.\n   *\n   * @param  {Array|String} v1 A string job id or an array of job ids.\n   * @return {Object}       Returns conrad.\n   */\n  function _killJob(v1) {\n    var i,\n        l,\n        k,\n        a,\n        job,\n        found = false;\n\n    // Array of job ids:\n    if (Array.isArray(v1))\n      for (i = 0, l = v1.length; i < l; i++)\n        _killJob(v1[i]);\n\n    // One job's id:\n    else if (typeof v1 === 'string') {\n      a = [_runningJobs, _waitingJobs, _jobs];\n\n      // Remove the job from the hashes:\n      for (i = 0, l = a.length; i < l; i++)\n        if (v1 in a[i]) {\n          job = a[i][v1];\n\n          if (_parameters.history) {\n            job.status = 'done';\n            _doneJobs.push(job);\n          }\n\n          _dispatch('jobEnded', __clone(job));\n          delete a[i][v1];\n\n          if (typeof job.end === 'function')\n            job.end();\n\n          found = true;\n        }\n\n      // Remove the priorities array:\n      a = _sortedByPriorityJobs;\n      for (i = 0, l = a.length; i < l; i++)\n        if (a[i].id === v1) {\n          a.splice(i, 1);\n          break;\n        }\n\n      if (!found)\n        throw new Error('[conrad.killJob] Job \"' + v1 + '\" not found.');\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.killJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills every running, waiting, and just added jobs.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _killAll() {\n    var k,\n        jobs = __extend(_jobs, _runningJobs, _waitingJobs);\n\n    // Take every jobs and push them into the _doneJobs object:\n    if (_parameters.history)\n      for (k in jobs) {\n        jobs[k].status = 'done';\n        _doneJobs.push(jobs[k]);\n\n        if (typeof jobs[k].end === 'function')\n          jobs[k].end();\n      }\n\n    // Reinitialize the different jobs lists:\n    _jobs = {};\n    _waitingJobs = {};\n    _runningJobs = {};\n    _sortedByPriorityJobs = [];\n\n    // In case some jobs are added right after the kill:\n    _isRunning = false;\n\n    return this;\n  }\n\n  /**\n   * Returns true if a job with the specified id is currently running or\n   * waiting, and false else.\n   *\n   * @param  {String}  id The id of the job.\n   * @return {?Object} Returns the job object if it exists.\n   */\n  function _hasJob(id) {\n    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];\n    return job ? __extend(job) : null;\n  }\n\n  /**\n   * This method will set the setting specified by \"v1\" to the value specified\n   * by \"v2\" if both are given, and else return the current value of the\n   * settings \"v1\".\n   *\n   * @param  {String}   v1 The name of the property.\n   * @param  {?*}       v2 Eventually, a value to set to the specified\n   *                       property.\n   * @return {Object|*} Returns the specified settings value if \"v2\" is not\n   *                    given, and conrad else.\n   */\n  function _settings(v1, v2) {\n    var o;\n\n    if (typeof a1 === 'string' && arguments.length === 1)\n      return _parameters[a1];\n    else {\n      o = (typeof a1 === 'object' && arguments.length === 1) ?\n        a1 || {} :\n        {};\n      if (typeof a1 === 'string')\n        o[a1] = a2;\n\n      for (var k in o)\n        if (o[k] !== undefined)\n          _parameters[k] = o[k];\n        else\n          delete _parameters[k];\n\n      return this;\n    }\n  }\n\n  /**\n   * Returns true if conrad is currently running, and false else.\n   *\n   * @return {Boolean} Returns _isRunning.\n   */\n  function _getIsRunning() {\n    return _isRunning;\n  }\n\n  /**\n   * Unreference every job that is stored in the _doneJobs object. It will\n   * not be possible anymore to get stats about these jobs, but it will release\n   * the memory.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _clearHistory() {\n    _doneJobs = [];\n    return this;\n  }\n\n  /**\n   * Returns a snapshot of every data about jobs that wait to be started, are\n   * currently running or are done.\n   *\n   * It is possible to get only running, waiting or done jobs by giving\n   * \"running\", \"waiting\" or \"done\" as fist argument.\n   *\n   * It is also possible to get every job with a specified id by giving it as\n   * first argument. Also, using a RegExp instead of an id will return every\n   * jobs whose ids match the RegExp. And these two last use cases work as well\n   * by giving before \"running\", \"waiting\" or \"done\".\n   *\n   * @return {Array} The array of the matching jobs.\n   *\n   * Some call examples:\n   * *******************\n   *  > conrad.getStats('running')\n   *  > conrad.getStats('waiting')\n   *  > conrad.getStats('done')\n   *  > conrad.getStats('myJob')\n   *  > conrad.getStats(/test/)\n   *  > conrad.getStats('running', 'myRunningJob')\n   *  > conrad.getStats('running', /test/)\n   */\n  function _getStats(v1, v2) {\n    var a,\n        k,\n        i,\n        l,\n        stats,\n        pattern,\n        isPatternString;\n\n    if (!arguments.length) {\n      stats = [];\n\n      for (k in _jobs)\n        stats.push(_jobs[k]);\n\n      for (k in _waitingJobs)\n        stats.push(_waitingJobs[k]);\n\n      for (k in _runningJobs)\n        stats.push(_runningJobs[k]);\n\n      stats = stats.concat(_doneJobs);\n    }\n\n    if (typeof v1 === 'string')\n      switch (v1) {\n        case 'waiting':\n          stats = __objectValues(_waitingJobs);\n          break;\n        case 'running':\n          stats = __objectValues(_runningJobs);\n          break;\n        case 'done':\n          stats = _doneJobs;\n          break;\n        default:\n          pattern = v1;\n      }\n\n    if (v1 instanceof RegExp)\n      pattern = v1;\n\n    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))\n      pattern = v2;\n\n    // Filter jobs if a pattern is given:\n    if (pattern) {\n      isPatternString = typeof pattern === 'string';\n\n      if (stats instanceof Array) {\n        a = stats;\n      } else if (typeof stats === 'object') {\n        a = [];\n\n        for (k in stats)\n          a = a.concat(stats[k]);\n      } else {\n        a = [];\n\n        for (k in _jobs)\n          a.push(_jobs[k]);\n\n        for (k in _waitingJobs)\n          a.push(_waitingJobs[k]);\n\n        for (k in _runningJobs)\n          a.push(_runningJobs[k]);\n\n        a = a.concat(_doneJobs);\n      }\n\n      stats = [];\n      for (i = 0, l = a.length; i < l; i++)\n        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))\n          stats.push(a[i]);\n    }\n\n    return __clone(stats);\n  }\n\n\n  /**\n   * TOOLS FUNCTIONS:\n   * ****************\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when two objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > __extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {Object+} Any number of objects.\n   * @return {Object}  The merged object.\n   */\n  function __extend() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  }\n\n  /**\n   * This function simply clones an object. This object must contain only\n   * objects, arrays and immutable values. Since it is not public, it does not\n   * deal with cyclic references, DOM elements and instantiated objects - so\n   * use it carefully.\n   *\n   * @param  {Object} The object to clone.\n   * @return {Object} The clone.\n   */\n  function __clone(item) {\n    var result, i, k, l;\n\n    if (!item)\n      return item;\n\n    if (Array.isArray(item)) {\n      result = [];\n      for (i = 0, l = item.length; i < l; i++)\n        result.push(__clone(item[i]));\n    } else if (typeof item === 'object') {\n      result = {};\n      for (i in item)\n        result[i] = __clone(item[i]);\n    } else\n      result = item;\n\n    return result;\n  }\n\n  /**\n   * Returns an array containing the values of an object.\n   *\n   * @param  {Object} The object.\n   * @return {Array}  The array of values.\n   */\n  function __objectValues(o) {\n    var k,\n        a = [];\n\n    for (k in o)\n      a.push(o[k]);\n\n    return a;\n  }\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  function __dateNow() {\n    return Date.now ? Date.now() : new Date().getTime();\n  }\n\n  /**\n   * Polyfill for the Array.isArray function:\n   */\n  if (!Array.isArray)\n    Array.isArray = function(v) {\n      return Object.prototype.toString.call(v) === '[object Array]';\n    };\n\n\n  /**\n   * EXPORT PUBLIC API:\n   * ******************\n   */\n  var conrad = {\n    hasJob: _hasJob,\n    addJob: _addJob,\n    killJob: _killJob,\n    killAll: _killAll,\n    settings: _settings,\n    getStats: _getStats,\n    isRunning: _getIsRunning,\n    clearHistory: _clearHistory,\n\n    // Events management:\n    bind: _bind,\n    unbind: _unbind,\n\n    // Version:\n    version: '0.1.0'\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = conrad;\n    exports.conrad = conrad;\n  }\n  global.conrad = conrad;\n})(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n\n  /**\n   * This middleware will just copy the graphic properties.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   */\n  sigma.middlewares.copy = function(readPrefix, writePrefix) {\n    var i,\n        l,\n        a;\n\n    if (writePrefix + '' === readPrefix + '')\n      return;\n\n    a = this.graph.nodes();\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];\n      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n\n    a = this.graph.edges();\n    for (i = 0, l = a.length; i < l; i++)\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n  sigma.utils.pkg('sigma.utils');\n\n  /**\n   * This middleware will rescale the graph such that it takes an optimal space\n   * on the renderer.\n   *\n   * As each middleware, this function is executed in the scope of the sigma\n   * instance.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   * @param {object}  options     The parameters.\n   */\n  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {\n    var i,\n        l,\n        a,\n        b,\n        c,\n        d,\n        scale,\n        margin,\n        n = this.graph.nodes(),\n        e = this.graph.edges(),\n        settings = this.settings.embedObjects(options || {}),\n        bounds = settings('bounds') || sigma.utils.getBoundaries(\n          this.graph,\n          readPrefix,\n          true\n        ),\n        minX = bounds.minX,\n        minY = bounds.minY,\n        maxX = bounds.maxX,\n        maxY = bounds.maxY,\n        sizeMax = bounds.sizeMax,\n        weightMax = bounds.weightMax,\n        w = settings('width') || 1,\n        h = settings('height') || 1,\n        rescaleSettings = settings('autoRescale'),\n        validSettings = {\n          nodePosition: 1,\n          nodeSize: 1,\n          edgeSize: 1\n        };\n\n    /**\n     * What elements should we rescale?\n     */\n    if (!(rescaleSettings instanceof Array))\n      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];\n\n    for (i = 0, l = rescaleSettings.length; i < l; i++)\n      if (!validSettings[rescaleSettings[i]])\n        throw new Error(\n          'The rescale setting \"' + rescaleSettings[i] + '\" is not recognized.'\n        );\n\n    var np = ~rescaleSettings.indexOf('nodePosition'),\n        ns = ~rescaleSettings.indexOf('nodeSize'),\n        es = ~rescaleSettings.indexOf('edgeSize');\n\n    /**\n     * First, we compute the scaling ratio, without considering the sizes\n     * of the nodes : Each node will have its center in the canvas, but might\n     * be partially out of it.\n     */\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    /**\n     * Then, we correct that scaling ratio considering a margin, which is\n     * basically the size of the biggest node.\n     * This has to be done as a correction since to compare the size of the\n     * biggest node to the X and Y values, we have to first get an\n     * approximation of the scaling ratio.\n     **/\n    margin =\n      (\n        settings('rescaleIgnoreSize') ?\n          0 :\n          (settings('maxNodeSize') || sizeMax) / scale\n      ) +\n      (settings('sideMargin') || 0);\n    maxX += margin;\n    minX -= margin;\n    maxY += margin;\n    minY -= margin;\n\n    // Fix the scaling with the new extrema:\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    // Size homothetic parameters:\n    if (!settings('maxNodeSize') && !settings('minNodeSize')) {\n      a = 1;\n      b = 0;\n    } else if (settings('maxNodeSize') === settings('minNodeSize')) {\n      a = 0;\n      b = +settings('maxNodeSize');\n    } else {\n      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;\n      b = +settings('minNodeSize');\n    }\n\n    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {\n      c = 1;\n      d = 0;\n    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {\n      c = 0;\n      d = +settings('minEdgeSize');\n    } else {\n      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;\n      d = +settings('minEdgeSize');\n    }\n\n    // Rescale the nodes and edges:\n    for (i = 0, l = e.length; i < l; i++)\n      e[i][writePrefix + 'size'] =\n        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      n[i][writePrefix + 'size'] =\n        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);\n      n[i][writePrefix + 'x'] =\n        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);\n      n[i][writePrefix + 'y'] =\n        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);\n    }\n  };\n\n  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {\n    var i,\n        l,\n        e = graph.edges(),\n        n = graph.nodes(),\n        weightMax = -Infinity,\n        sizeMax = -Infinity,\n        minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    if (doEdges)\n      for (i = 0, l = e.length; i < l; i++)\n        weightMax = Math.max(e[i][prefix + 'size'], weightMax);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);\n      maxX = Math.max(n[i][prefix + 'x'], maxX);\n      minX = Math.min(n[i][prefix + 'x'], minX);\n      maxY = Math.max(n[i][prefix + 'y'], maxY);\n      minY = Math.min(n[i][prefix + 'y'], minY);\n    }\n\n    weightMax = weightMax || 1;\n    sizeMax = sizeMax || 1;\n\n    return {\n      weightMax: weightMax,\n      sizeMax: sizeMax,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc.animation.running');\n\n  /**\n   * Generates a unique ID for the animation.\n   *\n   * @return {string} Returns the new ID.\n   */\n  var _getID = (function() {\n    var id = 0;\n    return function() {\n      return '' + (++id);\n    };\n  })();\n\n  /**\n   * This function animates a camera. It has to be called with the camera to\n   * animate, the values of the coordinates to reach and eventually some\n   * options. It returns a number id, that you can use to kill the animation,\n   * with the method sigma.misc.animation.kill(id).\n   *\n   * The available options are:\n   *\n   *   {?number}            duration   The duration of the animation.\n   *   {?function}          onNewFrame A callback to execute when the animation\n   *                                   enter a new frame.\n   *   {?function}          onComplete A callback to execute when the animation\n   *                                   is completed or killed.\n   *   {?(string|function)} easing     The name of a function from the package\n   *                                   sigma.utils.easings, or a custom easing\n   *                                   function.\n   *\n   * @param  {camera}  camera  The camera to animate.\n   * @param  {object}  target  The coordinates to reach.\n   * @param  {?object} options Eventually an object to specify some options to\n   *                           the function. The available options are\n   *                           presented in the description of the function.\n   * @return {number}          The animation id, to make it easy to kill\n   *                           through the method \"sigma.misc.animation.kill\".\n   */\n  sigma.misc.animation.camera = function(camera, val, options) {\n    if (\n      !(camera instanceof sigma.classes.camera) ||\n      typeof val !== 'object' ||\n      !val\n    )\n      throw 'animation.camera: Wrong arguments.';\n\n    if (\n      typeof val.x !== 'number' &&\n      typeof val.y !== 'number' &&\n      typeof val.ratio !== 'number' &&\n      typeof val.angle !== 'number'\n    )\n      throw 'There must be at least one valid coordinate in the given val.';\n\n    var fn,\n        id,\n        anim,\n        easing,\n        duration,\n        initialVal,\n        o = options || {},\n        start = sigma.utils.dateNow();\n\n    // Store initial values:\n    initialVal = {\n      x: camera.x,\n      y: camera.y,\n      ratio: camera.ratio,\n      angle: camera.angle\n    };\n\n    duration = o.duration;\n    easing = typeof o.easing !== 'function' ?\n      sigma.utils.easings[o.easing || 'quadraticInOut'] :\n      o.easing;\n\n    fn = function() {\n      var coef,\n          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;\n\n      // If the animation is over:\n      if (t >= 1) {\n        camera.isAnimated = false;\n        camera.goTo({\n          x: val.x !== undefined ? val.x : initialVal.x,\n          y: val.y !== undefined ? val.y : initialVal.y,\n          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,\n          angle: val.angle !== undefined ? val.angle : initialVal.angle\n        });\n\n        cancelAnimationFrame(id);\n        delete sigma.misc.animation.running[id];\n\n        // Check callbacks:\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n\n      // Else, let's keep going:\n      } else {\n        coef = easing(t);\n        camera.isAnimated = true;\n        camera.goTo({\n          x: val.x !== undefined ?\n            initialVal.x + (val.x - initialVal.x) * coef :\n            initialVal.x,\n          y: val.y !== undefined ?\n            initialVal.y + (val.y - initialVal.y) * coef :\n            initialVal.y,\n          ratio: val.ratio !== undefined ?\n            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :\n            initialVal.ratio,\n          angle: val.angle !== undefined ?\n            initialVal.angle + (val.angle - initialVal.angle) * coef :\n            initialVal.angle\n        });\n\n        // Check callbacks:\n        if (typeof o.onNewFrame === 'function')\n          o.onNewFrame();\n\n        anim.frameId = requestAnimationFrame(fn);\n      }\n    };\n\n    id = _getID();\n    anim = {\n      frameId: requestAnimationFrame(fn),\n      target: camera,\n      type: 'camera',\n      options: o,\n      fn: fn\n    };\n    sigma.misc.animation.running[id] = anim;\n\n    return id;\n  };\n\n  /**\n   * Kills a running animation. It triggers the eventual onComplete callback.\n   *\n   * @param  {number} id  The id of the animation to kill.\n   * @return {object}     Returns the sigma.misc.animation package.\n   */\n  sigma.misc.animation.kill = function(id) {\n    if (arguments.length !== 1 || typeof id !== 'number')\n      throw 'animation.kill: Wrong arguments.';\n\n    var o = sigma.misc.animation.running[id];\n\n    if (o) {\n      cancelAnimationFrame(id);\n      delete sigma.misc.animation.running[o.frameId];\n\n      if (o.type === 'camera')\n        o.target.isAnimated = false;\n\n      // Check callbacks:\n      if (typeof (o.options || {}).onComplete === 'function')\n        o.options.onComplete();\n    }\n\n    return this;\n  };\n\n  /**\n   * Kills every running animations, or only the one with the specified type,\n   * if a string parameter is given.\n   *\n   * @param  {?(string|object)} filter A string to filter the animations to kill\n   *                                   on their type (example: \"camera\"), or an\n   *                                   object to filter on their target.\n   * @return {number}                  Returns the number of animations killed\n   *                                   that way.\n   */\n  sigma.misc.animation.killAll = function(filter) {\n    var o,\n        id,\n        count = 0,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      ) {\n        o = sigma.misc.animation.running[id];\n        cancelAnimationFrame(o.frameId);\n        delete sigma.misc.animation.running[id];\n\n        if (o.type === 'camera')\n          o.target.isAnimated = false;\n\n        // Increment counter:\n        count++;\n\n        // Check callbacks:\n        if (typeof (o.options || {}).onComplete === 'function')\n          o.options.onComplete();\n      }\n\n    return count;\n  };\n\n  /**\n   * Returns \"true\" if any animation that is currently still running matches\n   * the filter given to the function.\n   *\n   * @param  {string|object} filter A string to filter the animations to kill\n   *                                on their type (example: \"camera\"), or an\n   *                                object to filter on their target.\n   * @return {boolean}              Returns true if any running animation\n   *                                matches.\n   */\n  sigma.misc.animation.has = function(filter) {\n    var id,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      )\n        return true;\n\n    return false;\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any DOM renderer (for instance svg)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindDOMEvents = function(container) {\n    var self = this,\n        graph = this.graph;\n\n    // DOMElement abstraction\n    function Element(domElement) {\n\n      // Helpers\n      this.attr = function(attrName) {\n        return domElement.getAttributeNS(null, attrName);\n      };\n\n      // Properties\n      this.tag = domElement.tagName;\n      this.class = this.attr('class');\n      this.id = this.attr('id');\n\n      // Methods\n      this.isNode = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');\n      };\n\n      this.isEdge = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');\n      };\n\n      this.isHover = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');\n      };\n    }\n\n    // Click\n    function click(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('click', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('clickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('clickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // Double click\n    function doubleClick(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('doubleClick', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('doubleClickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('doubleClickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // On over\n    function onOver(e) {\n      var target = e.toElement || e.target;\n\n      if (!self.settings('eventsEnabled') || !target)\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('overNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('overEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // On out\n    function onOut(e) {\n      var target = e.fromElement || e.originalTarget;\n\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('outNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('outEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // Registering Events:\n\n    // Click\n    container.addEventListener('click', click, false);\n    sigma.utils.doubleClick(container, 'click', doubleClick);\n\n    // Touch counterparts\n    container.addEventListener('touchstart', click, false);\n    sigma.utils.doubleClick(container, 'touchstart', doubleClick);\n\n    // Mouseover\n    container.addEventListener('mouseover', onOver, true);\n\n    // Mouseout\n    container.addEventListener('mouseout', onOut, true);\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindEvents = function(prefix) {\n    var i,\n        l,\n        mX,\n        mY,\n        captor,\n        self = this;\n\n    function getNodes(e) {\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          n,\n          x,\n          y,\n          s,\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          nodes = self.camera.quadtree.point(\n            point.x,\n            point.y\n          );\n\n      if (nodes.length)\n        for (i = 0, l = nodes.length; i < l; i++) {\n          n = nodes[i];\n          x = n[prefix + 'x'];\n          y = n[prefix + 'y'];\n          s = n[prefix + 'size'];\n\n          if (\n            !n.hidden &&\n            modifiedX > x - s &&\n            modifiedX < x + s &&\n            modifiedY > y - s &&\n            modifiedY < y + s &&\n            Math.sqrt(\n              Math.pow(modifiedX - x, 2) +\n              Math.pow(modifiedY - y, 2)\n            ) < s\n          ) {\n            // Insert the node:\n            inserted = false;\n\n            for (j = 0; j < selected.length; j++)\n              if (n.size > selected[j].size) {\n                selected.splice(j, 0, n);\n                inserted = true;\n                break;\n              }\n\n            if (!inserted)\n              selected.push(n);\n          }\n        }\n\n      return selected;\n    }\n\n\n    function getEdges(e) {\n      if (!self.settings('enableEdgeHovering')) {\n        // No event if the setting is off:\n        return [];\n      }\n\n      var isCanvas = (\n        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);\n\n      if (!isCanvas) {\n        // A quick hardcoded rule to prevent people from using this feature\n        // with the WebGL renderer (which is not good enough at the moment):\n        throw new Error(\n          'The edge events feature is not compatible with the WebGL renderer'\n        );\n      }\n\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          a,\n          edge,\n          s,\n          maxEpsilon = self.settings('edgeHoverPrecision'),\n          source,\n          target,\n          cp,\n          nodeIndex = {},\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          edges = [];\n\n      if (isCanvas) {\n        var nodesOnScreen = self.camera.quadtree.area(\n          self.camera.getRectangle(self.width, self.height)\n        );\n        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)\n          nodeIndex[a[i].id] = a[i];\n      }\n\n      if (self.camera.edgequadtree !== undefined) {\n        edges = self.camera.edgequadtree.point(\n          point.x,\n          point.y\n        );\n      }\n\n      function insertEdge(selected, edge) {\n        inserted = false;\n\n        for (j = 0; j < selected.length; j++)\n          if (edge.size > selected[j].size) {\n            selected.splice(j, 0, edge);\n            inserted = true;\n            break;\n          }\n\n        if (!inserted)\n          selected.push(edge);\n      }\n\n      if (edges.length)\n        for (i = 0, l = edges.length; i < l; i++) {\n          edge = edges[i];\n          source = self.graph.nodes(edge.source);\n          target = self.graph.nodes(edge.target);\n          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:\n          s = edge[prefix + 'size'] ||\n              edge['read_' + prefix + 'size'];\n\n          // First, let's identify which edges are drawn. To do this, we keep\n          // every edges that have at least one extremity displayed according to\n          // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n          // edges.\n          // Then, let's check if the mouse is on the edge (we suppose that it\n          // is a line segment).\n\n          if (\n            !edge.hidden &&\n            !source.hidden && !target.hidden &&\n            (!isCanvas ||\n              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&\n            sigma.utils.getDistance(\n              source[prefix + 'x'],\n              source[prefix + 'y'],\n              modifiedX,\n              modifiedY) > source[prefix + 'size'] &&\n            sigma.utils.getDistance(\n              target[prefix + 'x'],\n              target[prefix + 'y'],\n              modifiedX,\n              modifiedY) > target[prefix + 'size']\n          ) {\n            if (edge.type == 'curve' || edge.type == 'curvedArrow') {\n              if (source.id === target.id) {\n                cp = sigma.utils.getSelfLoopControlPoints(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  source[prefix + 'size']\n                );\n                if (\n                  sigma.utils.isPointOnBezierCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x1,\n                  cp.y1,\n                  cp.x2,\n                  cp.y2,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n              else {\n                cp = sigma.utils.getQuadraticControlPoint(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y']);\n                if (\n                  sigma.utils.isPointOnQuadraticCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x,\n                  cp.y,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n            } else if (\n                sigma.utils.isPointOnSegment(\n                modifiedX,\n                modifiedY,\n                source[prefix + 'x'],\n                source[prefix + 'y'],\n                target[prefix + 'x'],\n                target[prefix + 'y'],\n                Math.max(s, maxEpsilon)\n              )) {\n              insertEdge(selected, edge);\n            }\n          }\n        }\n\n      return selected;\n    }\n\n\n    function bindCaptor(captor) {\n      var nodes,\n          edges,\n          overNodes = {},\n          overEdges = {};\n\n      function onClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('click', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('clickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('clickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('clickStage', {captor: e.data});\n      }\n\n      function onDoubleClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('doubleClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('doubleClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('doubleClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('doubleClickStage', {captor: e.data});\n      }\n\n      function onRightClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('rightClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('rightClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('rightClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('rightClickStage', {captor: e.data});\n      }\n\n      function onOut(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        var k,\n            i,\n            l,\n            le,\n            outNodes = [],\n            outEdges = [];\n\n        for (k in overNodes)\n          outNodes.push(overNodes[k]);\n\n        overNodes = {};\n        // Dispatch both single and multi events:\n        for (i = 0, l = outNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: outNodes[i],\n            captor: e.data\n          });\n        if (outNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: outNodes,\n            captor: e.data\n          });\n\n        overEdges = {};\n        // Dispatch both single and multi events:\n        for (i = 0, le = outEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: outEdges[i],\n            captor: e.data\n          });\n        if (outEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: outEdges,\n            captor: e.data\n          });\n      }\n\n      function onMove(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        var i,\n            k,\n            node,\n            edge,\n            newOutNodes = [],\n            newOverNodes = [],\n            currentOverNodes = {},\n            l = nodes.length,\n            newOutEdges = [],\n            newOverEdges = [],\n            currentOverEdges = {},\n            le = edges.length;\n\n        // Check newly overred nodes:\n        for (i = 0; i < l; i++) {\n          node = nodes[i];\n          currentOverNodes[node.id] = node;\n          if (!overNodes[node.id]) {\n            newOverNodes.push(node);\n            overNodes[node.id] = node;\n          }\n        }\n\n        // Check no more overred nodes:\n        for (k in overNodes)\n          if (!currentOverNodes[k]) {\n            newOutNodes.push(overNodes[k]);\n            delete overNodes[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, l = newOverNodes.length; i < l; i++)\n          self.dispatchEvent('overNode', {\n            node: newOverNodes[i],\n            captor: e.data\n          });\n        for (i = 0, l = newOutNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: newOutNodes[i],\n            captor: e.data\n          });\n        if (newOverNodes.length)\n          self.dispatchEvent('overNodes', {\n            nodes: newOverNodes,\n            captor: e.data\n          });\n        if (newOutNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: newOutNodes,\n            captor: e.data\n          });\n\n        // Check newly overred edges:\n        for (i = 0; i < le; i++) {\n          edge = edges[i];\n          currentOverEdges[edge.id] = edge;\n          if (!overEdges[edge.id]) {\n            newOverEdges.push(edge);\n            overEdges[edge.id] = edge;\n          }\n        }\n\n        // Check no more overred edges:\n        for (k in overEdges)\n          if (!currentOverEdges[k]) {\n            newOutEdges.push(overEdges[k]);\n            delete overEdges[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, le = newOverEdges.length; i < le; i++)\n          self.dispatchEvent('overEdge', {\n            edge: newOverEdges[i],\n            captor: e.data\n          });\n        for (i = 0, le = newOutEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: newOutEdges[i],\n            captor: e.data\n          });\n        if (newOverEdges.length)\n          self.dispatchEvent('overEdges', {\n            edges: newOverEdges,\n            captor: e.data\n          });\n        if (newOutEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: newOutEdges,\n            captor: e.data\n          });\n      }\n\n      // Bind events:\n      captor.bind('click', onClick);\n      captor.bind('mousedown', onMove);\n      captor.bind('mouseup', onMove);\n      captor.bind('mousemove', onMove);\n      captor.bind('mouseout', onOut);\n      captor.bind('doubleclick', onDoubleClick);\n      captor.bind('rightclick', onRightClick);\n      self.bind('render', onMove);\n    }\n\n    for (i = 0, l = this.captors.length; i < l; i++)\n      bindCaptor(this.captors[i]);\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This method listens to \"overNode\", \"outNode\", \"overEdge\" and \"outEdge\"\n   * events from a renderer and renders the nodes differently on the top layer.\n   * The goal is to make any node label readable with the mouse, and to\n   * highlight hovered nodes and edges.\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.drawHovers = function(prefix) {\n    var self = this,\n        hoveredNodes = {},\n        hoveredEdges = {};\n\n    this.bind('overNode', function(event) {\n      var node = event.data.node;\n      if (!node.hidden) {\n        hoveredNodes[node.id] = node;\n        draw();\n      }\n    });\n\n    this.bind('outNode', function(event) {\n      delete hoveredNodes[event.data.node.id];\n      draw();\n    });\n\n    this.bind('overEdge', function(event) {\n      var edge = event.data.edge;\n      if (!edge.hidden) {\n        hoveredEdges[edge.id] = edge;\n        draw();\n      }\n    });\n\n    this.bind('outEdge', function(event) {\n      delete hoveredEdges[event.data.edge.id];\n      draw();\n    });\n\n    this.bind('render', function(event) {\n      draw();\n    });\n\n    function draw() {\n\n      var k,\n          source,\n          target,\n          hoveredNode,\n          hoveredEdge,\n          c = self.contexts.hover.canvas,\n          defaultNodeType = self.settings('defaultNodeType'),\n          defaultEdgeType = self.settings('defaultEdgeType'),\n          nodeRenderers = sigma.canvas.hovers,\n          edgeRenderers = sigma.canvas.edgehovers,\n          extremitiesRenderers = sigma.canvas.extremities,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Clear self.contexts.hover:\n      self.contexts.hover.clearRect(0, 0, c.width, c.height);\n\n      // Node render: single hover\n      if (\n        embedSettings('enableHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredNodes).length\n      ) {\n        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];\n        (\n          nodeRenderers[hoveredNode.type] ||\n          nodeRenderers[defaultNodeType] ||\n          nodeRenderers.def\n        )(\n          hoveredNode,\n          self.contexts.hover,\n          embedSettings\n        );\n      }\n\n      // Node render: multiple hover\n      if (\n        embedSettings('enableHovering') &&\n        !embedSettings('singleHover')\n      )\n        for (k in hoveredNodes)\n          (\n            nodeRenderers[hoveredNodes[k].type] ||\n            nodeRenderers[defaultNodeType] ||\n            nodeRenderers.def\n          )(\n            hoveredNodes[k],\n            self.contexts.hover,\n            embedSettings\n          );\n\n      // Edge render: single hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredEdges).length\n      ) {\n        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];\n        source = self.graph.nodes(hoveredEdge.source);\n        target = self.graph.nodes(hoveredEdge.target);\n\n        if (! hoveredEdge.hidden) {\n          (\n            edgeRenderers[hoveredEdge.type] ||\n            edgeRenderers[defaultEdgeType] ||\n            edgeRenderers.def\n          ) (\n            hoveredEdge,\n            source,\n            target,\n            self.contexts.hover,\n            embedSettings\n          );\n\n          if (embedSettings('edgeHoverExtremities')) {\n            (\n              extremitiesRenderers[hoveredEdge.type] ||\n              extremitiesRenderers.def\n            )(\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n          } else {\n            // Avoid edges rendered over nodes:\n            (\n              sigma.canvas.nodes[source.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              source,\n              self.contexts.hover,\n              embedSettings\n            );\n            (\n              sigma.canvas.nodes[target.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n          }\n        }\n      }\n\n      // Edge render: multiple hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        !embedSettings('singleHover')\n      ) {\n        for (k in hoveredEdges) {\n          hoveredEdge = hoveredEdges[k];\n          source = self.graph.nodes(hoveredEdge.source);\n          target = self.graph.nodes(hoveredEdge.target);\n\n          if (!hoveredEdge.hidden) {\n            (\n              edgeRenderers[hoveredEdge.type] ||\n              edgeRenderers[defaultEdgeType] ||\n              edgeRenderers.def\n            ) (\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n            if (embedSettings('edgeHoverExtremities')) {\n              (\n                extremitiesRenderers[hoveredEdge.type] ||\n                extremitiesRenderers.def\n              )(\n                hoveredEdge,\n                source,\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            } else {\n              // Avoid edges rendered over nodes:\n              (\n                sigma.canvas.nodes[source.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                source,\n                self.contexts.hover,\n                embedSettings\n              );\n              (\n                sigma.canvas.nodes[target.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            }\n          }\n        }\n      }\n    }\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.arrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    size = (edge.hover) ?\n      settings('edgeHoverSizeRatio') * size : size;\n    var aSize = size * 2.5,\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curve =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        d,\n        aSize,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aSize = size * 2.5;\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aSize = size * 2.5;\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.def =\n    function(edge, source, target, context, settings) {\n      var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curve = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves with arrow heading.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * The default edge renderer. It renders the edge as a simple line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.def = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.extremities');\n\n  /**\n   * The default renderer for hovered edge extremities. It renders the edge\n   * extremities as hovered.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.extremities.def =\n    function(edge, source, target, context, settings) {\n    // Source Node:\n    (\n      sigma.canvas.hovers[source.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      source, context, settings\n    );\n\n    // Target Node:\n    (\n      sigma.canvas.hovers[target.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      target, context, settings\n    );\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.hovers');\n\n  /**\n   * This hover renderer will basically display the label with a background.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.hovers.def = function(node, context, settings) {\n    var x,\n        y,\n        w,\n        h,\n        e,\n        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'],\n        fontSize = (settings('labelSize') === 'fixed') ?\n          settings('defaultLabelSize') :\n          settings('labelSizeRatio') * size;\n\n    // Label background:\n    context.font = (fontStyle ? fontStyle + ' ' : '') +\n      fontSize + 'px ' + (settings('hoverFont') || settings('font'));\n\n    context.beginPath();\n    context.fillStyle = settings('labelHoverBGColor') === 'node' ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultHoverLabelBGColor');\n\n    if (node.label && settings('labelHoverShadow')) {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 8;\n      context.shadowColor = settings('labelHoverShadowColor');\n    }\n\n    if (node.label && typeof node.label === 'string') {\n      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n      w = Math.round(\n        context.measureText(node.label).width + fontSize / 2 + size + 7\n      );\n      h = Math.round(fontSize + 4);\n      e = Math.round(fontSize / 2 + 2);\n\n      context.moveTo(x, y + e);\n      context.arcTo(x, y, x + e, y, e);\n      context.lineTo(x + w, y);\n      context.lineTo(x + w, y + h);\n      context.lineTo(x + e, y + h);\n      context.arcTo(x, y + h, x, y + h - e, e);\n      context.lineTo(x, y + e);\n\n      context.closePath();\n      context.fill();\n\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 0;\n    }\n\n    // Node border:\n    if (settings('borderSize') > 0) {\n      context.beginPath();\n      context.fillStyle = settings('nodeBorderColor') === 'node' ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultNodeBorderColor');\n      context.arc(\n        node[prefix + 'x'],\n        node[prefix + 'y'],\n        size + settings('borderSize'),\n        0,\n        Math.PI * 2,\n        true\n      );\n      context.closePath();\n      context.fill();\n    }\n\n    // Node:\n    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;\n    nodeRenderer(node, context, settings);\n\n    // Display the label:\n    if (node.label && typeof node.label === 'string') {\n      context.fillStyle = (settings('labelHoverColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelHoverColor');\n\n      context.fillText(\n        node.label,\n        Math.round(node[prefix + 'x'] + size + 3),\n        Math.round(node[prefix + 'y'] + fontSize / 3)\n      );\n    }\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.labels');\n\n  /**\n   * This label renderer will just display the label on the right of the node.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.labels.def = function(node, context, settings) {\n    var fontSize,\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'];\n\n    if (size < settings('labelThreshold'))\n      return;\n\n    if (!node.label || typeof node.label !== 'string')\n      return;\n\n    fontSize = (settings('labelSize') === 'fixed') ?\n      settings('defaultLabelSize') :\n      settings('labelSizeRatio') * size;\n\n    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +\n      fontSize + 'px ' + settings('font');\n    context.fillStyle = (settings('labelColor') === 'node') ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultLabelColor');\n\n    context.fillText(\n      node.label,\n      Math.round(node[prefix + 'x'] + size + 3),\n      Math.round(node[prefix + 'y'] + fontSize / 3)\n    );\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.nodes.def = function(node, context, settings) {\n    var prefix = settings('prefix') || '';\n\n    context.fillStyle = node.color || settings('defaultNodeColor');\n    context.beginPath();\n    context.arc(\n      node[prefix + 'x'],\n      node[prefix + 'y'],\n      node[prefix + 'size'],\n      0,\n      Math.PI * 2,\n      true\n    );\n\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.canvas = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.canvas: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Node indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + this.conradId + ':';\n\n    // Initialize the DOM elements:\n    if (\n      !this.settings('batchEdgesDrawing')\n    ) {\n      this.initDOM('canvas', 'scene');\n      this.contexts.edges = this.contexts.scene;\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    } else {\n      this.initDOM('canvas', 'edges');\n      this.initDOM('canvas', 'scene');\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.options.prefix);\n    sigma.misc.drawHovers.call(this, this.options.prefix);\n\n    this.resize(false);\n  };\n\n\n\n\n  /**\n   * This method renders the graph on the canvases.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.canvas}         Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        l,\n        o,\n        id,\n        end,\n        job,\n        start,\n        edges,\n        renderers,\n        rendererType,\n        batchSize,\n        tempGCO,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix\n        });\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Clear canvases:\n    this.clear();\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    // Find which nodes are on screen:\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Draw edges:\n    // - If settings('batchEdgesDrawing') is true, the edges are displayed per\n    //   batches. If not, they are drawn in one frame.\n    if (drawEdges) {\n      // First, let's identify which edges to draw. To do this, we just keep\n      // every edges that have at least one extremity displayed according to\n      // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n      // edges.\n      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n        o = a[i];\n        if (\n          (index[o.source] || index[o.target]) &&\n          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n        )\n          this.edgesOnScreen.push(o);\n      }\n\n      // If the \"batchEdgesDrawing\" settings is true, edges are batched:\n      if (this.settings(options, 'batchEdgesDrawing')) {\n        id = 'edges_' + this.conradId;\n        batchSize = embedSettings('canvasEdgesBatchSize');\n\n        edges = this.edgesOnScreen;\n        l = edges.length;\n\n        start = 0;\n        end = Math.min(edges.length, start + batchSize);\n\n        job = function() {\n          tempGCO = this.contexts.edges.globalCompositeOperation;\n          this.contexts.edges.globalCompositeOperation = 'destination-over';\n\n          renderers = sigma.canvas.edges;\n          for (i = start; i < end; i++) {\n            o = edges[i];\n            (renderers[\n              o.type || this.settings(options, 'defaultEdgeType')\n            ] || renderers.def)(\n              o,\n              graph.nodes(o.source),\n              graph.nodes(o.target),\n              this.contexts.edges,\n              embedSettings\n            );\n          }\n\n          // Draw edge labels:\n          if (drawEdgeLabels) {\n            renderers = sigma.canvas.edges.labels;\n            for (i = start; i < end; i++) {\n              o = edges[i];\n              if (!o.hidden)\n                (renderers[\n                  o.type || this.settings(options, 'defaultEdgeType')\n                ] || renderers.def)(\n                  o,\n                  graph.nodes(o.source),\n                  graph.nodes(o.target),\n                  this.contexts.labels,\n                  embedSettings\n                );\n            }\n          }\n\n          // Restore original globalCompositeOperation:\n          this.contexts.edges.globalCompositeOperation = tempGCO;\n\n          // Catch job's end:\n          if (end === edges.length) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          start = end + 1;\n          end = Math.min(edges.length, start + batchSize);\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this));\n\n      // If not, they are drawn in one frame:\n      } else {\n        renderers = sigma.canvas.edges;\n        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n          o = a[i];\n          (renderers[\n            o.type || this.settings(options, 'defaultEdgeType')\n          ] || renderers.def)(\n            o,\n            graph.nodes(o.source),\n            graph.nodes(o.target),\n            this.contexts.edges,\n            embedSettings\n          );\n        }\n\n        // Draw edge labels:\n        // - No batching\n        if (drawEdgeLabels) {\n          renderers = sigma.canvas.edges.labels;\n          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)\n            if (!a[i].hidden)\n              (renderers[\n                a[i].type || this.settings(options, 'defaultEdgeType')\n              ] || renderers.def)(\n                a[i],\n                graph.nodes(a[i].source),\n                graph.nodes(a[i].target),\n                this.contexts.labels,\n                embedSettings\n              );\n        }\n      }\n    }\n\n    // Draw nodes:\n    // - No batching\n    if (drawNodes) {\n      renderers = sigma.canvas.nodes;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.nodes,\n            embedSettings\n          );\n    }\n\n    // Draw labels:\n    // - No batching\n    if (drawLabels) {\n      renderers = sigma.canvas.labels;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.labels,\n            embedSettings\n          );\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {\n    var dom = document.createElement(tag);\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas')\n      this.contexts[id] = dom.getContext('2d');\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.canvas}        Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n          if (pixelRatio !== 1)\n            this.contexts[k].scale(pixelRatio, pixelRatio);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.canvas} Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.clear = function() {\n    for (var k in this.contexts) {\n      this.contexts[k].clearRect(0, 0, this.width, this.height);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.canvas.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./canvas\" folder.\n   */\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.canvas.edges');\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n"},function(A,e){A.exports=";(function(global) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  // Check if WebGL is enabled:\n  var canvas,\n      webgl = !!global.WebGLRenderingContext;\n  if (webgl) {\n    canvas = document.createElement('canvas');\n    try {\n      webgl = !!(\n        canvas.getContext('webgl') ||\n        canvas.getContext('experimental-webgl')\n      );\n    } catch (e) {\n      webgl = false;\n    }\n  }\n\n  // Copy the good renderer:\n  sigma.renderers.def = webgl ?\n    sigma.renderers.webgl :\n    sigma.renderers.canvas;\n})(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the svg sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.svg}             The renderer instance.\n   */\n  sigma.renderers.svg = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.svg: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.domElements = {\n      graph: null,\n      groups: {},\n      nodes: {},\n      edges: {},\n      labels: {},\n      hovers: {}\n    };\n    this.measurementCanvas = null;\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Is the renderer meant to be freestyle?\n    this.settings('freeStyle', !!this.options.freeStyle);\n\n    // SVG xmlns\n    this.settings('xmlns', 'http://www.w3.org/2000/svg');\n\n    // Indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + sigma.utils.id() + ':';\n\n    // Initialize the DOM elements\n    this.initDOM('svg');\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.graph,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Bind resize:\n    window.addEventListener('resize', function() {\n      self.resize();\n    });\n\n    // Deal with sigma events:\n    // TODO: keep an option to override the DOM events?\n    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);\n    this.bindHovers(this.options.prefix);\n\n    // Resize\n    this.resize(false);\n  };\n\n  /**\n   * This method renders the graph on the svg scene.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.svg}            Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        e,\n        l,\n        o,\n        source,\n        target,\n        start,\n        edges,\n        renderers,\n        subrenderers,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix,\n          forceLabels: this.options.forceLabels\n        });\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Hiding everything\n    // TODO: find a more sensible way to perform this operation\n    this.hideDOMElements(this.domElements.nodes);\n    this.hideDOMElements(this.domElements.edges);\n    this.hideDOMElements(this.domElements.labels);\n\n    // Find which nodes are on screen\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    // Node index\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Find which edges are on screen\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      o = a[i];\n      if (\n        (index[o.source] || index[o.target]) &&\n        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n      )\n        this.edgesOnScreen.push(o);\n    }\n\n    // Display nodes\n    //---------------\n    renderers = sigma.svg.nodes;\n    subrenderers = sigma.svg.labels;\n\n    //-- First we create the nodes which are not already created\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {\n\n          // Node\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.nodes[a[i].id] = e;\n          this.domElements.groups.nodes.appendChild(e);\n\n          // Label\n          e = (subrenderers[a[i].type] || subrenderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.labels[a[i].id] = e;\n          this.domElements.groups.labels.appendChild(e);\n        }\n      }\n\n    //-- Second we update the nodes\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n\n        if (a[i].hidden)\n          continue;\n\n        // Node\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.nodes[a[i].id],\n          embedSettings\n        );\n\n        // Label\n        (subrenderers[a[i].type] || subrenderers.def).update(\n          a[i],\n          this.domElements.labels[a[i].id],\n          embedSettings\n        );\n      }\n\n    // Display edges\n    //---------------\n    renderers = sigma.svg.edges;\n\n    //-- First we create the edges which are not already created\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!this.domElements.edges[a[i].id]) {\n          source = nodes(a[i].source);\n          target = nodes(a[i].target);\n\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            source,\n            target,\n            embedSettings\n          );\n\n          this.domElements.edges[a[i].id] = e;\n          this.domElements.groups.edges.appendChild(e);\n        }\n       }\n\n    //-- Second we update the edges\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        source = nodes(a[i].source);\n        target = nodes(a[i].target);\n\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.edges[a[i].id],\n          source,\n          target,\n          embedSettings\n        );\n       }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.svg.prototype.initDOM = function(tag) {\n    var dom = document.createElementNS(this.settings('xmlns'), tag),\n        c = this.settings('classPrefix'),\n        g,\n        l,\n        i;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', c + '-svg');\n\n    // Setting SVG namespace\n    dom.setAttribute('xmlns', this.settings('xmlns'));\n    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    dom.setAttribute('version', '1.1');\n\n    // Creating the measurement canvas\n    var canvas = document.createElement('canvas');\n    canvas.setAttribute('class', c + '-measurement-canvas');\n\n    // Appending elements\n    this.domElements.graph = this.container.appendChild(dom);\n\n    // Creating groups\n    var groups = ['edges', 'nodes', 'labels', 'hovers'];\n    for (i = 0, l = groups.length; i < l; i++) {\n      g = document.createElementNS(this.settings('xmlns'), 'g');\n\n      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);\n      g.setAttributeNS(null, 'class', c + '-group');\n\n      this.domElements.groups[groups[i]] =\n        this.domElements.graph.appendChild(g);\n    }\n\n    // Appending measurement canvas\n    this.container.appendChild(canvas);\n    this.measurementCanvas = canvas.getContext('2d');\n  };\n\n  /**\n   * This method hides a batch of SVG DOM elements.\n   *\n   * @param  {array}                  elements  An array of elements to hide.\n   * @param  {object}                 renderer  The renderer to use.\n   * @return {sigma.renderers.svg}              Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {\n    var o,\n        i;\n\n    for (i in elements) {\n      o = elements[i];\n      sigma.svg.utils.hide(o);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method binds the hover events to the renderer.\n   *\n   * @param  {string} prefix The renderer prefix.\n   */\n  // TODO: add option about whether to display hovers or not\n  sigma.renderers.svg.prototype.bindHovers = function(prefix) {\n    var renderers = sigma.svg.hovers,\n        self = this,\n        hoveredNode;\n\n    function overNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      var hover = (renderers[node.type] || renderers.def).create(\n        node,\n        self.domElements.nodes[node.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[node.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n      hoveredNode = node;\n    }\n\n    function outNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      // Deleting element\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[node.id]\n      );\n      hoveredNode = null;\n      delete self.domElements.hovers[node.id];\n\n      // Reinstate\n      self.domElements.groups.nodes.appendChild(\n        self.domElements.nodes[node.id]\n      );\n    }\n\n    // OPTIMIZE: perform a real update rather than a deletion\n    function update() {\n      if (!hoveredNode)\n        return;\n\n      var embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Deleting element before update\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[hoveredNode.id]\n      );\n      delete self.domElements.hovers[hoveredNode.id];\n\n      var hover = (renderers[hoveredNode.type] || renderers.def).create(\n        hoveredNode,\n        self.domElements.nodes[hoveredNode.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[hoveredNode.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n    }\n\n    // Binding events\n    this.bind('overNode', overNode);\n    this.bind('outNode', outNode);\n\n    // Update on render\n    this.bind('render', update);\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.svg}           Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.resize = function(w, h) {\n    var oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = 1;\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      this.domElements.graph.style.width = w + 'px';\n      this.domElements.graph.style.height = h + 'px';\n\n      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {\n        this.domElements.graph.setAttribute('width', (w * pixelRatio));\n        this.domElements.graph.setAttribute('height', (h * pixelRatio));\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./svg\" folder.\n   */\n  sigma.utils.pkg('sigma.svg.nodes');\n  sigma.utils.pkg('sigma.svg.edges');\n  sigma.utils.pkg('sigma.svg.labels');\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.webgl = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.webgl: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        _self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Find the prefix:\n    this.options.prefix = this.camera.readPrefix;\n\n    // Initialize programs hash\n    Object.defineProperty(this, 'nodePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'nodeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeIndicesArrays', {\n      value: {}\n    });\n\n    // Initialize the DOM elements:\n    if (this.settings(options, 'batchEdgesDrawing')) {\n      this.initDOM('canvas', 'edges', true);\n      this.initDOM('canvas', 'nodes', true);\n    } else {\n      this.initDOM('canvas', 'scene', true);\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.edges = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'labels');\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.camera.prefix);\n    sigma.misc.drawHovers.call(this, this.camera.prefix);\n\n    this.resize();\n  };\n\n\n\n\n  /**\n   * This method will generate the nodes and edges float arrays. This step is\n   * separated from the \"render\" method, because to keep WebGL efficient, since\n   * all the camera and middlewares are modelised as matrices and they do not\n   * require the float arrays to be regenerated.\n   *\n   * Basically, when the user moves the camera or applies some specific linear\n   * transformations, this process step will be skipped, and the \"render\"\n   * method will efficiently refresh the rendering.\n   *\n   * And when the user modifies the graph colors or positions (applying a new\n   * layout or filtering the colors, for instance), this \"process\" step will be\n   * required to regenerate the float arrays.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.process = function() {\n    var a,\n        i,\n        l,\n        k,\n        type,\n        renderer,\n        graph = this.graph,\n        options = sigma.utils.extend(options, this.options),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        defaultNodeType = this.settings(options, 'defaultNodeType');\n\n    // Empty float arrays:\n    for (k in this.nodeFloatArrays)\n      delete this.nodeFloatArrays[k];\n\n    for (k in this.edgeFloatArrays)\n      delete this.edgeFloatArrays[k];\n\n    for (k in this.edgeIndicesArrays)\n      delete this.edgeIndicesArrays[k];\n\n    // Sort edges and nodes per types:\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultEdgeType;\n      k = (type && sigma.webgl.edges[type]) ? type : 'def';\n\n      if (!this.edgeFloatArrays[k])\n        this.edgeFloatArrays[k] = {\n          edges: []\n        };\n\n      this.edgeFloatArrays[k].edges.push(a[i]);\n    }\n\n    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultNodeType;\n      k = (type && sigma.webgl.nodes[type]) ? type : 'def';\n\n      if (!this.nodeFloatArrays[k])\n        this.nodeFloatArrays[k] = {\n          nodes: []\n        };\n\n      this.nodeFloatArrays[k].nodes.push(a[i]);\n    }\n\n    // Push edges:\n    for (k in this.edgeFloatArrays) {\n      renderer = sigma.webgl.edges[k];\n      a = this.edgeFloatArrays[k].edges;\n\n      // Creating the necessary arrays\n      this.edgeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden &&\n          !graph.nodes(a[i].source).hidden &&\n          !graph.nodes(a[i].target).hidden\n        )\n          renderer.addEdge(\n            a[i],\n            graph.nodes(a[i].source),\n            graph.nodes(a[i].target),\n            this.edgeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n\n      if (typeof renderer.computeIndices === 'function')\n        this.edgeIndicesArrays[k] = renderer.computeIndices(\n          this.edgeFloatArrays[k].array\n        );\n    }\n\n    // Push nodes:\n    for (k in this.nodeFloatArrays) {\n      renderer = sigma.webgl.nodes[k];\n      a = this.nodeFloatArrays[k].nodes;\n\n      // Creating the necessary arrays\n      this.nodeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!this.nodeFloatArrays[k].array)\n          this.nodeFloatArrays[k].array = new Float32Array(\n            a.length * renderer.POINTS * renderer.ATTRIBUTES\n          );\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden\n        )\n          renderer.addNode(\n            a[i],\n            this.nodeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n    }\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method renders the graph. It basically calls each program (and\n   * generate them if they do not exist yet) to render nodes and edges, batched\n   * per renderer.\n   *\n   * As in the canvas renderer, it is possible to display edges, nodes and / or\n   * labels in batches, to make the whole thing way more scalable.\n   *\n   * @param  {?object}               params Eventually an object of options.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.render = function(params) {\n    var a,\n        i,\n        l,\n        k,\n        o,\n        program,\n        renderer,\n        self = this,\n        graph = this.graph,\n        nodesGl = this.contexts.nodes,\n        edgesGl = this.contexts.edges,\n        matrix = this.camera.getMatrix(),\n        options = sigma.utils.extend(params, this.options),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes');\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Clear canvases:\n    this.clear();\n\n    // Translate matrix to [width/2, height/2]:\n    matrix = sigma.utils.matrices.multiply(\n      matrix,\n      sigma.utils.matrices.translation(this.width / 2, this.height / 2)\n    );\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    if (drawEdges) {\n      if (this.settings(options, 'batchEdgesDrawing'))\n        (function() {\n          var a,\n              k,\n              i,\n              id,\n              job,\n              arr,\n              end,\n              start,\n              indices,\n              renderer,\n              batchSize,\n              currentProgram;\n\n          id = 'edges_' + this.conradId;\n          batchSize = this.settings(options, 'webglEdgesBatchSize');\n          a = Object.keys(this.edgeFloatArrays);\n\n          if (!a.length)\n            return;\n          i = 0;\n          renderer = sigma.webgl.edges[a[i]];\n          arr = this.edgeFloatArrays[a[i]].array;\n          indices = this.edgeIndicesArrays[a[i]];\n          start = 0;\n          end = Math.min(\n            start + batchSize * renderer.POINTS,\n            arr.length / renderer.ATTRIBUTES\n          );\n\n          job = function() {\n            // Check program:\n            if (!this.edgePrograms[a[i]])\n              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);\n\n            if (start < end) {\n              edgesGl.useProgram(this.edgePrograms[a[i]]);\n              renderer.render(\n                edgesGl,\n                this.edgePrograms[a[i]],\n                arr,\n                {\n                  settings: this.settings,\n                  matrix: matrix,\n                  width: this.width,\n                  height: this.height,\n                  ratio: this.camera.ratio,\n                  scalingRatio: this.settings(\n                    options,\n                    'webglOversamplingRatio'\n                  ),\n                  start: start,\n                  count: end - start,\n                  indicesData: indices\n                }\n              );\n            }\n\n            // Catch job's end:\n            if (\n              end >= arr.length / renderer.ATTRIBUTES &&\n              i === a.length - 1\n            ) {\n              delete this.jobs[id];\n              return false;\n            }\n\n            if (end >= arr.length / renderer.ATTRIBUTES) {\n              i++;\n              arr = this.edgeFloatArrays[a[i]].array;\n              renderer = sigma.webgl.edges[a[i]];\n              start = 0;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            } else {\n              start = end;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            }\n\n            return true;\n          };\n\n          this.jobs[id] = job;\n          conrad.addJob(id, job.bind(this));\n        }).call(this);\n      else {\n        for (k in this.edgeFloatArrays) {\n          renderer = sigma.webgl.edges[k];\n\n          // Check program:\n          if (!this.edgePrograms[k])\n            this.edgePrograms[k] = renderer.initProgram(edgesGl);\n\n          // Render\n          if (this.edgeFloatArrays[k]) {\n            edgesGl.useProgram(this.edgePrograms[k]);\n            renderer.render(\n              edgesGl,\n              this.edgePrograms[k],\n              this.edgeFloatArrays[k].array,\n              {\n                settings: this.settings,\n                matrix: matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n                indicesData: this.edgeIndicesArrays[k]\n              }\n            );\n          }\n        }\n      }\n    }\n\n    if (drawNodes) {\n      // Enable blending:\n      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);\n      nodesGl.enable(nodesGl.BLEND);\n\n      for (k in this.nodeFloatArrays) {\n        renderer = sigma.webgl.nodes[k];\n\n        // Check program:\n        if (!this.nodePrograms[k])\n          this.nodePrograms[k] = renderer.initProgram(nodesGl);\n\n        // Render\n        if (this.nodeFloatArrays[k]) {\n          nodesGl.useProgram(this.nodePrograms[k]);\n          renderer.render(\n            nodesGl,\n            this.nodePrograms[k],\n            this.nodeFloatArrays[k].array,\n            {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio')\n            }\n          );\n        }\n      }\n    }\n\n    if (drawLabels) {\n      a = this.camera.quadtree.area(\n        this.camera.getRectangle(this.width, this.height)\n      );\n\n      // Apply camera view to these nodes:\n      this.camera.applyView(\n        undefined,\n        undefined,\n        {\n          nodes: a,\n          edges: [],\n          width: this.width,\n          height: this.height\n        }\n      );\n\n      o = function(key) {\n        return self.settings({\n          prefix: self.camera.prefix\n        }, key);\n      };\n\n      for (i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (\n            sigma.canvas.labels[\n              a[i].type ||\n              this.settings(options, 'defaultNodeType')\n            ] || sigma.canvas.labels.def\n          )(a[i], this.contexts.labels, o);\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string}   tag   The label tag.\n   * @param  {string}   id    The id of the element (to store it in\n   *                          \"domElements\").\n   * @param  {?boolean} webgl Will init the WebGL context if true.\n   */\n  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {\n    var gl,\n        dom = document.createElement(tag),\n        self = this;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas') {\n      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {\n        preserveDrawingBuffer: true\n      });\n\n      // Adding webgl context loss listeners\n      if (webgl) {\n        dom.addEventListener('webglcontextlost', function(e) {\n          e.preventDefault();\n        }, false);\n\n        dom.addEventListener('webglcontextrestored', function(e) {\n          self.render();\n        }, false);\n      }\n    }\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}               width  The new width of the container.\n   * @param  {?number}               height The new height of the container.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          // If simple 2D canvas:\n          if (this.contexts[k] && this.contexts[k].scale) {\n            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n            if (pixelRatio !== 1)\n              this.contexts[k].scale(pixelRatio, pixelRatio);\n          } else {\n            this.domElements[k].setAttribute(\n              'width',\n              (w * this.settings('webglOversamplingRatio')) + 'px'\n            );\n            this.domElements[k].setAttribute(\n              'height',\n              (h * this.settings('webglOversamplingRatio')) + 'px'\n            );\n          }\n        }\n      }\n    }\n\n    // Scale:\n    for (k in this.contexts)\n      if (this.contexts[k] && this.contexts[k].viewport)\n        this.contexts[k].viewport(\n          0,\n          0,\n          this.width * this.settings('webglOversamplingRatio'),\n          this.height * this.settings('webglOversamplingRatio')\n        );\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.clear = function() {\n    this.contexts.labels.clearRect(0, 0, this.width, this.height);\n    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.webgl.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The object \"sigma.webgl.nodes\" contains the different WebGL node\n   * renderers. The default one draw nodes as discs. Here are the attributes\n   * any node renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw a node.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addNode     A function that adds a node to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       node\n   *                        > {number}       index   The node index in the\n   *                                                 nodes array.\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the nodes\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n\n\n\n  /**\n   * The object \"sigma.webgl.edges\" contains the different WebGL edge\n   * renderers. The default one draw edges as direct lines. Here are the\n   * attributes any edge renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw an edge.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addEdge     A function that adds an edge to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       edge\n   *                        > {object}       source\n   *                        > {object}       target\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the edges\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.edges');\n\n\n\n\n  /**\n   * The object \"sigma.canvas.labels\" contains the different\n   * label renderers for the WebGL renderer. Since displaying texts in WebGL is\n   * definitely painful and since there a way less labels to display than nodes\n   * or edges, the default renderer simply renders them in a canvas.\n   *\n   * A labels renderer is a simple function, taking as arguments the related\n   * node, the renderer and a settings function.\n   */\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The curve edge renderer. It renders the node as a bezier curve.\n   */\n  sigma.svg.edges.curve = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var path = document.createElementNS(settings('xmlns'), 'path');\n\n      // Attributes\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n\n      // Control point\n      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +\n        (target[prefix + 'y'] - source[prefix + 'y']) / 4,\n          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +\n        (source[prefix + 'x'] - target[prefix + 'x']) / 4;\n\n      // Path\n      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +\n              'Q' + cx + ',' + cy + ' ' +\n              target[prefix + 'x'] + ',' + target[prefix + 'y'];\n\n      // Updating attributes\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none');\n\n      // Showing\n      path.style.display = '';\n\n      return this;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The default edge renderer. It renders the node as a simple line.\n   */\n  sigma.svg.edges.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var line = document.createElementNS(settings('xmlns'), 'line');\n\n      // Attributes\n      line.setAttributeNS(null, 'data-edge-id', edge.id);\n      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      line.setAttributeNS(null, 'stroke', color);\n\n      return line;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, line, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n      line.setAttributeNS(null, 'x1', source[prefix + 'x']);\n      line.setAttributeNS(null, 'y1', source[prefix + 'y']);\n      line.setAttributeNS(null, 'x2', target[prefix + 'x']);\n      line.setAttributeNS(null, 'y2', target[prefix + 'y']);\n\n      // Showing\n      line.style.display = '';\n\n      return this;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.hovers');\n\n  /**\n   * The default hover renderer.\n   */\n  sigma.svg.hovers.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}           node               The node object.\n     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by\n     *                            the svg to perform some measurements and\n     *                            passed by the renderer.\n     * @param  {DOMElement}       nodeCircle         The node DOM Element.\n     * @param  {configurable}     settings           The settings function.\n     */\n    create: function(node, nodeCircle, measurementCanvas, settings) {\n\n      // Defining visual properties\n      var x,\n          y,\n          w,\n          h,\n          e,\n          d,\n          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          fontSize = (settings('labelSize') === 'fixed') ?\n            settings('defaultLabelSize') :\n            settings('labelSizeRatio') * size,\n          fontColor = (settings('labelHoverColor') === 'node') ?\n                        (node.color || settings('defaultNodeColor')) :\n                        settings('defaultLabelHoverColor');\n\n      // Creating elements\n      var group = document.createElementNS(settings('xmlns'), 'g'),\n          rectangle = document.createElementNS(settings('xmlns'), 'rect'),\n          circle = document.createElementNS(settings('xmlns'), 'circle'),\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      // Defining properties\n      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');\n      group.setAttributeNS(null, 'data-node-id', node.id);\n\n      if (typeof node.label === 'string') {\n\n        // Text\n        text.innerHTML = node.label;\n        text.textContent = node.label;\n        text.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-label');\n        text.setAttributeNS(null, 'font-size', fontSize);\n        text.setAttributeNS(null, 'font-family', settings('font'));\n        text.setAttributeNS(null, 'fill', fontColor);\n        text.setAttributeNS(null, 'x',\n          Math.round(node[prefix + 'x'] + size + 3));\n        text.setAttributeNS(null, 'y',\n          Math.round(node[prefix + 'y'] + fontSize / 3));\n\n        // Measures\n        // OPTIMIZE: Find a better way than a measurement canvas\n        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n        w = Math.round(\n          measurementCanvas.measureText(node.label).width +\n            fontSize / 2 + size + 9\n        );\n        h = Math.round(fontSize + 4);\n        e = Math.round(fontSize / 2 + 2);\n\n        // Circle\n        circle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        circle.setAttributeNS(null, 'fill', '#fff');\n        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n        circle.setAttributeNS(null, 'r', e);\n\n        // Rectangle\n        rectangle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        rectangle.setAttributeNS(null, 'fill', '#fff');\n        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);\n        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);\n        rectangle.setAttributeNS(null, 'width', w);\n        rectangle.setAttributeNS(null, 'height', h);\n      }\n\n      // Appending childs\n      group.appendChild(circle);\n      group.appendChild(rectangle);\n      group.appendChild(text);\n      group.appendChild(nodeCircle);\n\n      return group;\n    }\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.labels');\n\n  /**\n   * The default label renderer. It renders the label as a simple text.\n   */\n  sigma.svg.labels.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node       The node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      var fontColor = (settings('labelColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelColor');\n\n      text.setAttributeNS(null, 'data-label-target', node.id);\n      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');\n      text.setAttributeNS(null, 'font-size', fontSize);\n      text.setAttributeNS(null, 'font-family', settings('font'));\n      text.setAttributeNS(null, 'fill', fontColor);\n\n      text.innerHTML = node.label;\n      text.textContent = node.label;\n\n      return text;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               text     The label DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, text, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'];\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      // Case when we don't want to display the label\n      if (!settings('forceLabels') && size < settings('labelThreshold'))\n        return;\n\n      if (typeof node.label !== 'string')\n        return;\n\n      // Updating\n      text.setAttributeNS(null, 'x',\n        Math.round(node[prefix + 'x'] + size + 3));\n      text.setAttributeNS(null, 'y',\n        Math.round(node[prefix + 'y'] + fontSize / 3));\n\n      // Showing\n      text.style.display = '';\n\n      return this;\n    }\n  };\n}).call(this);\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   */\n  sigma.svg.nodes.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {configurable}             settings The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          circle = document.createElementNS(settings('xmlns'), 'circle');\n\n      // Defining the node's circle\n      circle.setAttributeNS(null, 'data-node-id', node.id);\n      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');\n      circle.setAttributeNS(\n        null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Returning the DOM Element\n      return circle;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               circle   The node DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, circle, settings) {\n      var prefix = settings('prefix') || '';\n\n      // Applying changes\n      // TODO: optimize - check if necessary\n      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n      circle.setAttributeNS(null, 'r', node[prefix + 'size']);\n\n      // Updating only if not freestyle\n      if (!settings('freeStyle'))\n        circle.setAttributeNS(\n          null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Showing\n      circle.style.display = '';\n\n      return this;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.utils');\n\n  /**\n   * Some useful functions used by sigma's SVG renderer.\n   */\n  sigma.svg.utils = {\n\n    /**\n     * SVG Element show.\n     *\n     * @param  {DOMElement}               element   The DOM element to show.\n     */\n    show: function(element) {\n      element.style.display = '';\n      return this;\n    },\n\n    /**\n     * SVG Element hide.\n     *\n     * @param  {DOMElement}               element   The DOM element to hide.\n     */\n    hide: function(element) {\n      element.style.display = 'none';\n      return this;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing\n   * mode.\n   *\n   * It is expensive, since drawing a single edge requires 9 points, each\n   * having a lot of attributes.\n   */\n  sigma.webgl.edges.arrow = {\n    POINTS: 9,\n    ATTRIBUTES: 11,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          targetSize = target[prefix + 'size'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      // Arrow head:\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = -1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation1 =\n            gl.getAttribLocation(program, 'a_pos1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_pos2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          targetSizeLocation =\n            gl.getAttribLocation(program, 'a_tSize'),\n          delayLocation =\n            gl.getAttribLocation(program, 'a_delay'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          headLocation =\n            gl.getAttribLocation(program, 'a_head'),\n          headPositionLocation =\n            gl.getAttribLocation(program, 'a_headPosition'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          nodeRatioLocation =\n            gl.getUniformLocation(program, 'u_nodeRatio'),\n          arrowHeadLocation =\n            gl.getUniformLocation(program, 'u_arrowHead'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(\n        nodeRatioLocation,\n        Math.pow(params.ratio, params.settings('nodesPowRatio')) /\n        params.ratio\n      );\n      gl.uniform1f(arrowHeadLocation, 5.0);\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(targetSizeLocation);\n      gl.enableVertexAttribArray(delayLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.enableVertexAttribArray(headLocation);\n      gl.enableVertexAttribArray(headPositionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(targetSizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(delayLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        28\n      );\n      gl.vertexAttribPointer(headLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        32\n      );\n      gl.vertexAttribPointer(headPositionLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        36\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        40\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_pos1;',\n          'attribute vec2 a_pos2;',\n          'attribute float a_thickness;',\n          'attribute float a_tSize;',\n          'attribute float a_delay;',\n          'attribute float a_minus;',\n          'attribute float a_head;',\n          'attribute float a_headPosition;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_nodeRatio;',\n          'uniform float u_arrowHead;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 pos = normalize(a_pos2 - a_pos1);',\n\n            'mat2 matrix = (1.0 - a_head) *',\n              '(',\n                'a_minus * u_matrixHalfPiMinus +',\n                '(1.0 - a_minus) * u_matrixHalfPi',\n              ') + a_head * (',\n                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',\n                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',\n              ');',\n\n            'pos = a_pos1 + (',\n              // Deal with body:\n              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',\n              // Deal with head:\n              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',\n              // Deal with delay:\n              'a_delay * pos * (',\n                'a_tSize / u_nodeRatio +',\n                'u_arrowHead * a_thickness * u_ratio',\n              ')',\n            ');',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(pos, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.\n   *\n   * It is expensive, since drawing a single edge requires 6 points, each\n   * having 7 attributes (source position, target position, thickness, color\n   * and a flag indicating which vertice of the rectangle it is).\n   */\n  sigma.webgl.edges.def = {\n    POINTS: 6,\n    ATTRIBUTES: 7,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation1 =\n            gl.getAttribLocation(program, 'a_position1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_position2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(minusLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position1;',\n          'attribute vec2 a_position2;',\n          'attribute float a_thickness;',\n          'attribute float a_minus;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 position = a_thickness * u_ratio *',\n              'normalize(a_position2 - a_position1);',\n\n            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',\n              '(1.0 - a_minus) * u_matrixHalfPi;',\n\n            'position = matrix * position + a_position1;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines with the gl.LINES display\n   * mode. Since this mode does not support well thickness, edges are all drawn\n   * with the same thickness (3px), independantly of the edge attributes or the\n   * zooming ratio.\n   */\n  sigma.webgl.edges.fast = {\n    POINTS: 2,\n    ATTRIBUTES: 3,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n\n      gl.lineWidth(3);\n      gl.drawArrays(\n        gl.LINES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes as discs, shaped in triangles with\n   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,\n   * it will store three times the center of node, with the color and the size,\n   * and an angle indicating which \"corner\" of the triangle to draw.\n   *\n   * The fragment shader does not deal with anti-aliasing, so make sure that\n   * you deal with it somewhere else in the code (by default, the WebGL\n   * renderer will oversample the rendering through the webglOversamplingRatio\n   * value).\n   */\n  sigma.webgl.nodes.def = {\n    POINTS: 3,\n    ATTRIBUTES: 5,\n    addNode: function(node, data, i, prefix, settings) {\n      var color = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 0;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 2 * Math.PI / 3;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 4 * Math.PI / 3;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          angleLocation =\n            gl.getAttribLocation(program, 'a_angle'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(angleLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n      gl.vertexAttribPointer(\n        angleLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n          'attribute float a_angle;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main() {',\n            // Multiply the point size twice:\n            'radius = a_size * u_ratio;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',\n            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n            'center = position * u_scale;',\n            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',\n\n            'position = position +',\n              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',\n            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n\n            'radius = radius * u_scale;',\n\n            'gl_Position = vec4(position, 0, 1);',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main(void) {',\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n\n            'vec2 m = gl_FragCoord.xy - center;',\n            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            // Here is how we draw a disc instead of a square:\n            'if (diff > 0.0)',\n              'gl_FragColor = color;',\n            'else',\n              'gl_FragColor = color0;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes in the fastest way: Nodes are basic\n   * squares, drawn through the gl.POINTS drawing method. The size of the nodes\n   * are represented with the \"gl_PointSize\" value in the vertex shader.\n   *\n   * It is the fastest node renderer here since the buffer just takes one line\n   * to draw each node (with attributes \"x\", \"y\", \"size\" and \"color\").\n   *\n   * Nevertheless, this method has some problems, especially due to some issues\n   * with the gl.POINTS:\n   *  - First, if the center of a node is outside the scene, the point will not\n   *    be drawn, even if it should be partly on screen.\n   *  - I tried applying a fragment shader similar to the one in the default\n   *    node renderer to display them as discs, but it did not work fine on\n   *    some computers settings, filling the discs with weird gradients not\n   *    depending on the actual color.\n   */\n  sigma.webgl.nodes.fast = {\n    POINTS: 1,\n    ATTRIBUTES: 4,\n    addNode: function(node, data, i, prefix, settings) {\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n\n      gl.drawArrays(\n        gl.POINTS,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Multiply the point size twice:\n            //  - x SCALING_RATIO to correct the canvas scaling\n            //  - x 2 to correct the formulae\n            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'float border = 0.01;',\n            'float radius = 0.5;',\n\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',\n            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            'float t = 0.0;',\n            'if (dist > border)',\n              't = 1.0;',\n            'else if (dist > 0.0)',\n              't = dist / border;',\n\n            'gl_FragColor = mix(color0, color, t);',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  var __instances = {};\n\n  /**\n   * This is the sigma instances constructor. One instance of sigma represent\n   * one graph. It is possible to represent this grapÄ¥ with several renderers\n   * at the same time. By default, the default renderer (WebGL + Canvas\n   * polyfill) will be used as the only renderer, with the container specified\n   * in the configuration.\n   *\n   * @param  {?*}    conf The configuration of the instance. There are a lot of\n   *                      different recognized forms to instantiate sigma, check\n   *                      example files, documentation in this file and unit\n   *                      tests to know more.\n   * @return {sigma}      The fresh new sigma instance.\n   *\n   * Instanciating sigma:\n   * ********************\n   * If no parameter is given to the constructor, the instance will be created\n   * without any renderer or camera. It will just instantiate the graph, and\n   * other modules will have to be instantiated through the public methods,\n   * like \"addRenderer\" etc:\n   *\n   *  > s0 = new sigma();\n   *  > s0.addRenderer({\n   *  >   type: 'canvas',\n   *  >   container: 'my-container-id'\n   *  > });\n   *\n   * In most of the cases, sigma will simply be used with the default renderer.\n   * Then, since the only required parameter is the DOM container, there are\n   * some simpler way to call the constructor. The four following calls do the\n   * exact same things:\n   *\n   *  > s1 = new sigma('my-container-id');\n   *  > s2 = new sigma(document.getElementById('my-container-id'));\n   *  > s3 = new sigma({\n   *  >   container: document.getElementById('my-container-id')\n   *  > });\n   *  > s4 = new sigma({\n   *  >   renderers: [{\n   *  >     container: document.getElementById('my-container-id')\n   *  >   }]\n   *  > });\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters, when calling the\n   * constructor with to top level configuration object (fourth case in the\n   * previous examples):\n   *\n   *   {?string} id        The id of the instance. It will be generated\n   *                       automatically if not specified.\n   *   {?array}  renderers An array containing objects describing renderers.\n   *   {?object} graph     An object containing an array of nodes and an array\n   *                       of edges, to avoid having to add them by hand later.\n   *   {?object} settings  An object containing instance specific settings that\n   *                       will override the default ones defined in the object\n   *                       sigma.settings.\n   */\n  var sigma = function(conf) {\n    // Local variables:\n    // ****************\n    var i,\n        l,\n        a,\n        c,\n        o,\n        id;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Private attributes:\n    // *******************\n    var _self = this,\n        _conf = conf || {};\n\n    // Little shortcut:\n    // ****************\n    // The configuration is supposed to have a list of the configuration\n    // objects for each renderer.\n    //  - If there are no configuration at all, then nothing is done.\n    //  - If there are no renderer list, the given configuration object will be\n    //    considered as describing the first and only renderer.\n    //  - If there are no renderer list nor \"container\" object, it will be\n    //    considered as the container itself (a DOM element).\n    //  - If the argument passed to sigma() is a string, it will be considered\n    //    as the ID of the DOM container.\n    if (\n      typeof _conf === 'string' ||\n      _conf instanceof HTMLElement\n    )\n      _conf = {\n        renderers: [_conf]\n      };\n    else if (Object.prototype.toString.call(_conf) === '[object Array]')\n      _conf = {\n        renderers: _conf\n      };\n\n    // Also check \"renderer\" and \"container\" keys:\n    o = _conf.renderers || _conf.renderer || _conf.container;\n    if (!_conf.renderers || _conf.renderers.length === 0)\n      if (\n        typeof o === 'string' ||\n        o instanceof HTMLElement ||\n        (typeof o === 'object' && 'container' in o)\n      )\n        _conf.renderers = [o];\n\n    // Recense the instance:\n    if (_conf.id) {\n      if (__instances[_conf.id])\n        throw 'sigma: Instance \"' + _conf.id + '\" already exists.';\n      Object.defineProperty(this, 'id', {\n        value: _conf.id\n      });\n    } else {\n      id = 0;\n      while (__instances[id])\n        id++;\n      Object.defineProperty(this, 'id', {\n        value: '' + id\n      });\n    }\n    __instances[this.id] = this;\n\n    // Initialize settings function:\n    this.settings = new sigma.classes.configurable(\n      sigma.settings,\n      _conf.settings || {}\n    );\n\n    // Initialize locked attributes:\n    Object.defineProperty(this, 'graph', {\n      value: new sigma.classes.graph(this.settings),\n      configurable: true\n    });\n    Object.defineProperty(this, 'middlewares', {\n      value: [],\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameras', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderers', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderersPerCamera', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameraFrames', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'camera', {\n      get: function() {\n        return this.cameras[0];\n      }\n    });\n    Object.defineProperty(this, 'events', {\n      value: [\n        'click',\n        'rightClick',\n        'clickStage',\n        'doubleClickStage',\n        'rightClickStage',\n        'clickNode',\n        'clickNodes',\n        'doubleClickNode',\n        'doubleClickNodes',\n        'rightClickNode',\n        'rightClickNodes',\n        'overNode',\n        'overNodes',\n        'outNode',\n        'outNodes',\n        'downNode',\n        'downNodes',\n        'upNode',\n        'upNodes'\n      ],\n      configurable: true\n    });\n\n    // Add a custom handler, to redispatch events from renderers:\n    this._handler = (function(e) {\n      var k,\n          data = {};\n\n      for (k in e.data)\n        data[k] = e.data[k];\n\n      data.renderer = e.target;\n      this.dispatchEvent(e.type, data);\n    }).bind(this);\n\n    // Initialize renderers:\n    a = _conf.renderers || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addRenderer(a[i]);\n\n    // Initialize middlewares:\n    a = _conf.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.middlewares.push(\n        typeof a[i] === 'string' ?\n          sigma.middlewares[a[i]] :\n          a[i]\n      );\n\n    // Check if there is already a graph to fill in:\n    if (typeof _conf.graph === 'object' && _conf.graph) {\n      this.graph.read(_conf.graph);\n\n      // If a graph is given to the to the instance, the \"refresh\" method is\n      // directly called:\n      this.refresh();\n    }\n\n    // Deal with resize:\n    window.addEventListener('resize', function() {\n      if (_self.settings)\n        _self.refresh();\n    });\n  };\n\n\n\n\n  /**\n   * This methods will instantiate and reference a new camera. If no id is\n   * specified, then an automatic id will be generated.\n   *\n   * @param  {?string}              id Eventually the camera id.\n   * @return {sigma.classes.camera}    The fresh new camera instance.\n   */\n  sigma.prototype.addCamera = function(id) {\n    var self = this,\n        camera;\n\n    if (!arguments.length) {\n      id = 0;\n      while (this.cameras['' + id])\n        id++;\n      id = '' + id;\n    }\n\n    if (this.cameras[id])\n      throw 'sigma.addCamera: The camera \"' + id + '\" already exists.';\n\n    camera = new sigma.classes.camera(id, this.graph, this.settings);\n    this.cameras[id] = camera;\n\n    // Add a quadtree to the camera:\n    camera.quadtree = new sigma.classes.quad();\n\n    // Add an edgequadtree to the camera:\n    if (sigma.classes.edgequad !== undefined) {\n      camera.edgequadtree = new sigma.classes.edgequad();\n    }\n\n    camera.bind('coordinatesUpdated', function(e) {\n      self.renderCamera(camera, camera.isAnimated);\n    });\n\n    this.renderersPerCamera[id] = [];\n\n    return camera;\n  };\n\n  /**\n   * This method kills a camera, and every renderer attached to it.\n   *\n   * @param  {string|camera} v The camera to kill or its ID.\n   * @return {sigma}           Returns the instance.\n   */\n  sigma.prototype.killCamera = function(v) {\n    v = typeof v === 'string' ? this.cameras[v] : v;\n\n    if (!v)\n      throw 'sigma.killCamera: The camera is undefined.';\n\n    var i,\n        l,\n        a = this.renderersPerCamera[v.id];\n\n    for (l = a.length, i = l - 1; i >= 0; i--)\n      this.killRenderer(a[i]);\n\n    delete this.renderersPerCamera[v.id];\n    delete this.cameraFrames[v.id];\n    delete this.cameras[v.id];\n\n    if (v.kill)\n      v.kill();\n\n    return this;\n  };\n\n  /**\n   * This methods will instantiate and reference a new renderer. The \"type\"\n   * argument can be the constructor or its name in the \"sigma.renderers\"\n   * package. If no type is specified, then \"sigma.renderers.def\" will be used.\n   * If no id is specified, then an automatic id will be generated.\n   *\n   * @param  {?object}  options Eventually some options to give to the renderer\n   *                            constructor.\n   * @return {renderer}         The fresh new renderer instance.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?string}            id     Eventually the renderer id.\n   *   {?(function|string)} type   Eventually the renderer constructor or its\n   *                               name in the \"sigma.renderers\" package.\n   *   {?(camera|string)}   camera Eventually the renderer camera or its\n   *                               id.\n   */\n  sigma.prototype.addRenderer = function(options) {\n    var id,\n        fn,\n        camera,\n        renderer,\n        o = options || {};\n\n    // Polymorphism:\n    if (typeof o === 'string')\n      o = {\n        container: document.getElementById(o)\n      };\n    else if (o instanceof HTMLElement)\n      o = {\n        container: o\n      };\n\n    // If the container still is a string, we get it by id\n    if (typeof o.container === 'string')\n      o.container = document.getElementById(o.container);\n\n    // Reference the new renderer:\n    if (!('id' in o)) {\n      id = 0;\n      while (this.renderers['' + id])\n        id++;\n      id = '' + id;\n    } else\n      id = o.id;\n\n    if (this.renderers[id])\n      throw 'sigma.addRenderer: The renderer \"' + id + '\" already exists.';\n\n    // Find the good constructor:\n    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];\n    fn = fn || sigma.renderers.def;\n\n    // Find the good camera:\n    camera = 'camera' in o ?\n      (\n        o.camera instanceof sigma.classes.camera ?\n          o.camera :\n          this.cameras[o.camera] || this.addCamera(o.camera)\n      ) :\n      this.addCamera();\n\n    if (this.cameras[camera.id] !== camera)\n      throw 'sigma.addRenderer: The camera is not properly referenced.';\n\n    // Instantiate:\n    renderer = new fn(this.graph, camera, this.settings, o);\n    this.renderers[id] = renderer;\n    Object.defineProperty(renderer, 'id', {\n      value: id\n    });\n\n    // Bind events:\n    if (renderer.bind)\n      renderer.bind(\n        [\n          'click',\n          'rightClick',\n          'clickStage',\n          'doubleClickStage',\n          'rightClickStage',\n          'clickNode',\n          'clickNodes',\n          'clickEdge',\n          'clickEdges',\n          'doubleClickNode',\n          'doubleClickNodes',\n          'doubleClickEdge',\n          'doubleClickEdges',\n          'rightClickNode',\n          'rightClickNodes',\n          'rightClickEdge',\n          'rightClickEdges',\n          'overNode',\n          'overNodes',\n          'overEdge',\n          'overEdges',\n          'outNode',\n          'outNodes',\n          'outEdge',\n          'outEdges',\n          'downNode',\n          'downNodes',\n          'downEdge',\n          'downEdges',\n          'upNode',\n          'upNodes',\n          'upEdge',\n          'upEdges'\n        ],\n        this._handler\n      );\n\n    // Reference the renderer by its camera:\n    this.renderersPerCamera[camera.id].push(renderer);\n\n    return renderer;\n  };\n\n  /**\n   * This method kills a renderer.\n   *\n   * @param  {string|renderer} v The renderer to kill or its ID.\n   * @return {sigma}             Returns the instance.\n   */\n  sigma.prototype.killRenderer = function(v) {\n    v = typeof v === 'string' ? this.renderers[v] : v;\n\n    if (!v)\n      throw 'sigma.killRenderer: The renderer is undefined.';\n\n    var a = this.renderersPerCamera[v.camera.id],\n        i = a.indexOf(v);\n\n    if (i >= 0)\n      a.splice(i, 1);\n\n    if (v.kill)\n      v.kill();\n\n    delete this.renderers[v.id];\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method calls the \"render\" method of each renderer, with the same\n   * arguments than the \"render\" method, but will also check if the renderer\n   * has a \"process\" method, and call it if it exists.\n   *\n   * It is useful for quadtrees or WebGL processing, for instance.\n   *\n   * @param  {?object}  options Eventually some options to give to the refresh\n   *                            method.\n   * @return {sigma}            Returns the instance itself.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?boolean} skipIndexation A flag specifying wether or not the refresh\n   *                             function should reindex the graph in the\n   *                             quadtrees or not (default: false).\n   */\n  sigma.prototype.refresh = function(options) {\n    var i,\n        l,\n        k,\n        a,\n        c,\n        bounds,\n        prefix = 0;\n\n    options = options || {};\n\n    // Call each middleware:\n    a = this.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      a[i].call(\n        this,\n        (i === 0) ? '' : 'tmp' + prefix + ':',\n        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')\n      );\n\n    // Then, for each camera, call the \"rescale\" middleware, unless the\n    // settings specify not to:\n    for (k in this.cameras) {\n      c = this.cameras[k];\n      if (\n        c.settings('autoRescale') &&\n        this.renderersPerCamera[c.id] &&\n        this.renderersPerCamera[c.id].length\n      )\n        sigma.middlewares.rescale.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix,\n          {\n            width: this.renderersPerCamera[c.id][0].width,\n            height: this.renderersPerCamera[c.id][0].height\n          }\n        );\n      else\n        sigma.middlewares.copy.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix\n        );\n\n      if (!options.skipIndexation) {\n        // Find graph boundaries:\n        bounds = sigma.utils.getBoundaries(\n          this.graph,\n          c.readPrefix\n        );\n\n        // Refresh quadtree:\n        c.quadtree.index(this.graph.nodes(), {\n          prefix: c.readPrefix,\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        });\n\n        // Refresh edgequadtree:\n        if (\n          c.edgequadtree !== undefined &&\n          c.settings('drawEdges') &&\n          c.settings('enableEdgeHovering')\n        ) {\n          c.edgequadtree.index(this.graph, {\n            prefix: c.readPrefix,\n            bounds: {\n              x: bounds.minX,\n              y: bounds.minY,\n              width: bounds.maxX - bounds.minX,\n              height: bounds.maxY - bounds.minY\n            }\n          });\n        }\n      }\n    }\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.renderers[a[i]].process) {\n        if (this.settings('skipErrors'))\n          try {\n            this.renderers[a[i]].process();\n          } catch (e) {\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".process()\"'\n            );\n          }\n        else\n          this.renderers[a[i]].process();\n      }\n\n    this.render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer.\n   *\n   * @return {sigma} Returns the instance itself.\n   */\n  sigma.prototype.render = function() {\n    var i,\n        l,\n        a,\n        prefix = 0;\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.settings('skipErrors'))\n        try {\n          this.renderers[a[i]].render();\n        } catch (e) {\n          if (this.settings('verbose'))\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".render()\"'\n            );\n        }\n      else\n        this.renderers[a[i]].render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer that is bound to\n   * the specified camera. To improve the performances, if this method is\n   * called too often, the number of effective renderings is limitated to one\n   * per frame, unless you are using the \"force\" flag.\n   *\n   * @param  {sigma.classes.camera} camera The camera to render.\n   * @param  {?boolean}             force  If true, will render the camera\n   *                                       directly.\n   * @return {sigma}                       Returns the instance itself.\n   */\n  sigma.prototype.renderCamera = function(camera, force) {\n    var i,\n        l,\n        a,\n        self = this;\n\n    if (force) {\n      a = this.renderersPerCamera[camera.id];\n      for (i = 0, l = a.length; i < l; i++)\n        if (this.settings('skipErrors'))\n          try {\n            a[i].render();\n          } catch (e) {\n            if (this.settings('verbose'))\n              console.log(\n                'Warning: The renderer \"' + a[i].id + '\" crashed on \".render()\"'\n              );\n          }\n        else\n          a[i].render();\n    } else {\n      if (!this.cameraFrames[camera.id]) {\n        a = this.renderersPerCamera[camera.id];\n        for (i = 0, l = a.length; i < l; i++)\n          if (this.settings('skipErrors'))\n            try {\n              a[i].render();\n            } catch (e) {\n              if (this.settings('verbose'))\n                console.log(\n                  'Warning: The renderer \"' +\n                    a[i].id +\n                    '\" crashed on \".render()\"'\n                );\n            }\n          else\n            a[i].render();\n\n        this.cameraFrames[camera.id] = requestAnimationFrame(function() {\n          delete self.cameraFrames[camera.id];\n        });\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"kill\" method of each module and destroys any\n   * reference from the instance.\n   */\n  sigma.prototype.kill = function() {\n    var k;\n\n    // Dispatching event\n    this.dispatchEvent('kill');\n\n    // Kill graph:\n    this.graph.kill();\n\n    // Kill middlewares:\n    delete this.middlewares;\n\n    // Kill each renderer:\n    for (k in this.renderers)\n      this.killRenderer(this.renderers[k]);\n\n    // Kill each camera:\n    for (k in this.cameras)\n      this.killCamera(this.cameras[k]);\n\n    delete this.renderers;\n    delete this.cameras;\n\n    // Kill everything else:\n    for (k in this)\n      if (this.hasOwnProperty(k))\n        delete this[k];\n\n    delete __instances[this.id];\n  };\n\n\n\n\n  /**\n   * Returns a clone of the instances object or a specific running instance.\n   *\n   * @param  {?string} id Eventually an instance ID.\n   * @return {object}     The related instance or a clone of the instances\n   *                      object.\n   */\n  sigma.instances = function(id) {\n    return arguments.length ?\n      __instances[id] :\n      sigma.utils.extend({}, __instances);\n  };\n\n\n\n  /**\n   * The current version of sigma:\n   */\n  sigma.version = '1.2.0';\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined')\n    throw 'An object called sigma is already in the global scope.';\n\n  this.sigma = sigma;\n\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Packages initialization:\n  sigma.utils.pkg('sigma.settings');\n\n  var settings = {\n    /**\n     * GRAPH SETTINGS:\n     * ***************\n     */\n    // {boolean} Indicates if the data have to be cloned in methods to add\n    //           nodes or edges.\n    clone: true,\n    // {boolean} Indicates if nodes \"id\" values and edges \"id\", \"source\" and\n    //           \"target\" values must be set as immutable.\n    immutable: true,\n    // {boolean} Indicates if sigma can log its errors and warnings.\n    verbose: false,\n\n\n    /**\n     * RENDERERS SETTINGS:\n     * *******************\n     */\n    // {string}\n    classPrefix: 'sigma',\n    // {string}\n    defaultNodeType: 'def',\n    // {string}\n    defaultEdgeType: 'def',\n    // {string}\n    defaultLabelColor: '#000',\n    // {string}\n    defaultEdgeColor: '#000',\n    // {string}\n    defaultNodeColor: '#000',\n    // {string}\n    defaultLabelSize: 14,\n    // {string} Indicates how to choose the edges color. Available values:\n    //          \"source\", \"target\", \"default\"\n    edgeColor: 'source',\n    // {number} Defines the minimal edge's arrow display size.\n    minArrowSize: 0,\n    // {string}\n    font: 'arial',\n    // {string} Example: 'bold'\n    fontStyle: '',\n    // {string} Indicates how to choose the labels color. Available values:\n    //          \"node\", \"default\"\n    labelColor: 'default',\n    // {string} Indicates how to choose the labels size. Available values:\n    //          \"fixed\", \"proportional\"\n    labelSize: 'fixed',\n    // {string} The ratio between the font size of the label and the node size.\n    labelSizeRatio: 1,\n    // {number} The minimum size a node must have to see its label displayed.\n    labelThreshold: 8,\n    // {number} The oversampling factor used in WebGL renderer.\n    webglOversamplingRatio: 2,\n    // {number} The size of the border of hovered nodes.\n    borderSize: 0,\n    // {number} The default hovered node border's color.\n    defaultNodeBorderColor: '#000',\n    // {number} The hovered node's label font. If not specified, will heritate\n    //          the \"font\" value.\n    hoverFont: '',\n    // {boolean} If true, then only one node can be hovered at a time.\n    singleHover: true,\n    // {string} Example: 'bold'\n    hoverFontStyle: '',\n    // {string} Indicates how to choose the hovered nodes shadow color.\n    //          Available values: \"node\", \"default\"\n    labelHoverShadow: 'default',\n    // {string}\n    labelHoverShadowColor: '#000',\n    // {string} Indicates how to choose the hovered nodes color.\n    //          Available values: \"node\", \"default\"\n    nodeHoverColor: 'node',\n    // {string}\n    defaultNodeHoverColor: '#000',\n    // {string} Indicates how to choose the hovered nodes background color.\n    //          Available values: \"node\", \"default\"\n    labelHoverBGColor: 'default',\n    // {string}\n    defaultHoverLabelBGColor: '#fff',\n    // {string} Indicates how to choose the hovered labels color.\n    //          Available values: \"node\", \"default\"\n    labelHoverColor: 'default',\n    // {string}\n    defaultLabelHoverColor: '#000',\n    // {string} Indicates how to choose the edges hover color. Available values:\n    //          \"edge\", \"default\"\n    edgeHoverColor: 'edge',\n    // {number} The size multiplicator of hovered edges.\n    edgeHoverSizeRatio: 1,\n    // {string}\n    defaultEdgeHoverColor: '#000',\n    // {boolean} Indicates if the edge extremities must be hovered when the\n    //           edge is hovered.\n    edgeHoverExtremities: false,\n    // {booleans} The different drawing modes:\n    //           false: Layered not displayed.\n    //           true: Layered displayed.\n    drawEdges: true,\n    drawNodes: true,\n    drawLabels: true,\n    drawEdgeLabels: false,\n    // {boolean} Indicates if the edges must be drawn in several frames or in\n    //           one frame, as the nodes and labels are drawn.\n    batchEdgesDrawing: false,\n    // {boolean} Indicates if the edges must be hidden during dragging and\n    //           animations.\n    hideEdgesOnMove: false,\n    // {numbers} The different batch sizes, when elements are displayed in\n    //           several frames.\n    canvasEdgesBatchSize: 500,\n    webglEdgesBatchSize: 1000,\n\n\n\n\n    /**\n     * RESCALE SETTINGS:\n     * *****************\n     */\n    // {string} Indicates of to scale the graph relatively to its container.\n    //          Available values: \"inside\", \"outside\"\n    scalingMode: 'inside',\n    // {number} The margin to keep around the graph.\n    sideMargin: 0,\n    // {number} Determine the size of the smallest and the biggest node / edges\n    //          on the screen. This mapping makes easier to display the graph,\n    //          avoiding too big nodes that take half of the screen, or too\n    //          small ones that are not readable. If the two parameters are\n    //          equals, then the minimal display size will be 0. And if they\n    //          are both equal to 0, then there is no mapping, and the radius\n    //          of the nodes will be their size.\n    minEdgeSize: 0.5,\n    maxEdgeSize: 1,\n    minNodeSize: 1,\n    maxNodeSize: 8,\n\n\n\n\n    /**\n     * CAPTORS SETTINGS:\n     * *****************\n     */\n    // {boolean}\n    touchEnabled: true,\n    // {boolean}\n    mouseEnabled: true,\n    // {boolean}\n    mouseWheelEnabled: true,\n    // {boolean}\n    doubleClickEnabled: true,\n    // {boolean} Defines whether the custom events such as \"clickNode\" can be\n    //           used.\n    eventsEnabled: true,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms with the mouse-wheel.\n    zoomingRatio: 1.7,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms by double clicking.\n    doubleClickZoomingRatio: 2.2,\n    // {number} The minimum zooming level.\n    zoomMin: 0.0625,\n    // {number} The maximum zooming level.\n    zoomMax: 2,\n    // {number} The duration of animations following a mouse scrolling.\n    mouseZoomDuration: 200,\n    // {number} The duration of animations following a mouse double click.\n    doubleClickZoomDuration: 200,\n    // {number} The duration of animations following a mouse dropping.\n    mouseInertiaDuration: 200,\n    // {number} The inertia power (mouse captor).\n    mouseInertiaRatio: 3,\n    // {number} The duration of animations following a touch dropping.\n    touchInertiaDuration: 200,\n    // {number} The inertia power (touch captor).\n    touchInertiaRatio: 3,\n    // {number} The maximum time between two clicks to make it a double click.\n    doubleClickTimeout: 300,\n    // {number} The maximum time between two taps to make it a double tap.\n    doubleTapTimeout: 300,\n    // {number} The maximum time of dragging to trigger intertia.\n    dragTimeout: 200,\n\n\n\n\n    /**\n     * GLOBAL SETTINGS:\n     * ****************\n     */\n    // {boolean} Determines whether the instance has to refresh itself\n    //           automatically when a \"resize\" event is dispatched from the\n    //           window object.\n    autoResize: true,\n    // {boolean} Determines whether the \"rescale\" middleware has to be called\n    //           automatically for each camera on refresh.\n    autoRescale: true,\n    // {boolean} If set to false, the camera method \"goTo\" will basically do\n    //           nothing.\n    enableCamera: true,\n    // {boolean} If set to false, the nodes cannot be hovered.\n    enableHovering: true,\n    // {boolean} If set to true, the edges can be hovered.\n    enableEdgeHovering: false,\n    // {number} The size of the area around the edges to activate hovering.\n    edgeHoverPrecision: 5,\n    // {boolean} If set to true, the rescale middleware will ignore node sizes\n    //           to determine the graphs boundings.\n    rescaleIgnoreSize: false,\n    // {boolean} Determines if the core has to try to catch errors on\n    //           rendering.\n    skipErrors: false,\n\n\n\n\n    /**\n     * CAMERA SETTINGS:\n     * ****************\n     */\n    // {number} The power degrees applied to the nodes/edges size relatively to\n    //          the zooming level. Basically:\n    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R\n    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T\n    nodesPowRatio: 0.5,\n    edgesPowRatio: 0.5,\n\n\n\n\n    /**\n     * ANIMATIONS SETTINGS:\n     * ********************\n     */\n    // {number} The default animation time.\n    animationsTime: 200\n  };\n\n  // Export the previously designed settings:\n  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);\n}).call(this);\n"},function(A,e){A.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  var _root = this;\n\n  // Initialize packages:\n  sigma.utils = sigma.utils || {};\n\n  /**\n   * MISC UTILS:\n   */\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when several objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > sigma.utils.extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {object+} Any number of objects.\n   * @return {object}  The merged object.\n   */\n  sigma.utils.extend = function() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  };\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  sigma.utils.dateNow = function() {\n    return Date.now ? Date.now() : new Date().getTime();\n  };\n\n  /**\n   * Takes a package name as parameter and checks at each lebel if it exists,\n   * and if it does not, creates it.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.pkg('a.b.c');\n   *  > a.b.c;\n   *  > // Object {};\n   *  >\n   *  > sigma.utils.pkg('a.b.d');\n   *  > a.b;\n   *  > // Object { c: {}, d: {} };\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.pkg = function(pkgName) {\n    return (pkgName || '').split('.').reduce(function(context, objName) {\n      return (objName in context) ?\n        context[objName] :\n        (context[objName] = {});\n    }, _root);\n  };\n\n  /**\n   * Returns a unique incremental number ID.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.id();\n   *  > // 1;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 2;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 3;\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.id = (function() {\n    var i = 0;\n    return function() {\n      return ++i;\n    };\n  })();\n\n  /**\n   * This function takes an hexa color (for instance \"#ffcc00\" or \"#fc0\") or a\n   * rgb / rgba color (like \"rgb(255,255,12)\" or \"rgba(255,255,12,1)\") and\n   * returns an integer equal to \"r * 255 * 255 + g * 255 + b\", to gain some\n   * memory in the data given to WebGL shaders.\n   *\n   * Note that the function actually caches its results for better performance.\n   *\n   * @param  {string} val The hexa or rgba color.\n   * @return {number}     The number value.\n   */\n  var floatColorCache = {};\n\n  sigma.utils.floatColor = function(val) {\n\n    // Is the color already computed?\n    if (floatColorCache[val])\n      return floatColorCache[val];\n\n    var original = val,\n        r = 0,\n        g = 0,\n        b = 0;\n\n    if (val[0] === '#') {\n      val = val.slice(1);\n\n      if (val.length === 3) {\n        r = parseInt(val.charAt(0) + val.charAt(0), 16);\n        g = parseInt(val.charAt(1) + val.charAt(1), 16);\n        b = parseInt(val.charAt(2) + val.charAt(2), 16);\n      }\n      else {\n        r = parseInt(val.charAt(0) + val.charAt(1), 16);\n        g = parseInt(val.charAt(2) + val.charAt(3), 16);\n        b = parseInt(val.charAt(4) + val.charAt(5), 16);\n      }\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      r = +val[1];\n      g = +val[2];\n      b = +val[3];\n    }\n\n    var color = (\n      r * 256 * 256 +\n      g * 256 +\n      b\n    );\n\n    // Caching the color\n    floatColorCache[original] = color;\n\n    return color;\n  };\n\n    /**\n   * Perform a zoom into a camera, with or without animation, to the\n   * coordinates indicated using a specified ratio.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the animation\n   * object:\n   *\n   *   {?number} duration     An amount of time that means the duration of the\n   *                          animation. If this parameter doesn't exist the\n   *                          zoom will be performed without animation.\n   *   {?function} onComplete A function to perform it after the animation. It\n   *                          will be performed even if there is no duration.\n   *\n   * @param {camera}     The camera where perform the zoom.\n   * @param {x}          The X coordiantion where the zoom goes.\n   * @param {y}          The Y coordiantion where the zoom goes.\n   * @param {ratio}      The ratio to apply it to the current camera ratio.\n   * @param {?animation} A dictionary with options for a possible animation.\n   */\n  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {\n    var settings = camera.settings,\n        count,\n        newRatio,\n        animationSettings,\n        coordinates;\n\n    // Create the newRatio dealing with min / max:\n    newRatio = Math.max(\n      settings('zoomMin'),\n      Math.min(\n        settings('zoomMax'),\n        camera.ratio * ratio\n      )\n    );\n\n    // Check that the new ratio is different from the initial one:\n    if (newRatio !== camera.ratio) {\n      // Create the coordinates variable:\n      ratio = newRatio / camera.ratio;\n      coordinates = {\n        x: x * (1 - ratio) + camera.x,\n        y: y * (1 - ratio) + camera.y,\n        ratio: newRatio\n      };\n\n      if (animation && animation.duration) {\n        // Complete the animation setings:\n        count = sigma.misc.animation.killAll(camera);\n        animation = sigma.utils.extend(\n          animation,\n          {\n            easing: count ? 'quadraticOut' : 'quadraticInOut'\n          }\n        );\n\n        sigma.misc.animation.camera(camera, coordinates, animation);\n      } else {\n        camera.goTo(coordinates);\n        if (animation && animation.onComplete)\n          animation.onComplete();\n      }\n    }\n  };\n\n  /**\n   * Return the control point coordinates for a quadratic bezier curve.\n   *\n   * @param  {number} x1  The X coordinate of the start point.\n   * @param  {number} y1  The Y coordinate of the start point.\n   * @param  {number} x2  The X coordinate of the end point.\n   * @param  {number} y2  The Y coordinate of the end point.\n   * @return {x,y}        The control point coordinates.\n   */\n  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {\n    return {\n      x: (x1 + x2) / 2 + (y2 - y1) / 4,\n      y: (y1 + y2) / 2 + (x1 - x2) / 4\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the quadratic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the ending point.\n    * @param  {number} y2 The Y coordinate of the ending point.\n    * @param  {number} xi The X coordinate of the control point.\n    * @param  {number} yi The Y coordinate of the control point.\n    * @return {object}    {x,y}.\n  */\n  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {\n    // http://stackoverflow.com/a/5634528\n    return {\n      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,\n      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the cubic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the end point.\n    * @param  {number} y2 The Y coordinate of the end point.\n    * @param  {number} cx The X coordinate of the first control point.\n    * @param  {number} cy The Y coordinate of the first control point.\n    * @param  {number} dx The X coordinate of the second control point.\n    * @param  {number} dy The Y coordinate of the second control point.\n    * @return {object}    {x,y} The point at t.\n  */\n  sigma.utils.getPointOnBezierCurve =\n    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {\n    // http://stackoverflow.com/a/15397596\n    // Blending functions:\n    var B0_t = Math.pow(1 - t, 3),\n        B1_t = 3 * t * Math.pow(1 - t, 2),\n        B2_t = 3 * Math.pow(t, 2) * (1 - t),\n        B3_t = Math.pow(t, 3);\n\n    return {\n      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),\n      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)\n    };\n  };\n\n  /**\n   * Return the coordinates of the two control points for a self loop (i.e.\n   * where the start point is also the end point) computed as a cubic bezier\n   * curve.\n   *\n   * @param  {number} x    The X coordinate of the node.\n   * @param  {number} y    The Y coordinate of the node.\n   * @param  {number} size The node size.\n   * @return {x1,y1,x2,y2} The coordinates of the two control points.\n   */\n  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {\n    return {\n      x1: x - size * 7,\n      y1: y,\n      x2: x,\n      y2: y + size * 7\n    };\n  };\n\n  /**\n   * Return the euclidian distance between two points of a plane\n   * with an orthonormal basis.\n   *\n   * @param  {number} x1  The X coordinate of the first point.\n   * @param  {number} y1  The Y coordinate of the first point.\n   * @param  {number} x2  The X coordinate of the second point.\n   * @param  {number} y2  The Y coordinate of the second point.\n   * @return {number}     The euclidian distance.\n   */\n  sigma.utils.getDistance = function(x0, y0, x1, y1) {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  };\n\n  /**\n   * Return the coordinates of the intersection points of two circles.\n   *\n   * @param  {number} x0  The X coordinate of center location of the first\n   *                      circle.\n   * @param  {number} y0  The Y coordinate of center location of the first\n   *                      circle.\n   * @param  {number} r0  The radius of the first circle.\n   * @param  {number} x1  The X coordinate of center location of the second\n   *                      circle.\n   * @param  {number} y1  The Y coordinate of center location of the second\n   *                      circle.\n   * @param  {number} r1  The radius of the second circle.\n   * @return {xi,yi}      The coordinates of the intersection points.\n   */\n  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {\n    // http://stackoverflow.com/a/12219802\n    var a, dx, dy, d, h, rx, ry, x2, y2;\n\n    // dx and dy are the vertical and horizontal distances between the circle\n    // centers:\n    dx = x1 - x0;\n    dy = y1 - y0;\n\n    // Determine the straight-line distance between the centers:\n    d = Math.sqrt((dy * dy) + (dx * dx));\n\n    // Check for solvability:\n    if (d > (r0 + r1)) {\n        // No solution. circles do not intersect.\n        return false;\n    }\n    if (d < Math.abs(r0 - r1)) {\n        // No solution. one circle is contained in the other.\n        return false;\n    }\n\n    //'point 2' is the point where the line through the circle intersection\n    // points crosses the line between the circle centers.\n\n    // Determine the distance from point 0 to point 2:\n    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);\n\n    // Determine the coordinates of point 2:\n    x2 = x0 + (dx * a / d);\n    y2 = y0 + (dy * a / d);\n\n    // Determine the distance from point 2 to either of the intersection\n    // points:\n    h = Math.sqrt((r0 * r0) - (a * a));\n\n    // Determine the offsets of the intersection points from point 2:\n    rx = -dy * (h / d);\n    ry = dx * (h / d);\n\n    // Determine the absolute intersection points:\n    var xi = x2 + rx;\n    var xi_prime = x2 - rx;\n    var yi = y2 + ry;\n    var yi_prime = y2 - ry;\n\n    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};\n  };\n\n  /**\n    * Check if a point is on a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if point is \"close to\" the line\n    *                          segment, false otherwise.\n  */\n  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {\n    // http://stackoverflow.com/a/328122\n    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),\n        d = sigma.utils.getDistance(x1, y1, x2, y2),\n        nCrossProduct = crossProduct / d; // normalized cross product\n\n    return (nCrossProduct < epsilon &&\n     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&\n     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));\n  };\n\n  /**\n    * Check if a point is on a quadratic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx     The X coordinate of the curve control point.\n    * @param  {number} cpy     The Y coordinate of the curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnQuadraticCurve =\n    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);\n    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n    * Check if a point is on a cubic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx1    The X coordinate of the 1st curve control point.\n    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.\n    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.\n    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnBezierCurve =\n    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);\n    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnBezierCurve(\n          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnBezierCurve(\n        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n   * ************\n   * EVENTS UTILS:\n   * ************\n   */\n  /**\n   * Here are some useful functions to unify extraction of the information we\n   * need with mouse events and touch events, from different browsers:\n   */\n\n  /**\n   * Extract the local X position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local X value of the mouse.\n   */\n  sigma.utils.getX = function(e) {\n    return (\n      (e.offsetX !== undefined && e.offsetX) ||\n      (e.layerX !== undefined && e.layerX) ||\n      (e.clientX !== undefined && e.clientX)\n    );\n  };\n\n  /**\n   * Extract the local Y position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local Y value of the mouse.\n   */\n  sigma.utils.getY = function(e) {\n    return (\n      (e.offsetY !== undefined && e.offsetY) ||\n      (e.layerY !== undefined && e.layerY) ||\n      (e.clientY !== undefined && e.clientY)\n    );\n  };\n\n  /**\n   * The pixel ratio of the screen. Taking zoom into account\n   *\n   * @return {number}        Pixel ratio of the screen\n   */\n  sigma.utils.getPixelRatio = function() {\n    var ratio = 1;\n    if (window.screen.deviceXDPI !== undefined &&\n         window.screen.logicalXDPI !== undefined &&\n         window.screen.deviceXDPI > window.screen.logicalXDPI) {\n        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;\n    }\n    else if (window.devicePixelRatio !== undefined) {\n        ratio = window.devicePixelRatio;\n    }\n    return ratio;\n  };\n\n  /**\n   * Extract the width from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The width of the event's target.\n   */\n  sigma.utils.getWidth = function(e) {\n    var w = (!e.target.ownerSVGElement) ?\n              e.target.width :\n              e.target.ownerSVGElement.width;\n\n    return (\n      (typeof w === 'number' && w) ||\n      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the center from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {object}   The center of the event's target.\n   */\n  sigma.utils.getCenter = function(e) {\n    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :\n        sigma.utils.getPixelRatio();\n    return {\n      x: sigma.utils.getWidth(e) / (2 * ratio),\n      y: sigma.utils.getHeight(e) / (2 * ratio)\n    };\n  };\n\n  /**\n   * Convert mouse coords to sigma coords\n   *\n   * @param  {event}   e A mouse or touch event.\n   * @param  {number?} x The x coord to convert\n   * @param  {number?} x The y coord to convert\n   *\n   * @return {object}    The standardized event\n   */\n  sigma.utils.mouseCoords = function(e, x, y) {\n    x = x || sigma.utils.getX(e);\n    y = y || sigma.utils.getY(e);\n    return {\n        x: x - sigma.utils.getCenter(e).x,\n        y: y - sigma.utils.getCenter(e).y,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey\n    };\n  };\n\n  /**\n   * Extract the height from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The height of the event's target.\n   */\n  sigma.utils.getHeight = function(e) {\n    var h = (!e.target.ownerSVGElement) ?\n              e.target.height :\n              e.target.ownerSVGElement.height;\n\n    return (\n      (typeof h === 'number' && h) ||\n      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the wheel delta from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The wheel delta of the mouse.\n   */\n  sigma.utils.getDelta = function(e) {\n    return (\n      (e.wheelDelta !== undefined && e.wheelDelta) ||\n      (e.detail !== undefined && -e.detail)\n    );\n  };\n\n  /**\n   * Returns the offset of a DOM element.\n   *\n   * @param  {DOMElement} dom The element to retrieve the position.\n   * @return {object}         The offset of the DOM element (top, left).\n   */\n  sigma.utils.getOffset = function(dom) {\n    var left = 0,\n        top = 0;\n\n    while (dom) {\n      top = top + parseInt(dom.offsetTop);\n      left = left + parseInt(dom.offsetLeft);\n      dom = dom.offsetParent;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n\n  /**\n   * Simulates a \"double click\" event.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   * @param  {function}    callback The callback to execute.\n   */\n  sigma.utils.doubleClick = function(target, type, callback) {\n    var clicks = 0,\n        self = this,\n        handlers;\n\n    target._doubleClickHandler = target._doubleClickHandler || {};\n    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];\n    handlers = target._doubleClickHandler[type];\n\n    handlers.push(function(e) {\n      clicks++;\n\n      if (clicks === 2) {\n        clicks = 0;\n        return callback(e);\n      } else if (clicks === 1) {\n        setTimeout(function() {\n          clicks = 0;\n        }, sigma.settings.doubleClickTimeout);\n      }\n    });\n\n    target.addEventListener(type, handlers[handlers.length - 1], false);\n  };\n\n  /**\n   * Unbind simulated \"double click\" events.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   */\n  sigma.utils.unbindDoubleClick = function(target, type) {\n    var handler,\n        handlers = (target._doubleClickHandler || {})[type] || [];\n\n    while ((handler = handlers.pop())) {\n      target.removeEventListener(type, handler);\n    }\n\n    delete (target._doubleClickHandler || {})[type];\n  };\n\n\n\n\n  /**\n   * Here are just some of the most basic easing functions, used for the\n   * animated camera \"goTo\" calls.\n   *\n   * If you need some more easings functions, don't hesitate to add them to\n   * sigma.utils.easings. But I will not add some more here or merge PRs\n   * containing, because I do not want sigma sources full of overkill and never\n   * used stuff...\n   */\n  sigma.utils.easings = sigma.utils.easings || {};\n  sigma.utils.easings.linearNone = function(k) {\n    return k;\n  };\n  sigma.utils.easings.quadraticIn = function(k) {\n    return k * k;\n  };\n  sigma.utils.easings.quadraticOut = function(k) {\n    return k * (2 - k);\n  };\n  sigma.utils.easings.quadraticInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k;\n    return - 0.5 * (--k * (k - 2) - 1);\n  };\n  sigma.utils.easings.cubicIn = function(k) {\n    return k * k * k;\n  };\n  sigma.utils.easings.cubicOut = function(k) {\n    return --k * k * k + 1;\n  };\n  sigma.utils.easings.cubicInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n  };\n\n\n\n\n  /**\n   * ************\n   * WEBGL UTILS:\n   * ************\n   */\n  /**\n   * Loads a WebGL shader and returns it.\n   *\n   * @param  {WebGLContext}           gl           The WebGLContext to use.\n   * @param  {string}                 shaderSource The shader source.\n   * @param  {number}                 shaderType   The type of shader.\n   * @param  {function(string): void} error        Callback for errors.\n   * @return {WebGLShader}                         The created shader.\n   */\n  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {\n    var compiled,\n        shader = gl.createShader(shaderType);\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    // If something went wrong:\n    if (!compiled) {\n      if (error) {\n        error(\n          'Error compiling shader \"' + shader + '\":' +\n          gl.getShaderInfoLog(shader)\n        );\n      }\n\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  };\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.\n   * @param  {Array.<string>}         attribs   The attribs names.\n   * @param  {Array.<number>}         locations The locations for the attribs.\n   * @param  {function(string): void} error     Callback for errors.\n   * @return {WebGLProgram}                     The created program.\n   */\n  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {\n    var i,\n        linked,\n        program = gl.createProgram();\n\n    for (i = 0; i < shaders.length; ++i)\n      gl.attachShader(program, shaders[i]);\n\n    if (attribs)\n      for (i = 0; i < attribs.length; ++i)\n        gl.bindAttribLocation(\n          program,\n          locations ? locations[i] : i,\n          opt_attribs[i]\n        );\n\n    gl.linkProgram(program);\n\n    // Check the link status\n    linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n      if (error)\n        error('Error in program linking: ' + gl.getProgramInfoLog(program));\n\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    return program;\n  };\n\n\n\n\n  /**\n   * *********\n   * MATRICES:\n   * *********\n   * The following utils are just here to help generating the transformation\n   * matrices for the WebGL renderers.\n   */\n  sigma.utils.pkg('sigma.utils.matrices');\n\n  /**\n   * The returns a 3x3 translation matrix.\n   *\n   * @param  {number} dx The X translation.\n   * @param  {number} dy The Y translation.\n   * @return {array}     Returns the matrix.\n   */\n  sigma.utils.matrices.translation = function(dx, dy) {\n    return [\n      1, 0, 0,\n      0, 1, 0,\n      dx, dy, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 rotation matrix.\n   *\n   * @param  {number}  angle The rotation angle.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.rotation = function(angle, m2) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    return m2 ? [\n      cos, -sin,\n      sin, cos\n    ] : [\n      cos, -sin, 0,\n      sin, cos, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {number}  ratio The scaling ratio.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.scale = function(ratio, m2) {\n    return m2 ? [\n      ratio, 0,\n      0, ratio\n    ] : [\n      ratio, 0, 0,\n      0, ratio, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {array}   a  The first matrix.\n   * @param  {array}   b  The second matrix.\n   * @param  {boolean} m2 If true, the function will assume both matrices are\n   *                      2x2.\n   * @return {array}      Returns the matrix.\n   */\n  sigma.utils.matrices.multiply = function(a, b, m2) {\n    var l = m2 ? 2 : 3,\n        a00 = a[0 * l + 0],\n        a01 = a[0 * l + 1],\n        a02 = a[0 * l + 2],\n        a10 = a[1 * l + 0],\n        a11 = a[1 * l + 1],\n        a12 = a[1 * l + 2],\n        a20 = a[2 * l + 0],\n        a21 = a[2 * l + 1],\n        a22 = a[2 * l + 2],\n        b00 = b[0 * l + 0],\n        b01 = b[0 * l + 1],\n        b02 = b[0 * l + 2],\n        b10 = b[1 * l + 0],\n        b11 = b[1 * l + 1],\n        b12 = b[1 * l + 2],\n        b20 = b[2 * l + 0],\n        b21 = b[2 * l + 1],\n        b22 = b[2 * l + 2];\n\n    return m2 ? [\n      a00 * b00 + a01 * b10,\n      a00 * b01 + a01 * b11,\n      a10 * b00 + a11 * b10,\n      a10 * b01 + a11 * b11\n    ] : [\n      a00 * b00 + a01 * b10 + a02 * b20,\n      a00 * b01 + a01 * b11 + a02 * b21,\n      a00 * b02 + a01 * b12 + a02 * b22,\n      a10 * b00 + a11 * b10 + a12 * b20,\n      a10 * b01 + a11 * b11 + a12 * b21,\n      a10 * b02 + a11 * b12 + a12 * b22,\n      a20 * b00 + a21 * b10 + a22 * b20,\n      a20 * b01 + a21 * b11 + a22 * b21,\n      a20 * b02 + a21 * b12 + a22 * b22\n    ];\n  };\n}).call(this);\n"},function(A,e,n){n(0)(n(103))},function(A,e,n){n(0)(n(104))},function(A,e,n){n(0)(n(105))},function(A,e,n){n(0)(n(106))},function(A,e,n){n(0)(n(107))},function(A,e,n){n(0)(n(108))},function(A,e,n){n(0)(n(109))},function(A,e,n){n(0)(n(110))},function(A,e,n){n(0)(n(111))},function(A,e,n){n(0)(n(112))},function(A,e,n){n(0)(n(113))},function(A,e,n){n(0)(n(114))},function(A,e,n){n(0)(n(115))},function(A,e,n){n(0)(n(116))},function(A,e,n){n(0)(n(117))},function(A,e,n){n(0)(n(118))},function(A,e,n){n(0)(n(119))},function(A,e,n){n(0)(n(120))},function(A,e,n){n(0)(n(121))},function(A,e,n){n(0)(n(122))},function(A,e,n){n(0)(n(123))},function(A,e,n){n(0)(n(124))},function(A,e,n){n(0)(n(125))},function(A,e,n){n(0)(n(126))},function(A,e,n){n(0)(n(127))},function(A,e,n){n(0)(n(128))},function(A,e,n){n(0)(n(129))},function(A,e,n){n(0)(n(130))},function(A,e,n){n(0)(n(131))},function(A,e,n){n(0)(n(132))},function(A,e,n){n(0)(n(133))},function(A,e,n){n(0)(n(134))},function(A,e,n){n(0)(n(135))},function(A,e,n){n(0)(n(136))},function(A,e,n){n(0)(n(137))},function(A,e,n){n(0)(n(138))},function(A,e,n){n(0)(n(139))},function(A,e,n){n(0)(n(140))},function(A,e,n){n(0)(n(141))},function(A,e,n){n(0)(n(142))},function(A,e,n){n(0)(n(143))},function(A,e,n){n(0)(n(144))},function(A,e,n){n(0)(n(145))},function(A,e,n){n(0)(n(146))},function(A,e,n){n(0)(n(147))},function(A,e,n){n(0)(n(148))},function(A,e,n){n(0)(n(149))},function(A,e,n){n(0)(n(150))},function(A,e,n){n(0)(n(151))},function(A,e){A.exports=function(A){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!A||"string"!=typeof A)return A;var n=e.protocol+"//"+e.host,t=n+e.pathname.replace(/\/[^\/]*$/,"/");return A.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(A,e){var i=e.trim().replace(/^"(.*)"$/,function(A,e){return e}).replace(/^'(.*)'$/,function(A,e){return e});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(i))return A;var g;return g=0===i.indexOf("//")?i:0===i.indexOf("/")?n+i:t+i.replace(/^\.\//,""),"url("+JSON.stringify(g)+")"})}},function(A,e,n){var t=n(83);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(84);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(85);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(86);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(87);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(88);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(89);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(90);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(91);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(92);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(93);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(94);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(95);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(96);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(97);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(98);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(99);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(100);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e,n){var t=n(101);"string"==typeof t&&(t=[[A.i,t,""]]);n(5)(t,{});t.locals&&(A.exports=t.locals)},function(A,e){A.exports="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiID4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgRm9udEZvcmdlIDIwMTYxMDAzIGF0IFR1ZSBNYXkgMTYgMTY6NDQ6NTQgMjAxNwogQnkgd3d3LWRhdGEKQ29weXJpZ2h0IChjKSAyMDEwLCBBbmRyZXkgTWFrYXJvdiAobWFrYXJvdkBibXN0dS5ydSwgbWthLWF0LW1haWxydUBtYWlsLnJ1KSwKd2l0aCBSZXNlcnZlZCBGb250IE5hbWUgQW5rYS9Db2RlciBOYXJyb3cuCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpUaGUgQW5rYS8qIGFyZSBtZW1iZXJzIG9mIEFubmEgU2h1Z29sIG5hbWUgZm9udCBmYW1pbHk7IE1hcmNoIDIwMTAKPC9tZXRhZGF0YT4KPGRlZnM+Cjxmb250IGlkPSJBbmthQ29kZXJDNzVSZWd1bGFyIiBob3Jpei1hZHYteD0iOTIyIiA+CiAgPGZvbnQtZmFjZSAKICAgIGZvbnQtZmFtaWx5PSJBbmthQ29kZXJDNzVSZWd1bGFyIgogICAgZm9udC13ZWlnaHQ9IjQwMCIKICAgIGZvbnQtc3RyZXRjaD0iY29uZGVuc2VkIgogICAgdW5pdHMtcGVyLWVtPSIyMDQ4IgogICAgcGFub3NlLTE9IjIgMTEgNSA5IDIgNSAyIDIgMiA0IgogICAgYXNjZW50PSIxNjM4IgogICAgZGVzY2VudD0iLTQxMCIKICAgIHgtaGVpZ2h0PSIxMDI0IgogICAgY2FwLWhlaWdodD0iMTQwMCIKICAgIGJib3g9Ii0xMiAtNjE1IDEwMTYgMTc5NyIKICAgIHVuZGVybGluZS10aGlja25lc3M9IjE1MCIKICAgIHVuZGVybGluZS1wb3NpdGlvbj0iLTQ0MiIKICAgIHVuaWNvZGUtcmFuZ2U9IlUrMDAyMC0yNjZCIgogIC8+CjxtaXNzaW5nLWdseXBoIApkPSJNNjggMHYxMzY1aDU0NHYtMTM2NWgtNTQ0ek0xMzYgNjhoNDA4djEyMjloLTQwOHYtMTIyOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iLm5vdGRlZiIgCmQ9Ik02OCAwdjEzNjVoNTQ0di0xMzY1aC01NDR6TTEzNiA2OGg0MDh2MTIyOWgtNDA4di0xMjI5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSIubnVsbCIgaG9yaXotYWR2LXg9IjAiIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJub25tYXJraW5ncmV0dXJuIiAKIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3BhY2UiIHVuaWNvZGU9IiAiIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJleGNsYW0iIHVuaWNvZGU9IiEiIApkPSJNNDU4IDE0MThxNDMgMCA3MiAtMzAuNXQyOSAtOTcuNWwtMjQgLTkwNmgtMTQ2bC0yNCA5MDdxMCA2NiAyNyA5Ni41dDY2IDMwLjV6TTYxMCAxMjVxMCAtNjEgLTQ0LjUgLTEwMXQtMTA1LjUgLTQwcS01OSAwIC0xMDQgNDF0LTQ1IDEwMHEwIDU3IDQzLjUgOTl0MTA1LjUgNDJxNjEgMCAxMDUuNSAtNDB0NDQuNSAtMTAxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJxdW90ZWRibCIgdW5pY29kZT0iJiN4MjI7IiAKZD0iTTE2MSAxMDAxcS0yOSAtNDggLTc2IC00OHEtMjcgMCAtNDYgMjB0LTE5IDU0cTAgMTEgNiAzMWw3OCAzMTlxOSAzOCA0Ni41IDYzdDgwLjUgMjVxNTAgMCA4MSAtMzcuNXQzMSAtODUuNXEwIC0zNCAtMTYgLTU5ek03MjAgMTAwMXEtMjkgLTQ4IC03MyAtNDhxLTI4IDAgLTQ4IDIwdC0yMCA1NHEwIDYgNSAzMWw3OCAzMTlxMTAgMzggNDggNjN0ODAgMjVxNTAgMCA4MSAtMzcuNXQzMSAtODUuNXEwIC0zMiAtMTYgLTU5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJudW1iZXJzaWduIiB1bmljb2RlPSIjIiAKZD0iTTMyNyA0OTFoMjE5bDU0IDQwN2gtMjIwek0yNjIgMGgtMTUxbDQ1IDM0MWgtMTM1bDIwIDE1MGgxMzVsNTQgNDA3aC0xMzZsMjAgMTUwaDEzNmw0MCAzMDJoMTUwbC00MCAtMzAyaDIyMGw0MCAzMDJoMTUwbC00MCAtMzAyaDEzNmwtMjAgLTE1MGgtMTM2bC01MyAtNDA3aDEzNmwtMjAgLTE1MGgtMTM2bC00NSAtMzQxaC0xNTFsNDUgMzQxaC0yMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRvbGxhciIgdW5pY29kZT0iJCIgCmQ9Ik0zODYgODgxdjM4M3EtNTkgLTE5IC05MSAtNzAuNXQtMzIgLTEzMC41di0zMHEwIC0zNiAyNCAtNzV0NjcgLTYxek01MzYgNjM2di01MDBxNjQgMjIgMTA2LjUgNzh0NDIuNSAxMjN2MzBxMCAxOTQgLTE0OSAyNjl6TTUzNiAtOTNoLTE1MHY3M3EtMTM3IDE5IC0yMjkuNSAxMDh0LTkyLjUgMjM3aDE1MHEwIC04MiA0OC41IC0xMzB0MTIzLjUgLTYzdjU4MGwtMTAwIDUxcS03NyA0MCAtMTI1IDExNC41dC00OCAxNTUuNXYzMApxMCAxNDggNzYgMjQxdDE5NyAxMTV2NzVoMTUwdi03M3EyOTUgLTM3IDI5NSAtMzU4aC0xNTBxMCAzMCAtMSA0Ny41dC04LjUgNDcuNXQtMjIgNDl0LTQzLjUgMzd0LTcwIDI1di00NjVsODIgLTQycTExMCAtNTYgMTYzLjUgLTE2MnQ1My41IC0yMzN2LTMwcTAgLTEzMCAtODcgLTIzMS41dC0yMTIgLTEyNS41di03M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGVyY2VudCIgdW5pY29kZT0iJSIgCmQ9Ik05MTAgMjYzcTAgLTEwNiAtNjcgLTE4NC41dC0xNjggLTc4LjVxLTExMCAwIC0xNzIuNSA2N3QtNjIuNSAxOTZxMCA2MCAxNi41IDEwNy41dDQyIDc2dDU4IDQ3dDYyIDI1LjV0NTYuNSA3cTU4IDAgMTAyLjUgLTE5dDY5IC00Ni41dDM5LjUgLTY1LjV0MTkuNSAtNjl0NC41IC02M3pNNzYwIDI2M3EwIDQ1IC0yMyA3OXQtNjIgMzR0LTYyIC0zNHQtMjMgLTc5dDIzIC03OXQ2MiAtMzR0NjIgMzR0MjMgNzl6TTc2OCAxMzYzbDEyOCAtNzYKbC03NDIgLTEyNDlsLTEyOCA3NnpNNDg3IDExNDVxMCAtMTA2IC02NyAtMTg0LjV0LTE2OCAtNzguNXEtMTEwIDAgLTE3Mi41IDY3dC02Mi41IDE5NnEwIDYwIDE2LjUgMTA3LjV0NDIgNzZ0NTggNDd0NjIgMjUuNXQ1Ni41IDdxNTggMCAxMDIuNSAtMTl0NjkgLTQ2LjV0MzkuNSAtNjUuNXQxOS41IC02OXQ0LjUgLTYzek0zMzcgMTE0NXEwIDQ1IC0yMyA3OXQtNjIgMzR0LTYyIC0zNHQtMjMgLTc5dDIzIC03OXQ2MiAtMzR0NjIgMzR0MjMgNzl6CiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhbXBlcnNhbmQiIHVuaWNvZGU9IiYjeDI2OyIgCmQ9Ik02MjAgMjI5bC0yMjggNDMxbC03MiAtNzFxLTYwIC01OSAtODMgLTExMHQtMjMgLTExMnYtMzBxMCAtMTAzIDYyIC0xNTcuNXQxNTMgLTU0LjVoMThxMTE2IDAgMTczIDEwNHpNNjk3IDgzcS05OSAtMTA4IC0yNTAgLTEwOGgtMThxLTE1MyAwIC0yNTkgOTguNXQtMTA2IDI2My41djMwcTAgMTgyIDE0NCAzMjJsMTEwIDEwOHEtMTI0IDIwNiAtMTI0IDM0M3YyMnEwIDQwIDI3LjUgMTExLjV0NzguNSAxMDkuNXE2NCA0MiAxNTIgNDJoMTkKcTEyMSAwIDE5NS41IC03NXQ3NC41IC0xOTN2LTM5cTAgLTU1IC0zMi41IC0xMTYuNXQtODguNSAtMTE2LjVsLTExNyAtMTE1bDE4NyAtMzU0bDcxIDE5OWwxNDIgLTUwbC0xMTggLTMyOWwxMDEgLTE5MWwtMTMyIC03MHpNNDUyIDEyNzVxLTU2IDAgLTgyIC0zNXQtMjYgLTc4di0yMnEwIC04MyA4NCAtMjM0bDg4IDg3cTI1IDI0IDUwIDY2LjV0MjUgNTguNXYzOXEwIDUzIC0yOS41IDg1LjV0LTkwLjUgMzIuNWgtMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InF1b3Rlc2luZ2xlIiB1bmljb2RlPSInIiAKZD0iTTQ0MCAxMDAxcS0yOCAtNDggLTc0IC00OHEtMjggMCAtNDcgMjB0LTE5IDU0cTAgMTggNCAzMWw3OSAzMTlxOSAzOCA0NyA2M3Q4MCAyNXE1MSAwIDgxLjUgLTM3LjV0MzAuNSAtODUuNXEwIC0zNCAtMTUgLTU5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwYXJlbmxlZnQiIHVuaWNvZGU9IigiIApkPSJNNDI1IDcyMnEwIC0yMjYgMTA0IC00MjMuNXQyNTggLTMxOS41bC05NCAtMTE4cS04NCA2NyAtMTU3IDE1NS41dC0xMzIuNSAxOTcuNXQtOTQgMjQwLjV0LTM0LjUgMjY3LjVxMCAyNTkgMTI0IDQ4NHQzMDEgMzM3bDgwIC0xMjZxLTE0NiAtOTIgLTI1MC41IC0yODQuNXQtMTA0LjUgLTQxMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwYXJlbnJpZ2h0IiB1bmljb2RlPSIpIiAKZD0iTTY0NyA3MjJxMCAtMjY0IC0xMjAgLTQ5MnQtMjk4IC0zNjlsLTk0IDExOHExNTQgMTIyIDI1OCAzMjB0MTA0IDQyM3EwIDIxOCAtMTA0LjUgNDEwLjV0LTI1MC41IDI4NC41bDgwIDEyNnExNzcgLTExMiAzMDEgLTMzN3QxMjQgLTQ4NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXN0ZXJpc2siIHVuaWNvZGU9IioiIApkPSJNNzM2IDM0OXExNCAtMTggMTQgLTQ0cTAgLTQwIC0zMCAtNjFxLTIwIC0xNCAtNDMgLTE0cS0zOSAwIC02MiAzMWwtMTU0IDIxMWwtMTU0IC0yMTFxLTIzIC0zMSAtNjIgLTMxcS0yMyAwIC00MyAxNHEtMzAgMjEgLTMwIDYxcTAgMjYgMTQgNDRsMTU0IDIxMmwtMjQ5IDgwcS0yMyA3IC0zNy41IDI3LjV0LTE0LjUgNDQuNXEwIDEyIDQgMjNxNyAyMyAyNy41IDM3LjV0NDMuNSAxNC41cTEyIDAgMjMgLTRsMjQ5IC04MXYyNjJxMCAzMSAyMiA1Mwp0NTMgMjJ0NTMgLTIydDIyIC01M3YtMjYybDI0OSA4MXExMSA0IDIzIDRxMjMgMCA0My41IC0xNC41dDI3LjUgLTM3LjVxNCAtMTEgNCAtMjNxMCAtMjQgLTE0LjUgLTQ0LjV0LTM3LjUgLTI3LjVsLTI0OSAtODB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InBsdXMiIHVuaWNvZGU9IisiIApkPSJNODcyIDY3NXYtMTUwaC0zMzZ2LTM2OGgtMTUwdjM2OGgtMzM2djE1MGgzMzZ2MzM2aDE1MHYtMzM2aDMzNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29tbWEiIHVuaWNvZGU9IiwiIApkPSJNNjA3IDY1cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDJ0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJoeXBoZW4iIHVuaWNvZGU9Ii0iIApkPSJNODcyIDY3NXYtMTUwaC04MjJ2MTUwaDgyMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGVyaW9kIiB1bmljb2RlPSIuIiAKZD0iTTUxNCAtNDBoLTJ2MTJoLTJ2LTE0aDR2MnpNNTA2IC00MGgtMnY2aDJ2LTZ6TTQ0NCAtMjJoMnY2aDR2LTZoMnYxNGgtNmwtMiAtNHYtMTB6TTQ0NyAtMTBoM3YtNGgtNHYyek00NTggLTE0di04aDJ2OGwtMSAyaC01di0xMGgydjhoMnpNNDY2IC0xNHYtOGgydjhsLTEgMmgtNXYtMTBoMnY4aDJ6TTQ3MiAtMThoMnYtMmgtMnYyek00NzEgLTIyaDV2OGwtMSAyaC01di0yaDR2LTJoLTNsLTEgLTJ2LTJ6TTQ4MiAtMzR2LThoMnY4bC0xIDJoLTMKdjRoLTJ2LTE0aDJ2OGgyek00NzUgLTM0aC01djRoNnYyaC03bC0xIC0ydi00bDEgLTJoNXYtNGgtNnYtMmg3bDEgMnY0ek00OTAgLTQwaC0ydjhoLTJ2LThsMSAtMmg1djEwaC0ydi04ek00OTYgLTQwdjZoMnYtNmgtMnpNNDk1IC0zMmwtMSAtMnYtNmwxIC0yaDN2LTJoLTR2LTJoNWwxIDJ2MTJoLTV6TTUwMyAtMzJsLTEgLTJ2LTZsMSAtMmg0bDEgMnY2bC0xIDJoLTR6TTYwNyA1OXEwIC02MCAtNDEuNSAtMTAyLjV0LTEwNS41IC00Mi41CnEtNjIgMCAtMTA0IDQyLjV0LTQyIDEwMi41cTAgNTkgNDEgMTAydDEwNSA0M3E2MyAwIDEwNSAtNDIuNXQ0MiAtMTAyLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNsYXNoIiB1bmljb2RlPSIvIiAKZD0iTTY3MCAxNDUybDE0MCAtNTJsLTU1OCAtMTQ1MmwtMTQwIDUyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ6ZXJvIiB1bmljb2RlPSIwIiAKZD0iTTQ2MSAxMjc1cS0xMTIgMCAtMTYzIC0xMjd0LTUxIC00MTZxMCAtMTA5IDggLTIwOGwzODQgNTgwcS00OCAxNzEgLTE3OCAxNzF6TTgyNSA3MzJxMCAtODcgLTMgLTE1Ny41dC0xMi41IC0xNTEuNXQtMjUgLTE0M3QtNDMuNSAtMTIxLjV0LTY1LjUgLTk4dC05MiAtNjJ0LTEyMi41IC0yMy41cS0xODAgMCAtMjcyIDE4MmwtMTExIC0xNjdsLTY3IDE2OGwxMTkgMTc4cS0zMyAxNTggLTMzIDM5NnEwIDc0IDMgMTM1dDEyIDEzNQp0MjQuNSAxMzEuNXQ0My41IDExNHQ2NS41IDk0dDkyLjUgNjAuNXQxMjMgMjNxMTg3IDAgMjc4IC0xNzFsMTExIDE2N2w2MiAtMTc1bC0xMTMgLTE3MXEyNiAtMTMwIDI2IC0zNDN6TTY3MSA4ODNsLTM4MSAtNTc0cTUyIC0xODQgMTcxIC0xODRxNzUgMCAxMjAuNSA1NS41dDY5LjUgMTkwdDI0IDM2MS41cTAgOTAgLTQgMTUxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvbmUiIHVuaWNvZGU9IjEiIApkPSJNNjM1IDE0MjV2LTE0MjVoLTE1MHYxMDgzbC0xOTEgLTExN2wtNTQgNThsMjkwIDM5OWwyIDJoMTAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0d28iIHVuaWNvZGU9IjIiIApkPSJNNDUyIDE0MjVoMThxMzQ1IDAgMzQ1IC0yODF2LTQwcTAgLTQzIC0zMS41IC0xMzl0LTczLjUgLTE1NWwtMzI4IC00NjZxLTY1IC05MSAtOTUgLTE5NGg1NDV2LTE1MGgtNjkydjE4OHEyOSA4MCA2MyAxNDZ0NTEgOTBsMzM0IDQ3NHE0MyA2MCA2MCAxMTd0MTcgODl2NDBxMCA3NiAtNDkgMTAzLjV0LTE0NiAyNy41aC0xOHEtODUgMCAtMTIzIC0yNy41dC02NyAtOTUuNWwtMTM4IDU4cTQ0IDEwNSAxMTcuNSAxNjB0MjEwLjUgNTV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRocmVlIiB1bmljb2RlPSIzIiAKZD0iTTQ1MiAxNDI1aDE4cTEzOCAwIDIxOSAtODF0ODEgLTIzMXYtNDFxMCAtNTUgLTI4LjUgLTEzNS41dC03Mi41IC0xMjEuNXE3NiAtNjQgMTExIC0xNDUuNXQzNSAtMjAyLjV2LTIwcTAgLTcyIC05IC0xMzUuNXQtMzMgLTEyN3QtNjIgLTEwOC41dC05OS41IC03M3QtMTQxLjUgLTI4aC0xOHEtODkgMCAtMTY2LjUgMzd0LTEyOCAxMTMuNXQtNTAuNSAxNzkuNWgxNTBxMCAtNTEgMjAgLTg4LjV0NTIgLTU2dDYyLjUgLTI3dDYwLjUgLTguNWgxOApxMTk1IDAgMTk1IDMyMnYyMHEwIDI2NyAtMTk1IDI2N2gtMTY4djE1MGgxNjlxMzEgMCA2MC41IDIzLjV0NDggNTZ0MjkuNSA2Mi41dDExIDQ2djQxcTAgMTYyIC0xNTAgMTYyaC0xOHEtNjMgMCAtMTEyLjUgLTI5LjV0LTY5LjUgLTgxLjVsLTE0MCA1MnEzOCAxMDEgMTI4IDE1NXQxOTQgNTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZvdXIiIHVuaWNvZGU9IjQiIApkPSJNNTk3IDEwNTlsLTMwNSAtNTU3aDMwNXY1NTd6TTkwIDQ0N2w1MzYgOTc4aDEyMXYtOTIzaDgzdi0xNTBoLTgzdi0zNTJoLTE1MHYzNTJoLTUwN3Y5NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZml2ZSIgdW5pY29kZT0iNSIgCmQ9Ik00NzAgODA0aC0yMnEtMzMgMCAtODYuNSAtNDR0LTgyLjUgLTEzM2wtMTQ2IDExNGw3MiA2NTloNTY5di0xNTBoLTQzNWwtMzcgLTM0OHE3OSA1MiAxNTAgNTJoMThxODcgMCAxNTQuNSAtMzh0MTA4IC0xMDMuNXQ2MS41IC0xNDh0MjEgLTE3Ny41di02MHEwIC0xMTMgLTIzLjUgLTE5OHQtNTggLTEzMnQtODMuNSAtNzZ0LTkwLjUgLTM3LjV0LTg5LjUgLTguNWgtNjhxLTk0IDAgLTE4NSA2MXQtMTMzIDE2MmwxMjkgODgKcTE3IC03MyA3NiAtMTE3dDExMyAtNDRoNjhxNDQgMCA3NiAxMnQ2MC41IDQzdDQzLjUgOTN0MTUgMTU0djYwcTAgNTcgLTkgMTA4LjV0LTI5LjUgMTAwLjV0LTYwLjUgNzguNXQtOTYgMjkuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2l4IiB1bmljb2RlPSI2IiAKZD0iTTI1NyA0ODd2LTYwcTAgLTU2IDkgLTEwNXQyOS41IC05NS41dDYwLjUgLTc0dDk2IC0yNy41aDE4cTU2IDAgOTYgMjYuNXQ2MC41IDcydDI5LjUgOTUuNXQ5IDEwOHY2MHEwIDE3MSAtNTAuNSAyNDR0LTE0NC41IDczaC0xOHEtNTYgMCAtOTYgLTI5LjV0LTYwLjUgLTc4LjV0LTI5LjUgLTEwMC41dC05IC0xMDguNXpNNDUyIDk1NGgxOHEzOCAwIDczLjUgLTcuNXQ3Ni41IC0yNXQ3NC41IC01MnQ2MS41IC04NHQ0My41IC0xMjYKdDE1LjUgLTE3Mi41di02MHEwIC0yMDcgLTkwLjUgLTMyOS41dC0yNTQuNSAtMTIyLjVoLTE4cS0xNTMgMCAtMjQ5IDExOC41dC05NiAzMzMuNXY1NDdxMSAxOTggOTYgMzI0LjV0MjQ5IDEyNi41aDE4cTExOSAwIDE5OC41IC0zNy41dDExNy41IC0xMjYuNWwtMTM4IC01OHEtMTYgMzggLTU2IDU1dC0xMjIgMTdoLTE4cS01NSAwIC05NS41IC0zMC41dC02MC41IC04MHQtMjkuNSAtOTYuNXQtOS41IC05NHYtODZxODAgNjYgMTk1IDY2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzZXZlbiIgdW5pY29kZT0iNyIgCmQ9Ik0xOTAgMHE1NiAyOTkgMTYyLjUgNTkzLjV0MjcwLjUgNjU2LjVoLTUzM3YxNTBoNzQydi01NGwtMjQgLTUycS0xODEgLTM5MiAtMjkzLjUgLTY5Mi41dC0xNzEuNSAtNjAxLjVoLTE1M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZWlnaHQiIHVuaWNvZGU9IjgiIApkPSJNNDUxIDg4NGgyMHE2NiAwIDEwNy41IDQ2dDQxLjUgMTAzdjcycTAgODYgLTQwIDEyOHQtMTEwIDQyaC0xOHEtNTkgMCAtMTA0LjUgLTQ2LjV0LTQ1LjUgLTEyMi41di03NnEwIC0xMSA4IC0zMi41dDIzLjUgLTQ4dDQ2LjUgLTQ2dDcxIC0xOS41ek03NzAgMTEwNXYtNzJxMCAtNjAgLTI0LjUgLTExOS41dC02Ny41IC05OS41cTEzNyAtMTE0IDEzNyAtMzg3di01MnEwIC05NSAtMjkgLTE3Mi41dC03Ny41IC0xMjYuNXQtMTEwIC03NQp0LTEyOC41IC0yNmgtMThxLTE0NyAwIC0yNDYgMTA0LjV0LTk5IDI5NS41djUycTAgMjY0IDE0NiAzODhxLTM5IDM2IC03MCA5OC41dC0zMSAxMjAuNXY3MnEwIDE0OCA4MyAyMzMuNXQyMTcgODUuNWgxOHE2NCAwIDExNiAtMTYuNXQ5NC41IC01Mi41dDY2IC05OS41dDIzLjUgLTE1MS41ek00NzEgNzM0aC0yMHEtNTUgMCAtOTUgLTI4dC02MC41IC03NXQtMjkuNSAtOTcuNXQtOSAtMTA2LjV2LTUycTAgLTEyMyA1MyAtMTg2LjV0MTQyIC02My41CmgxOHE5MyAwIDE0NCA2NXQ1MSAxODV2NTJxMCAxNjkgLTUwIDIzOHQtMTQ0IDY5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJuaW5lIiB1bmljb2RlPSI5IiAKZD0iTTY2NSA5MzB2NzVxMCAxMzMgLTU2IDIwMS41dC0xMzkgNjguNWgtMThxLTE5NSAwIC0xOTUgLTI3MHYtNzVxMCAtODIgMTggLTE0M3Q0OC41IC05NHQ2NC41IC00OXQ3MSAtMTZoMTFxNDQgMCA3NiAxMnQ2MC41IDQzLjV0NDMuNSA5My41dDE1IDE1M3pNNDQ1IDQ3OHEtNDEgMCAtODMgMTEuNXQtODkgNDMuNXQtODMgODF0LTU5LjUgMTMwLjV0LTIzLjUgMTg1LjV2NzVxMCAyMTMgOTEuNSAzMTYuNXQyNTMuNSAxMDMuNWgxOApxMTYxIDAgMjUzIC0xMTEuNXQ5MiAtMzA4LjV2LTU5NHEwIC0xMDAgLTIzIC0xNzguNXQtNTguNSAtMTI1LjV0LTgzIC03OHQtOTEuNSAtNDIuNXQtODkgLTExLjVoLTE4cS0xMTggMCAtMTk3LjUgMzcuNXQtMTE3LjUgMTI2LjVsMTM4IDU4cTE2IC0zOCA1Ni41IC01NXQxMjAuNSAtMTdoMThxODcgMCAxNDEgNzJ0NTQgMjE0djEyMnEtNzkgLTU1IC0xOTUgLTU1aC0yNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29sb24iIHVuaWNvZGU9IjoiIApkPSJNNTE0IDgxOGgtMnYxMmgtMnYtMTRoNHYyek01MDYgODE4aC0ydjZoMnYtNnpNNDQ0IDgzNmgydjZoNHYtNmgydjE0aC02bC0yIC00di0xMHpNNDQ3IDg0OGgzdi00aC00djJ6TTQ1OCA4NDR2LThoMnY4bC0xIDJoLTV2LTEwaDJ2OGgyek00NjYgODQ0di04aDJ2OGwtMSAyaC01di0xMGgydjhoMnpNNDcyIDg0MGgydi0yaC0ydjJ6TTQ3MSA4MzZoNXY4bC0xIDJoLTV2LTJoNHYtMmgtM2wtMSAtMnYtMnpNNDgyIDgyNHYtOGgydjhsLTEgMmgtMwp2NGgtMnYtMTRoMnY4aDJ6TTQ3NSA4MjRoLTV2NGg2djJoLTdsLTEgLTJ2LTRsMSAtMmg1di00aC02di0yaDdsMSAydjR6TTQ5MCA4MThoLTJ2OGgtMnYtOGwxIC0yaDV2MTBoLTJ2LTh6TTQ5NiA4MTh2Nmgydi02aC0yek00OTUgODI2bC0xIC0ydi02bDEgLTJoM3YtMmgtNHYtMmg1bDEgMnYxMmgtNXpNNTAzIDgyNmwtMSAtMnYtNmwxIC0yaDRsMSAydjZsLTEgMmgtNHpNNjA3IDkxN3EwIC02MCAtNDEuNSAtMTAyLjV0LTEwNS41IC00Mi41CnEtNjIgMCAtMTA0IDQyLjV0LTQyIDEwMi41cTAgNTkgNDEgMTAydDEwNSA0M3E2MyAwIDEwNSAtNDIuNXQ0MiAtMTAyLjV6TTUxNCAxMDBoLTJ2MTJoLTJ2LTE0aDR2MnpNNTA2IDEwMGgtMnY2aDJ2LTZ6TTQ0NCAxMThoMnY2aDR2LTZoMnYxNGgtNmwtMiAtNHYtMTB6TTQ0NyAxMzBoM3YtNGgtNHYyek00NTggMTI2di04aDJ2OGwtMSAyaC01di0xMGgydjhoMnpNNDY2IDEyNnYtOGgydjhsLTEgMmgtNXYtMTBoMnY4aDJ6TTQ3MiAxMjJoMnYtMgpoLTJ2MnpNNDcxIDExOGg1djhsLTEgMmgtNXYtMmg0di0yaC0zbC0xIC0ydi0yek00ODIgMTA2di04aDJ2OGwtMSAyaC0zdjRoLTJ2LTE0aDJ2OGgyek00NzUgMTA2aC01djRoNnYyaC03bC0xIC0ydi00bDEgLTJoNXYtNGgtNnYtMmg3bDEgMnY0ek00OTAgMTAwaC0ydjhoLTJ2LThsMSAtMmg1djEwaC0ydi04ek00OTYgMTAwdjZoMnYtNmgtMnpNNDk1IDEwOGwtMSAtMnYtNmwxIC0yaDN2LTJoLTR2LTJoNWwxIDJ2MTJoLTV6TTUwMyAxMDgKbC0xIC0ydi02bDEgLTJoNGwxIDJ2NmwtMSAyaC00ek02MDcgMTk5cTAgLTYwIC00MS41IC0xMDIuNXQtMTA1LjUgLTQyLjVxLTYyIDAgLTEwNCA0Mi41dC00MiAxMDIuNXEwIDU5IDQxIDEwMnQxMDUgNDNxNjMgMCAxMDUgLTQyLjV0NDIgLTEwMi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzZW1pY29sb24iIHVuaWNvZGU9IjsiIApkPSJNNTE0IDc2MGgtMnYxMmgtMnYtMTRoNHYyek01MDYgNzYwaC0ydjZoMnYtNnpNNDQ0IDc3OGgydjZoNHYtNmgydjE0aC02bC0yIC00di0xMHpNNDQ3IDc5MGgzdi00aC00djJ6TTQ1OCA3ODZ2LThoMnY4bC0xIDJoLTV2LTEwaDJ2OGgyek00NjYgNzg2di04aDJ2OGwtMSAyaC01di0xMGgydjhoMnpNNDcyIDc4Mmgydi0yaC0ydjJ6TTQ3MSA3NzhoNXY4bC0xIDJoLTV2LTJoNHYtMmgtM2wtMSAtMnYtMnpNNDgyIDc2NnYtOGgydjhsLTEgMmgtMwp2NGgtMnYtMTRoMnY4aDJ6TTQ3NSA3NjZoLTV2NGg2djJoLTdsLTEgLTJ2LTRsMSAtMmg1di00aC02di0yaDdsMSAydjR6TTQ5MCA3NjBoLTJ2OGgtMnYtOGwxIC0yaDV2MTBoLTJ2LTh6TTQ5NiA3NjB2Nmgydi02aC0yek00OTUgNzY4bC0xIC0ydi02bDEgLTJoM3YtMmgtNHYtMmg1bDEgMnYxMmgtNXpNNTAzIDc2OGwtMSAtMnYtNmwxIC0yaDRsMSAydjZsLTEgMmgtNHpNNjA3IDg1OXEwIC02MCAtNDEuNSAtMTAyLjV0LTEwNS41IC00Mi41CnEtNjIgMCAtMTA0IDQyLjV0LTQyIDEwMi41cTAgNTkgNDEgMTAydDEwNSA0M3E2MyAwIDEwNSAtNDIuNXQ0MiAtMTAyLjV6TTYwNyA2NXEwIC0zNDYgLTI5OCAtMzgwbC0xNSA1NXE0OSAxOCA5Ni41IDU5dDQ3LjUgODVxMCA1NiAtMzQgNjZxLTQ1IDEzIC02Ny41IDQ0LjV0LTIyLjUgNzAuNXEwIDU5IDQxLjUgMTAydDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGVzcyIgdW5pY29kZT0iJiN4M2M7IiAKZD0iTTkwIDYzNmw3NDIgNjExdi0xOTVsLTU1MCAtNDUybDU1MCAtNDUydi0xOTVsLTc0MiA2MTF2NzJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVxdWFsIiB1bmljb2RlPSI9IiAKZD0iTTg3MiA5MTd2LTE1MGgtODIydjE1MGg4MjJ6TTg3MiA0NzV2LTE1MGgtODIydjE1MGg4MjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImdyZWF0ZXIiIHVuaWNvZGU9IiYjeDNlOyIgCmQ9Ik05MCAxMjQ3bDc0MiAtNjExdi03MmwtNzQyIC02MTF2MTk1bDU1MCA0NTJsLTU1MCA0NTJ2MTk1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJxdWVzdGlvbiIgdW5pY29kZT0iPyIgCmQ9Ik0zODYgNDgwcTAgMTMwIDg4IDI0MGwxMzEgMTYycTYwIDczIDYwIDE0MnY3MXEwIDM1IC05IDY1dC0yOS41IDU3dC02MC41IDQyLjV0LTk2IDE1LjVoLTE4cS0xMDYgMCAtMTUwIC01MnQtNDUgLTEyOWwtMTUwIDJxMSAxNDkgOTQgMjM5dDI1MSA5MGgxOHExNjAgMCAyNTIuNSAtOTEuNXQ5Mi41IC0yMzguNXYtNzFxMCAtMTE2IC05NCAtMjM2bC0xMjkgLTE2MnEtNTYgLTcwIC01NiAtMTQ2di0xMDBoLTE1MHYxMDB6TTU4NyA5CnEwIC01MSAtMzYgLTg4LjV0LTkwIC0zNy41dC05MCAzN3QtMzYgODl0MzUgODkuNXQ5MSAzNy41cTU1IDAgOTAuNSAtMzd0MzUuNSAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImF0IiB1bmljb2RlPSJAIiAKZD0iTTYxMSA1MTBxNDUgMCA2NyAzMnQyNyA5N3YyODdoLTk0cS00NSAwIC03MS41IC01MXQtMjYuNSAtMTQxcTAgLTUxIDAuNSAtNzcuNXQzLjUgLTU3dDkgLTQzLjV0MTcuNSAtMjZ0MjcuNSAtMTYuNXQ0MCAtMy41ek0zNjMgNzM0cTAgNjYgMTIuNSAxMjMuNXQzOS41IDEwOC41dDc3IDgwLjV0MTE5IDI5LjVoOTRxLTIgNDYgLTE3LjUgODEuNXQtMzkuNSA1Ny41dC01NiAzNnQtNjQgMTl0LTY3IDVxLTc4IDAgLTEzNC41IC01M3QtODUgLTEzOQp0LTQxLjUgLTE3My41dC0xMyAtMTc3LjVxMCAtMjY3IDc2IC00Mzd0MTk4IC0xNzBxNDYgMCA3Ny41IDJ0NzcgMTZ0NzEuNSA0MGwxMDYgLTEwNnEtNTkgLTYwIC0xNDEgLTgxdC0xOTEgLTIxcS0xOTQgMCAtMzA5IDE5Ny41dC0xMTUgNTU5LjVxMCAxMDQgMTAuNSAxOTZ0NDAgMTg2dDc1LjUgMTYwLjV0MTIyLjUgMTA4LjV0MTc1LjUgNDJxMTc3IDAgMjgzLjUgLTk1LjV0MTEwLjUgLTI1My41di03MzZoLTE1MHY0MnEtNDQgLTIyIC05NCAtMjIKcS0yNDggMCAtMjQ4IDM3NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iQSIgdW5pY29kZT0iQSIgCmQ9Ik0zMjkgMzk5aDI2NGwtMTMyIDYwNXpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJCIiB1bmljb2RlPSJCIiAKZD0iTTQyMCAxNDAwcTM2IDAgNTkgLTF0NjMgLTd0NjYuNSAtMTd0NTkgLTMzLjV0NTEuNSAtNTR0MzIuNSAtODF0MTMuNSAtMTExLjV2LTcxcTAgLTE1MCAtNzMgLTIyNnExMjMgLTkzIDEyMyAtMzAzdi0xNDhxMCAtMTYyIC04Ni41IC0yNTQuNXQtMjU4LjUgLTkyLjVoLTM2M3YxNDAwaDMxM3pNNjY1IDM0N3YxNDhxMCA2NiAtMTIgMTA5dC0zOC41IDY2LjV0LTYwIDMyLjV0LTg0LjUgOWgtMjEzdi01NjJoMjEzcTEwNSAwIDE1MCA0Ny41CnQ0NSAxNDkuNXpNNjE1IDEwOTVxMCAxMDAgLTM4IDEyNy41dC0xNTcgMjcuNWgtMTYzdi0zODhoMTYzcTExNyAwIDE1NiAzNC41dDM5IDEyNy41djcxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJDIiB1bmljb2RlPSJDIiAKZD0iTTQ4NyAtMjVoLTMxcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMzJxNTQgMCAxMDAuNSAtMTZ0NzggLTM4dDU4IC01N3Q0MSAtNjJ0MjcgLTY1dDE2IC01M3Q4LjUgLTM5bC0xNDYgLTMwcS0xMyA2NCAtMzMgMTA3LjV0LTQ1LjUgNjV0LTUwIDI5LjV0LTU0LjUgOGgtMzJxLTEwNSAwIC0xNTYuNSAtMTI1dC01MS41IC0zODd2LTY3cTAgLTczIDQgLTE0MQp0MTcuNSAtMTQ5LjV0MzUgLTE0MXQ2MSAtOTkuNXQ5MS41IC00MGgzMXExNiAwIDI5LjUgMi41dDM1LjUgMTR0MzkuNSAzMnQzNi41IDYxLjV0MzIgOTdsMTQ2IC0zNHEtMjAgLTg1IC01My41IC0xNDh0LTY2LjUgLTk1LjV0LTc0IC01MS41dC02OC41IC0yMy41dC01Ni41IC00LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkQiIHVuaWNvZGU9IkQiIApkPSJNODI1IDc3NXYtMTA0cTAgLTEyMSAtMTIuNSAtMjIxdC0zMy41IC0xNjh0LTUxLjUgLTEyMHQtNjIgLTgydC02OSAtNDl0LTY5IC0yNXQtNjYuNSAtNmgtMzU0djE0MDBoMzU0cTc1IDAgMTM0IC0yNHQ5OCAtNjkuNXQ2NiAtMTAydDQxIC0xMzAuNXQxOS41IC0xNDQuNXQ1LjUgLTE1NC41ek00NjEgMTI1MGgtMjA0di0xMTAwaDIwNHE0NCAwIDc5IDIyLjV0NTcuNSA2M3QzOC41IDg5LjV0MjQgMTExdDExLjUgMTE3LjV0My41IDExNy41djEwNApxMCAxNzcgLTI0LjUgMjgyLjV0LTcwLjUgMTQ5dC0xMTkgNDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iRSIgdW5pY29kZT0iRSIgCmQ9Ik0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJGIiB1bmljb2RlPSJGIiAKZD0iTTI1NyA3MTJ2LTYzNmgtMTUwdjEzMjRoNzI1di0xNTBoLTU3NXYtMzg4aDQ4M3YtMTUwaC00ODN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkciIHVuaWNvZGU9IkciIApkPSJNODE1IDI0N3EtNDEgLTEzNyAtMTMxIC0yMDQuNXQtMTk3IC02Ny41aC0zMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjV0LTg3IDEyMnQtNjAgMjEwLjV0LTI0IDMxNHY2N3EwIDY2MiAzNTggNjYyaDMycTU0IDAgMTAwLjUgLTE2dDc4IC0zOHQ1OCAtNTd0NDEgLTYydDI3IC02NXQxNiAtNTN0OC41IC0zOWwtMTQ2IC0zMHEtMTMgNjQgLTMzIDEwNy41dC00NS41IDY1dC01MCAyOS41dC01NC41IDhoLTMycS0xMDUgMCAtMTU2LjUgLTEyNQp0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMzFxNjMgMCAxMTAuNSA0MC41dDY3LjUgMTAyLjV2Mjc0aC0xNjF2MTUwaDMxMXYtNDQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJIIiB1bmljb2RlPSJIIiAKZD0iTTI1NyAwaC0xNTB2MTQwMGgxNTB2LTU5M2g0MDh2NTkzaDE1MHYtMTQwMGgtMTUwdjY1N2gtNDA4di02NTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkkiIHVuaWNvZGU9IkkiIApkPSJNODMyIDE0MDB2LTE1MGgtMjk2di0xMTAwaDI5NnYtMTUwaC03NDJ2MTUwaDI5NnYxMTAwaC0yOTZ2MTUwaDc0MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iSiIgdW5pY29kZT0iSiIgCmQ9Ik04NTIgMTQwMHYtMTUwaC0xNzJ2LTkxM3EwIC0xNjUgLTgzIC0yNjMuNXQtMjE3IC05OC41aC0xOHEtNTUgMCAtMTAwIDEydC03NC41IDMzLjV0LTUwLjUgNDN0LTM0IDUwdC0xOC41IDQ0dC05LjUgMzMuNWwxNDYgMzRxMTIgLTUzIDQ0LjUgLTc2LjV0OTYuNSAtMjMuNWgxOHE0MyAwIDc0IDE5LjV0NDYuNSA1MnQyMi41IDY3dDcgNzMuNXY5MTNoLTIxMnYxNTBoNTM0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJLIiB1bmljb2RlPSJLIiAKZD0iTTEwOCAwdjE0MDBoMTUwdi02NDhsMzk3IDY0OGgxNzZsLTM2NiAtNTk3bDM4MyAtODAzaC0xNjdsLTMxMCA2NTBsLTExMyAtMTg0di00NjZoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iTCIgdW5pY29kZT0iTCIgCmQ9Ik0yNTcgMTUxaDU3NXYtMTUxaC03MjV2MTQwMGgxNTB2LTEyNDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik0iIHVuaWNvZGU9Ik0iIApkPSJNMjYgMGwxMDEgMTQwMGgxNTNsMTgxIC03MzVsMTgxIDczNWgxNTNsMTAxIC0xNDAwaC0xNTFsLTY2IDkyM2wtMTc2IC03MTJoLTg0bC0xNzYgNzEybC02NiAtOTIzaC0xNTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik4iIHVuaWNvZGU9Ik4iIApkPSJNMjU3IDBoLTE1MHYxNDAwaDEzNWw0MjMgLTk4NnY5ODZoMTUwdi0xNDAwaC0xMzZsLTQyMiA5ODV2LTk4NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iTyIgdW5pY29kZT0iTyIgCmQ9Ik04MjUgNzY1di02OXEwIC0xNzkgLTI0IC0zMTMuNXQtNjAgLTIxMHQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjUKdDkxLjUgLTQwaDExcTUyIDAgOTEuNSA0MC41dDYxIDk5LjV0MzQuNSAxNDAuNXQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iUCIgdW5pY29kZT0iUCIgCmQ9Ik0yNTcgNjQydi02NDJoLTE1MHYxNDAwaDM2M3E3OCAwIDEzNyAtMTV0MTA4IC01MS41dDc0LjUgLTEwNC41dDI1LjUgLTE2NnYtOTFxMCAtNjcgLTE2IC0xMjIuNXQtNTIuNSAtMTA0dC0xMDcgLTc2dC0xNjkuNSAtMjcuNWgtMjEzek00NzAgNzkycTExMCAwIDE1Mi41IDQxdDQyLjUgMTM5djkxcTAgMTEwIC00MC41IDE0OC41dC0xNTQuNSAzOC41aC0yMTN2LTQ1OGgyMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlEiIHVuaWNvZGU9IlEiIApkPSJNNDY3IDEyNzVoLTEycS0xMDUgMCAtMTU2LjUgLTEyNXQtNTEuNSAtMzg3di02N3EwIC03MyA0IC0xNDF0MTcuNSAtMTQ5LjV0MzUgLTE0MXQ2MSAtOTkuNXQ5MS41IC00MGgxMXEyNSAwIDQ2IDlsLTExOSAyMzFsMTM0IDY4bDg5IC0xNzNxNTggMTQ3IDU4IDQzNnY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXpNODA3IC0xMTBsLTEzMiAtNjhsLTkzIDE3OHEtNTYgLTI1IC0xMTUgLTI1aC0xMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjUKdC04NyAxMjJ0LTYwIDIxMC41dC0yNCAzMTR2NjdxMCA2NjIgMzU4IDY2MmgxMnEzNTggMCAzNTggLTY2MHYtNjlxMCAtNDE2IC0xMjYgLTU5NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iUiIgdW5pY29kZT0iUiIgCmQ9Ik00NzAgNzkycTEyMCAwIDE2NiA0NnQ0NiAxMzV2OTBxMCAxMDUgLTQ1LjUgMTQ2dC0xNjYuNSA0MWgtMjMxdi00NThoMjMxek04OSAwdjE0MDBoMzgxcTYyIDAgMTEyLjUgLTl0OTggLTMydDgwIC02MC41dDUyIC05N3QxOS41IC0xMzguNXYtOTBxMCAtNTUgLTEyLjUgLTEwMy41dC00MC41IC05NC41dC04MSAtNzl0LTEyNyAtNDZsMjg4IC02NTBoLTE2NGwtMjg1IDY0MmgtMTcxdi02NDJoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iUyIgdW5pY29kZT0iUyIgCmQ9Ik00NTIgMTI1aDE4cTg0IDAgMTQ5LjUgNjMuNXQ2NS41IDE0OC41djMwcTAgNzUgLTM2LjUgMTUzdC0xMDAuNSAxMTBsLTI2MiAxMzNxLTg0IDQzIC0xMjguNSAxMTZ0LTQ0LjUgMTU0djMwcTAgMTQ5IDk0LjUgMjU1LjV0MjQwLjUgMTA2LjVoMjdxMTI0IDAgMjE1LjUgLTU3dDEyNS41IC0xNjlxMTUgLTQ5IDE1IC0xMzZoLTE1MHEwIDYxIC05IDkycS0zNiAxMjAgLTE5NyAxMjBoLTI3cS04MSAwIC0xMzMgLTYxLjV0LTUyIC0xNTAuNXYtMzAKcTAgLTM0IDIwIC03MnQ3MSAtNjRsMjY0IC0xMzVxMTAzIC01MyAxNjAgLTE2Ny41dDU3IC0yMjcuNXYtMzBxMCAtMTQ4IC0xMTAgLTI1NXQtMjU1IC0xMDdoLTE4cS05NiAwIC0xODYgNTMuNXQtMTQ2IDE0Mi41dC01NiAxODZoMTUwcTAgLTg2IDc2IC0xNTl0MTYyIC03M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVCIgdW5pY29kZT0iVCIgCmQ9Ik04NTIgMTQwMHYtMTUwaC0zMTZ2LTEyNTBoLTE1MHYxMjUwaC0zMTZ2MTUwaDc4MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVSIgdW5pY29kZT0iVSIgCmQ9Ik0yNTcgMzM3cTAgLTExNSA1MC41IC0xNjMuNXQxNDQuNSAtNDguNWgxOHE5NCAwIDE0NC41IDQ4LjV0NTAuNSAxNjMuNXYxMDYzaDE1MHYtMTA2M3EwIC0xNzIgLTkxLjUgLTI2N3QtMjUzLjUgLTk1aC0xOHEtMTYyIDAgLTI1My41IDk0LjV0LTkxLjUgMjY3LjV2MTA2M2gxNTB2LTEwNjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlYiIHVuaWNvZGU9IlYiIApkPSJNMzkxIC0yNWwtMzA1IDE0MjVoMTUzbDIyMiAtMTAzOGwyMjQgMTAzOGgxNTNsLTMwNyAtMTQyNWgtMTQweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJXIiB1bmljb2RlPSJXIiAKZD0iTTEyNyAwbC0xMDEgMTQwMGgxNTFsNjYgLTkyMmwxNzYgNzEyaDg0bDE3NiAtNzEybDY2IDkyMmgxNTFsLTEwMSAtMTQwMGgtMTUzbC0xODEgNzM2bC0xODEgLTczNmgtMTUzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJYIiB1bmljb2RlPSJYIiAKZD0iTTk0IDBsMjg3IDcwMGwtMjg3IDcwMGgxNjFsMjA2IC01MDNsMjA2IDUwM2gxNjFsLTI4NyAtNzAwbDI4NyAtNzAwaC0xNjFsLTIwNiA1MDNsLTIwNiAtNTAzaC0xNjF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlkiIHVuaWNvZGU9IlkiIApkPSJNMzg2IC0yNXY1MjZsLTI5NiA4OTloMTU3bDIxNSAtNjQ4bDIxMyA2NDhoMTU3bC0yOTUgLTg5OWwtMSAtNTI2aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IloiIHVuaWNvZGU9IloiIApkPSJNOTAgMTI1MHYxNTBoNzQydi0xMzlsLTU2NyAtMTExMGg1Njd2LTE1MWgtNzQydjE0MGw1NjcgMTExMGgtNTY3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJicmFja2V0bGVmdCIgdW5pY29kZT0iWyIgCmQ9Ik00MjUgMTQwNXYtMTQxMGgzMTV2LTE1MGgtNDY1djE3MTBoNDY1di0xNTBoLTMxNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmFja3NsYXNoIiB1bmljb2RlPSJcIiAKZD0iTTExMiAxNDAwbDE0MCA1Mmw1NTggLTE0NTJsLTE0MCAtNTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJyYWNrZXRyaWdodCIgdW5pY29kZT0iXSIgCmQ9Ik0xODIgMTU1NWg0NjV2LTE3MTBoLTQ2NXYxNTBoMzE1djE0MTBoLTMxNXYxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFzY2lpY2lyY3VtIiB1bmljb2RlPSJeIiAKZD0iTTUyNSAxNDI1bDI3NyAtNDA5bC0xMjQgLTg0bC0yMTcgMzE5bC0yMTcgLTMxOWwtMTI0IDg0bDI3NyA0MDloMTI4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmRlcnNjb3JlIiB1bmljb2RlPSJfIiAKZD0iTTgzMiAtMTd2LTE1MGgtNzQydjE1MGg3NDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImdyYXZlIiB1bmljb2RlPSJgIiAKZD0iTTY4NSAxMDk5cTE3IC0yMCAxNyAtNDRxMCAtMjkgLTI0IC01M3QtNTIgLTI0cS0yMyAwIC00NSAxN2wtMzE2IDI0N3EtNDUgMzcgLTQ1IDk5cTAgNTMgMzIgODdxMjkgMzIgODQgMzJxNjQgMCAxMDAgLTQ2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhIiB1bmljb2RlPSJhIiAKZD0iTTQ1MiA0ODZxLTUwIDAgLTkwIC0xN3QtNjEuNSAtNDJ0LTMyLjUgLTQ4LjV0LTExIC00MS41di03OHEwIC00MyA0OS41IC04OC41dDE0NS41IC00NS41aDE4cTc0IDAgMTM0LjUgNjYuNXQ2MC41IDExMC41djE4NGgtMjEzek00NTIgMTA0OWgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NDlxLTg3IC02NiAtMTk1IC03NGgtMThxLTc4IDAgLTE0NC41IDI1dC0xMDkuNSA2Ngp0LTY3IDkxdC0yNCAxMDJ2NzhxMCA1MSAyNCAxMDMuNXQ2Ni41IDk2LjV0MTA5LjUgNzEuNXQxNDUgMjcuNWgyMTN2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS04MiAwIC0xMjEuNSAtMTcuNXQtNTUuNSAtNTYuNWwtMTM4IDU4cTM3IDkwIDExNi41IDEyOHQxOTguNSAzOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYiIgdW5pY29kZT0iYiIgCmQ9Ik0yNTcgNDI3cTAgLTEzNSA1NyAtMjE4LjV0MTM4IC04My41aDE4cTU2IDAgOTYgMjYuNXQ2MC41IDcydDI5LjUgOTUuNXQ5IDEwOHYxNzBxMCA1OCAtOSAxMDcuNXQtMjkuNSA5NS41dC02MC41IDcyLjV0LTk2IDI2LjVoLTE4cS01NiAwIC05NiAtMjYuNXQtNjAuNSAtNzIuNXQtMjkuNSAtOTUuNXQtOSAtMTA3LjV2LTE3MHpNNDUyIDEwNDloMThxMTEzIDAgMTkyLjUgLTYxdDExNiAtMTYxdDM2LjUgLTIzMHYtMTcwCnEwIC0yMDcgLTkwLjUgLTMyOS41dC0yNTQuNSAtMTIyLjVoLTE4cS0xMTAgMCAtMTk1IDczdi00OGgtMTUwdjE0MDBoMTUwdi00MTNxODEgNjIgMTk1IDYyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjIiB1bmljb2RlPSJjIiAKZD0iTTQ3MCA4OThoLTE4cS01NiAwIC05NiAtMjYuNXQtNjAuNSAtNzJ0LTI5LjUgLTk1dC05IC0xMDcuNXYtMTcwcTAgLTEzNSA1NyAtMjE4LjV0MTM4IC04My41aDE4cTgzIDAgMTI1IDE5LjV0NTggNjcuNWwxNDIgLTQ4cS02MyAtMTg5IC0zMjUgLTE4OWgtMThxLTE0OCAwIC0yNDYuNSAxMjd0LTk4LjUgMzI1djE3MHEwIDEzMCAzNi41IDIzMHQxMTYgMTYwLjV0MTkyLjUgNjAuNWgxOHEyNjggMCAzMjcgLTE5NmwtMTQ0IC00NApxLTkgMjkgLTI1IDQ3LjV0LTU1IDMwLjV0LTEwMyAxMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZCIgdW5pY29kZT0iZCIgCmQ9Ik0yNTcgNTk3di0xNzBxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxNTYgMCA5NiAyNi41dDYwLjUgNzJ0MjkuNSA5NS41dDkgMTA4djE3MHEwIDU4IC05IDEwNy41dC0yOS41IDk1LjV0LTYwLjUgNzIuNXQtOTYgMjYuNWgtMThxLTU2IDAgLTk2IC0yNi41dC02MC41IC03Mi41dC0yOS41IC05NS41dC05IC0xMDcuNXpNNDUyIDEwNDloMThxMTE0IDAgMTk1IC02MnY0MTNoMTUwdi0xNDAwaC0xNTB2MzdxLTgxIC02MiAtMTk1IC02MgpoLTE4cS0xNDggMCAtMjQ2LjUgMTI3LjV0LTk4LjUgMzI0LjV2MTcwcTAgMTMwIDM2LjUgMjMwdDExNiAxNjF0MTkyLjUgNjF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImUiIHVuaWNvZGU9ImUiIApkPSJNMjU3IDQ4NnYtMTQ5cTAgLTkwIDQ5LjUgLTE1MXQxNDUuNSAtNjFoMThxOTUgMCAxMzQgMjQuNXQ1MiA3Mi41bDE0NCAtNDBxLTU2IC0yMDcgLTMzMCAtMjA3aC0xOHEtMTYwIDAgLTI1Mi41IDEwNnQtOTIuNSAyNTZ2MzgycTAgNTMgOSA5OHQzMyA4OXQ2MiA3NC41dDk5LjUgNDkuNXQxNDEuNSAxOWgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtMjMzaC01NTh6TTY2NSA2MzZ2ODMKcTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtMTA5IDAgLTE1MiAtNDF0LTQzIC0xMzl2LTgzaDQwOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZiIgdW5pY29kZT0iZiIgCmQ9Ik02NjUgMTE4NXEwIDM2IC0zMSA2M3QtNzQgMjdoLTE4cS00OSAwIC03NyAtMjl0LTI4IC02MnYtMjUzaDMwM3YtMTUwaC0zMDN2LTc4MWgtMTUwdjc4MWgtMTk3djE1MGgxOTd2MjUzcTAgMjMgNSA0OS41dDIyIDYydDQzLjUgNjN0NzQuNSA0N3QxMTAgMTkuNWgxOHE3MiAwIDEzNyAtMzd0OTYgLTEwNnEyMiAtNDUgMjIgLTk3aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImciIHVuaWNvZGU9ImciIApkPSJNNjY1IC04N3EwIDEwIC0xMiAyN3QtMzMuNSAzNi41dC02MS41IDMzdC04OCAxMy41aC0xOHEtNzQgMCAtMTM0LjUgLTM2LjV0LTYwLjUgLTczLjV2LTIwcTAgLTQ1IDUzIC04NnQxNDIgLTQxaDE4cTY2IDAgMTMwLjUgMzQuNXQ2NC41IDkyLjV2MjB6TTQ3MCA4OTloLTE4cS03MCAwIC0xMzIuNSAtNTUuNXQtNjIuNSAtMTI0LjV2LTU2cTAgLTczIDYyIC0xMzV0MTMzIC02MmgxOHE3MSAwIDEzMyA2MnQ2MiAxMzV2NTYKcTAgNjkgLTYyLjUgMTI0LjV0LTEzMi41IDU1LjV6TTE3MiA2MnEtNjUgNjQgLTY1IDE1M3Y2NnEwIDk4IDc5IDE3NnEtNzkgMTAyIC03OSAyMDZ2NTZxMCAxMjkgMTA1IDIyOS41dDI0MCAxMDAuNWgxOHExMDkgMCAyMDYgLTcycTc0IDU3IDE1NiA1N3YtMTUwcS0zMCAwIC01NyAtMTlxNDAgLTcyIDQwIC0xNDZ2LTU2cTAgLTEzOCAtMTA2LjUgLTI0Mi41dC0yMzguNSAtMTA0LjVoLTE4cS03NyAwIC0xNTMgNDNxLTQyIC0zNSAtNDIgLTczdi03MQpxMCAtMzcgNDcgLTY5cTc0IDI3IDE0OCAyN2gxOHE4MSAwIDE0OSAtMjV0MTA5LjUgLTY0LjV0NjQgLTg0dDIyLjUgLTg2LjV2LTIwcTAgLTExMyAtMTA0IC0xOTUuNXQtMjQxIC04Mi41aC0xOHEtODcgMCAtMTU2LjUgMjcuNXQtMTA5IDcwLjV0LTU5LjUgODkuNXQtMjAgOTAuNXYyMHEwIDc0IDY1IDE0OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaCIgdW5pY29kZT0iaCIgCmQ9Ik0yNTcgMGgtMTUwdjE0MDBoMTUwdi00NDNxODkgOTIgMTk1IDkyaDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY3MTlxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS00OCAwIC05NC41IC01My41dC03My41IC0xMjMuNXQtMjcgLTEyNXYtNTk3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpIiB1bmljb2RlPSJpIiAKZD0iTTM1MiAxMjk3cTAgNDkgMzMuNSA4M3Q4Mi41IDM0dDgzLjUgLTM0dDM0LjUgLTgzdC0zNC41IC04M3QtODMuNSAtMzR0LTgyLjUgMzR0LTMzLjUgODN6TTE4MiAxMDI0aDM1NHYtODc0aDIwNHYtMTUwaC01NTh2MTUwaDIwNHY3MjRoLTIwNHYxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImoiIHVuaWNvZGU9ImoiIApkPSJNNTMzIDEyOTdxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNNDc2IC0yMTlxNTAgMCA3OS41IDI4dDI5LjUgODJ2OTgzaC0zMTh2MTUwaDQ2OHYtMTEzM3EwIC0xMTcgLTczLjUgLTE4OC41dC0xODUuNSAtNzEuNXEtMTA3IDAgLTE4MyA3Ny41dC03NiAxODEuNWgxNTBxMCAtNDIgMzIuNSAtNzUuNXQ3Ni41IC0zMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJrIiB1bmljb2RlPSJrIiAKZD0iTTEwNyAwdjE0MjVoMTUwdi04MzJsNDI1IDUxOGwxMTYgLTk2bC0zMjcgLTM5OWwzNTggLTYxNmgtMTc1bC0yODUgNDkybC0xMTIgLTEzNnYtMzU2aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImwiIHVuaWNvZGU9ImwiIApkPSJNMTgyIDE0MDBoMzU0di0xMjUwaDIwNHYtMTUwaC01NTh2MTUwaDIwNHYxMTAwaC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtIiB1bmljb2RlPSJtIiAKZD0iTTMxNiA4OTlxLTQxIDAgLTcwIC01NnQtMjkgLTEyNHYtNzE5aC0xNTB2MTAyNGgxNTBxNDcgMjUgOTkgMjVoMTBxMTA3IDAgMTYwIC02NXE3MCA2NSAxNDkgNjVoMTBxNDggMCA4NS41IC0xNHQ1OSAtMzl0MzYgLTUwLjV0MjAgLTU2dDcuNSAtNDcuNXQyIC0zM3YtODA5aC0xNTB2ODA5cTAgNTEgLTE0IDcwLjV0LTQ2IDE5LjVoLTEwcS00MyAwIC03MSAtNTV0LTI4IC0xMjV2LTcxOWgtMTUwdjgwOXEwIDUxIC0xNCA3MC41dC00NiAxOS41CmgtMTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im4iIHVuaWNvZGU9Im4iIApkPSJNMjU3IDBoLTE1MHYxMDI0aDE1MHYtNjdxODkgOTIgMTk1IDkyaDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY3MTlxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS00OCAwIC05NC41IC01My41dC03My41IC0xMjMuNXQtMjcgLTEyNXYtNTk3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvIiB1bmljb2RlPSJvIiAKZD0iTTgyNSA1NjJ2LTkycTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjV0MTU1LjUgMzkuNWgzOXE4OSAwIDE1NyAtMzl0MTA4LjUgLTEwN3Q2MSAtMTU0dDIwLjUgLTE4NnpNNDc4IDg5OGgtMzlxLTU1IDAgLTk0LjUgLTMwLjV0LTU5LjUgLTgyLjV0LTI5IC0xMDcKdC05IC0xMTd2LTkwcTAgLTYzIDkgLTExOS41dDI5LjUgLTExMHQ2MC41IC04NXQ5NSAtMzEuNWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNDkgLTUgOTR0LTE5IDkwdC0zNS41IDc4dC01Ni41IDUzLjV0LTgxIDIwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InAiIHVuaWNvZGU9InAiIApkPSJNMjU3IDQyN3EwIC0xMzUgNTcgLTIxOC41dDEzOCAtODMuNWgxOHE1NiAwIDk2IDI2LjV0NjAuNSA3MnQyOS41IDk1LjV0OSAxMDh2MTcwcTAgNTggLTkgMTA3LjV0LTI5LjUgOTUuNXQtNjAuNSA3Mi41dC05NiAyNi41aC0xOHEtNTYgMCAtOTYgLTI2LjV0LTYwLjUgLTcyLjV0LTI5LjUgLTk1LjV0LTkgLTEwNy41di0xNzB6TTI1NyAtMzg1aC0xNTB2MTQwOWgxNTB2LTM3cTgxIDYyIDE5NSA2MmgxOHExMTMgMCAxOTIuNSAtNjEKdDExNiAtMTYxdDM2LjUgLTIzMHYtMTcwcTAgLTIwNyAtOTAuNSAtMzI5LjV0LTI1NC41IC0xMjIuNWgtMThxLTExMCAwIC0xOTUgNzN2LTQzM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icSIgdW5pY29kZT0icSIgCmQ9Ik0yNTcgNTk3di0xNzBxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxNTYgMCA5NiAyNi41dDYwLjUgNzJ0MjkuNSA5NS41dDkgMTA4djE3MHEwIDU4IC05IDEwNy41dC0yOS41IDk1LjV0LTYwLjUgNzIuNXQtOTYgMjYuNWgtMThxLTU2IDAgLTk2IC0yNi41dC02MC41IC03Mi41dC0yOS41IC05NS41dC05IC0xMDcuNXpNNDUyIDEwNDloMThxMTE0IDAgMTk1IC02MnYzN2gxNTB2LTE0MDloLTE1MHY0MjJxLTgxIC02MiAtMTk1IC02MgpoLTE4cS0xNDggMCAtMjQ2LjUgMTI3LjV0LTk4LjUgMzI0LjV2MTcwcTAgMTMwIDM2LjUgMjMwdDExNiAxNjF0MTkyLjUgNjF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InIiIHVuaWNvZGU9InIiIApkPSJNMjU3IDBoLTE1MHYxMDI0aDE1MHYtMTI1cTExOSAxNTAgMjY1IDE1MGgxOHExOTkgMCAyNzQgLTE1MGwtMTM0IC02OHEtMTggMzUgLTQ5IDUxLjV0LTkxIDE2LjVoLTE4cS02MSAwIC0xMjMuNSAtNjYuNXQtMTAyIC0xNjcuNXQtMzkuNSAtMTk1di00NzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InMiIHVuaWNvZGU9InMiIApkPSJNNjY1IDcxOXEwIDc5IC01MS41IDEyOS41dC0xNDMuNSA1MC41aC0xOHEtOTYgMCAtMTQ1LjUgLTMyLjV0LTQ5LjUgLTc3LjV2LTEycTMgLTM1IDE3LjUgLTU2LjV0MjguNSAtMjYuNWwzNzcgLTE3NXE1NSAtMjYgOTUgLTgydDQwIC0xMzZ2LTQ2cTAgLTEyNCAtOTkgLTIwMnQtMjQ2IC03OGgtNDhxLTEwNCAwIC0xODUgNTR0LTEyMC41IDEzNS41dC0zOS41IDE3Mi41aDE1MHEwIC04MCA1My41IC0xNDZ0MTQxLjUgLTY2aDQ4CnE3OCAwIDEzNi41IDM0dDU4LjUgOTZ2NDZxMCAyNiAtMTYgNDkuNXQtMzMgMzIuNWwtMzc1IDE3M3EtMzcgMTggLTY1IDQ5LjV0LTQyIDY1dC0yMC41IDYwLjV0LTYuNSA0NnYxMnEwIDY2IDM0LjUgMTE4dDg4LjUgODJ0MTExIDQ1dDExMSAxNWgxOHExMTMgMCAxOTMgLTQ2LjV0MTE2IC0xMTkuNXQzNiAtMTY0aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InQiIHVuaWNvZGU9InQiIApkPSJNNTQwIDEyNXEzNyAwIDY5LjUgMjN0MzUuNSA2N2gxNTBxLTUgLTU5IC0yNyAtMTA0LjV0LTUwLjUgLTcwdC02NC41IC00MC41dC02Mi41IC0yMC41dC01MC41IC00LjVoLTE4cS05NyAwIC0xNzYgNjkuNXQtNzkgMTY2LjV2MTZsMzEgNjMxaC0yMDh2MTUwaDIxNWwyMSA0MTdoMTUwbC0yMCAtNDE3aDI4NHYtMTUwaC0yOTFsLTMyIC02Mzl2LThxMCAtMjkgMjkuNSAtNTcuNXQ3NS41IC0yOC41aDE4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1IiB1bmljb2RlPSJ1IiAKZD0iTTY2NSAxMDI0aDE1MHYtMTAyNGgtMTUwdjg4cS0xMDAgLTExMyAtMjE1IC0xMTNoLTE4cS02NiAwIC0xMjEuNSAxOHQtMTAyLjUgNTcuNXQtNzQgMTEyLjV0LTI3IDE3NHY2ODdoMTUwdi02ODdxMCAtMTIwIDQzLjUgLTE2NnQxMzEuNSAtNDZoMThxNDcgMCA5OSA1OHQ4NCAxMzR0MzIgMTMwdjU3N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idiIgdW5pY29kZT0idiIgCmQ9Ik00MDUgLTI1bC0zMDUgMTA0OWgxNTZsMjA1IC03MDVsMjA1IDcwNWgxNTdsLTMwNiAtMTA0OWgtMTEyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ3IiB1bmljb2RlPSJ3IiAKZD0iTTEzNCAwbC0xMDYgMTAyNGgxNTJsNjEgLTU5NGwxNzIgNTE5aDk2bDE3MiAtNTE5bDYxIDU5NGgxNTJsLTEwNiAtMTAyNGgtMTIybC0yMDUgNjE3bC0yMDUgLTYxN2gtMTIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ4IiB1bmljb2RlPSJ4IiAKZD0iTTk3IDBsMjc4IDUxMmwtMjc4IDUxMmgxNzFsMTkzIC0zNTVsMTkzIDM1NWgxNzFsLTI3OSAtNTEybDI3OSAtNTEyaC0xNzFsLTE5MyAzNTRsLTE5MyAtMzU0aC0xNzF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InkiIHVuaWNvZGU9InkiIApkPSJNODQxIDEwMjRsLTI2MSAtMTE1NHEtMTUgLTY1IC00MiAtMTEyLjV0LTU0LjUgLTcxdC02MiAtMzd0LTU1IC0xNnQtNDIuNSAtMi41cS03OSAwIC0xNDUuNSA1MC41dC05NS41IDEyMC41bDEzOCA1NnExMyAtMzEgNDMgLTU0dDYwIC0yM3EzNCAwIDY3IDM3LjV0NDUgOTEuNWw0NCAxOTVsLTM3MiA5MTloMTYzbDI2NyAtNjYwbDE0OSA2NjBoMTU0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ6IiB1bmljb2RlPSJ6IiAKZD0iTTg3IDExM2w1NDcgNzYxaC00OTR2MTUwaDY5N3YtMTI0bC01MzkgLTc1MGg1Mzl2LTE1MGgtNzUwdjExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYnJhY2VsZWZ0IiB1bmljb2RlPSJ7IiAKZD0iTTYyMCAxNDA1cS04NiAwIC0xNDAuNSAtNDMuNXQtNTQuNSAtMTE5LjV2LTI3MnEwIC02NyAtMjkgLTEzM3QtODMgLTExMXE1MyAtNTMgODIuNSAtMTMxdDI5LjUgLTE2NXYtMjcycTAgLTc2IDU0IC0xMTkuNXQxNDEgLTQzLjVoMTIwdi0xNTBoLTEyMHEtMTUwIDAgLTI0Ny41IDg3dC05Ny41IDIyNnYyNzJxMCA1MyAtMTYuNSAxMDMuNXQtNTMgODd0LTg1LjUgMzYuNWgtMzB2MTUwaDMwcTczIDAgMTE0IDUxdDQxIDExMnYyNzIKcTAgMTM5IDk3LjUgMjI2dDI0Ny41IDg3aDEyMHYtMTUwaC0xMjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJhciIgdW5pY29kZT0ifCIgCmQ9Ik0zODYgMTQ3N2gxNTB2LTE1NTRoLTE1MHYxNTU0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJicmFjZXJpZ2h0IiB1bmljb2RlPSJ9IiAKZD0iTTIxMCAxNTU1cTE1MCAwIDI0Ny41IC04N3Q5Ny41IC0yMjZ2LTI3MnEwIC02MSA0MSAtMTEydDExNCAtNTFoMzB2LTE1MGgtMzBxLTcyIDAgLTExMy41IC03MXQtNDEuNSAtMTU2di0yNzJxMCAtMTM5IC05Ny41IC0yMjZ0LTI0Ny41IC04N2gtMTIwdjE1MGgxMjBxODcgMCAxNDEgNDMuNXQ1NCAxMTkuNXYyNzJxMCA4NyAyOS41IDE2NXQ4Mi41IDEzMXEtNTQgNDUgLTgzIDExMXQtMjkgMTMzdjI3MnEwIDc2IC01NC41IDExOS41CnQtMTQwLjUgNDMuNWgtMTIwdjE1MGgxMjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFzY2lpdGlsZGUiIHVuaWNvZGU9In4iIApkPSJNMzE3IDEwNTJoMTVxODAgMCAxNTEgLTU5bDc1IC02M3EyNiAtMjIgNDIgLTIyaDE1cTI4IDAgNTUuNSAyNHQ0Mi41IDY4bDE0MiAtNDZxLTMwIC05MSAtOTcgLTE0My41dC0xNTMgLTUyLjVoLTE1cS02MCAwIC0xMjggNTdsLTc1IDY0cS0yNiAyMyAtNTUgMjNoLTE1cS04MCAwIC0xMDYgLTkxbC0xNDQgNDJxMjggOTggOTUuNSAxNDguNXQxNTQuNSA1MC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJub25icmVha2luZ3NwYWNlIiB1bmljb2RlPSImI3hhMDsiIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJleGNsYW1kb3duIiB1bmljb2RlPSImI3hhMTsiIApkPSJNNDYzIC0yM3EtNDMgMCAtNzIgMzAuNXQtMjkgOTcuNWwyNCA5MDZoMTQ2bDI0IC05MDdxMCAtNjYgLTI3IC05Ni41dC02NiAtMzAuNXpNMzExIDEyNzBxMCA2MSA0NC41IDEwMXQxMDUuNSA0MHE1OSAwIDEwNCAtNDF0NDUgLTEwMHEwIC01NyAtNDMuNSAtOTl0LTEwNS41IC00MnEtNjEgMCAtMTA1LjUgNDB0LTQ0LjUgMTAxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjZW50IiB1bmljb2RlPSImI3hhMjsiIApkPSJNNTMxIDExOTVsMTQ4IC0yNmwtMjcgLTE1MXExMDggLTQ3IDE0NSAtMTY2bC0xNDQgLTQ0cS0xMCAzMyAtMzAgNTJsLTEzMiAtNzM1cTcyIDIgMTA5IDIydDUzIDY1bDE0MiAtNDhxLTYzIC0xODkgLTMyNSAtMTg5aC02bC0xOCAtOThsLTE0OCAyNmwxOSAxMDVxLTk2IDQ5IC0xNTMgMTYwLjV0LTU3IDI1OC41djE3MHEwIDEzMCAzNi41IDIzMHQxMTYgMTYwLjV0MTkyLjUgNjAuNWgxOHEyMyAwIDM0IC0xek00NzcgODk4aC0yNQpxLTU2IDAgLTk2IC0yNi41dC02MC41IC03MnQtMjkuNSAtOTV0LTkgLTEwNy41di0xNzBxMCAtMTczIDg5IC0yNTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InN0ZXJsaW5nIiB1bmljb2RlPSImI3hhMzsiIApkPSJNNjMzIDExOTJxLTUzIDgzIC0xNjMgODNoLTE4cS0xOTUgMCAtMTk1IC0xOTJ2LTM5cTAgLTQxIDM3IC0xMTVsNjIgLTEyM2gzNjR2LTE1MGgtMzAxcTE4IC03MiAxOCAtMTQwdi00NnEwIC0xMzAgLTg1IC0yNzFoMzlxOTMgMCAxMjggLTIzbDY5IC00NXExMSAtNiAzNyAtNmgyNXEyNCAwIDU5LjUgOXQ1NS41IDI5bDExNCAtOTZxLTg1IC05MiAtMjI5IC05MmgtMjVxLTI5IDAgLTYzIDh0LTUyIDIwbC03MSA0N3EtMTAgNyAtNTEgNwpxLTUwIDAgLTExNCAtMTYuNXQtMTEwIC00NC41bC0zNCAtMjFsLTgwIDEyNmwzMiAyMXE3MCA0NSAxMzcuNSAxNDguNXQ2Ny41IDE5OS41djQ2cTAgNzMgLTI0IDE0MGgtMTkzdjE1MGgxMTlsLTI5IDU3cS0xOCAzNiAtMjcgNTcuNXQtMTcuNSA1NnQtOC41IDY3LjV2MzlxMCAxNjMgOTUuNSAyNTIuNXQyNDkuNSA4OS41aDE4cTM5IDAgNzkuNSAtOHQ4OCAtMzIuNXQ4NCAtNjIuNXQ2MyAtMTA0LjV0MzAuNSAtMTUxLjVsLTE1MCAtNgpxLTEgMzAgLTEwIDcxdC0yMiA2MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY3VycmVuY3kiIHVuaWNvZGU9IiYjeGE0OyIgCmQ9Ik03ODcgNzk2di0yNHEwIC04NSAtNDggLTE2MmwxMjQgLTEyNGwtMTA2IC0xMDZsLTEyNCAxMjRxLTc4IC01MCAtMTY0IC01MGgtMTZxLTg3IDAgLTE2NCA1MGwtMTI0IC0xMjRsLTEwNiAxMDZsMTI1IDEyNXEtNDkgNzYgLTQ5IDE2MXYyNHEwIDgxIDQ4IDE1OGwtMTI0IDEyNGwxMDYgMTA2bDEyMyAtMTIzcTgwIDUzIDE2NSA1M2gxNnE4NiAwIDE2NSAtNTNsMTIzIDEyM2wxMDYgLTEwNmwtMTI0IC0xMjRxNDggLTc3IDQ4IC0xNTh6Ck00NjkgOTY0aC0xNnEtNjEgMCAtMTE0LjUgLTU1dC01My41IC0xMTN2LTI0cTAgLTY0IDU0IC0xMTZ0MTE0IC01MmgxNnE2MSAwIDExNC41IDUydDUzLjUgMTE2djI0cTAgNTggLTUzLjUgMTEzdC0xMTQuNSA1NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ieWVuIiB1bmljb2RlPSImI3hhNTsiIApkPSJNODMyIDQ1N3YtMTUwaC0yOTV2LTEwOWgyOTV2LTE1MGgtMjk2di0yMDhoLTE0OXYyMDhoLTI5N3YxNTBoMjk3djEwOWgtMjk3djE1MGgyOTd2NDRsLTI5NyA4OTloMTU3bDIxNSAtNjQ4bDIxMyA2NDhoMTU3bC0yOTUgLTg5OXYtNDRoMjk1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJicm9rZW5iYXIiIHVuaWNvZGU9IiYjeGE2OyIgCmQ9Ik0zODYgNjAwaDE1MHYtNjc3aC0xNTB2Njc3ek0zODYgMTQ3N2gxNTB2LTY0NWgtMTUwdjY0NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2VjdGlvbiIgdW5pY29kZT0iJiN4YTc7IiAKZD0iTTQ3MCA4OTFoLTE4cS03NCAwIC0xMzQuNSAtNTZ0LTYwLjUgLTEyMXYtNDdxMCAtNzIgNjEuNSAtMTI0LjV0MTMzLjUgLTUyLjVoMThxNzIgMCAxMzMuNSA1MnQ2MS41IDEyNXY0N3EwIDY1IC02MC41IDEyMXQtMTM0LjUgNTZ6TTQ1MyAxMDQxaDE3cTEzNiAwIDI0MC41IC05OXQxMDQuNSAtMjI4di00N3EwIC0xNDggLTEzOCAtMjU0cTYyIC00NiAxMDAgLTEwOS41dDM4IC0xMzEuNXYtMjNxMCAtMTI3IC05OCAtMjIyLjV0LTIyMCAtOTUuNQpoLTE2cS05NiAwIC0xNzcuNSA2Ny41dC0xMTYuNSAxNTMuNWwxMzggNThxMjAgLTQ4IDY2IC04OC41dDkwIC00MC41aDE2cTYyIDAgMTE1IDUyLjV0NTMgMTE1LjV2MjNxMCA1NyAtNjYuNSAxMTIuNXQtMTI5LjUgNTUuNWgtMTdxLTEzNiAwIC0yNDAuNSA5Ny41dC0xMDQuNSAyMjkuNXY0N3EwIDc2IDM3IDE1MHQ5NSAxMTNxLTYwIDQ5IC05NiAxMTR0LTM2IDEzM3YyM3EwIDEyMyA5OSAyMjAuNXQyMTkgOTcuNWgxNnE4NiAwIDE2Ny41IC02MQp0MTIzLjUgLTE1M2wtMTM2IC02MnEtMjIgNDcgLTY3IDg2LjV0LTg4IDM5LjVoLTE2cS02MSAwIC0xMTQuNSAtNTV0LTUzLjUgLTExM3YtMjNxMCAtNjIgNjcgLTEyMi41dDEyOSAtNjAuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGllcmVzaXMiIHVuaWNvZGU9IiYjeGE4OyIgCmQ9Ik0zMjcgMTUyNHEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE2IDE1MjRxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29weXJpZ2h0IiB1bmljb2RlPSImI3hhOTsiIApkPSJNOTA4IDU5M3EwIC04OCAtMjkuNSAtMTcwLjV0LTgzLjUgLTE0OC41dC0xNDEgLTEwNnQtMTkzIC00MHEtMTA0IDAgLTE5MC41IDM5dC0xNDEuNSAxMDR0LTg1IDE0OHQtMzAgMTc0cTAgOTIgMzAuNSAxNzV0ODYuNSAxNDcuNXQxNDEuNSAxMDIuNXQxODguNSAzOHExMzcgMCAyNDAuNSAtNjQuNXQxNTUgLTE2OC41dDUxLjUgLTIzMHpNNDYxIDkzMHEtMTUxIDAgLTIzNiAtOTh0LTg1IC0yMzlxMCAtMTQwIDg0LjUgLTIzOS41CnQyMzYuNSAtOTkuNXE3OSAwIDE0MiAyOXQxMDEgNzcuNXQ1OCAxMDh0MjAgMTI0LjVxMCA5MCAtMzMuNSAxNjQuNXQtMTA4IDEyMy41dC0xNzkuNSA0OXpNNDU3IDM0NnEtMTA5IDAgLTE3NyA3MHQtNjggMTc2dDY3LjUgMTc2dDE3Ny41IDcwcTExMyAwIDE4MSAtNzJsLTk5IC05MnEtMjkgMjkgLTgyIDI5cS01NiAwIC04MyAtMzEuNXQtMjcgLTc5LjVxMCAtNDcgMjcgLTc5dDgzIC0zMnE1NSAwIDgzIDMxbDk5IC05MnEtNzAgLTc0IC0xODIgLTc0CnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib3JkZmVtaW5pbmUiIHVuaWNvZGU9IiYjeGFhOyIgCmQ9Ik04MzIgMzk0di0xNTBoLTc0MnYxNTBoNzQyek00NjkgNjY4cTUzIDAgMTA0IDU0dDUxIDEwMXYxMTVoLTE3MHEtNDYgMCAtNzkuNSAtMTQuNXQtNDggLTM1dC0yMSAtMzZ0LTYuNSAtMjUuNXYtNDNxMCAtNDAgNDEuNSAtNzh0MTEzLjUgLTM4aDE1ek00NTQgMTA4OGgxNzB2NjRxMCA4NSAtMzcuNSAxMjB0LTExNy41IDM1aC0xNXEtMTEyIDAgLTE0MSAtNjlsLTEzOCA1OHE2OCAxNjEgMjc5IDE2MWgxNXExNDAgMCAyMjIuNSAtNzYuNQp0ODIuNSAtMjI4LjV2LTYxNmgtMTUwdjM5cS02OSAtNDkgLTE1NSAtNTdoLTE1cS01NCAwIC0xMDYgMTZ0LTk3LjUgNDYuNXQtNzMuNSA4My41dC0yOCAxMjB2MzlxMCAzMyA5LjUgNjcuNXQzMiA3MC41dDU2LjUgNjR0ODcuNSA0NS41dDExOS41IDE3LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imd1aWxsZW1vdGxlZnQiIHVuaWNvZGU9IiYjeGFiOyIgCmQ9Ik03MDggODZsLTE5MSAzMTh2MTI5bDE5MSAzMTlsMTI4IC03NmwtMTY5IC0yODV2LTQ1bDE2OSAtMjg0ek0yODggODZsLTE5MSAzMTh2MTI5bDE5MSAzMTlsMTI4IC03NmwtMTY5IC0yODV2LTQ1bDE2OSAtMjg0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsb2dpY2Fsbm90IiB1bmljb2RlPSImI3hhYzsiIApkPSJNNTAgNjc1aDc2NXYtNDYxaC0xNTB2MzExaC02MTV2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzb2Z0aHlwaGVuIiB1bmljb2RlPSImI3hhZDsiIApkPSJNNzAwIDY3NXYtMTUwaC00Nzh2MTUwaDQ3OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icmVnaXN0ZXJlZCIgdW5pY29kZT0iJiN4YWU7IiAKZD0iTTQxOSA1OTdoNThxMzEgMCA0NC41IDE3LjV0MTMuNSAzNC41djI3cTAgMTAgLTE1LjUgMjN0LTQyLjUgMTNoLTU4di0xMTV6TTE0MCA1OTVxMCAtOTAgMzUgLTE2NnQxMDkuNSAtMTI1LjV0MTc2LjUgLTQ5LjVxNzkgMCAxNDIgMjkuNXQxMDEgNzguNXQ1OCAxMDl0MjAgMTI0cTAgNjYgLTE5LjUgMTI1LjV0LTU4IDEwN3QtMTAxIDc1dC0xNDIuNSAyNy41cS0xNDggMCAtMjM0LjUgLTk1LjV0LTg2LjUgLTIzOS41ek0yODEgODI1aDE5NgpxNTYgMCA5NiAtMTR0NTggLTM3LjV0MjUuNSAtNDV0Ny41IC00NC41di0zMXEwIC04OSAtNzcgLTEyN2w4MyAtMTE4bC0xMDkgLTc4bC0xMjUgMTc1aC0yMHYtMTM2aC0xMzV2NDU2ek05MDggNTk1cTAgLTg4IC0yOSAtMTcwLjV0LTgzLjUgLTE0OS41dC0xNDEuNSAtMTA3dC0xOTMgLTQwcS0xMDQgMCAtMTkwLjUgMzkuNXQtMTQxLjUgMTA1dC04NSAxNDl0LTMwIDE3My41cTAgOTIgMzAuNSAxNzV0ODYuNSAxNDYuNXQxNDEuNSAxMDEuNQp0MTg4LjUgMzhxMTA2IDAgMTkyIC0zOHQxNDEgLTEwMi41dDg0LjUgLTE0N3QyOS41IC0xNzMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibWFjcm9uIiB1bmljb2RlPSImI3hhZjsiIApkPSJNMjMwIDQ2NHYxNTBoNDUzdi0xNTBoLTQ1M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGVncmVlIiB1bmljb2RlPSImI3hiMDsiIApkPSJNNzYxIDExMDhxMCAtMTI2IC04MiAtMjEzLjV0LTIxOCAtODcuNXQtMjE4IDg3dC04MiAyMTRxMCAxMjggODIuNSAyMTR0MjE3LjUgODZxMTM4IDAgMjE5IC04NnQ4MSAtMjE0ek00NjEgMTI1OHEtNzUgMCAtMTEyLjUgLTQzdC0zNy41IC0xMDd0MzcuNSAtMTA3LjV0MTEyLjUgLTQzLjV0MTEyLjUgNDR0MzcuNSAxMDdxMCAyNyAtNyA1MXQtMjIuNSA0Ny41dC00Ni41IDM3LjV0LTc0IDE0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwbHVzbWludXMiIHVuaWNvZGU9IiYjeGIxOyIgCmQ9Ik04NzIgMTgzdi0xNTBoLTgyMnYxNTBoODIyek04NzIgOTM3di0xNTBoLTMzNnYtMzY4aC0xNTB2MzY4aC0zMzZ2MTUwaDMzNnYzMzZoMTUwdi0zMzZoMzM2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0d29zdXBlcmlvciIgdW5pY29kZT0iJiN4YjI7IiAKZD0iTTQ3NyAxNDI1aDEwcTEwNSAwIDE2NCAtNjIuNXQ1OSAtMTQ1LjV2LTIycTAgLTM4IC0xNi41IC05NC41dC01MC41IC05NS41bC0xODIgLTIwOXEtMTMgLTE2IC0zMyAtNzFoMjU4di0xNTBoLTQwNnYxODFxMzEgOTQgNjUgMTM0bDE4MiAyMDlxMTcgMTkgMjUgNTB0OCA0NnYyMnEwIDU4IC03MyA1OGgtMTBxLTM0IDAgLTQ5IC05LjV0LTI1IC0zMS41bC0xMzggNjBxMzEgNzAgODAuNSAxMDAuNXQxMzEuNSAzMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0aHJlZXN1cGVyaW9yIiB1bmljb2RlPSImI3hiMzsiIApkPSJNNDU1IDEyODVxLTcwIDAgLTk4IC01MmwtMTM3IDYycTkgMTUgMjQuNSAzMy41dDQ1IDQ1dDczIDQ0dDkyLjUgMTcuNWgxMnE5OSAwIDE2MSAtNjQuNXQ2MiAtMTU4LjV2LTIzcTAgLTcyIC00OCAtMTQxcTc4IC01OSA3OCAtMjAxdi0xMXEwIC0xMjkgLTY5IC0yMDR0LTE4NCAtNzVoLTEycS05MiAwIC0xNzIuNSA3NS41dC04MC41IDE3OS41aDE1MHEwIC00MCAzNSAtNzIuNXQ2OCAtMzIuNWgxMnExMDMgMCAxMDMgMTI5djExCnEwIDEwMCAtMTAzIDEwMGgtMTExdjE1MGgxMTJxMjMgMCA0Ny41IDI5dDI0LjUgNjN2MjNxMCAzMiAtMTguNSA1Mi41dC01NC41IDIwLjVoLTEyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhY3V0ZSIgdW5pY29kZT0iJiN4YjQ7IiAKZD0iTTQxMSAxMTg5bC0xNTggMTE0bDI1OSAzNjNsMTU4IC0xMTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1pY3JvIiB1bmljb2RlPSImI3hiNTsiIApkPSJNNjY1IDYwcS05MCAtODUgLTE5NSAtODVoLTE4cS0xMTAgMCAtMTk1IDY2di02NnEwIC0xMTYgLTggLTE4NS41dC0zNyAtMTYwLjVsLTE0MiA0NnEyNCA3NCAzMC41IDEzMi41dDYuNSAxNjcuNXYxMDQ5aDE1MHYtNjI3cTAgLTExMyA1MC41IC0xOTIuNXQxNDQuNSAtNzkuNWgxOHE0OSAwIDk1LjUgNDYuNXQ3MyAxMDkuNXQyNi41IDExNnY2MjdoMTUwdi05MjVxMCAtMTkgMi41IC0zNHQ1IC0yMy41dDkgLTI2LjV0MTAuNSAtMzIKbC0xNDQgLTQ2cS00IDEzIC0xMC41IDMyLjV0LTEwIDMwLjV0LTcuNSAyN3QtNSAzM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGFyYWdyYXBoIiB1bmljb2RlPSImI3hiNjsiIApkPSJNMzA1IDY4OXEtNDQgNyAtODEgMjcuNXQtNzIgNjAuNXQtNTUgMTExLjV0LTIwIDE2OC41djcwcTAgMTU5IDg2IDI1My41dDE5OSA5NC41aDQ1M3YtMTQ3NWgtMTUwdjEzMjVoLTIxMHYtMTMyNWgtMTUwdjY4OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGVyaW9kY2VudGVyZWQiIHVuaWNvZGU9IiYjeGI3OyIgCmQ9Ik02MDYgNzQ3cTAgLTYwIC00MSAtMTAzdC0xMDUgLTQzcS02MiAwIC0xMDQgNDN0LTQyIDEwM3EwIDU5IDQxLjUgMTAzdDEwNC41IDQ0dDEwNC41IC00My41dDQxLjUgLTEwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjZWRpbGxhIiB1bmljb2RlPSImI3hiODsiIApkPSJNNjEyIC0yNzBxMCAzOSAtNDEgNjEuNXQtODIgMjIuNWgtODBsMTQgMTg5djE1aDE1MHYtMjFsLTQgLTYwcTE5MyAtMzUgMTkzIC0yMDdxMCAtNTggLTI4IC0xMDN0LTcxIC02OHQtODQuNSAtMzR0LTc3LjUgLTExcS0xNDAgMCAtMjUwIDk1bDk4IDEwNHE2OCAtNTkgMTUyIC01OXEzNSAwIDczIDIwLjV0MzggNTUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib25lc3VwZXJpb3IiIHVuaWNvZGU9IiYjeGI5OyIgCmQ9Ik02MDEgMTQyNXYtNzg0aC0xNTB2NTg5bC05MCAtNTFsLTQ4IDU3bDE3NCAxODdsNCAyaDExMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib3JkbWFzY3VsaW5lIiB1bmljb2RlPSImI3hiYTsiIApkPSJNODMyIDM5NHYtMTUwaC03NDJ2MTUwaDc0MnpNNzgyIDk4M3EwIC0yMjkgLTg1LjUgLTM0NC41dC0yMzUuNSAtMTE1LjV0LTIzNS41IDExNS41dC04NS41IDM0NC41cTAgMTE4IDIxLjUgMjA2LjV0NTQgMTM5dDc4IDgxLjV0ODQuNSA0MC41dDgzIDkuNXQ4MyAtOS41dDg0LjUgLTQwLjV0NzggLTgxLjV0NTQgLTEzOXQyMS41IC0yMDYuNXpNNDYxIDEzMTBxLTUxIDAgLTg2LjUgLTMwdC01MyAtODEuNXQtMjQuNSAtMTAzLjV0LTcgLTExMgpxMCAtMTYzIDQzLjUgLTIzNi41dDEyNy41IC03My41dDEyNy41IDczLjV0NDMuNSAyMzYuNXEwIDYwIC03IDExMnQtMjQuNSAxMDMuNXQtNTMgODEuNXQtODYuNSAzMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ3VpbGxlbW90cmlnaHQiIHVuaWNvZGU9IiYjeGJiOyIgCmQ9Ik0yNTUgNDQ2djQ1bC0xNjkgMjg1bDEyOCA3NmwxOTEgLTMxOXYtMTI5bC0xOTEgLTMxOGwtMTI4IDc2ek02NzUgNDQ2djQ1bC0xNjkgMjg1bDEyOCA3NmwxOTEgLTMxOXYtMTI5bC0xOTEgLTMxOGwtMTI4IDc2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvbmVxdWFydGVyIiB1bmljb2RlPSImI3hiYzsiIApkPSJNNzAzIDI0NWwtNzQgLTEyOWg3NHYxMjl6TTY3MCAxNDUybDE0MCAtNTJsLTU1OCAtMTQ1MmwtMTQwIDUyek00NzcgMTUzbDI0MyA0MjJoMTMzdi00NTloMzN2LTE1MGgtMzN2LTE3NWgtMTUwdjE3NWgtMjI2djE4N3pNMjkxIDE1ODF2LTc3OGgtMTUwdjU1OWwtOTEgLTYybC00NyA1MWwxOTEgMjI5bDIgMWg5NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib25laGFsZiIgdW5pY29kZT0iJiN4YmQ7IiAKZD0iTTQ2MiA0MDJxMzIgNjkgNzguNSAxMDcuNXQxMzMuNSAzOC41aDEwcTEwOSAwIDE2NiAtNjAuNXQ1NyAtMTYyLjV2LTIycTAgLTM4IC0xNi41IC05NC41dC01MC41IC05NS41bC0xODMgLTIxMXEtMTAgLTExIC0yNSAtMzdoMjUxdi0xNTBoLTQ1NWwyNCA5NHEzMSAxMjAgOTEgMTkxbDE4MSAyMDdxMTcgMTkgMjUgNTB0OCA0NnYyMnEwIDQzIC0xNS41IDU4dC01Ny41IDE1aC0xMHEtMTEgMCAtMjAgLTF0LTE1LjUgLTQuNXQtMTEgLTYKdC05IC05LjV0LTYgLTEwdC02IC0xMi41dC02LjUgLTEyLjV6TTY3MCAxNDUybDE0MCAtNTJsLTU1OCAtMTQ1MmwtMTQwIDUyek0yOTEgMTU4MXYtNzc4aC0xNTB2NTU5bC05MSAtNjJsLTQ3IDUxbDE5MSAyMjlsMiAxaDk1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0aHJlZXF1YXJ0ZXJzIiB1bmljb2RlPSImI3hiZTsiIApkPSJNMTcgMTQ2MHEyIDYgNi41IDE1LjV0MjMgMzR0NDEgNDMuNXQ2Mi41IDM0LjV0ODYgMTUuNWgxMHE4NyAwIDE0OCAtNjMuNXQ2MSAtMTM5LjV2LTExcTAgLTcyIC00OSAtMTMycTc2IC02OSA3NiAtMTgydi0xMXEwIC02NyAtMTYgLTExOC41dC0zOS41IC04MC41dC01Ni41IC00N3QtNjIgLTIzLjV0LTYxIC01LjVoLTExcS0xMDUgMCAtMTcwLjUgNDkuNXQtNjUuNSAxNDQuNXYyaDE1M3EyIC00NiA4MyAtNDZoMTFxMjUgMCA0MyAxMi41CnQyNi41IDMzdDEyIDM5LjV0My41IDQwdjExcTAgNTEgLTI3LjUgNzguNXQtNjkuNSAyNy41aC02OWwtMSAxNDloODJxMjQgMCA0MSAyMHQxNyAzOXYxMXEwIDE0IC0xOCAzMy41dC00MSAxOS41aC0xMHEtNTUgMCAtODEgLTQ5ek03MDMgMjQ1bC03NCAtMTI5aDc0djEyOXpNNzQwIDE0NTNsMTQwIC01M2wtNTU4IC0xNDUybC0xNDAgNTJ6TTQ3NyAxNTNsMjQzIDQyMmgxMzN2LTQ1OWgzM3YtMTUwaC0zM3YtMTc1aC0xNTB2MTc1aC0yMjZ2MTg3egoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icXVlc3Rpb25kb3duIiB1bmljb2RlPSImI3hiZjsiIApkPSJNNTM2IDkxMHEwIC0xMzAgLTg4IC0yNDBsLTEzMSAtMTYycS02MCAtNzMgLTYwIC0xNDJ2LTcxcTAgLTM1IDkgLTY1dDI5LjUgLTU3dDYwLjUgLTQyLjV0OTYgLTE1LjVoMThxMTA2IDAgMTUwIDUydDQ1IDEyOWwxNTAgLTJxLTEgLTE0OSAtOTQgLTIzOXQtMjUxIC05MGgtMThxLTE2MCAwIC0yNTIuNSA5MS41dC05Mi41IDIzOC41djcxcTAgMTE2IDk0IDIzNmwxMjkgMTYycTU2IDcwIDU2IDE0NnYxMDBoMTUwdi0xMDB6TTMzNSAxMzgxCnEwIDUxIDM2IDg4LjV0OTAgMzcuNXQ5MCAtMzd0MzYgLTg5dC0zNSAtODkuNXQtOTEgLTM3LjVxLTU1IDAgLTkwLjUgMzd0LTM1LjUgOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkFncmF2ZSIgdW5pY29kZT0iJiN4YzA7IiAKZD0iTTU5OCAxNTE3bC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1ek0zMjkgMzk5aDI2NGwtMTMyIDYwNXpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJBYWN1dGUiIHVuaWNvZGU9IiYjeGMxOyIgCmQ9Ik00NzcgMTM4NGwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek0zMjkgMzk5aDI2NGwtMTMyIDYwNXpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJBY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4YzI7IiAKZD0iTTUzOSAxNzA2bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek0zMjkgMzk5aDI2NGwtMTMyIDYwNXpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJBdGlsZGUiIHVuaWNvZGU9IiYjeGMzOyIgCmQ9Ik0xMjkgMTYzNHE5MSAxMTUgMTkzIDExNWgxNnE4NyAwIDE1MSAtNTVsMTkgLTE3cTIyIC0xOCA1MSAtMThoMTdxMjMgMiAzOCAxMS41dDM2IDQxLjVsMTYgMjRsMTI0IC04NGwtMTYgLTI0cS04MCAtMTE5IC0xOTggLTExOWgtMTdxLTMzIDAgLTc2LjUgMTQuNXQtNzQuNSA0MS41bC0yMSAxOHEtMTggMTYgLTQ5IDE2aC0xNnEtMTcgMCAtMzIuNSAtMTEuNXQtNDAuNSAtNDIuNWwtMTkgLTI2bC0xMjAgOTB6TTMyOSAzOTloMjY0bC0xMzIgNjA1CnpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJBZGllcmVzaXMiIHVuaWNvZGU9IiYjeGM0OyIgCmQ9Ik0zMjggMTU5NXEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE3IDE1OTVxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNMzI5IDM5OWgyNjRsLTEzMiA2MDV6TTI0MSAwaC0xNTNsMzExIDE0MjUKaDEyNGwzMTAgLTE0MjVoLTE1M2wtNTQgMjQ5aC0zMzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkFyaW5nIiB1bmljb2RlPSImI3hjNTsiIApkPSJNMjUyIDE0ODlxMCA4NCA1OCAxNDN0MTQyIDU5dDE0NCAtNTl0NjAgLTE0M3QtNjAgLTE0M3QtMTQ0IC01OXQtMTQyIDU5dC01OCAxNDN6TTM2MiAxNDg5cTAgLTM4IDI2LjUgLTY1dDY0LjUgLTI3dDY1LjUgMjd0MjcuNSA2NXQtMjcuNSA2NXQtNjUuNSAyN3QtNjQuNSAtMjd0LTI2LjUgLTY1ek0zMjkgMzk5aDI2NGwtMTMyIDYwNXpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJBRSIgdW5pY29kZT0iJiN4YzY7IiAKZD0iTTQ0NiA4Mzl2NDExcS05NCAtOCAtMTA3IC05M2wtNDcgLTMxOGgxNTR6TTE2IDBsMTc1IDExNzlxMTQgOTUgODMgMTU2dDE3MiA2NWgzNzV2LTE1MGgtMjI1di00MTFoMTc0di0xNTBoLTE3NHYtNTM5aDIyNXYtMTUwaC0zNzV2Njg5aC0xNzdsLTEwMiAtNjg5aC0xNTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkNjZWRpbGxhIiB1bmljb2RlPSImI3hjNzsiIApkPSJNNjIyIC0yNzZxMCAzOSAtNDEgNjEuNXQtODIgMjIuNWgtODBsMTQgMTg5djE1aDE1MHYtMjFsLTQgLTYwcTE5MyAtMzUgMTkzIC0yMDdxMCAtNTggLTI4IC0xMDN0LTcxIC02OHQtODQuNSAtMzR0LTc3LjUgLTExcS0xNDAgMCAtMjUwIDk1bDk4IDEwNHE2OCAtNTkgMTUyIC01OXEzNSAwIDczIDIwLjV0MzggNTUuNXpNNDg3IC0yNWgtMzFxLTQ5IDAgLTkzIDE0dC05NSA2MC41dC04NyAxMjJ0LTYwIDIxMC41dC0yNCAzMTR2NjcKcTAgNjYyIDM1OCA2NjJoMzJxNTQgMCAxMDAuNSAtMTZ0NzggLTM4dDU4IC01N3Q0MSAtNjJ0MjcgLTY1dDE2IC01M3Q4LjUgLTM5bC0xNDYgLTMwcS0xMyA2NCAtMzMgMTA3LjV0LTQ1LjUgNjV0LTUwIDI5LjV0LTU0LjUgOGgtMzJxLTEwNSAwIC0xNTYuNSAtMTI1dC01MS41IC0zODd2LTY3cTAgLTczIDQgLTE0MXQxNy41IC0xNDkuNXQzNSAtMTQxdDYxIC05OS41dDkxLjUgLTQwaDMxcTE2IDAgMjkuNSAyLjV0MzUuNSAxNHQzOS41IDMyCnQzNi41IDYxLjV0MzIgOTdsMTQ2IC0zNHEtMjAgLTg1IC01My41IC0xNDh0LTY2LjUgLTk1LjV0LTc0IC01MS41dC02OC41IC0yMy41dC01Ni41IC00LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkVncmF2ZSIgdW5pY29kZT0iJiN4Yzg7IiAKZD0iTTU5NyAxNTE5bC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1ek0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFYWN1dGUiIHVuaWNvZGU9IiYjeGM5OyIgCmQ9Ik00NzYgMTM4NGwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4Y2E7IiAKZD0iTTUzOCAxNzA1bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFZGllcmVzaXMiIHVuaWNvZGU9IiYjeGNiOyIgCmQ9Ik0zMjcgMTU5MnEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE2IDE1OTJxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNMjU3IDcxMnYtNTYxaDU3NXYtMTUxaC03MjV2MTQwMGg3MjV2LTE1MApoLTU3NXYtMzg4aDQ4M3YtMTUwaC00ODN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IklncmF2ZSIgdW5pY29kZT0iJiN4Y2M7IiAKZD0iTTU5OCAxNTE5bC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1ek04MzIgMTQwMHYtMTUwaC0yOTZ2LTExMDBoMjk2di0xNTBoLTc0MnYxNTBoMjk2djExMDBoLTI5NnYxNTBoNzQyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJYWN1dGUiIHVuaWNvZGU9IiYjeGNkOyIgCmQ9Ik00NzcgMTM4NGwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek04MzIgMTQwMHYtMTUwaC0yOTZ2LTExMDBoMjk2di0xNTBoLTc0MnYxNTBoMjk2djExMDBoLTI5NnYxNTBoNzQyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4Y2U7IiAKZD0iTTUzOSAxNzA1bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek04MzIgMTQwMHYtMTUwaC0yOTZ2LTExMDBoMjk2di0xNTBoLTc0MnYxNTBoMjk2djExMDBoLTI5NnYxNTBoNzQyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJZGllcmVzaXMiIHVuaWNvZGU9IiYjeGNmOyIgCmQ9Ik0zMjggMTU5MnEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE3IDE1OTJxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNODMyIDE0MDB2LTE1MGgtMjk2di0xMTAwaDI5NnYtMTUwaC03NDJ2MTUwCmgyOTZ2MTEwMGgtMjk2djE1MGg3NDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkV0aCIgdW5pY29kZT0iJiN4ZDA7IiAKZD0iTTgyNSA3MzJxMCAtNzEgLTIuNSAtMTMxLjV0LTExLjUgLTEzOHQtMjQuNSAtMTM5LjV0LTQzIC0xMjQuNXQtNjUgLTEwNHQtOTMgLTY4dC0xMjQuNSAtMjYuNWgtMzE0djY4MWgtMTA1djE1MGgxMDV2NTY5aDMxNHE2OCAwIDEyMi41IC0yMXQ5MiAtNTUuNXQ2NSAtODd0NDMuNSAtMTA3LjV0MjUuNSAtMTI2dDEyLjUgLTEzM3QzIC0xMzh6TTQ2MSAxMjUwaC0xNjR2LTQxOWgxNTV2LTE1MGgtMTU1di01MzFoMTY0CnExMDkgMCAxNjEuNSAxNDIuNXQ1Mi41IDQzOS41cTAgMjg2IC01MCA0MDJ0LTE2NCAxMTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik50aWxkZSIgdW5pY29kZT0iJiN4ZDE7IiAKZD0iTTEyOSAxNjQxcTkxIDExNSAxOTMgMTE1aDE2cTg3IDAgMTUxIC01NWwxOSAtMTdxMjIgLTE4IDUxIC0xOGgxN3EyMyAyIDM4IDExLjV0MzYgNDEuNWwxNiAyNGwxMjQgLTg0bC0xNiAtMjRxLTgwIC0xMTkgLTE5OCAtMTE5aC0xN3EtMzMgMCAtNzYuNSAxNC41dC03NC41IDQxLjVsLTIxIDE4cS0xOCAxNiAtNDkgMTZoLTE2cS0xNyAwIC0zMi41IC0xMS41dC00MC41IC00Mi41bC0xOSAtMjZsLTEyMCA5MHpNMjU3IDBoLTE1MHYxNDAwaDEzNQpsNDIzIC05ODZ2OTg2aDE1MHYtMTQwMGgtMTM2bC00MjIgOTg1di05ODV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik9ncmF2ZSIgdW5pY29kZT0iJiN4ZDI7IiAKZD0iTTYwMyAxNTE5bC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1ek04MjUgNzY1di02OXEwIC0xNzkgLTI0IC0zMTMuNXQtNjAgLTIxMHQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjcKcTAgLTczIDQgLTE0MXQxNy41IC0xNDkuNXQzNSAtMTQxdDYxIC05OS41dDkxLjUgLTQwaDExcTUyIDAgOTEuNSA0MC41dDYxIDk5LjV0MzQuNSAxNDAuNXQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iT2FjdXRlIiB1bmljb2RlPSImI3hkMzsiIApkPSJNNDgyIDEzODNsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNODI1IDc2NXYtNjlxMCAtMTc5IC0yNCAtMzEzLjV0LTYwIC0yMTB0LTg2LjUgLTEyMnQtOTQuNSAtNjF0LTkzIC0xNC41aC0xMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjV0LTg3IDEyMnQtNjAgMjEwLjV0LTI0IDMxNHY2N3EwIDY2MiAzNTggNjYyaDEycTM1OCAwIDM1OCAtNjYwek00NjcgMTI3NWgtMTJxLTEwNSAwIC0xNTYuNSAtMTI1dC01MS41IC0zODd2LTY3CnEwIC03MyA0IC0xNDF0MTcuNSAtMTQ5LjV0MzUgLTE0MXQ2MSAtOTkuNXQ5MS41IC00MGgxMXE1MiAwIDkxLjUgNDAuNXQ2MSA5OS41dDM0LjUgMTQwLjV0MTcgMTQ5LjV0NCAxNDF2NjlxMCAyNjEgLTUxIDM4NS41dC0xNTcgMTI0LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik9jaXJjdW1mbGV4IiB1bmljb2RlPSImI3hkNDsiIApkPSJNNTQ0IDE3MDRsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTgyNSA3NjV2LTY5cTAgLTE3OSAtMjQgLTMxMy41dC02MCAtMjEwdC04Ni41IC0xMjJ0LTk0LjUgLTYxdC05MyAtMTQuNWgtMTFxLTQ5IDAgLTkzIDE0dC05NSA2MC41dC04NyAxMjJ0LTYwIDIxMC41dC0yNCAzMTR2NjdxMCA2NjIgMzU4IDY2MmgxMnEzNTggMCAzNTggLTY2MHpNNDY3IDEyNzVoLTEyCnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMTFxNTIgMCA5MS41IDQwLjV0NjEgOTkuNXQzNC41IDE0MC41dDE3IDE0OS41dDQgMTQxdjY5cTAgMjYxIC01MSAzODUuNXQtMTU3IDEyNC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJPdGlsZGUiIHVuaWNvZGU9IiYjeGQ1OyIgCmQ9Ik0xMzUgMTYzN3E5MSAxMTUgMTkzIDExNWgxNnE4NyAwIDE1MSAtNTVsMTkgLTE3cTIyIC0xOCA1MSAtMThoMTdxMjMgMiAzOCAxMS41dDM2IDQxLjVsMTYgMjRsMTI0IC04NGwtMTYgLTI0cS04MCAtMTE5IC0xOTggLTExOWgtMTdxLTMzIDAgLTc2LjUgMTQuNXQtNzQuNSA0MS41bC0yMSAxOHEtMTggMTYgLTQ5IDE2aC0xNnEtMTcgMCAtMzIuNSAtMTEuNXQtNDAuNSAtNDIuNWwtMTkgLTI2bC0xMjAgOTB6TTgyNSA3NjV2LTY5CnEwIC0xNzkgLTI0IC0zMTMuNXQtNjAgLTIxMHQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMTEKcTUyIDAgOTEuNSA0MC41dDYxIDk5LjV0MzQuNSAxNDAuNXQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iT2RpZXJlc2lzIiB1bmljb2RlPSImI3hkNjsiIApkPSJNMzMzIDE1OTBxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTgyMiAxNTkwcTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTgyNSA3NjV2LTY5cTAgLTE3OSAtMjQgLTMxMy41dC02MCAtMjEwCnQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMTFxNTIgMCA5MS41IDQwLjV0NjEgOTkuNXQzNC41IDE0MC41CnQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibXVsdGlwbHkiIHVuaWNvZGU9IiYjeGQ3OyIgCmQ9Ik02OTggOTc1bDEwOCAtMTA0bC0yNDIgLTI1NWwyNDIgLTI1NWwtMTA4IC0xMDRsLTIzNyAyNTBsLTIzNyAtMjUwbC0xMDggMTA0bDI0MiAyNTVsLTI0MiAyNTVsMTA4IDEwNGwyMzcgLTI1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iT3NsYXNoIiB1bmljb2RlPSImI3hkODsiIApkPSJNNDYxIDEyNzVxLTExMiAwIC0xNjMgLTEyN3QtNTEgLTQxNnEwIC0xMDkgOCAtMjA4bDM4NCA1ODBxLTQ4IDE3MSAtMTc4IDE3MXpNODI1IDczMnEwIC04NyAtMyAtMTU3LjV0LTEyLjUgLTE1MS41dC0yNSAtMTQzdC00My41IC0xMjEuNXQtNjUuNSAtOTh0LTkyIC02MnQtMTIyLjUgLTIzLjVxLTE4MCAwIC0yNzIgMTgybC0xMTEgLTE2N2wtNjcgMTY4bDExOSAxNzhxLTMzIDE1OCAtMzMgMzk2cTAgNzQgMyAxMzV0MTIgMTM1CnQyNC41IDEzMS41dDQzLjUgMTE0dDY1LjUgOTR0OTIuNSA2MC41dDEyMyAyM3ExODcgMCAyNzggLTE3MWwxMTEgMTY3bDYyIC0xNzVsLTExMyAtMTcxcTI2IC0xMzAgMjYgLTM0M3pNNjcxIDg4M2wtMzgxIC01NzRxNTIgLTE4NCAxNzEgLTE4NHE3NSAwIDEyMC41IDU1LjV0NjkuNSAxOTB0MjQgMzYxLjVxMCA5MCAtNCAxNTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlVncmF2ZSIgdW5pY29kZT0iJiN4ZDk7IiAKZD0iTTU5NyAxNTE4bC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1ek0yNTcgMzM3cTAgLTExNSA1MC41IC0xNjMuNXQxNDQuNSAtNDguNWgxOHE5NCAwIDE0NC41IDQ4LjV0NTAuNSAxNjMuNXYxMDYzaDE1MHYtMTA2M3EwIC0xNzIgLTkxLjUgLTI2N3QtMjUzLjUgLTk1aC0xOHEtMTYyIDAgLTI1My41IDk0LjV0LTkxLjUgMjY3LjV2MTA2M2gxNTB2LTEwNjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlVhY3V0ZSIgdW5pY29kZT0iJiN4ZGE7IiAKZD0iTTQ3NiAxMzg0bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTI1NyAzMzdxMCAtMTE1IDUwLjUgLTE2My41dDE0NC41IC00OC41aDE4cTk0IDAgMTQ0LjUgNDguNXQ1MC41IDE2My41djEwNjNoMTUwdi0xMDYzcTAgLTE3MiAtOTEuNSAtMjY3dC0yNTMuNSAtOTVoLTE4cS0xNjIgMCAtMjUzLjUgOTQuNXQtOTEuNSAyNjcuNXYxMDYzaDE1MHYtMTA2M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVWNpcmN1bWZsZXgiIHVuaWNvZGU9IiYjeGRiOyIgCmQ9Ik01MzggMTcwM2wxNjYgLTExN2wtODYgLTEyMWwtMTU3IDEwOGwtMTU3IC0xMDhsLTg2IDEyMWwxNjYgMTE3aDE1NHpNMjU3IDMzN3EwIC0xMTUgNTAuNSAtMTYzLjV0MTQ0LjUgLTQ4LjVoMThxOTQgMCAxNDQuNSA0OC41dDUwLjUgMTYzLjV2MTA2M2gxNTB2LTEwNjNxMCAtMTcyIC05MS41IC0yNjd0LTI1My41IC05NWgtMThxLTE2MiAwIC0yNTMuNSA5NC41dC05MS41IDI2Ny41djEwNjNoMTUwdi0xMDYzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJVZGllcmVzaXMiIHVuaWNvZGU9IiYjeGRjOyIgCmQ9Ik0zMjcgMTU5MXEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE2IDE1OTFxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNMjU3IDMzN3EwIC0xMTUgNTAuNSAtMTYzLjV0MTQ0LjUgLTQ4LjVoMTgKcTk0IDAgMTQ0LjUgNDguNXQ1MC41IDE2My41djEwNjNoMTUwdi0xMDYzcTAgLTE3MiAtOTEuNSAtMjY3dC0yNTMuNSAtOTVoLTE4cS0xNjIgMCAtMjUzLjUgOTQuNXQtOTEuNSAyNjcuNXYxMDYzaDE1MHYtMTA2M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iWWFjdXRlIiB1bmljb2RlPSImI3hkZDsiIApkPSJNNDc3IDEzODNsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNMzg2IC0yNXY1MjZsLTI5NiA4OTloMTU3bDIxNSAtNjQ4bDIxMyA2NDhoMTU3bC0yOTUgLTg5OWwtMSAtNTI2aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlRob3JuIiB1bmljb2RlPSImI3hkZTsiIApkPSJNNDcwIDUyMHExOTUgMCAxOTUgMjI3djIyM3EwIDEwMiAtNDIuNSAxNDMuNXQtMTUyLjUgNDEuNWgtMjEzdi02MzVoMjEzek0yNTcgMGgtMTUwdjE1NDBoMTUwdi0yMzVoMjEzcTM0NSAwIDM0NSAtMzM1di0yMjNxMCAtMTcyIC05MS41IC0yNzQuNXQtMjUzLjUgLTEwMi41aC0yMTN2LTM3MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2VybWFuZGJscyIgdW5pY29kZT0iJiN4ZGY7IiAKZD0iTTEwNyAxMDk2cTAgNTIgOSA5N3QzMyA4OXQ2MiA3NC41dDk5LjUgNDkuNXQxNDEuNSAxOWgxOHExNDAgMCAyMTcuNSAtOTB0NzcuNSAtMjUydi0zOXEwIC04MSAtMjEgLTE0Ny41dC01OCAtMTAyLjVxMTI5IC0xMDEgMTI5IC0zMDl2LTE0OHEwIC0xNjUgLTgyLjUgLTI2My41dC0yMTcuNSAtOTguNWgtOHEtMTE0IDAgLTE4NSA2OGwxMDQgMTA4cTI4IC0yNiA4MSAtMjZoOHE0MyAwIDc0IDE5LjV0NDYuNSA1MnQyMi41IDY3dDcgNzMuNXYxNDgKcTAgNDYgLTkgODMuNXQtMjkuNSA3MS41dC02MC41IDUzdC05NiAxOWgtNjh2MTUwaDE4cTExMyAwIDE1NCA0My41dDQxIDEzOC41djM5cTAgMTkyIC0xNDUgMTkyaC0xOHEtMTA5IDAgLTE1MiAtNDF0LTQzIC0xMzh2LTE0ODRoLTE1MHYxNDg0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhZ3JhdmUiIHVuaWNvZGU9IiYjeGUwOyIgCmQ9Ik02MzggMTMxM2wtMTQwIC0xMzVsLTI1OCAyNzJsMTQwIDEzNXpNNDUyIDQ4NnEtNTAgMCAtOTAgLTE3dC02MS41IC00MnQtMzIuNSAtNDguNXQtMTEgLTQxLjV2LTc4cTAgLTQzIDQ5LjUgLTg4LjV0MTQ1LjUgLTQ1LjVoMThxNzQgMCAxMzQuNSA2Ni41dDYwLjUgMTEwLjV2MTg0aC0yMTN6TTQ1MiAxMDQ5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY0OQpxLTg3IC02NiAtMTk1IC03NGgtMThxLTc4IDAgLTE0NC41IDI1dC0xMDkuNSA2NnQtNjcgOTF0LTI0IDEwMnY3OHEwIDUxIDI0IDEwMy41dDY2LjUgOTYuNXQxMDkuNSA3MS41dDE0NSAyNy41aDIxM3Y4M3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTgyIDAgLTEyMS41IC0xNy41dC01NS41IC01Ni41bC0xMzggNThxMzcgOTAgMTE2LjUgMTI4dDE5OC41IDM4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYWN1dGUiIHVuaWNvZGU9IiYjeGUxOyIgCmQ9Ik0zOTcgMTE2OWwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek00NTIgNDg2cS01MCAwIC05MCAtMTd0LTYxLjUgLTQydC0zMi41IC00OC41dC0xMSAtNDEuNXYtNzhxMCAtNDMgNDkuNSAtODguNXQxNDUuNSAtNDUuNWgxOHE3NCAwIDEzNC41IDY2LjV0NjAuNSAxMTAuNXYxODRoLTIxM3pNNDUyIDEwNDloMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTcxOWgtMTUwdjQ5CnEtODcgLTY2IC0xOTUgLTc0aC0xOHEtNzggMCAtMTQ0LjUgMjV0LTEwOS41IDY2dC02NyA5MXQtMjQgMTAydjc4cTAgNTEgMjQgMTAzLjV0NjYuNSA5Ni41dDEwOS41IDcxLjV0MTQ1IDI3LjVoMjEzdjgzcTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtODIgMCAtMTIxLjUgLTE3LjV0LTU1LjUgLTU2LjVsLTEzOCA1OHEzNyA5MCAxMTYuNSAxMjh0MTk4LjUgMzh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFjaXJjdW1mbGV4IiB1bmljb2RlPSImI3hlMjsiIApkPSJNNTU4IDE0MDdsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTQ1MiA0ODZxLTUwIDAgLTkwIC0xN3QtNjEuNSAtNDJ0LTMyLjUgLTQ4LjV0LTExIC00MS41di03OHEwIC00MyA0OS41IC04OC41dDE0NS41IC00NS41aDE4cTc0IDAgMTM0LjUgNjYuNXQ2MC41IDExMC41djE4NGgtMjEzek00NTIgMTA0OWgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OQp0OSAtOTh2LTcxOWgtMTUwdjQ5cS04NyAtNjYgLTE5NSAtNzRoLTE4cS03OCAwIC0xNDQuNSAyNXQtMTA5LjUgNjZ0LTY3IDkxdC0yNCAxMDJ2NzhxMCA1MSAyNCAxMDMuNXQ2Ni41IDk2LjV0MTA5LjUgNzEuNXQxNDUgMjcuNWgyMTN2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS04MiAwIC0xMjEuNSAtMTcuNXQtNTUuNSAtNTYuNWwtMTM4IDU4cTM3IDkwIDExNi41IDEyOHQxOTguNSAzOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXRpbGRlIiB1bmljb2RlPSImI3hlMzsiIApkPSJNMTQ5IDEzMjNxOTEgMTE1IDE5MyAxMTVoMTZxODcgMCAxNTEgLTU1bDE5IC0xN3EyMiAtMTggNTEgLTE4aDE3cTIzIDIgMzggMTEuNXQzNiA0MS41bDE2IDI0bDEyNCAtODRsLTE2IC0yNHEtODAgLTExOSAtMTk4IC0xMTloLTE3cS0zMyAwIC03Ni41IDE0LjV0LTc0LjUgNDEuNWwtMjEgMThxLTE4IDE2IC00OSAxNmgtMTZxLTE3IDAgLTMyLjUgLTExLjV0LTQwLjUgLTQyLjVsLTE5IC0yNmwtMTIwIDkwek00NTIgNDg2CnEtNTAgMCAtOTAgLTE3dC02MS41IC00MnQtMzIuNSAtNDguNXQtMTEgLTQxLjV2LTc4cTAgLTQzIDQ5LjUgLTg4LjV0MTQ1LjUgLTQ1LjVoMThxNzQgMCAxMzQuNSA2Ni41dDYwLjUgMTEwLjV2MTg0aC0yMTN6TTQ1MiAxMDQ5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY0OXEtODcgLTY2IC0xOTUgLTc0aC0xOHEtNzggMCAtMTQ0LjUgMjV0LTEwOS41IDY2dC02NyA5MXQtMjQgMTAyCnY3OHEwIDUxIDI0IDEwMy41dDY2LjUgOTYuNXQxMDkuNSA3MS41dDE0NSAyNy41aDIxM3Y4M3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTgyIDAgLTEyMS41IC0xNy41dC01NS41IC01Ni41bC0xMzggNThxMzcgOTAgMTE2LjUgMTI4dDE5OC41IDM4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhZGllcmVzaXMiIHVuaWNvZGU9IiYjeGU0OyIgCmQ9Ik0zNDcgMTI1NHEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODM2IDEyNTRxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNNDUyIDQ4NnEtNTAgMCAtOTAgLTE3dC02MS41IC00Mgp0LTMyLjUgLTQ4LjV0LTExIC00MS41di03OHEwIC00MyA0OS41IC04OC41dDE0NS41IC00NS41aDE4cTc0IDAgMTM0LjUgNjYuNXQ2MC41IDExMC41djE4NGgtMjEzek00NTIgMTA0OWgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NDlxLTg3IC02NiAtMTk1IC03NGgtMThxLTc4IDAgLTE0NC41IDI1dC0xMDkuNSA2NnQtNjcgOTF0LTI0IDEwMnY3OHEwIDUxIDI0IDEwMy41CnQ2Ni41IDk2LjV0MTA5LjUgNzEuNXQxNDUgMjcuNWgyMTN2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS04MiAwIC0xMjEuNSAtMTcuNXQtNTUuNSAtNTYuNWwtMTM4IDU4cTM3IDkwIDExNi41IDEyOHQxOTguNSAzOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXJpbmciIHVuaWNvZGU9IiYjeGU1OyIgCmQ9Ik0yNzEgMTM2OXEwIDg0IDU4IDE0M3QxNDIgNTl0MTQ0IC01OXQ2MCAtMTQzdC02MCAtMTQzdC0xNDQgLTU5dC0xNDIgNTl0LTU4IDE0M3pNMzgxIDEzNjlxMCAtMzggMjYuNSAtNjV0NjQuNSAtMjd0NjUuNSAyN3QyNy41IDY1dC0yNy41IDY1dC02NS41IDI3dC02NC41IC0yN3QtMjYuNSAtNjV6TTQ1MiA0ODZxLTUwIDAgLTkwIC0xN3QtNjEuNSAtNDJ0LTMyLjUgLTQ4LjV0LTExIC00MS41di03OHEwIC00MyA0OS41IC04OC41CnQxNDUuNSAtNDUuNWgxOHE3NCAwIDEzNC41IDY2LjV0NjAuNSAxMTAuNXYxODRoLTIxM3pNNDUyIDEwNDloMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTcxOWgtMTUwdjQ5cS04NyAtNjYgLTE5NSAtNzRoLTE4cS03OCAwIC0xNDQuNSAyNXQtMTA5LjUgNjZ0LTY3IDkxdC0yNCAxMDJ2NzhxMCA1MSAyNCAxMDMuNXQ2Ni41IDk2LjV0MTA5LjUgNzEuNXQxNDUgMjcuNWgyMTN2ODNxMCA5OCAtNDMgMTM5CnQtMTUyIDQxaC0xOHEtODIgMCAtMTIxLjUgLTE3LjV0LTU1LjUgLTU2LjVsLTEzOCA1OHEzNyA5MCAxMTYuNSAxMjh0MTk4LjUgMzh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFlIiB1bmljb2RlPSImI3hlNjsiIApkPSJNMzg2IDQ2N2gtMTAxcS00NiAwIC03Ny41IC0zMXQtMzEuNSAtNzh2LTEzOXEwIC00NCAyOS41IC02OXQ3NS41IC0yNXEzOCAwIDcxLjUgMjcuNXQzMy41IDY2LjV2MjQ4ek01MzYgNjE3aDIxMHYxODhxMCA0NSAtMjkuNSA2OS41dC03NS41IDI0LjVxLTM5IDAgLTcyIC0yN3QtMzMgLTY3di0xODh6TTUzNiAyMTlxMCAtNDIgMzMgLTY4dDcyIC0yNnE0NCAwIDc0LjUgMjV0MzAuNSA2OWgxNTBxMCAtMTA3IC03NC41IC0xNzUuNQp0LTE4MC41IC02OC41cS0xMDUgMCAtMTgxIDczcS03NiAtNzMgLTE3OSAtNzNxLTEwNyAwIC0xODEgNjguNXQtNzQgMTc1LjV2MTM5cTAgMTA4IDc1IDE4My41dDE4NCA3NS41aDEwMXYxODhxMCA0MiAtMzMgNjh0LTcyIDI2cS00MyAwIC03NCAtMjV0LTMxIC02OWgtMTUwcTAgMTA4IDc1LjUgMTc2dDE3OS41IDY4cTEwNiAwIDE4MSAtNzJxNzUgNzIgMTc5IDcycTEwNyAwIDE4MSAtNjh0NzQgLTE3NnYtMzM4aC0zNjB2LTI0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2NlZGlsbGEiIHVuaWNvZGU9IiYjeGU3OyIgCmQ9Ik02MjcgLTI4M3EwIDM5IC00MSA2MS41dC04MiAyMi41aC04MGwxNCAxODl2MTVoMTUwdi0yMWwtNCAtNjBxMTkzIC0zNSAxOTMgLTIwN3EwIC01OCAtMjggLTEwM3QtNzEgLTY4dC04NC41IC0zNHQtNzcuNSAtMTFxLTE0MCAwIC0yNTAgOTVsOTggMTA0cTY4IC01OSAxNTIgLTU5cTM1IDAgNzMgMjAuNXQzOCA1NS41ek00NzAgODk4aC0xOHEtNTYgMCAtOTYgLTI2LjV0LTYwLjUgLTcydC0yOS41IC05NXQtOSAtMTA3LjV2LTE3MApxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxODMgMCAxMjUgMTkuNXQ1OCA2Ny41bDE0MiAtNDhxLTYzIC0xODkgLTMyNSAtMTg5aC0xOHEtMTQ4IDAgLTI0Ni41IDEyN3QtOTguNSAzMjV2MTcwcTAgMTMwIDM2LjUgMjMwdDExNiAxNjAuNXQxOTIuNSA2MC41aDE4cTI2OCAwIDMyNyAtMTk2bC0xNDQgLTQ0cS05IDI5IC0yNSA0Ny41dC01NSAzMC41dC0xMDMgMTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVncmF2ZSIgdW5pY29kZT0iJiN4ZTg7IiAKZD0iTTY0MSAxMzAybC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1ek0yNTcgNDg2di0xNDlxMCAtOTAgNDkuNSAtMTUxdDE0NS41IC02MWgxOHE5NSAwIDEzNCAyNC41dDUyIDcyLjVsMTQ0IC00MHEtNTYgLTIwNyAtMzMwIC0yMDdoLTE4cS0xNjAgMCAtMjUyLjUgMTA2dC05Mi41IDI1NnYzODJxMCA1MyA5IDk4dDMzIDg5dDYyIDc0LjV0OTkuNSA0OS41dDE0MS41IDE5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjUKdDMzIC04OXQ5IC05OHYtMjMzaC01NTh6TTY2NSA2MzZ2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS0xMDkgMCAtMTUyIC00MXQtNDMgLTEzOXYtODNoNDA4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlYWN1dGUiIHVuaWNvZGU9IiYjeGU5OyIgCmQ9Ik00MTUgMTE3MWwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek0yNTcgNDg2di0xNDlxMCAtOTAgNDkuNSAtMTUxdDE0NS41IC02MWgxOHE5NSAwIDEzNCAyNC41dDUyIDcyLjVsMTQ0IC00MHEtNTYgLTIwNyAtMzMwIC0yMDdoLTE4cS0xNjAgMCAtMjUyLjUgMTA2dC05Mi41IDI1NnYzODJxMCA1MyA5IDk4dDMzIDg5dDYyIDc0LjV0OTkuNSA0OS41dDE0MS41IDE5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5CnQ5IC05OHYtMjMzaC01NTh6TTY2NSA2MzZ2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS0xMDkgMCAtMTUyIC00MXQtNDMgLTEzOXYtODNoNDA4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4ZWE7IiAKZD0iTTU2MSAxNDA5bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek0yNTcgNDg2di0xNDlxMCAtOTAgNDkuNSAtMTUxdDE0NS41IC02MWgxOHE5NSAwIDEzNCAyNC41dDUyIDcyLjVsMTQ0IC00MHEtNTYgLTIwNyAtMzMwIC0yMDdoLTE4cS0xNjAgMCAtMjUyLjUgMTA2dC05Mi41IDI1NnYzODJxMCA1MyA5IDk4dDMzIDg5dDYyIDc0LjV0OTkuNSA0OS41dDE0MS41IDE5aDE4CnE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtMjMzaC01NTh6TTY2NSA2MzZ2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS0xMDkgMCAtMTUyIC00MXQtNDMgLTEzOXYtODNoNDA4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlZGllcmVzaXMiIHVuaWNvZGU9IiYjeGViOyIgCmQ9Ik0zNTAgMTI1NnEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODM5IDEyNTZxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNMjU3IDQ4NnYtMTQ5cTAgLTkwIDQ5LjUgLTE1MXQxNDUuNSAtNjFoMTgKcTk1IDAgMTM0IDI0LjV0NTIgNzIuNWwxNDQgLTQwcS01NiAtMjA3IC0zMzAgLTIwN2gtMThxLTE2MCAwIC0yNTIuNSAxMDZ0LTkyLjUgMjU2djM4MnEwIDUzIDkgOTh0MzMgODl0NjIgNzQuNXQ5OS41IDQ5LjV0MTQxLjUgMTloMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTIzM2gtNTU4ek02NjUgNjM2djgzcTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtMTA5IDAgLTE1MiAtNDF0LTQzIC0xMzkKdi04M2g0MDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImlncmF2ZSIgdW5pY29kZT0iJiN4ZWM7IiAKZD0iTTYzMCAxMzE5bC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1ek0xODIgMTAyNGgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpYWN1dGUiIHVuaWNvZGU9IiYjeGVkOyIgCmQ9Ik00ODggMTE2OGwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek0xODIgMTAyNGgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4ZWU7IiAKZD0iTTU0NyAxNDA3bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek0xODIgMTAyNGgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpZGllcmVzaXMiIHVuaWNvZGU9IiYjeGVmOyIgCmQ9Ik0zMzYgMTI1NHEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODI1IDEyNTRxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNMTgyIDEwMjRoMzU0di04NzRoMjA0di0xNTBoLTU1OHYxNTBoMjA0CnY3MjRoLTIwNHYxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImV0aCIgdW5pY29kZT0iJiN4ZjA7IiAKZD0iTTI1NyA0NTd2LTMwcTAgLTEzNSA1NyAtMjE4LjV0MTM4IC04My41aDE4cTU2IDAgOTYgMjYuNXQ2MC41IDcydDI5LjUgOTUuNXQ5IDEwOHYzMHEwIDU3IC05IDEwOC41dC0yOS41IDEwMC41dC02MC41IDc4LjV0LTk2IDI5LjVoLTE4cS01NiAwIC05NiAtMjkuNXQtNjAuNSAtNzguNXQtMjkuNSAtMTAwLjV0LTkgLTEwOC41ek00NTIgOTI0aDE4cTY3IDAgMTIyIC0yM3EtNTIgMTEzIC0xMzggMjI5bC0yNDMgLTEwMGwtNTYgMTM4bDE5OSA4MgpxLTU4IDYzIC0xMzAgMTI0bDk2IDExNnE5NSAtODAgMTgxIC0xODBsMjM5IDk4bDU2IC0xMzhsLTIwMCAtODJxMjE5IC0zMDcgMjE5IC01Njh2LTE5M3EwIC0yMDcgLTkwLjUgLTMyOS41dC0yNTQuNSAtMTIyLjVoLTE4cS0xNDggMCAtMjQ2LjUgMTI3LjV0LTk4LjUgMzI0LjV2MzBxMCA5NSAyMSAxNzh0NjIgMTQ4LjV0MTA4LjUgMTAzdDE1My41IDM3LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im50aWxkZSIgdW5pY29kZT0iJiN4ZjE7IiAKZD0iTTEyOSAxMzI1cTkxIDExNSAxOTMgMTE1aDE2cTg3IDAgMTUxIC01NWwxOSAtMTdxMjIgLTE4IDUxIC0xOGgxN3EyMyAyIDM4IDExLjV0MzYgNDEuNWwxNiAyNGwxMjQgLTg0bC0xNiAtMjRxLTgwIC0xMTkgLTE5OCAtMTE5aC0xN3EtMzMgMCAtNzYuNSAxNC41dC03NC41IDQxLjVsLTIxIDE4cS0xOCAxNiAtNDkgMTZoLTE2cS0xNyAwIC0zMi41IC0xMS41dC00MC41IC00Mi41bC0xOSAtMjZsLTEyMCA5MHpNMjU3IDBoLTE1MHYxMDI0aDE1MAp2LTY3cTg5IDkyIDE5NSA5MmgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NzE5cTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtNDggMCAtOTQuNSAtNTMuNXQtNzMuNSAtMTIzLjV0LTI3IC0xMjV2LTU5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib2dyYXZlIiB1bmljb2RlPSImI3hmMjsiIApkPSJNNjIzIDEzMThsLTE0MCAtMTM1bC0yNTggMjcybDE0MCAxMzV6TTgyNSA1NjJ2LTkycTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjV0MTU1LjUgMzkuNWgzOXE4OSAwIDE1NyAtMzl0MTA4LjUgLTEwN3Q2MSAtMTU0dDIwLjUgLTE4NnpNNDc4IDg5OGgtMzkKcS01NSAwIC05NC41IC0zMC41dC01OS41IC04Mi41dC0yOSAtMTA3dC05IC0xMTd2LTkwcTAgLTYzIDkgLTExOS41dDI5LjUgLTExMHQ2MC41IC04NXQ5NSAtMzEuNWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNDkgLTUgOTR0LTE5IDkwdC0zNS41IDc4dC01Ni41IDUzLjV0LTgxIDIwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im9hY3V0ZSIgdW5pY29kZT0iJiN4ZjM7IiAKZD0iTTQ2NyAxMTg0bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTgyNSA1NjJ2LTkycTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjV0MTU1LjUgMzkuNWgzOXE4OSAwIDE1NyAtMzl0MTA4LjUgLTEwN3Q2MSAtMTU0dDIwLjUgLTE4NnpNNDc4IDg5OGgtMzkKcS01NSAwIC05NC41IC0zMC41dC01OS41IC04Mi41dC0yOSAtMTA3dC05IC0xMTd2LTkwcTAgLTYzIDkgLTExOS41dDI5LjUgLTExMHQ2MC41IC04NXQ5NSAtMzEuNWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNDkgLTUgOTR0LTE5IDkwdC0zNS41IDc4dC01Ni41IDUzLjV0LTgxIDIwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im9jaXJjdW1mbGV4IiB1bmljb2RlPSImI3hmNDsiIApkPSJNNTUwIDE0MDdsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTgyNSA1NjJ2LTkycTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjV0MTU1LjUgMzkuNWgzOXE4OSAwIDE1NyAtMzl0MTA4LjUgLTEwNwp0NjEgLTE1NHQyMC41IC0xODZ6TTQ3OCA4OThoLTM5cS01NSAwIC05NC41IC0zMC41dC01OS41IC04Mi41dC0yOSAtMTA3dC05IC0xMTd2LTkwcTAgLTYzIDkgLTExOS41dDI5LjUgLTExMHQ2MC41IC04NXQ5NSAtMzEuNWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNDkgLTUgOTR0LTE5IDkwdC0zNS41IDc4dC01Ni41IDUzLjV0LTgxIDIwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im90aWxkZSIgdW5pY29kZT0iJiN4ZjU7IiAKZD0iTTEzOSAxMzIzcTkxIDExNSAxOTMgMTE1aDE2cTg3IDAgMTUxIC01NWwxOSAtMTdxMjIgLTE4IDUxIC0xOGgxN3EyMyAyIDM4IDExLjV0MzYgNDEuNWwxNiAyNGwxMjQgLTg0bC0xNiAtMjRxLTgwIC0xMTkgLTE5OCAtMTE5aC0xN3EtMzMgMCAtNzYuNSAxNC41dC03NC41IDQxLjVsLTIxIDE4cS0xOCAxNiAtNDkgMTZoLTE2cS0xNyAwIC0zMi41IC0xMS41dC00MC41IC00Mi41bC0xOSAtMjZsLTEyMCA5MHpNODI1IDU2MnYtOTIKcTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjV0MTU1LjUgMzkuNWgzOXE4OSAwIDE1NyAtMzl0MTA4LjUgLTEwN3Q2MSAtMTU0dDIwLjUgLTE4NnpNNDc4IDg5OGgtMzlxLTU1IDAgLTk0LjUgLTMwLjV0LTU5LjUgLTgyLjV0LTI5IC0xMDd0LTkgLTExN3YtOTAKcTAgLTYzIDkgLTExOS41dDI5LjUgLTExMHQ2MC41IC04NXQ5NSAtMzEuNWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNDkgLTUgOTR0LTE5IDkwdC0zNS41IDc4dC01Ni41IDUzLjV0LTgxIDIwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im9kaWVyZXNpcyIgdW5pY29kZT0iJiN4ZjY7IiAKZD0iTTMzOSAxMjU0cTAgLTQ2IC0zMi41IC04MC41dC03Ny41IC0zNC41cS00NiAwIC03OSAzMy41dC0zMyA4MS41cTAgNDkgMzMuNSA4MXQ3Ni41IDMycTQ3IDAgNzkuNSAtMzMuNXQzMi41IC03OS41ek04MjggMTI1NHEwIC00OSAtMzMgLTgydC03NiAtMzNxLTQ1IDAgLTc4IDM0dC0zMyA4MXEwIDQ4IDMzIDgwLjV0NzggMzIuNXE0MiAwIDc1LjUgLTMydDMzLjUgLTgxek04MjUgNTYydi05MnEwIC0xMTYgLTIzLjUgLTIwNi41dC01OSAtMTQzLjUKdC04My41IC04N3QtOTIuNSAtNDZ0LTkwLjUgLTEyaC0zNXEtMTY4IDAgLTI1NiAxMzh0LTg4IDM1OHY5MHEwIDEwMCAxOS41IDE4NXQ1OS41IDE1NHQxMDcuNSAxMDguNXQxNTUuNSAzOS41aDM5cTg5IDAgMTU3IC0zOXQxMDguNSAtMTA3dDYxIC0xNTR0MjAuNSAtMTg2ek00NzggODk4aC0zOXEtNTUgMCAtOTQuNSAtMzAuNXQtNTkuNSAtODIuNXQtMjkgLTEwN3QtOSAtMTE3di05MHEwIC02MyA5IC0xMTkuNXQyOS41IC0xMTB0NjAuNSAtODUKdDk1IC0zMS41aDM1cTQ2IDAgODEuNSAyMC41dDU3LjUgNTR0MzUuNSA3OS41dDE5IDkyLjV0NS41IDk4LjV2OTJxMCA0OSAtNSA5NHQtMTkgOTB0LTM1LjUgNzh0LTU2LjUgNTMuNXQtODEgMjAuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGl2aWRlIiB1bmljb2RlPSImI3hmNzsiIApkPSJNODcyIDY3NXYtMTUwaC04MjJ2MTUwaDgyMnpNNTc5IDk2MHEwIC00MSAtMzIgLTc1LjV0LTc3IC0zNC41cS00OCAwIC03OSAzNS41dC0zMSA3NC41dDMxIDc0LjV0NzkgMzUuNXE0NSAwIDc3IC0zNC41dDMyIC03NS41ek01NzkgMjQzcTAgLTQzIC0zMS41IC03N3QtNzcuNSAtMzRxLTQ1IDAgLTc3LjUgMzV0LTMyLjUgNzZxMCAzOSAzMiA3M3Q3OCAzNHQ3Ny41IC0zNHQzMS41IC03M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib3NsYXNoIiB1bmljb2RlPSImI3hmODsiIApkPSJNNjYyIDcwMmwtMzE0IC01NDZxNDEgLTMxIDkzIC0zMWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNzQgLTEzIDE0MHpNNDc4IDg5OGgtMzlxLTU1IDAgLTk0LjUgLTMwLjV0LTU5LjUgLTgyLjV0LTI5IC0xMDd0LTkgLTExN3YtOTBxMCAtODcgMTcgLTE2MWwzMTggNTUycS00MiAzNiAtMTA0IDM2ek03MTggMTA5OWwxMzAgLTc1bC04OCAtMTUxcTY1IC0xMjYgNjUgLTMxMXYtOTIKcTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTk1IDAgLTE2OSA0OWwtNjMgLTEwOWwtMTMwIDc0bDg4IDE1M3EtNzAgMTMwIC03MCAzMjl2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjV0MTU1LjUgMzkuNWgzOXExMDQgMCAxODAgLTU0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1Z3JhdmUiIHVuaWNvZGU9IiYjeGY5OyIgCmQ9Ik02MjEgMTMwN2wtMTQwIC0xMzVsLTI1OCAyNzJsMTQwIDEzNXpNNjY1IDEwMjRoMTUwdi0xMDI0aC0xNTB2ODhxLTEwMCAtMTEzIC0yMTUgLTExM2gtMThxLTY2IDAgLTEyMS41IDE4dC0xMDIuNSA1Ny41dC03NCAxMTIuNXQtMjcgMTc0djY4N2gxNTB2LTY4N3EwIC0xMjAgNDMuNSAtMTY2dDEzMS41IC00NmgxOHE0NyAwIDk5IDU4dDg0IDEzNHQzMiAxMzB2NTc3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1YWN1dGUiIHVuaWNvZGU9IiYjeGZhOyIgCmQ9Ik00NDYgMTE2M2wtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek02NjUgMTAyNGgxNTB2LTEwMjRoLTE1MHY4OHEtMTAwIC0xMTMgLTIxNSAtMTEzaC0xOHEtNjYgMCAtMTIxLjUgMTh0LTEwMi41IDU3LjV0LTc0IDExMi41dC0yNyAxNzR2Njg3aDE1MHYtNjg3cTAgLTEyMCA0My41IC0xNjZ0MTMxLjUgLTQ2aDE4cTQ3IDAgOTkgNTh0ODQgMTM0dDMyIDEzMHY1Nzd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVjaXJjdW1mbGV4IiB1bmljb2RlPSImI3hmYjsiIApkPSJNNTM4IDE0MDdsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTY2NSAxMDI0aDE1MHYtMTAyNGgtMTUwdjg4cS0xMDAgLTExMyAtMjE1IC0xMTNoLTE4cS02NiAwIC0xMjEuNSAxOHQtMTAyLjUgNTcuNXQtNzQgMTEyLjV0LTI3IDE3NHY2ODdoMTUwdi02ODdxMCAtMTIwIDQzLjUgLTE2NnQxMzEuNSAtNDZoMThxNDcgMCA5OSA1OHQ4NCAxMzR0MzIgMTMwdjU3N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idWRpZXJlc2lzIiB1bmljb2RlPSImI3hmYzsiIApkPSJNMzI3IDEyNTRxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTgxNiAxMjU0cTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTY2NSAxMDI0aDE1MHYtMTAyNGgtMTUwdjg4CnEtMTAwIC0xMTMgLTIxNSAtMTEzaC0xOHEtNjYgMCAtMTIxLjUgMTh0LTEwMi41IDU3LjV0LTc0IDExMi41dC0yNyAxNzR2Njg3aDE1MHYtNjg3cTAgLTEyMCA0My41IC0xNjZ0MTMxLjUgLTQ2aDE4cTQ3IDAgOTkgNTh0ODQgMTM0dDMyIDEzMHY1Nzd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InlhY3V0ZSIgdW5pY29kZT0iJiN4ZmQ7IiAKZD0iTTQzNiAxMTUxbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTg0MSAxMDI0bC0yNjEgLTExNTRxLTE1IC02NSAtNDIgLTExMi41dC01NC41IC03MXQtNjIgLTM3dC01NSAtMTZ0LTQyLjUgLTIuNXEtNzkgMCAtMTQ1LjUgNTAuNXQtOTUuNSAxMjAuNWwxMzggNTZxMTMgLTMxIDQzIC01NHQ2MCAtMjNxMzQgMCA2NyAzNy41dDQ1IDkxLjVsNDQgMTk1bC0zNzIgOTE5aDE2M2wyNjcgLTY2MGwxNDkgNjYwaDE1NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGhvcm4iIHVuaWNvZGU9IiYjeGZlOyIgCmQ9Ik0yNTcgMzc0cTAgLTExNCA1NSAtMTgxLjV0MTQ5IC02Ny41cTIxNCAwIDIxNCAzODhxMCAzODUgLTIxNCAzODVxLTk0IDAgLTE0OSAtNTAuNXQtNTUgLTE2Mi41di0zMTF6TTgyNSA1MTNxMCAtOTUgLTEyLjUgLTE3NHQtMzMuNSAtMTM0dC01MS41IC05N3QtNjIgLTY2LjV0LTY5IC00MHQtNjkuNSAtMjF0LTY2IC01LjVxLTExNyAwIC0yMDQgNjR2LTQyNGgtMTUwdjE3ODVoMTUwdi00MDZxODUgNTQgMjA0IDU0cTUwIDAgOTQuNSAtMTEKdDk2IC00NnQ4OCAtOTEuNXQ2MSAtMTU2dDI0LjUgLTIzMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ5ZGllcmVzaXMiIHVuaWNvZGU9IiYjeGZmOyIgCmQ9Ik0zNDcgMTI1NHEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODM2IDEyNTRxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNODQxIDEwMjRsLTI2MSAtMTE1NHEtMTUgLTY1IC00MiAtMTEyLjUKdC01NC41IC03MXQtNjIgLTM3dC01NSAtMTZ0LTQyLjUgLTIuNXEtNzkgMCAtMTQ1LjUgNTAuNXQtOTUuNSAxMjAuNWwxMzggNTZxMTMgLTMxIDQzIC01NHQ2MCAtMjNxMzQgMCA2NyAzNy41dDQ1IDkxLjVsNDQgMTk1bC0zNzIgOTE5aDE2M2wyNjcgLTY2MGwxNDkgNjYwaDE1NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iQW1hY3JvbiIgdW5pY29kZT0iJiN4MTAwOyIgCmQ9Ik0yMzUgMTUwNnYxNTBoNDUzdi0xNTBoLTQ1M3pNMzI5IDM5OWgyNjRsLTEzMiA2MDV6TTI0MSAwaC0xNTNsMzExIDE0MjVoMTI0bDMxMCAtMTQyNWgtMTUzbC01NCAyNDloLTMzMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYW1hY3JvbiIgdW5pY29kZT0iJiN4MTAxOyIgCmQ9Ik0yNTQgMTEzNXYxNTBoNDUzdi0xNTBoLTQ1M3pNNDUyIDQ4NnEtNTAgMCAtOTAgLTE3dC02MS41IC00MnQtMzIuNSAtNDguNXQtMTEgLTQxLjV2LTc4cTAgLTQzIDQ5LjUgLTg4LjV0MTQ1LjUgLTQ1LjVoMThxNzQgMCAxMzQuNSA2Ni41dDYwLjUgMTEwLjV2MTg0aC0yMTN6TTQ1MiAxMDQ5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY0OXEtODcgLTY2IC0xOTUgLTc0aC0xOApxLTc4IDAgLTE0NC41IDI1dC0xMDkuNSA2NnQtNjcgOTF0LTI0IDEwMnY3OHEwIDUxIDI0IDEwMy41dDY2LjUgOTYuNXQxMDkuNSA3MS41dDE0NSAyNy41aDIxM3Y4M3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTgyIDAgLTEyMS41IC0xNy41dC01NS41IC01Ni41bC0xMzggNThxMzcgOTAgMTE2LjUgMTI4dDE5OC41IDM4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJBYnJldmUiIHVuaWNvZGU9IiYjeDEwMjsiIApkPSJNNDU5IDE0NzJxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek0zMjkgMzk5aDI2NGwtMTMyIDYwNXpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhYnJldmUiIHVuaWNvZGU9IiYjeDEwMzsiIApkPSJNNDc4IDExNjlxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek00NTIgNDg2cS01MCAwIC05MCAtMTd0LTYxLjUgLTQydC0zMi41IC00OC41dC0xMSAtNDEuNXYtNzhxMCAtNDMgNDkuNSAtODguNXQxNDUuNSAtNDUuNWgxOHE3NCAwIDEzNC41IDY2LjV0NjAuNSAxMTAuNXYxODRoLTIxM3pNNDUyIDEwNDloMTgKcTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY0OXEtODcgLTY2IC0xOTUgLTc0aC0xOHEtNzggMCAtMTQ0LjUgMjV0LTEwOS41IDY2dC02NyA5MXQtMjQgMTAydjc4cTAgNTEgMjQgMTAzLjV0NjYuNSA5Ni41dDEwOS41IDcxLjV0MTQ1IDI3LjVoMjEzdjgzcTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtODIgMCAtMTIxLjUgLTE3LjV0LTU1LjUgLTU2LjVsLTEzOCA1OApxMzcgOTAgMTE2LjUgMTI4dDE5OC41IDM4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJBb2dvbmVrIiB1bmljb2RlPSImI3gxMDQ7IiAKZD0iTTgzOSAtMzY2cS01OSAtNDkgLTEzMyAtNDlxLTg0IDAgLTE0My41IDYwdC01OS41IDE0NHEwIDgyIDU3IDE0MmwxMDUgMTA1djQxaDE1MHYtMTAzbC0xNDcgLTE0N3EtMTUgLTE3IC0xNSAtMzhxMCAtMjIgMTYgLTM4dDM3IC0xNnExOSAwIDM1IDEzbDI3IDIzbDk4IC0xMTN6TTMyOSAzOTloMjY0bC0xMzIgNjA1ek0yNDEgMGgtMTUzbDMxMSAxNDI1aDEyNGwzMTAgLTE0MjVoLTE1M2wtNTQgMjQ5aC0zMzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFvZ29uZWsiIHVuaWNvZGU9IiYjeDEwNTsiIApkPSJNODM5IC0zODRxLTU5IC00OSAtMTMzIC00OXEtODQgMCAtMTQzLjUgNjB0LTU5LjUgMTQ0cTAgODIgNTcgMTQybDEwNSAxMDV2NDFoMTUwdi0xMDNsLTE0NyAtMTQ3cS0xNSAtMTcgLTE1IC0zOHEwIC0yMiAxNiAtMzh0MzcgLTE2cTE5IDAgMzUgMTNsMjcgMjNsOTggLTExM3pNNDUyIDQ4NnEtNTAgMCAtOTAgLTE3dC02MS41IC00MnQtMzIuNSAtNDguNXQtMTEgLTQxLjV2LTc4cTAgLTQzIDQ5LjUgLTg4LjV0MTQ1LjUgLTQ1LjVoMTgKcTc0IDAgMTM0LjUgNjYuNXQ2MC41IDExMC41djE4NGgtMjEzek00NTIgMTA0OWgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NDlxLTg3IC02NiAtMTk1IC03NGgtMThxLTc4IDAgLTE0NC41IDI1dC0xMDkuNSA2NnQtNjcgOTF0LTI0IDEwMnY3OHEwIDUxIDI0IDEwMy41dDY2LjUgOTYuNXQxMDkuNSA3MS41dDE0NSAyNy41aDIxM3Y4M3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMTgKcS04MiAwIC0xMjEuNSAtMTcuNXQtNTUuNSAtNTYuNWwtMTM4IDU4cTM3IDkwIDExNi41IDEyOHQxOTguNSAzOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iQ2FjdXRlIiB1bmljb2RlPSImI3gxMDY7IiAKZD0iTTUxNSAxMzg1bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTQ4NyAtMjVoLTMxcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMzJxNTQgMCAxMDAuNSAtMTZ0NzggLTM4dDU4IC01N3Q0MSAtNjJ0MjcgLTY1dDE2IC01M3Q4LjUgLTM5bC0xNDYgLTMwcS0xMyA2NCAtMzMgMTA3LjV0LTQ1LjUgNjV0LTUwIDI5LjV0LTU0LjUgOGgtMzJxLTEwNSAwIC0xNTYuNSAtMTI1CnQtNTEuNSAtMzg3di02N3EwIC03MyA0IC0xNDF0MTcuNSAtMTQ5LjV0MzUgLTE0MXQ2MSAtOTkuNXQ5MS41IC00MGgzMXExNiAwIDI5LjUgMi41dDM1LjUgMTR0MzkuNSAzMnQzNi41IDYxLjV0MzIgOTdsMTQ2IC0zNHEtMjAgLTg1IC01My41IC0xNDh0LTY2LjUgLTk1LjV0LTc0IC01MS41dC02OC41IC0yMy41dC01Ni41IC00LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNhY3V0ZSIgdW5pY29kZT0iJiN4MTA3OyIgCmQ9Ik00NDIgMTE3NGwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek00NzAgODk4aC0xOHEtNTYgMCAtOTYgLTI2LjV0LTYwLjUgLTcydC0yOS41IC05NXQtOSAtMTA3LjV2LTE3MHEwIC0xMzUgNTcgLTIxOC41dDEzOCAtODMuNWgxOHE4MyAwIDEyNSAxOS41dDU4IDY3LjVsMTQyIC00OHEtNjMgLTE4OSAtMzI1IC0xODloLTE4cS0xNDggMCAtMjQ2LjUgMTI3dC05OC41IDMyNXYxNzBxMCAxMzAgMzYuNSAyMzB0MTE2IDE2MC41dDE5Mi41IDYwLjUKaDE4cTI2OCAwIDMyNyAtMTk2bC0xNDQgLTQ0cS05IDI5IC0yNSA0Ny41dC01NSAzMC41dC0xMDMgMTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkNjaXJjdW1mbGV4IiB1bmljb2RlPSImI3gxMDg7IiAKZD0iTTU3NyAxNzA0bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek00ODcgLTI1aC0zMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjV0LTg3IDEyMnQtNjAgMjEwLjV0LTI0IDMxNHY2N3EwIDY2MiAzNTggNjYyaDMycTU0IDAgMTAwLjUgLTE2dDc4IC0zOHQ1OCAtNTd0NDEgLTYydDI3IC02NXQxNiAtNTN0OC41IC0zOWwtMTQ2IC0zMHEtMTMgNjQgLTMzIDEwNy41dC00NS41IDY1dC01MCAyOS41CnQtNTQuNSA4aC0zMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMzFxMTYgMCAyOS41IDIuNXQzNS41IDE0dDM5LjUgMzJ0MzYuNSA2MS41dDMyIDk3bDE0NiAtMzRxLTIwIC04NSAtNTMuNSAtMTQ4dC02Ni41IC05NS41dC03NCAtNTEuNXQtNjguNSAtMjMuNXQtNTYuNSAtNC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4MTA5OyIgCmQ9Ik01ODggMTQwN2wxNjYgLTExN2wtODYgLTEyMWwtMTU3IDEwOGwtMTU3IC0xMDhsLTg2IDEyMWwxNjYgMTE3aDE1NHpNNDcwIDg5OGgtMThxLTU2IDAgLTk2IC0yNi41dC02MC41IC03MnQtMjkuNSAtOTV0LTkgLTEwNy41di0xNzBxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxODMgMCAxMjUgMTkuNXQ1OCA2Ny41bDE0MiAtNDhxLTYzIC0xODkgLTMyNSAtMTg5aC0xOHEtMTQ4IDAgLTI0Ni41IDEyN3QtOTguNSAzMjV2MTcwCnEwIDEzMCAzNi41IDIzMHQxMTYgMTYwLjV0MTkyLjUgNjAuNWgxOHEyNjggMCAzMjcgLTE5NmwtMTQ0IC00NHEtOSAyOSAtMjUgNDcuNXQtNTUgMzAuNXQtMTAzIDEyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJDZG90YWNjZW50IiB1bmljb2RlPSImI3gxMGE7IiAKZD0iTTM3OSAxNTc2cTAgNDkgMzMuNSA4M3Q4Mi41IDM0dDgzLjUgLTM0dDM0LjUgLTgzdC0zNC41IC04M3QtODMuNSAtMzR0LTgyLjUgMzR0LTMzLjUgODN6TTQ4NyAtMjVoLTMxcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMzJxNTQgMCAxMDAuNSAtMTZ0NzggLTM4dDU4IC01N3Q0MSAtNjJ0MjcgLTY1dDE2IC01M3Q4LjUgLTM5bC0xNDYgLTMwcS0xMyA2NCAtMzMgMTA3LjUKdC00NS41IDY1dC01MCAyOS41dC01NC41IDhoLTMycS0xMDUgMCAtMTU2LjUgLTEyNXQtNTEuNSAtMzg3di02N3EwIC03MyA0IC0xNDF0MTcuNSAtMTQ5LjV0MzUgLTE0MXQ2MSAtOTkuNXQ5MS41IC00MGgzMXExNiAwIDI5LjUgMi41dDM1LjUgMTR0MzkuNSAzMnQzNi41IDYxLjV0MzIgOTdsMTQ2IC0zNHEtMjAgLTg1IC01My41IC0xNDh0LTY2LjUgLTk1LjV0LTc0IC01MS41dC02OC41IC0yMy41dC01Ni41IC00LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNkb3RhY2NlbnQiIHVuaWNvZGU9IiYjeDEwYjsiIApkPSJNMzkwIDEyOTdxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNNDcwIDg5OGgtMThxLTU2IDAgLTk2IC0yNi41dC02MC41IC03MnQtMjkuNSAtOTV0LTkgLTEwNy41di0xNzBxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxODMgMCAxMjUgMTkuNXQ1OCA2Ny41bDE0MiAtNDhxLTYzIC0xODkgLTMyNSAtMTg5aC0xOHEtMTQ4IDAgLTI0Ni41IDEyNwp0LTk4LjUgMzI1djE3MHEwIDEzMCAzNi41IDIzMHQxMTYgMTYwLjV0MTkyLjUgNjAuNWgxOHEyNjggMCAzMjcgLTE5NmwtMTQ0IC00NHEtOSAyOSAtMjUgNDcuNXQtNTUgMzAuNXQtMTAzIDEyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJDY2Fyb24iIHVuaWNvZGU9IiYjeDEwYzsiIApkPSJNNTAwIDE2MThsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnpNNDg3IC0yNWgtMzFxLTQ5IDAgLTkzIDE0dC05NSA2MC41dC04NyAxMjJ0LTYwIDIxMC41dC0yNCAzMTR2NjdxMCA2NjIgMzU4IDY2MmgzMnE1NCAwIDEwMC41IC0xNnQ3OCAtMzh0NTggLTU3dDQxIC02MnQyNyAtNjV0MTYgLTUzdDguNSAtMzlsLTE0NiAtMzBxLTEzIDY0IC0zMyAxMDcuNXQtNDUuNSA2NXQtNTAgMjkuNXQtNTQuNSA4aC0zMgpxLTEwNSAwIC0xNTYuNSAtMTI1dC01MS41IC0zODd2LTY3cTAgLTczIDQgLTE0MXQxNy41IC0xNDkuNXQzNSAtMTQxdDYxIC05OS41dDkxLjUgLTQwaDMxcTE2IDAgMjkuNSAyLjV0MzUuNSAxNHQzOS41IDMydDM2LjUgNjEuNXQzMiA5N2wxNDYgLTM0cS0yMCAtODUgLTUzLjUgLTE0OHQtNjYuNSAtOTUuNXQtNzQgLTUxLjV0LTY4LjUgLTIzLjV0LTU2LjUgLTQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2Nhcm9uIiB1bmljb2RlPSImI3gxMGQ7IiAKZD0iTTUxMSAxMzIxbDE1NyAxMDlsODYgLTEyMmwtMTY2IC0xMTdoLTE1NGwtMTY2IDExN2w4NiAxMjJ6TTQ3MCA4OThoLTE4cS01NiAwIC05NiAtMjYuNXQtNjAuNSAtNzJ0LTI5LjUgLTk1dC05IC0xMDcuNXYtMTcwcTAgLTEzNSA1NyAtMjE4LjV0MTM4IC04My41aDE4cTgzIDAgMTI1IDE5LjV0NTggNjcuNWwxNDIgLTQ4cS02MyAtMTg5IC0zMjUgLTE4OWgtMThxLTE0OCAwIC0yNDYuNSAxMjd0LTk4LjUgMzI1djE3MHEwIDEzMCAzNi41IDIzMAp0MTE2IDE2MC41dDE5Mi41IDYwLjVoMThxMjY4IDAgMzI3IC0xOTZsLTE0NCAtNDRxLTkgMjkgLTI1IDQ3LjV0LTU1IDMwLjV0LTEwMyAxMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iRGNhcm9uIiB1bmljb2RlPSImI3gxMGU7IiAKZD0iTTQ2MSAxNjE3bDE1NyAxMDlsODYgLTEyMmwtMTY2IC0xMTdoLTE1NGwtMTY2IDExN2w4NiAxMjJ6TTgyNSA3NzV2LTEwNHEwIC0xMjEgLTEyLjUgLTIyMXQtMzMuNSAtMTY4dC01MS41IC0xMjB0LTYyIC04MnQtNjkgLTQ5dC02OSAtMjV0LTY2LjUgLTZoLTM1NHYxNDAwaDM1NHE3NSAwIDEzNCAtMjR0OTggLTY5LjV0NjYgLTEwMnQ0MSAtMTMwLjV0MTkuNSAtMTQ0LjV0NS41IC0xNTQuNXpNNDYxIDEyNTBoLTIwNHYtMTEwMGgyMDQKcTQ0IDAgNzkgMjIuNXQ1Ny41IDYzdDM4LjUgODkuNXQyNCAxMTF0MTEuNSAxMTcuNXQzLjUgMTE3LjV2MTA0cTAgMTc3IC0yNC41IDI4Mi41dC03MC41IDE0OXQtMTE5IDQzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRjYXJvbiIgdW5pY29kZT0iJiN4MTBmOyIgCmQ9Ik05NjcgMTU3OHEwIC0zNDYgLTI5OCAtMzgwbC0xNSA1NXE0OSAxOCA5Ni41IDU5dDQ3LjUgODVxMCA1NiAtMzQgNjZxLTQ1IDEzIC02Ny41IDQ0LjV0LTIyLjUgNzAuNXEwIDU5IDQxLjUgMTAydDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3pNMTUwLjA0OCA1OTd2LTE3MHEwIC0xMzUgNTEuNjg3NSAtMjE4LjV0MTI1LjEzOCAtODMuNWgxNi4zMjIzcTUwLjc4MTIgMCA4Ny4wNTI3IDI2LjVxMzYuMjcyNSAyNi41IDU0Ljg2MTMgNzIKcTE4LjU4OTggNDUuNSAyNi43NTEgOTUuNXQ4LjE2MTEzIDEwOHYxNzBxMCA1OCAtOC4xNjExMyAxMDcuNXQtMjYuNzUxIDk1LjVxLTE4LjU4ODkgNDYgLTU0Ljg2MTMgNzIuNXEtMzYuMjcxNSAyNi41IC04Ny4wNTI3IDI2LjVoLTE2LjMyMjNxLTUwLjc4MDMgMCAtODcuMDUyNyAtMjYuNXEtMzYuMjcxNSAtMjYuNSAtNTQuODYxMyAtNzIuNXEtMTguNTg4OSAtNDYgLTI2Ljc1IC05NS41dC04LjE2MTEzIC0xMDcuNXpNMzI2Ljg3MyAxMDQ5CmgxNi4zMjIzcTEwMy4zNzUgMCAxNzYuODI2IC02MnY0MTNoMTM2LjAydi0xNDAwaC0xMzYuMDJ2MzdxLTczLjQ1MTIgLTYyIC0xNzYuODI2IC02MmgtMTYuMzIyM3EtMTM0LjIwNiAwIC0yMjMuNTI1IDEyNy41cS04OS4zMjAzIDEyNy41IC04OS4zMjAzIDMyNC41djE3MHEwIDEzMCAzMy4wOTg2IDIzMHEzMy4wOTc3IDEwMCAxMDUuMTg4IDE2MXQxNzQuNTU5IDYxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJEY3JvYXQiIHVuaWNvZGU9IiYjeDExMDsiIApkPSJNODI1IDczMnEwIC03MSAtMi41IC0xMzEuNXQtMTEuNSAtMTM4dC0yNC41IC0xMzkuNXQtNDMgLTEyNC41dC02NSAtMTA0dC05MyAtNjh0LTEyNC41IC0yNi41aC0zMTR2NjgxaC0xMDV2MTUwaDEwNXY1NjloMzE0cTY4IDAgMTIyLjUgLTIxdDkyIC01NS41dDY1IC04N3Q0My41IC0xMDcuNXQyNS41IC0xMjZ0MTIuNSAtMTMzdDMgLTEzOHpNNDYxIDEyNTBoLTE2NHYtNDE5aDE1NXYtMTUwaC0xNTV2LTUzMWgxNjQKcTEwOSAwIDE2MS41IDE0Mi41dDUyLjUgNDM5LjVxMCAyODYgLTUwIDQwMnQtMTY0IDExNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGNyb2F0IiB1bmljb2RlPSImI3gxMTE7IiAKZD0iTTI1NyA1OTd2LTE3MHEwIC0xMzUgNTcgLTIxOC41dDEzOCAtODMuNWgxOHE1NiAwIDk2IDI2LjV0NjAuNSA3MnQyOS41IDk1LjV0OSAxMDh2MTcwcTAgNTggLTkgMTA3LjV0LTI5LjUgOTUuNXQtNjAuNSA3Mi41dC05NiAyNi41aC0xOHEtNTYgMCAtOTYgLTI2LjV0LTYwLjUgLTcyLjV0LTI5LjUgLTk1LjV0LTkgLTEwNy41ek00NTIgMTA0OWgxOHExMTQgMCAxOTUgLTYydjIxOGgtMjk1djE1MGgyOTV2NDVoMTUwdi00NWg0N3YtMTUwaC00Nwp2LTEyMDVoLTE1MHYzN3EtODEgLTYyIC0xOTUgLTYyaC0xOHEtMTQ4IDAgLTI0Ni41IDEyNy41dC05OC41IDMyNC41djE3MHEwIDEzMCAzNi41IDIzMHQxMTYgMTYxdDE5Mi41IDYxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFbWFjcm9uIiB1bmljb2RlPSImI3gxMTI7IiAKZD0iTTIzNCAxNTAzdjE1MGg0NTN2LTE1MGgtNDUzek0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlbWFjcm9uIiB1bmljb2RlPSImI3gxMTM7IiAKZD0iTTI1NyAxMTM3djE1MGg0NTN2LTE1MGgtNDUzek0yNTcgNDg2di0xNDlxMCAtOTAgNDkuNSAtMTUxdDE0NS41IC02MWgxOHE5NSAwIDEzNCAyNC41dDUyIDcyLjVsMTQ0IC00MHEtNTYgLTIwNyAtMzMwIC0yMDdoLTE4cS0xNjAgMCAtMjUyLjUgMTA2dC05Mi41IDI1NnYzODJxMCA1MyA5IDk4dDMzIDg5dDYyIDc0LjV0OTkuNSA0OS41dDE0MS41IDE5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4CnYtMjMzaC01NTh6TTY2NSA2MzZ2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS0xMDkgMCAtMTUyIC00MXQtNDMgLTEzOXYtODNoNDA4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFYnJldmUiIHVuaWNvZGU9IiYjeDExNDsiIApkPSJNNDU4IDE0NjdxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlYnJldmUiIHVuaWNvZGU9IiYjeDExNTsiIApkPSJNNDgxIDExNzFxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek0yNTcgNDg2di0xNDlxMCAtOTAgNDkuNSAtMTUxdDE0NS41IC02MWgxOHE5NSAwIDEzNCAyNC41dDUyIDcyLjVsMTQ0IC00MHEtNTYgLTIwNyAtMzMwIC0yMDdoLTE4cS0xNjAgMCAtMjUyLjUgMTA2dC05Mi41IDI1NnYzODJxMCA1MyA5IDk4dDMzIDg5CnQ2MiA3NC41dDk5LjUgNDkuNXQxNDEuNSAxOWgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtMjMzaC01NTh6TTY2NSA2MzZ2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS0xMDkgMCAtMTUyIC00MXQtNDMgLTEzOXYtODNoNDA4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFZG90YWNjZW50IiB1bmljb2RlPSImI3gxMTY7IiAKZD0iTTM0MCAxNTc0cTAgNDkgMzMuNSA4M3Q4Mi41IDM0dDgzLjUgLTM0dDM0LjUgLTgzdC0zNC41IC04M3QtODMuNSAtMzR0LTgyLjUgMzR0LTMzLjUgODN6TTI1NyA3MTJ2LTU2MWg1NzV2LTE1MWgtNzI1djE0MDBoNzI1di0xNTBoLTU3NXYtMzg4aDQ4M3YtMTUwaC00ODN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVkb3RhY2NlbnQiIHVuaWNvZGU9IiYjeDExNzsiIApkPSJNMzYzIDEyOTlxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNMjU3IDQ4NnYtMTQ5cTAgLTkwIDQ5LjUgLTE1MXQxNDUuNSAtNjFoMThxOTUgMCAxMzQgMjQuNXQ1MiA3Mi41bDE0NCAtNDBxLTU2IC0yMDcgLTMzMCAtMjA3aC0xOHEtMTYwIDAgLTI1Mi41IDEwNnQtOTIuNSAyNTZ2MzgycTAgNTMgOSA5OHQzMyA4OXQ2MiA3NC41dDk5LjUgNDkuNQp0MTQxLjUgMTloMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTIzM2gtNTU4ek02NjUgNjM2djgzcTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtMTA5IDAgLTE1MiAtNDF0LTQzIC0xMzl2LTgzaDQwOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iRW9nb25layIgdW5pY29kZT0iJiN4MTE4OyIgCmQ9Ik02MTcgLTM2NXEtNTkgLTQ5IC0xMzMgLTQ5cS04NCAwIC0xNDMuNSA2MHQtNTkuNSAxNDRxMCA4MiA1NyAxNDJsMTA1IDEwNXY0MWgxNTB2LTEwM2wtMTQ3IC0xNDdxLTE1IC0xNyAtMTUgLTM4cTAgLTIyIDE2IC0zOHQzNyAtMTZxMTkgMCAzNSAxM2wyNyAyM2w5OCAtMTEzek0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlb2dvbmVrIiB1bmljb2RlPSImI3gxMTk7IiAKZD0iTTU4MSAtMzgycS01OSAtNDkgLTEzMyAtNDlxLTg0IDAgLTE0My41IDYwdC01OS41IDE0NHEwIDgyIDU3IDE0MmwxMDUgMTA1djQxaDE1MHYtMTAzbC0xNDcgLTE0N3EtMTUgLTE3IC0xNSAtMzhxMCAtMjIgMTYgLTM4dDM3IC0xNnExOSAwIDM1IDEzbDI3IDIzbDk4IC0xMTN6TTI1NyA0ODZ2LTE0OXEwIC05MCA0OS41IC0xNTF0MTQ1LjUgLTYxaDE4cTk1IDAgMTM0IDI0LjV0NTIgNzIuNWwxNDQgLTQwcS01NiAtMjA3IC0zMzAgLTIwN2gtMTgKcS0xNjAgMCAtMjUyLjUgMTA2dC05Mi41IDI1NnYzODJxMCA1MyA5IDk4dDMzIDg5dDYyIDc0LjV0OTkuNSA0OS41dDE0MS41IDE5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di0yMzNoLTU1OHpNNjY1IDYzNnY4M3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTEwOSAwIC0xNTIgLTQxdC00MyAtMTM5di04M2g0MDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkVjYXJvbiIgdW5pY29kZT0iJiN4MTFhOyIgCmQ9Ik00NjEgMTYxOWwxNTcgMTA5bDg2IC0xMjJsLTE2NiAtMTE3aC0xNTRsLTE2NiAxMTdsODYgMTIyek0yNTcgNzEydi01NjFoNTc1di0xNTFoLTcyNXYxNDAwaDcyNXYtMTUwaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlY2Fyb24iIHVuaWNvZGU9IiYjeDExYjsiIApkPSJNNDg0IDEzMjNsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnpNMjU3IDQ4NnYtMTQ5cTAgLTkwIDQ5LjUgLTE1MXQxNDUuNSAtNjFoMThxOTUgMCAxMzQgMjQuNXQ1MiA3Mi41bDE0NCAtNDBxLTU2IC0yMDcgLTMzMCAtMjA3aC0xOHEtMTYwIDAgLTI1Mi41IDEwNnQtOTIuNSAyNTZ2MzgycTAgNTMgOSA5OHQzMyA4OXQ2MiA3NC41dDk5LjUgNDkuNXQxNDEuNSAxOWgxOHE4MCAwIDE0MS41IC0xOQp0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTIzM2gtNTU4ek02NjUgNjM2djgzcTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtMTA5IDAgLTE1MiAtNDF0LTQzIC0xMzl2LTgzaDQwOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iR2NpcmN1bWZsZXgiIHVuaWNvZGU9IiYjeDExYzsiIApkPSJNNTg4IDE3MDVsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTgxNSAyNDdxLTQxIC0xMzcgLTEzMSAtMjA0LjV0LTE5NyAtNjcuNWgtMzFxLTQ5IDAgLTkzIDE0dC05NSA2MC41dC04NyAxMjJ0LTYwIDIxMC41dC0yNCAzMTR2NjdxMCA2NjIgMzU4IDY2MmgzMnE1NCAwIDEwMC41IC0xNnQ3OCAtMzh0NTggLTU3dDQxIC02MnQyNyAtNjV0MTYgLTUzdDguNSAtMzlsLTE0NiAtMzAKcS0xMyA2NCAtMzMgMTA3LjV0LTQ1LjUgNjV0LTUwIDI5LjV0LTU0LjUgOGgtMzJxLTEwNSAwIC0xNTYuNSAtMTI1dC01MS41IC0zODd2LTY3cTAgLTczIDQgLTE0MXQxNy41IC0xNDkuNXQzNSAtMTQxdDYxIC05OS41dDkxLjUgLTQwaDMxcTYzIDAgMTEwLjUgNDAuNXQ2Ny41IDEwMi41djI3NGgtMTYxdjE1MGgzMTF2LTQ0NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2NpcmN1bWZsZXgiIHVuaWNvZGU9IiYjeDExZDsiIApkPSJNNTAyIDE0MThsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTY2NSAtODdxMCAxMCAtMTIgMjd0LTMzLjUgMzYuNXQtNjEuNSAzM3QtODggMTMuNWgtMThxLTc0IDAgLTEzNC41IC0zNi41dC02MC41IC03My41di0yMHEwIC00NSA1MyAtODZ0MTQyIC00MWgxOHE2NiAwIDEzMC41IDM0LjV0NjQuNSA5Mi41djIwek00NzAgODk5aC0xOHEtNzAgMCAtMTMyLjUgLTU1LjUKdC02Mi41IC0xMjQuNXYtNTZxMCAtNzMgNjIgLTEzNXQxMzMgLTYyaDE4cTcxIDAgMTMzIDYydDYyIDEzNXY1NnEwIDY5IC02Mi41IDEyNC41dC0xMzIuNSA1NS41ek0xNzIgNjJxLTY1IDY0IC02NSAxNTN2NjZxMCA5OCA3OSAxNzZxLTc5IDEwMiAtNzkgMjA2djU2cTAgMTI5IDEwNSAyMjkuNXQyNDAgMTAwLjVoMThxMTA5IDAgMjA2IC03MnE3NCA1NyAxNTYgNTd2LTE1MHEtMzAgMCAtNTcgLTE5cTQwIC03MiA0MCAtMTQ2di01NgpxMCAtMTM4IC0xMDYuNSAtMjQyLjV0LTIzOC41IC0xMDQuNWgtMThxLTc3IDAgLTE1MyA0M3EtNDIgLTM1IC00MiAtNzN2LTcxcTAgLTM3IDQ3IC02OXE3NCAyNyAxNDggMjdoMThxODEgMCAxNDkgLTI1dDEwOS41IC02NC41dDY0IC04NHQyMi41IC04Ni41di0yMHEwIC0xMTMgLTEwNCAtMTk1LjV0LTI0MSAtODIuNWgtMThxLTg3IDAgLTE1Ni41IDI3LjV0LTEwOSA3MC41dC01OS41IDg5LjV0LTIwIDkwLjV2MjBxMCA3NCA2NSAxNDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkdicmV2ZSIgdW5pY29kZT0iJiN4MTFlOyIgCmQ9Ik01MDggMTQ2NnEtODQgMCAtMTU4LjUgMzd0LTEyOC41IDEwMmwxMTUgOTZxNzAgLTg1IDE3MiAtODVxMTA1IDAgMTc4IDg2bDExNCAtOTdxLTU1IC02NSAtMTMxIC0xMDJ0LTE2MSAtMzd6TTgxNSAyNDdxLTQxIC0xMzcgLTEzMSAtMjA0LjV0LTE5NyAtNjcuNWgtMzFxLTQ5IDAgLTkzIDE0dC05NSA2MC41dC04NyAxMjJ0LTYwIDIxMC41dC0yNCAzMTR2NjdxMCA2NjIgMzU4IDY2MmgzMnE1NCAwIDEwMC41IC0xNnQ3OCAtMzh0NTggLTU3CnQ0MSAtNjJ0MjcgLTY1dDE2IC01M3Q4LjUgLTM5bC0xNDYgLTMwcS0xMyA2NCAtMzMgMTA3LjV0LTQ1LjUgNjV0LTUwIDI5LjV0LTU0LjUgOGgtMzJxLTEwNSAwIC0xNTYuNSAtMTI1dC01MS41IC0zODd2LTY3cTAgLTczIDQgLTE0MXQxNy41IC0xNDkuNXQzNSAtMTQxdDYxIC05OS41dDkxLjUgLTQwaDMxcTYzIDAgMTEwLjUgNDAuNXQ2Ny41IDEwMi41djI3NGgtMTYxdjE1MGgzMTF2LTQ0NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2JyZXZlIiB1bmljb2RlPSImI3gxMWY7IiAKZD0iTTQyMiAxMTgwcS04NCAwIC0xNTguNSAzN3QtMTI4LjUgMTAybDExNSA5NnE3MCAtODUgMTcyIC04NXExMDUgMCAxNzggODZsMTE0IC05N3EtNTUgLTY1IC0xMzEgLTEwMnQtMTYxIC0zN3pNNjY1IC04N3EwIDEwIC0xMiAyN3QtMzMuNSAzNi41dC02MS41IDMzdC04OCAxMy41aC0xOHEtNzQgMCAtMTM0LjUgLTM2LjV0LTYwLjUgLTczLjV2LTIwcTAgLTQ1IDUzIC04NnQxNDIgLTQxaDE4cTY2IDAgMTMwLjUgMzQuNXQ2NC41IDkyLjV2MjB6Ck00NzAgODk5aC0xOHEtNzAgMCAtMTMyLjUgLTU1LjV0LTYyLjUgLTEyNC41di01NnEwIC03MyA2MiAtMTM1dDEzMyAtNjJoMThxNzEgMCAxMzMgNjJ0NjIgMTM1djU2cTAgNjkgLTYyLjUgMTI0LjV0LTEzMi41IDU1LjV6TTE3MiA2MnEtNjUgNjQgLTY1IDE1M3Y2NnEwIDk4IDc5IDE3NnEtNzkgMTAyIC03OSAyMDZ2NTZxMCAxMjkgMTA1IDIyOS41dDI0MCAxMDAuNWgxOHExMDkgMCAyMDYgLTcycTc0IDU3IDE1NiA1N3YtMTUwCnEtMzAgMCAtNTcgLTE5cTQwIC03MiA0MCAtMTQ2di01NnEwIC0xMzggLTEwNi41IC0yNDIuNXQtMjM4LjUgLTEwNC41aC0xOHEtNzcgMCAtMTUzIDQzcS00MiAtMzUgLTQyIC03M3YtNzFxMCAtMzcgNDcgLTY5cTc0IDI3IDE0OCAyN2gxOHE4MSAwIDE0OSAtMjV0MTA5LjUgLTY0LjV0NjQgLTg0dDIyLjUgLTg2LjV2LTIwcTAgLTExMyAtMTA0IC0xOTUuNXQtMjQxIC04Mi41aC0xOHEtODcgMCAtMTU2LjUgMjcuNXQtMTA5IDcwLjUKdC01OS41IDg5LjV0LTIwIDkwLjV2MjBxMCA3NCA2NSAxNDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ikdkb3RhY2NlbnQiIHVuaWNvZGU9IiYjeDEyMDsiIApkPSJNMzkwIDE1NzVxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNODE1IDI0N3EtNDEgLTEzNyAtMTMxIC0yMDQuNXQtMTk3IC02Ny41aC0zMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjV0LTg3IDEyMnQtNjAgMjEwLjV0LTI0IDMxNHY2N3EwIDY2MiAzNTggNjYyaDMycTU0IDAgMTAwLjUgLTE2dDc4IC0zOHQ1OCAtNTd0NDEgLTYydDI3IC02NXQxNiAtNTMKdDguNSAtMzlsLTE0NiAtMzBxLTEzIDY0IC0zMyAxMDcuNXQtNDUuNSA2NXQtNTAgMjkuNXQtNTQuNSA4aC0zMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMzFxNjMgMCAxMTAuNSA0MC41dDY3LjUgMTAyLjV2Mjc0aC0xNjF2MTUwaDMxMXYtNDQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJnZG90YWNjZW50IiB1bmljb2RlPSImI3gxMjE7IiAKZD0iTTMwNCAxMzA4cTAgNDkgMzMuNSA4M3Q4Mi41IDM0dDgzLjUgLTM0dDM0LjUgLTgzdC0zNC41IC04M3QtODMuNSAtMzR0LTgyLjUgMzR0LTMzLjUgODN6TTY2NSAtODdxMCAxMCAtMTIgMjd0LTMzLjUgMzYuNXQtNjEuNSAzM3QtODggMTMuNWgtMThxLTc0IDAgLTEzNC41IC0zNi41dC02MC41IC03My41di0yMHEwIC00NSA1MyAtODZ0MTQyIC00MWgxOHE2NiAwIDEzMC41IDM0LjV0NjQuNSA5Mi41djIwek00NzAgODk5aC0xOApxLTcwIDAgLTEzMi41IC01NS41dC02Mi41IC0xMjQuNXYtNTZxMCAtNzMgNjIgLTEzNXQxMzMgLTYyaDE4cTcxIDAgMTMzIDYydDYyIDEzNXY1NnEwIDY5IC02Mi41IDEyNC41dC0xMzIuNSA1NS41ek0xNzIgNjJxLTY1IDY0IC02NSAxNTN2NjZxMCA5OCA3OSAxNzZxLTc5IDEwMiAtNzkgMjA2djU2cTAgMTI5IDEwNSAyMjkuNXQyNDAgMTAwLjVoMThxMTA5IDAgMjA2IC03MnE3NCA1NyAxNTYgNTd2LTE1MHEtMzAgMCAtNTcgLTE5CnE0MCAtNzIgNDAgLTE0NnYtNTZxMCAtMTM4IC0xMDYuNSAtMjQyLjV0LTIzOC41IC0xMDQuNWgtMThxLTc3IDAgLTE1MyA0M3EtNDIgLTM1IC00MiAtNzN2LTcxcTAgLTM3IDQ3IC02OXE3NCAyNyAxNDggMjdoMThxODEgMCAxNDkgLTI1dDEwOS41IC02NC41dDY0IC04NHQyMi41IC04Ni41di0yMHEwIC0xMTMgLTEwNCAtMTk1LjV0LTI0MSAtODIuNWgtMThxLTg3IDAgLTE1Ni41IDI3LjV0LTEwOSA3MC41dC01OS41IDg5LjV0LTIwIDkwLjV2MjAKcTAgNzQgNjUgMTQ5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJHY2VkaWxsYSIgdW5pY29kZT0iJiN4MTIyOyIgCmQ9Ik02ODEgLTIwNnEwIC0zNDYgLTI5OCAtMzgwbC0xNSA1NXE0OSAxOCA5Ni41IDU5dDQ3LjUgODVxMCA1NiAtMzQgNjZxLTQ1IDEzIC02Ny41IDQ0LjV0LTIyLjUgNzAuNXEwIDU5IDQxLjUgMTAydDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3pNODE1IDI0N3EtNDEgLTEzNyAtMTMxIC0yMDQuNXQtMTk3IC02Ny41aC0zMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjV0LTg3IDEyMnQtNjAgMjEwLjV0LTI0IDMxNHY2N3EwIDY2MiAzNTggNjYyaDMyCnE1NCAwIDEwMC41IC0xNnQ3OCAtMzh0NTggLTU3dDQxIC02MnQyNyAtNjV0MTYgLTUzdDguNSAtMzlsLTE0NiAtMzBxLTEzIDY0IC0zMyAxMDcuNXQtNDUuNSA2NXQtNTAgMjkuNXQtNTQuNSA4aC0zMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMzFxNjMgMCAxMTAuNSA0MC41dDY3LjUgMTAyLjV2Mjc0aC0xNjF2MTUwaDMxMXYtNDQ1egoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2NlZGlsbGEiIHVuaWNvZGU9IiYjeDEyMzsiIApkPSJNMzIyIDEzMjJxMCAzNDYgMjk4IDM4MGwxNSAtNTVxLTQ5IC0xOCAtOTYuNSAtNTl0LTQ3LjUgLTg1cTAgLTU2IDM0IC02NnE0NSAtMTMgNjcuNSAtNDQuNXQyMi41IC03MC41cTAgLTU5IC00MS41IC0xMDJ0LTEwNC41IC00M3QtMTA1IDQydC00MiAxMDN6TTY2NSAtODdxMCAxMCAtMTIgMjd0LTMzLjUgMzYuNXQtNjEuNSAzM3QtODggMTMuNWgtMThxLTc0IDAgLTEzNC41IC0zNi41dC02MC41IC03My41di0yMHEwIC00NSA1MyAtODYKdDE0MiAtNDFoMThxNjYgMCAxMzAuNSAzNC41dDY0LjUgOTIuNXYyMHpNNDcwIDg5OWgtMThxLTcwIDAgLTEzMi41IC01NS41dC02Mi41IC0xMjQuNXYtNTZxMCAtNzMgNjIgLTEzNXQxMzMgLTYyaDE4cTcxIDAgMTMzIDYydDYyIDEzNXY1NnEwIDY5IC02Mi41IDEyNC41dC0xMzIuNSA1NS41ek0xNzIgNjJxLTY1IDY0IC02NSAxNTN2NjZxMCA5OCA3OSAxNzZxLTc5IDEwMiAtNzkgMjA2djU2cTAgMTI5IDEwNSAyMjkuNXQyNDAgMTAwLjVoMTgKcTEwOSAwIDIwNiAtNzJxNzQgNTcgMTU2IDU3di0xNTBxLTMwIDAgLTU3IC0xOXE0MCAtNzIgNDAgLTE0NnYtNTZxMCAtMTM4IC0xMDYuNSAtMjQyLjV0LTIzOC41IC0xMDQuNWgtMThxLTc3IDAgLTE1MyA0M3EtNDIgLTM1IC00MiAtNzN2LTcxcTAgLTM3IDQ3IC02OXE3NCAyNyAxNDggMjdoMThxODEgMCAxNDkgLTI1dDEwOS41IC02NC41dDY0IC04NHQyMi41IC04Ni41di0yMHEwIC0xMTMgLTEwNCAtMTk1LjV0LTI0MSAtODIuNWgtMTgKcS04NyAwIC0xNTYuNSAyNy41dC0xMDkgNzAuNXQtNTkuNSA4OS41dC0yMCA5MC41djIwcTAgNzQgNjUgMTQ5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJIY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4MTI0OyIgCmQ9Ik01MzggMTcwNWwxNjYgLTExN2wtODYgLTEyMWwtMTU3IDEwOGwtMTU3IC0xMDhsLTg2IDEyMWwxNjYgMTE3aDE1NHpNMjU3IDBoLTE1MHYxNDAwaDE1MHYtNTkzaDQwOHY1OTNoMTUwdi0xNDAwaC0xNTB2NjU3aC00MDh2LTY1N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaGNpcmN1bWZsZXgiIHVuaWNvZGU9IiYjeDEyNTsiIApkPSJNNjU4IDE3MDNsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTI1NyAwaC0xNTB2MTQwMGgxNTB2LTQ0M3E4OSA5MiAxOTUgOTJoMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTcxOWgtMTUwdjcxOXEwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTQ4IDAgLTk0LjUgLTUzLjV0LTczLjUgLTEyMy41dC0yNyAtMTI1di01OTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkhiYXIiIHVuaWNvZGU9IiYjeDEyNjsiIApkPSJNMjU3IDgwN2g0MDh2Mjg4aC00MDh2LTI4OHpNMjU3IDBoLTE1MHYxMDk1aC00N3YxNTBoNDd2MTU1aDE1MHYtMTU1aDQwOHYxNTVoMTUwdi0xNTVoNDd2LTE1MGgtNDd2LTEwOTVoLTE1MHY2NTdoLTQwOHYtNjU3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJoYmFyIiB1bmljb2RlPSImI3gxMjc7IiAKZD0iTTI1NyAwaC0xNTB2MTIwNWgtNDd2MTUwaDQ3djQ1aDE1MHYtNDVoMjk1di0xNTBoLTI5NXYtMjQ4cTg5IDkyIDE5NSA5MmgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NzE5cTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtNDggMCAtOTQuNSAtNTMuNXQtNzMuNSAtMTIzLjV0LTI3IC0xMjV2LTU5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iSXRpbGRlIiB1bmljb2RlPSImI3gxMjg7IiAKZD0iTTEyOSAxNjQxcTkxIDExNSAxOTMgMTE1aDE2cTg3IDAgMTUxIC01NWwxOSAtMTdxMjIgLTE4IDUxIC0xOGgxN3EyMyAyIDM4IDExLjV0MzYgNDEuNWwxNiAyNGwxMjQgLTg0bC0xNiAtMjRxLTgwIC0xMTkgLTE5OCAtMTE5aC0xN3EtMzMgMCAtNzYuNSAxNC41dC03NC41IDQxLjVsLTIxIDE4cS0xOCAxNiAtNDkgMTZoLTE2cS0xNyAwIC0zMi41IC0xMS41dC00MC41IC00Mi41bC0xOSAtMjZsLTEyMCA5MHpNODMyIDE0MDB2LTE1MGgtMjk2CnYtMTEwMGgyOTZ2LTE1MGgtNzQydjE1MGgyOTZ2MTEwMGgtMjk2djE1MGg3NDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Iml0aWxkZSIgdW5pY29kZT0iJiN4MTI5OyIgCmQ9Ik0xMzcgMTMyM3E5MSAxMTUgMTkzIDExNWgxNnE4NyAwIDE1MSAtNTVsMTkgLTE3cTIyIC0xOCA1MSAtMThoMTdxMjMgMiAzOCAxMS41dDM2IDQxLjVsMTYgMjRsMTI0IC04NGwtMTYgLTI0cS04MCAtMTE5IC0xOTggLTExOWgtMTdxLTMzIDAgLTc2LjUgMTQuNXQtNzQuNSA0MS41bC0yMSAxOHEtMTggMTYgLTQ5IDE2aC0xNnEtMTcgMCAtMzIuNSAtMTEuNXQtNDAuNSAtNDIuNWwtMTkgLTI2bC0xMjAgOTB6TTE4MiAxMDI0aDM1NHYtODc0CmgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJbWFjcm9uIiB1bmljb2RlPSImI3gxMmE7IiAKZD0iTTIzNSAxNTAzdjE1MGg0NTN2LTE1MGgtNDUzek04MzIgMTQwMHYtMTUwaC0yOTZ2LTExMDBoMjk2di0xNTBoLTc0MnYxNTBoMjk2djExMDBoLTI5NnYxNTBoNzQyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpbWFjcm9uIiB1bmljb2RlPSImI3gxMmI7IiAKZD0iTTI0MyAxMTM1djE1MGg0NTN2LTE1MGgtNDUzek0xODIgMTAyNGgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJYnJldmUiIHVuaWNvZGU9IiYjeDEyYzsiIApkPSJNNDU5IDE0NjdxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek04MzIgMTQwMHYtMTUwaC0yOTZ2LTExMDBoMjk2di0xNTBoLTc0MnYxNTBoMjk2djExMDBoLTI5NnYxNTBoNzQyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpYnJldmUiIHVuaWNvZGU9IiYjeDEyZDsiIApkPSJNNDY3IDExNjlxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek0xODIgMTAyNGgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJb2dvbmVrIiB1bmljb2RlPSImI3gxMmU7IiAKZD0iTTU2MCAtMzU4cS01OSAtNDkgLTEzMyAtNDlxLTg0IDAgLTE0My41IDYwdC01OS41IDE0NHEwIDgyIDU3IDE0MmwxMDUgMTA1djQxaDE1MHYtMTAzbC0xNDcgLTE0N3EtMTUgLTE3IC0xNSAtMzhxMCAtMjIgMTYgLTM4dDM3IC0xNnExOSAwIDM1IDEzbDI3IDIzbDk4IC0xMTN6TTgzMiAxNDAwdi0xNTBoLTI5NnYtMTEwMGgyOTZ2LTE1MGgtNzQydjE1MGgyOTZ2MTEwMGgtMjk2djE1MGg3NDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImlvZ29uZWsiIHVuaWNvZGU9IiYjeDEyZjsiIApkPSJNNTYwIC0zNThxLTU5IC00OSAtMTMzIC00OXEtODQgMCAtMTQzLjUgNjB0LTU5LjUgMTQ0cTAgODIgNTcgMTQybDEwNSAxMDV2NDFoMTUwdi0xMDNsLTE0NyAtMTQ3cS0xNSAtMTcgLTE1IC0zOHEwIC0yMiAxNiAtMzh0MzcgLTE2cTE5IDAgMzUgMTNsMjcgMjNsOTggLTExM3pNMzUyIDEyOTdxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3oKTTE4MiAxMDI0aDM1NHYtODc0aDIwNHYtMTUwaC01NTh2MTUwaDIwNHY3MjRoLTIwNHYxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Iklkb3RhY2NlbnQiIHVuaWNvZGU9IiYjeDEzMDsiIApkPSJNMzQxIDE1NzRxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNODMyIDE0MDB2LTE1MGgtMjk2di0xMTAwaDI5NnYtMTUwaC03NDJ2MTUwaDI5NnYxMTAwaC0yOTZ2MTUwaDc0MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZG90bGVzc2kiIHVuaWNvZGU9IiYjeDEzMTsiIApkPSJNMTgyIDEwMjRoMzU0di04NzRoMjA0di0xNTBoLTU1OHYxNTBoMjA0djcyNGgtMjA0djE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iSUoiIHVuaWNvZGU9IiYjeDEzMjsiIApkPSJNNTE1IDQxMnE2MCAwIDYwIDE4NXY2NTNoLTIyOXYtMTEwMGgyMTZ2LTE1MGgtNTIydjE1MGgxNTZ2MTEwMGgtMTU2djE1MGg4NDJ2LTE1MGgtMTU3di02NTNxMCAtODMgLTE0IC0xNDZ0LTM1IC05OHQtNTEgLTU2LjV0LTU1LjUgLTI4dC01NC41IC02LjVoLTg4djE1MGg4OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaWoiIHVuaWNvZGU9IiYjeDEzMzsiIApkPSJNNzgyIDEzMTVxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNNzI1IC0yMDFxNTAgMCA3OS41IDI4dDI5LjUgODJ2OTgzaC0zMTh2MTUwaDQ2OHYtMTEzM3EwIC0xMTcgLTczLjUgLTE4OC41dC0xODUuNSAtNzEuNXEtMTA3IDAgLTE4MyA3Ny41dC03NiAxODEuNWgxNTBxMCAtNDIgMzIuNSAtNzUuNXQ3Ni41IC0zMy41ek0yMjYgMTI5OApxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNNTYgMTAyNWgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJKY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4MTM0OyIgCmQ9Ik02NjAgMTcwNWwxNjYgLTExN2wtODYgLTEyMWwtMTU3IDEwOGwtMTU3IC0xMDhsLTg2IDEyMWwxNjYgMTE3aDE1NHpNODUyIDE0MDB2LTE1MGgtMTcydi05MTNxMCAtMTY1IC04MyAtMjYzLjV0LTIxNyAtOTguNWgtMThxLTU1IDAgLTEwMCAxMnQtNzQuNSAzMy41dC01MC41IDQzdC0zNCA1MHQtMTguNSA0NHQtOS41IDMzLjVsMTQ2IDM0cTEyIC01MyA0NC41IC03Ni41dDk2LjUgLTIzLjVoMThxNDMgMCA3NCAxOS41dDQ2LjUgNTIKdDIyLjUgNjd0NyA3My41djkxM2gtMjEydjE1MGg1MzR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImpjaXJjdW1mbGV4IiB1bmljb2RlPSImI3gxMzU7IiAKZD0iTTczOCAxNDA3bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek00NzYgLTIxOXE1MCAwIDc5LjUgMjh0MjkuNSA4MnY5ODNoLTMxOHYxNTBoNDY4di0xMTMzcTAgLTExNyAtNzMuNSAtMTg4LjV0LTE4NS41IC03MS41cS0xMDcgMCAtMTgzIDc3LjV0LTc2IDE4MS41aDE1MHEwIC00MiAzMi41IC03NS41dDc2LjUgLTMzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IktjZWRpbGxhIiB1bmljb2RlPSImI3gxMzY7IiAKZD0iTTYyMyAtMTk1cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDJ0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzek0xMDggMHYxNDAwaDE1MHYtNjQ4bDM5NyA2NDhoMTc2bC0zNjYgLTU5N2wzODMgLTgwM2gtMTY3bC0zMTAgNjUwbC0xMTMgLTE4NHYtNDY2aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImtjZWRpbGxhIiB1bmljb2RlPSImI3gxMzc7IiAKZD0iTTYyNCAtMTk1cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDJ0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzek0xMDcgMHYxNDI1aDE1MHYtODMybDQyNSA1MThsMTE2IC05NmwtMzI3IC0zOTlsMzU4IC02MTZoLTE3NWwtMjg1IDQ5MmwtMTEyIC0xMzZ2LTM1NmgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJrZ3JlZW5sYW5kaWMiIHVuaWNvZGU9IiYjeDEzODsiIApkPSJNMjU3IDBoLTE1MHYxMDI0aDE1MHYtNjU3bDQ1MSA2NTdsMTI0IC04NWwtMzM4IC00OTFsMzM5IC00NDhoLTE4OGwtMjQxIDMxN2wtMTQ3IC0yMTR2LTEwM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iTGFjdXRlIiB1bmljb2RlPSImI3gxMzk7IiAKZD0iTTQyNiAxMzgzbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTI1NyAxNTFoNTc1di0xNTFoLTcyNXYxNDAwaDE1MHYtMTI0OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGFjdXRlIiB1bmljb2RlPSImI3gxM2E7IiAKZD0iTTQ3NiAxMzg0bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTE4MiAxMzcwLjg2aDM1NHYtMTIyMy45OGgyMDR2LTE0Ni44NzhoLTU1OHYxNDYuODc4aDIwNHYxMDc3LjExaC0yMDR2MTQ2Ljg3OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iTGNlZGlsbGEiIHVuaWNvZGU9IiYjeDEzYjsiIApkPSJNNjMyIC0xOTVxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6TTI1NyAxNTFoNTc1di0xNTFoLTcyNXYxNDAwaDE1MHYtMTI0OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGNlZGlsbGEiIHVuaWNvZGU9IiYjeDEzYzsiIApkPSJNNjMyIC0xOTVxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6TTE4MiAxNDAwaDM1NHYtMTI1MGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2MTEwMGgtMjA0djE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iTGNhcm9uIiB1bmljb2RlPSImI3gxM2Q7IiAKZD0iTTc2MiAxMzM4cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDJ0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzek0yNTcgMTUxaDU3NXYtMTUxaC03MjV2MTQwMGgxNTB2LTEyNDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxjYXJvbiIgdW5pY29kZT0iJiN4MTNlOyIgCmQ9Ik04ODAgMTQxNnEwIC0zNDYgLTI5OCAtMzgwbC0xNSA1NXE0OSAxOCA5Ni41IDU5dDQ3LjUgODVxMCA1NiAtMzQgNjZxLTQ1IDEzIC02Ny41IDQ0LjV0LTIyLjUgNzAuNXEwIDU5IDQxLjUgMTAydDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3pNMTEyIDE0MDBoMzU0di0xMjUwaDIwNHYtMTUwaC01NTh2MTUwaDIwNHYxMTAwaC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJMZG90IiB1bmljb2RlPSImI3gxM2Y7IiAKZD0iTTgyNiA3MTFxMCAtNjAgLTQxIC0xMDN0LTEwNSAtNDNxLTYyIDAgLTEwNCA0M3QtNDIgMTAzcTAgNTkgNDEuNSAxMDN0MTA0LjUgNDR0MTA0LjUgLTQzLjV0NDEuNSAtMTAzLjV6TTI1NyAxNTFoNTc1di0xNTFoLTcyNXYxNDAwaDE1MHYtMTI0OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGRvdCIgdW5pY29kZT0iJiN4MTQwOyIgCmQ9Ik04NzggNzQ3cTAgLTYwIC00MSAtMTAzdC0xMDUgLTQzcS02MiAwIC0xMDQgNDN0LTQyIDEwM3EwIDU5IDQxLjUgMTAzdDEwNC41IDQ0dDEwNC41IC00My41dDQxLjUgLTEwMy41ek0xMTIgMTQwMGgzNTR2LTEyNTBoMjA0di0xNTBoLTU1OHYxNTBoMjA0djExMDBoLTIwNHYxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkxzbGFzaCIgdW5pY29kZT0iJiN4MTQxOyIgCmQ9Ik0yNTcgMTUxaDU3NXYtMTUxaC03MjV2NDU2bC00MSAtMTVsLTUyIDE0Mmw5MyAzNHY3ODNoMTUwdi03MjlsMzU5IDEzMGw1MiAtMTQybC00MTEgLTE0OXYtMzU5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsc2xhc2giIHVuaWNvZGU9IiYjeDE0MjsiIApkPSJNNzM2IDgwMWw1MiAtMTQybC0yNTIgLTkxdi00MThoMjA0di0xNTBoLTU1OHYxNTBoMjA0djM2M2wtMjAwIC03MmwtNTIgMTQybDI1MiA5MXY1NzZoLTIwNHYxNTBoMzU0di02NzF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik5hY3V0ZSIgdW5pY29kZT0iJiN4MTQzOyIgCmQ9Ik00NzYgMTM4NGwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek0yNTcgMGgtMTUwdjE0MDBoMTM1bDQyMyAtOTg2djk4NmgxNTB2LTE0MDBoLTEzNmwtNDIyIDk4NXYtOTg1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJuYWN1dGUiIHVuaWNvZGU9IiYjeDE0NDsiIApkPSJNNDI0IDExNTlsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNMjU3IDBoLTE1MHYxMDI0aDE1MHYtNjdxODkgOTIgMTk1IDkyaDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY3MTlxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS00OCAwIC05NC41IC01My41dC03My41IC0xMjMuNXQtMjcgLTEyNXYtNTk3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJOY2VkaWxsYSIgdW5pY29kZT0iJiN4MTQ1OyIgCmQ9Ik02MzIgLTE5NXEwIC0zNDYgLTI5OCAtMzgwbC0xNSA1NXE0OSAxOCA5Ni41IDU5dDQ3LjUgODVxMCA1NiAtMzQgNjZxLTQ1IDEzIC02Ny41IDQ0LjV0LTIyLjUgNzAuNXEwIDU5IDQxLjUgMTAydDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3pNMjU3IDBoLTE1MHYxNDAwaDEzNWw0MjMgLTk4NnY5ODZoMTUwdi0xNDAwaC0xMzZsLTQyMiA5ODV2LTk4NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibmNlZGlsbGEiIHVuaWNvZGU9IiYjeDE0NjsiIApkPSJNNjMyIC0xOTVxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6TTI1NyAwaC0xNTB2MTAyNGgxNTB2LTY3cTg5IDkyIDE5NSA5MmgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NzE5cTAgOTggLTQzIDEzOQp0LTE1MiA0MWgtMThxLTQ4IDAgLTk0LjUgLTUzLjV0LTczLjUgLTEyMy41dC0yNyAtMTI1di01OTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik5jYXJvbiIgdW5pY29kZT0iJiN4MTQ3OyIgCmQ9Ik00NjEgMTYxNGwxNTcgMTA5bDg2IC0xMjJsLTE2NiAtMTE3aC0xNTRsLTE2NiAxMTdsODYgMTIyek0yNTcgMGgtMTUwdjE0MDBoMTM1bDQyMyAtOTg2djk4NmgxNTB2LTE0MDBoLTEzNmwtNDIyIDk4NXYtOTg1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJuY2Fyb24iIHVuaWNvZGU9IiYjeDE0ODsiIApkPSJNNDYxIDEzMjNsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnpNMjU3IDBoLTE1MHYxMDI0aDE1MHYtNjdxODkgOTIgMTk1IDkyaDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY3MTlxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS00OCAwIC05NC41IC01My41dC03My41IC0xMjMuNXQtMjcgLTEyNXYtNTk3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJuYXBvc3Ryb3BoZSIgdW5pY29kZT0iJiN4MTQ5OyIgCmQ9Ik0xMjggMTEwMnEtMjggLTQ4IC03NCAtNDhxLTI4IDAgLTQ3IDIwdC0xOSA1NHEwIDE4IDQgMzFsNzkgMzE5cTkgMzggNDcgNjN0ODAgMjVxNTEgMCA4MS41IC0zNy41dDMwLjUgLTg1LjVxMCAtMzQgLTE1IC01OXpNMzM3IDBoLTE1MHYxMDI0aDE1MHYtNjdxODkgOTIgMTk1IDkyaDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di03MTloLTE1MHY3MTlxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4CnEtNDggMCAtOTQuNSAtNTMuNXQtNzMuNSAtMTIzLjV0LTI3IC0xMjV2LTU5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iRW5nIiB1bmljb2RlPSImI3gxNGE7IiAKZD0iTTI1NyAwaC0xNTB2MTQwMGgxNTB2LTcxcTg5IDk2IDE5NSA5NmgxOHExNjEgMCAyNTMgLTk2dDkyIC0yNjZ2LTEwOTFxMCAtMTQ0IC04MSAtMjQyLjV0LTIwOCAtOTguNWgtNTFxLTEyOCAwIC0yMDMgOTRsMTE4IDk0cTMwIC0zOCA4NSAtMzhoNTFxNjIgMCAxMDAuNSA1NXQzOC41IDEzNnYxMDkxcTAgMTE0IC01MC41IDE2M3QtMTQ0LjUgNDloLTE4cS00NyAwIC05NCAtNTcuNXQtNzQgLTEzMXQtMjcgLTEyOC41di05NTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVuZyIgdW5pY29kZT0iJiN4MTRiOyIgCmQ9Ik0yNTcgMGgtMTUwdjEwMjRoMTUwdi02N3E4OSA5MiAxOTUgOTJoMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTc0N3EwIC0xNDQgLTgxIC0yNDIuNXQtMjA4IC05OC41aC01MXEtMTI4IDAgLTIwMyA5NGwxMTggOTRxMzAgLTM4IDg1IC0zOGg1MXE2MiAwIDEwMC41IDU1dDM4LjUgMTM2djc0N3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTQ4IDAgLTk0LjUgLTUzLjV0LTczLjUgLTEyMy41CnQtMjcgLTEyNXYtNTk3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJPbWFjcm9uIiB1bmljb2RlPSImI3gxNGM7IiAKZD0iTTI0MCAxNTAzdjE1MGg0NTN2LTE1MGgtNDUzek04MjUgNzY1di02OXEwIC0xNzkgLTI0IC0zMTMuNXQtNjAgLTIxMHQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxCnQxNy41IC0xNDkuNXQzNSAtMTQxdDYxIC05OS41dDkxLjUgLTQwaDExcTUyIDAgOTEuNSA0MC41dDYxIDk5LjV0MzQuNSAxNDAuNXQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib21hY3JvbiIgdW5pY29kZT0iJiN4MTRkOyIgCmQ9Ik0yNDYgMTEzNXYxNTBoNDUzdi0xNTBoLTQ1M3pNODI1IDU2MnYtOTJxMCAtMTE2IC0yMy41IC0yMDYuNXQtNTkgLTE0My41dC04My41IC04N3QtOTIuNSAtNDZ0LTkwLjUgLTEyaC0zNXEtMTY4IDAgLTI1NiAxMzh0LTg4IDM1OHY5MHEwIDEwMCAxOS41IDE4NXQ1OS41IDE1NHQxMDcuNSAxMDguNXQxNTUuNSAzOS41aDM5cTg5IDAgMTU3IC0zOXQxMDguNSAtMTA3dDYxIC0xNTR0MjAuNSAtMTg2ek00NzggODk4aC0zOQpxLTU1IDAgLTk0LjUgLTMwLjV0LTU5LjUgLTgyLjV0LTI5IC0xMDd0LTkgLTExN3YtOTBxMCAtNjMgOSAtMTE5LjV0MjkuNSAtMTEwdDYwLjUgLTg1dDk1IC0zMS41aDM1cTQ2IDAgODEuNSAyMC41dDU3LjUgNTR0MzUuNSA3OS41dDE5IDkyLjV0NS41IDk4LjV2OTJxMCA0OSAtNSA5NHQtMTkgOTB0LTM1LjUgNzh0LTU2LjUgNTMuNXQtODEgMjAuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iT2JyZXZlIiB1bmljb2RlPSImI3gxNGU7IiAKZD0iTTQ2NCAxNDY5cS04NCAwIC0xNTguNSAzN3QtMTI4LjUgMTAybDExNSA5NnE3MCAtODUgMTcyIC04NXExMDUgMCAxNzggODZsMTE0IC05N3EtNTUgLTY1IC0xMzEgLTEwMnQtMTYxIC0zN3pNODI1IDc2NXYtNjlxMCAtMTc5IC0yNCAtMzEzLjV0LTYwIC0yMTB0LTg2LjUgLTEyMnQtOTQuNSAtNjF0LTkzIC0xNC41aC0xMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjV0LTg3IDEyMnQtNjAgMjEwLjV0LTI0IDMxNHY2N3EwIDY2MiAzNTggNjYyaDEyCnEzNTggMCAzNTggLTY2MHpNNDY3IDEyNzVoLTEycS0xMDUgMCAtMTU2LjUgLTEyNXQtNTEuNSAtMzg3di02N3EwIC03MyA0IC0xNDF0MTcuNSAtMTQ5LjV0MzUgLTE0MXQ2MSAtOTkuNXQ5MS41IC00MGgxMXE1MiAwIDkxLjUgNDAuNXQ2MSA5OS41dDM0LjUgMTQwLjV0MTcgMTQ5LjV0NCAxNDF2NjlxMCAyNjEgLTUxIDM4NS41dC0xNTcgMTI0LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im9icmV2ZSIgdW5pY29kZT0iJiN4MTRmOyIgCmQ9Ik00NzAgMTE2OXEtODQgMCAtMTU4LjUgMzd0LTEyOC41IDEwMmwxMTUgOTZxNzAgLTg1IDE3MiAtODVxMTA1IDAgMTc4IDg2bDExNCAtOTdxLTU1IC02NSAtMTMxIC0xMDJ0LTE2MSAtMzd6TTgyNSA1NjJ2LTkycTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjUKdDE1NS41IDM5LjVoMzlxODkgMCAxNTcgLTM5dDEwOC41IC0xMDd0NjEgLTE1NHQyMC41IC0xODZ6TTQ3OCA4OThoLTM5cS01NSAwIC05NC41IC0zMC41dC01OS41IC04Mi41dC0yOSAtMTA3dC05IC0xMTd2LTkwcTAgLTYzIDkgLTExOS41dDI5LjUgLTExMHQ2MC41IC04NXQ5NSAtMzEuNWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNDkgLTUgOTR0LTE5IDkwdC0zNS41IDc4CnQtNTYuNSA1My41dC04MSAyMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJPaHVuZ2FydW1sYXV0IiB1bmljb2RlPSImI3gxNTA7IiAKZD0iTTE4NCAxMzgxbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTY0MiAxMzg3bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTgyNSA3NjV2LTY5cTAgLTE3OSAtMjQgLTMxMy41dC02MCAtMjEwdC04Ni41IC0xMjJ0LTk0LjUgLTYxdC05MyAtMTQuNWgtMTFxLTQ5IDAgLTkzIDE0dC05NSA2MC41dC04NyAxMjJ0LTYwIDIxMC41dC0yNCAzMTR2NjdxMCA2NjIgMzU4IDY2MmgxMnEzNTggMCAzNTggLTY2MHpNNDY3IDEyNzVoLTEyCnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMTFxNTIgMCA5MS41IDQwLjV0NjEgOTkuNXQzNC41IDE0MC41dDE3IDE0OS41dDQgMTQxdjY5cTAgMjYxIC01MSAzODUuNXQtMTU3IDEyNC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvaHVuZ2FydW1sYXV0IiB1bmljb2RlPSImI3gxNTE7IiAKZD0iTTE2NSAxMTM5bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTYyMyAxMTQ1bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTgyNSA1NjJ2LTkycTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjV0MTU1LjUgMzkuNWgzOXE4OSAwIDE1NyAtMzl0MTA4LjUgLTEwNwp0NjEgLTE1NHQyMC41IC0xODZ6TTQ3OCA4OThoLTM5cS01NSAwIC05NC41IC0zMC41dC01OS41IC04Mi41dC0yOSAtMTA3dC05IC0xMTd2LTkwcTAgLTYzIDkgLTExOS41dDI5LjUgLTExMHQ2MC41IC04NXQ5NSAtMzEuNWgzNXE0NiAwIDgxLjUgMjAuNXQ1Ny41IDU0dDM1LjUgNzkuNXQxOSA5Mi41dDUuNSA5OC41djkycTAgNDkgLTUgOTR0LTE5IDkwdC0zNS41IDc4dC01Ni41IDUzLjV0LTgxIDIwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik9FIiB1bmljb2RlPSImI3gxNTI7IiAKZD0iTTI4NSAxNDAwaDU2cTUzIDAgMTA1IC0yMnYyMmgzNzV2LTE1MGgtMjI1di00NDNoMTc0di0xNTBoLTE3NHYtNTA3aDIyNXYtMTUwaC0zNzV2MjNxLTUxIC0yMyAtMTA1IC0yM2gtNTZxLTEwNiAwIC0xODIuNSA3MS41dC03Ni41IDE3Mi41djkxMnEwIDEwMyA3Ni41IDE3My41dDE4Mi41IDcwLjV6TTE3NiAxMTU2di05MTJxMCAtMzYgMzEgLTY1dDc4IC0yOWg1NnEzOCAwIDcxLjUgMjcuNXQzMy41IDY2LjV2OTEycTAgNDIgLTMzIDY4CnQtNzIgMjZoLTU2cS00OCAwIC03OC41IC0yOC41dC0zMC41IC02NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvZSIgdW5pY29kZT0iJiN4MTUzOyIgCmQ9Ik01MzYgODA1di0xODhoMjEwdjE4OHEwIDQ1IC0zMCA2OS41dC03NSAyNC41cS0zOCAwIC03MS41IC0yNy41dC0zMy41IC02Ni41ek01MzYgMjE5cTAgLTQyIDMzIC02OHQ3MiAtMjZxNDQgMCA3NC41IDI1dDMwLjUgNjloMTUwcTAgLTEwNyAtNzQuNSAtMTc1LjV0LTE4MC41IC02OC41dC0xODEgNzJxLTc1IC03MiAtMTc5IC03MnEtMTA3IDAgLTE4MSA2OC41dC03NCAxNzUuNXY1ODZxMCAxMDcgNzUgMTc1LjV0MTgwIDY4LjUKcTEwNiAwIDE4MSAtNzJxNzUgNzIgMTc5IDcycTEwOCAwIDE4MS41IC02OHQ3My41IC0xNzZ2LTMzOGgtMzYwdi0yNDh6TTE3NiA4MDV2LTU4NnEwIC00NCAyOS41IC02OXQ3NS41IC0yNXEzOCAwIDcxLjUgMjcuNXQzMy41IDY2LjV2NTg2cTAgNDIgLTMzIDY4dC03MiAyNnEtNDQgMCAtNzQuNSAtMjV0LTMwLjUgLTY5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJSYWN1dGUiIHVuaWNvZGU9IiYjeDE1NDsiIApkPSJNMjcwIDEzODRsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNNDcwIDc5MnExMjAgMCAxNjYgNDZ0NDYgMTM1djkwcTAgMTA1IC00NS41IDE0NnQtMTY2LjUgNDFoLTIzMXYtNDU4aDIzMXpNODkgMHYxNDAwaDM4MXE2MiAwIDExMi41IC05dDk4IC0zMnQ4MCAtNjAuNXQ1MiAtOTd0MTkuNSAtMTM4LjV2LTkwcTAgLTU1IC0xMi41IC0xMDMuNXQtNDAuNSAtOTQuNXQtODEgLTc5dC0xMjcgLTQ2bDI4OCAtNjUwaC0xNjRsLTI4NSA2NDJoLTE3MQp2LTY0MmgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyYWN1dGUiIHVuaWNvZGU9IiYjeDE1NTsiIApkPSJNNDA3IDExNTNsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNMjU3IDBoLTE1MHYxMDI0aDE1MHYtMTI1cTExOSAxNTAgMjY1IDE1MGgxOHExOTkgMCAyNzQgLTE1MGwtMTM0IC02OHEtMTggMzUgLTQ5IDUxLjV0LTkxIDE2LjVoLTE4cS02MSAwIC0xMjMuNSAtNjYuNXQtMTAyIC0xNjcuNXQtMzkuNSAtMTk1di00NzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlJjZWRpbGxhIiB1bmljb2RlPSImI3gxNTY7IiAKZD0iTTYyNSAtMTk1cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDJ0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzek00NzAgNzkycTEyMCAwIDE2NiA0NnQ0NiAxMzV2OTBxMCAxMDUgLTQ1LjUgMTQ2dC0xNjYuNSA0MWgtMjMxdi00NThoMjMxek04OSAwdjE0MDBoMzgxcTYyIDAgMTEyLjUgLTl0OTggLTMyCnQ4MCAtNjAuNXQ1MiAtOTd0MTkuNSAtMTM4LjV2LTkwcTAgLTU1IC0xMi41IC0xMDMuNXQtNDAuNSAtOTQuNXQtODEgLTc5dC0xMjcgLTQ2bDI4OCAtNjUwaC0xNjRsLTI4NSA2NDJoLTE3MXYtNjQyaC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJjZWRpbGxhIiB1bmljb2RlPSImI3gxNTc7IiAKZD0iTTM3NyAtMTk1cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDJ0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzek0yNTcgMGgtMTUwdjEwMjRoMTUwdi0xMjVxMTE5IDE1MCAyNjUgMTUwaDE4cTE5OSAwIDI3NCAtMTUwbC0xMzQgLTY4cS0xOCAzNSAtNDkgNTEuNXQtOTEgMTYuNWgtMTgKcS02MSAwIC0xMjMuNSAtNjYuNXQtMTAyIC0xNjcuNXQtMzkuNSAtMTk1di00NzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlJjYXJvbiIgdW5pY29kZT0iJiN4MTU4OyIgCmQ9Ik00MTYgMTYxOGwxNTcgMTA5bDg2IC0xMjJsLTE2NiAtMTE3aC0xNTRsLTE2NiAxMTdsODYgMTIyek00NzAgNzkycTEyMCAwIDE2NiA0NnQ0NiAxMzV2OTBxMCAxMDUgLTQ1LjUgMTQ2dC0xNjYuNSA0MWgtMjMxdi00NThoMjMxek04OSAwdjE0MDBoMzgxcTYyIDAgMTEyLjUgLTl0OTggLTMydDgwIC02MC41dDUyIC05N3QxOS41IC0xMzguNXYtOTBxMCAtNTUgLTEyLjUgLTEwMy41dC00MC41IC05NC41dC04MSAtNzl0LTEyNyAtNDYKbDI4OCAtNjUwaC0xNjRsLTI4NSA2NDJoLTE3MXYtNjQyaC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJjYXJvbiIgdW5pY29kZT0iJiN4MTU5OyIgCmQ9Ik00NTggMTMyM2wxNTcgMTA5bDg2IC0xMjJsLTE2NiAtMTE3aC0xNTRsLTE2NiAxMTdsODYgMTIyek0yNTcgMGgtMTUwdjEwMjRoMTUwdi0xMjVxMTE5IDE1MCAyNjUgMTUwaDE4cTE5OSAwIDI3NCAtMTUwbC0xMzQgLTY4cS0xOCAzNSAtNDkgNTEuNXQtOTEgMTYuNWgtMThxLTYxIDAgLTEyMy41IC02Ni41dC0xMDIgLTE2Ny41dC0zOS41IC0xOTV2LTQ3MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iU2FjdXRlIiB1bmljb2RlPSImI3gxNWE7IiAKZD0iTTQwNyAxMzg0bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTQ1MiAxMjVoMThxODQgMCAxNDkuNSA2My41dDY1LjUgMTQ4LjV2MzBxMCA3NSAtMzYuNSAxNTN0LTEwMC41IDExMGwtMjYyIDEzM3EtODQgNDMgLTEyOC41IDExNnQtNDQuNSAxNTR2MzBxMCAxNDkgOTQuNSAyNTUuNXQyNDAuNSAxMDYuNWgyN3ExMjQgMCAyMTUuNSAtNTd0MTI1LjUgLTE2OXExNSAtNDkgMTUgLTEzNmgtMTUwcTAgNjEgLTkgOTJxLTM2IDEyMCAtMTk3IDEyMApoLTI3cS04MSAwIC0xMzMgLTYxLjV0LTUyIC0xNTAuNXYtMzBxMCAtMzQgMjAgLTcydDcxIC02NGwyNjQgLTEzNXExMDMgLTUzIDE2MCAtMTY3LjV0NTcgLTIyNy41di0zMHEwIC0xNDggLTExMCAtMjU1dC0yNTUgLTEwN2gtMThxLTk2IDAgLTE4NiA1My41dC0xNDYgMTQyLjV0LTU2IDE4NmgxNTBxMCAtODYgNzYgLTE1OXQxNjIgLTczeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzYWN1dGUiIHVuaWNvZGU9IiYjeDE1YjsiIApkPSJNNDExIDExNDRsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNNjY1IDcxOXEwIDc5IC01MS41IDEyOS41dC0xNDMuNSA1MC41aC0xOHEtOTYgMCAtMTQ1LjUgLTMyLjV0LTQ5LjUgLTc3LjV2LTEycTMgLTM1IDE3LjUgLTU2LjV0MjguNSAtMjYuNWwzNzcgLTE3NXE1NSAtMjYgOTUgLTgydDQwIC0xMzZ2LTQ2cTAgLTEyNCAtOTkgLTIwMnQtMjQ2IC03OGgtNDhxLTEwNCAwIC0xODUgNTR0LTEyMC41IDEzNS41dC0zOS41IDE3Mi41aDE1MApxMCAtODAgNTMuNSAtMTQ2dDE0MS41IC02Nmg0OHE3OCAwIDEzNi41IDM0dDU4LjUgOTZ2NDZxMCAyNiAtMTYgNDkuNXQtMzMgMzIuNWwtMzc1IDE3M3EtMzcgMTggLTY1IDQ5LjV0LTQyIDY1dC0yMC41IDYwLjV0LTYuNSA0NnYxMnEwIDY2IDM0LjUgMTE4dDg4LjUgODJ0MTExIDQ1dDExMSAxNWgxOHExMTMgMCAxOTMgLTQ2LjV0MTE2IC0xMTkuNXQzNiAtMTY0aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlNjaXJjdW1mbGV4IiB1bmljb2RlPSImI3gxNWM7IiAKZD0iTTU1OCAxNzA0bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek00NTIgMTI1aDE4cTg0IDAgMTQ5LjUgNjMuNXQ2NS41IDE0OC41djMwcTAgNzUgLTM2LjUgMTUzdC0xMDAuNSAxMTBsLTI2MiAxMzNxLTg0IDQzIC0xMjguNSAxMTZ0LTQ0LjUgMTU0djMwcTAgMTQ5IDk0LjUgMjU1LjV0MjQwLjUgMTA2LjVoMjdxMTI0IDAgMjE1LjUgLTU3dDEyNS41IC0xNjlxMTUgLTQ5IDE1IC0xMzYKaC0xNTBxMCA2MSAtOSA5MnEtMzYgMTIwIC0xOTcgMTIwaC0yN3EtODEgMCAtMTMzIC02MS41dC01MiAtMTUwLjV2LTMwcTAgLTM0IDIwIC03MnQ3MSAtNjRsMjY0IC0xMzVxMTAzIC01MyAxNjAgLTE2Ny41dDU3IC0yMjcuNXYtMzBxMCAtMTQ4IC0xMTAgLTI1NXQtMjU1IC0xMDdoLTE4cS05NiAwIC0xODYgNTMuNXQtMTQ2IDE0Mi41dC01NiAxODZoMTUwcTAgLTg2IDc2IC0xNTl0MTYyIC03M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2NpcmN1bWZsZXgiIHVuaWNvZGU9IiYjeDE1ZDsiIApkPSJNNTY2IDE0MDlsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTY2NSA3MTlxMCA3OSAtNTEuNSAxMjkuNXQtMTQzLjUgNTAuNWgtMThxLTk2IDAgLTE0NS41IC0zMi41dC00OS41IC03Ny41di0xMnEzIC0zNSAxNy41IC01Ni41dDI4LjUgLTI2LjVsMzc3IC0xNzVxNTUgLTI2IDk1IC04MnQ0MCAtMTM2di00NnEwIC0xMjQgLTk5IC0yMDJ0LTI0NiAtNzhoLTQ4cS0xMDQgMCAtMTg1IDU0CnQtMTIwLjUgMTM1LjV0LTM5LjUgMTcyLjVoMTUwcTAgLTgwIDUzLjUgLTE0NnQxNDEuNSAtNjZoNDhxNzggMCAxMzYuNSAzNHQ1OC41IDk2djQ2cTAgMjYgLTE2IDQ5LjV0LTMzIDMyLjVsLTM3NSAxNzNxLTM3IDE4IC02NSA0OS41dC00MiA2NXQtMjAuNSA2MC41dC02LjUgNDZ2MTJxMCA2NiAzNC41IDExOHQ4OC41IDgydDExMSA0NXQxMTEgMTVoMThxMTEzIDAgMTkzIC00Ni41dDExNiAtMTE5LjV0MzYgLTE2NGgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJTY2VkaWxsYSIgdW5pY29kZT0iJiN4MTVlOyIgCmQ9Ik01NzggLTI4MXEwIDM5IC00MSA2MS41dC04MiAyMi41aC04MGwxNCAxODl2MTVoMTUwdi0yMWwtNCAtNjBxMTkzIC0zNSAxOTMgLTIwN3EwIC01OCAtMjggLTEwM3QtNzEgLTY4dC04NC41IC0zNHQtNzcuNSAtMTFxLTE0MCAwIC0yNTAgOTVsOTggMTA0cTY4IC01OSAxNTIgLTU5cTM1IDAgNzMgMjAuNXQzOCA1NS41ek00NTIgMTI1aDE4cTg0IDAgMTQ5LjUgNjMuNXQ2NS41IDE0OC41djMwcTAgNzUgLTM2LjUgMTUzdC0xMDAuNSAxMTAKbC0yNjIgMTMzcS04NCA0MyAtMTI4LjUgMTE2dC00NC41IDE1NHYzMHEwIDE0OSA5NC41IDI1NS41dDI0MC41IDEwNi41aDI3cTEyNCAwIDIxNS41IC01N3QxMjUuNSAtMTY5cTE1IC00OSAxNSAtMTM2aC0xNTBxMCA2MSAtOSA5MnEtMzYgMTIwIC0xOTcgMTIwaC0yN3EtODEgMCAtMTMzIC02MS41dC01MiAtMTUwLjV2LTMwcTAgLTM0IDIwIC03MnQ3MSAtNjRsMjY0IC0xMzVxMTAzIC01MyAxNjAgLTE2Ny41dDU3IC0yMjcuNXYtMzAKcTAgLTE0OCAtMTEwIC0yNTV0LTI1NSAtMTA3aC0xOHEtOTYgMCAtMTg2IDUzLjV0LTE0NiAxNDIuNXQtNTYgMTg2aDE1MHEwIC04NiA3NiAtMTU5dDE2MiAtNzN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNjZWRpbGxhIiB1bmljb2RlPSImI3gxNWY7IiAKZD0iTTU5MCAtMjgxcTAgMzkgLTQxIDYxLjV0LTgyIDIyLjVoLTgwbDE0IDE4OXYxNWgxNTB2LTIxbC00IC02MHExOTMgLTM1IDE5MyAtMjA3cTAgLTU4IC0yOCAtMTAzdC03MSAtNjh0LTg0LjUgLTM0dC03Ny41IC0xMXEtMTQwIDAgLTI1MCA5NWw5OCAxMDRxNjggLTU5IDE1MiAtNTlxMzUgMCA3MyAyMC41dDM4IDU1LjV6TTY2NSA3MTlxMCA3OSAtNTEuNSAxMjkuNXQtMTQzLjUgNTAuNWgtMThxLTk2IDAgLTE0NS41IC0zMi41CnQtNDkuNSAtNzcuNXYtMTJxMyAtMzUgMTcuNSAtNTYuNXQyOC41IC0yNi41bDM3NyAtMTc1cTU1IC0yNiA5NSAtODJ0NDAgLTEzNnYtNDZxMCAtMTI0IC05OSAtMjAydC0yNDYgLTc4aC00OHEtMTA0IDAgLTE4NSA1NHQtMTIwLjUgMTM1LjV0LTM5LjUgMTcyLjVoMTUwcTAgLTgwIDUzLjUgLTE0NnQxNDEuNSAtNjZoNDhxNzggMCAxMzYuNSAzNHQ1OC41IDk2djQ2cTAgMjYgLTE2IDQ5LjV0LTMzIDMyLjVsLTM3NSAxNzNxLTM3IDE4IC02NSA0OS41CnQtNDIgNjV0LTIwLjUgNjAuNXQtNi41IDQ2djEycTAgNjYgMzQuNSAxMTh0ODguNSA4MnQxMTEgNDV0MTExIDE1aDE4cTExMyAwIDE5MyAtNDYuNXQxMTYgLTExOS41dDM2IC0xNjRoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iU2Nhcm9uIiB1bmljb2RlPSImI3gxNjA7IiAKZD0iTTQ4MSAxNjE2bDE1NyAxMDlsODYgLTEyMmwtMTY2IC0xMTdoLTE1NGwtMTY2IDExN2w4NiAxMjJ6TTQ1MiAxMjVoMThxODQgMCAxNDkuNSA2My41dDY1LjUgMTQ4LjV2MzBxMCA3NSAtMzYuNSAxNTN0LTEwMC41IDExMGwtMjYyIDEzM3EtODQgNDMgLTEyOC41IDExNnQtNDQuNSAxNTR2MzBxMCAxNDkgOTQuNSAyNTUuNXQyNDAuNSAxMDYuNWgyN3ExMjQgMCAyMTUuNSAtNTd0MTI1LjUgLTE2OXExNSAtNDkgMTUgLTEzNmgtMTUwCnEwIDYxIC05IDkycS0zNiAxMjAgLTE5NyAxMjBoLTI3cS04MSAwIC0xMzMgLTYxLjV0LTUyIC0xNTAuNXYtMzBxMCAtMzQgMjAgLTcydDcxIC02NGwyNjQgLTEzNXExMDMgLTUzIDE2MCAtMTY3LjV0NTcgLTIyNy41di0zMHEwIC0xNDggLTExMCAtMjU1dC0yNTUgLTEwN2gtMThxLTk2IDAgLTE4NiA1My41dC0xNDYgMTQyLjV0LTU2IDE4NmgxNTBxMCAtODYgNzYgLTE1OXQxNjIgLTczeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzY2Fyb24iIHVuaWNvZGU9IiYjeDE2MTsiIApkPSJNNDg5IDEzMjNsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnpNNjY1IDcxOXEwIDc5IC01MS41IDEyOS41dC0xNDMuNSA1MC41aC0xOHEtOTYgMCAtMTQ1LjUgLTMyLjV0LTQ5LjUgLTc3LjV2LTEycTMgLTM1IDE3LjUgLTU2LjV0MjguNSAtMjYuNWwzNzcgLTE3NXE1NSAtMjYgOTUgLTgydDQwIC0xMzZ2LTQ2cTAgLTEyNCAtOTkgLTIwMnQtMjQ2IC03OGgtNDhxLTEwNCAwIC0xODUgNTQKdC0xMjAuNSAxMzUuNXQtMzkuNSAxNzIuNWgxNTBxMCAtODAgNTMuNSAtMTQ2dDE0MS41IC02Nmg0OHE3OCAwIDEzNi41IDM0dDU4LjUgOTZ2NDZxMCAyNiAtMTYgNDkuNXQtMzMgMzIuNWwtMzc1IDE3M3EtMzcgMTggLTY1IDQ5LjV0LTQyIDY1dC0yMC41IDYwLjV0LTYuNSA0NnYxMnEwIDY2IDM0LjUgMTE4dDg4LjUgODJ0MTExIDQ1dDExMSAxNWgxOHExMTMgMCAxOTMgLTQ2LjV0MTE2IC0xMTkuNXQzNiAtMTY0aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlRjZWRpbGxhIiB1bmljb2RlPSImI3gxNjI7IiAKZD0iTTU3NSAtMjU3cTAgMzkgLTQxIDYxLjV0LTgyIDIyLjVoLTgwbDE0IDE4OXYxNWgxNTB2LTIxbC00IC02MHExOTMgLTM1IDE5MyAtMjA3cTAgLTU4IC0yOCAtMTAzdC03MSAtNjh0LTg0LjUgLTM0dC03Ny41IC0xMXEtMTQwIDAgLTI1MCA5NWw5OCAxMDRxNjggLTU5IDE1MiAtNTlxMzUgMCA3MyAyMC41dDM4IDU1LjV6TTg1MiAxNDAwdi0xNTBoLTMxNnYtMTI1MGgtMTUwdjEyNTBoLTMxNnYxNTBoNzgyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0Y2VkaWxsYSIgdW5pY29kZT0iJiN4MTYzOyIgCmQ9Ik02NTYgLTI3NnEwIDM5IC00MSA2MS41dC04MiAyMi41aC04MGwxNCAxODl2MTVoMTUwdi0yMWwtNCAtNjBxMTkzIC0zNSAxOTMgLTIwN3EwIC01OCAtMjggLTEwM3QtNzEgLTY4dC04NC41IC0zNHQtNzcuNSAtMTFxLTE0MCAwIC0yNTAgOTVsOTggMTA0cTY4IC01OSAxNTIgLTU5cTM1IDAgNzMgMjAuNXQzOCA1NS41ek01NDAgMTI1cTM3IDAgNjkuNSAyM3QzNS41IDY3aDE1MHEtNSAtNTkgLTI3IC0xMDQuNXQtNTAuNSAtNzAKdC02NC41IC00MC41dC02Mi41IC0yMC41dC01MC41IC00LjVoLTE4cS05NyAwIC0xNzYgNjkuNXQtNzkgMTY2LjV2MTZsMzEgNjMxaC0yMDh2MTUwaDIxNWwyMSA0MTdoMTUwbC0yMCAtNDE3aDI4NHYtMTUwaC0yOTFsLTMyIC02Mzl2LThxMCAtMjkgMjkuNSAtNTcuNXQ3NS41IC0yOC41aDE4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJUY2Fyb24iIHVuaWNvZGU9IiYjeDE2NDsiIApkPSJNNDYxIDE2MThsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnpNODUyIDE0MDB2LTE1MGgtMzE2di0xMjUwaC0xNTB2MTI1MGgtMzE2djE1MGg3ODJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRjYXJvbiIgdW5pY29kZT0iJiN4MTY1OyIgCmQ9Ik04NTMgMTYxM3EwIC0zNDYgLTI5OCAtMzgwbC0xNSA1NXE0OSAxOCA5Ni41IDU5dDQ3LjUgODVxMCA1NiAtMzQgNjZxLTQ1IDEzIC02Ny41IDQ0LjV0LTIyLjUgNzAuNXEwIDU5IDQxLjUgMTAydDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3pNNTQwIDEyNXEzNyAwIDY5LjUgMjN0MzUuNSA2N2gxNTBxLTUgLTU5IC0yNyAtMTA0LjV0LTUwLjUgLTcwdC02NC41IC00MC41dC02Mi41IC0yMC41dC01MC41IC00LjVoLTE4CnEtOTcgMCAtMTc2IDY5LjV0LTc5IDE2Ni41djE2bDMxIDYzMWgtMjA4djE1MGgyMTVsMjEgNDE3aDE1MGwtMjAgLTQxN2gyODR2LTE1MGgtMjkxbC0zMiAtNjM5di04cTAgLTI5IDI5LjUgLTU3LjV0NzUuNSAtMjguNWgxOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVGJhciIgdW5pY29kZT0iJiN4MTY2OyIgCmQ9Ik04NTIgMTQwMHYtMTUwaC0zMTZ2LTYxNWgyNjl2LTE1MGgtMjY5di00ODVoLTE1MHY0ODVoLTI3MXYxNTBoMjcxdjYxNWgtMzE2djE1MGg3ODJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRiYXIiIHVuaWNvZGU9IiYjeDE2NzsiIApkPSJNNDE3IDIxMXEwIC0yOSAyOC41IC01NS41dDc2LjUgLTMwLjVoMThxMzIgMCA1OSAxNS41dDM4IDQwLjVsMTM2IC02MnEtMzEgLTY4IC05NiAtMTA2dC0xMzcgLTM4aC0xOHEtOTcgMCAtMTc2IDY5LjV0LTc5IDE2Ni41djI3bDEzIDI0N2gtMTY1djE1MGgxNzJsMTEgMjIzaC0yMDh2MTUwaDIxNWwyMSA0MTdoMTUwbC0yMCAtNDE3aDI4NHYtMTUwaC0yOTFsLTExIC0yMjNoMzY3di0xNTBoLTM3NWwtMTMgLTI1NXYtMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlV0aWxkZSIgdW5pY29kZT0iJiN4MTY4OyIgCmQ9Ik0xMjkgMTYzNHE5MSAxMTUgMTkzIDExNWgxNnE4NyAwIDE1MSAtNTVsMTkgLTE3cTIyIC0xOCA1MSAtMThoMTdxMjMgMiAzOCAxMS41dDM2IDQxLjVsMTYgMjRsMTI0IC04NGwtMTYgLTI0cS04MCAtMTE5IC0xOTggLTExOWgtMTdxLTMzIDAgLTc2LjUgMTQuNXQtNzQuNSA0MS41bC0yMSAxOHEtMTggMTYgLTQ5IDE2aC0xNnEtMTcgMCAtMzIuNSAtMTEuNXQtNDAuNSAtNDIuNWwtMTkgLTI2bC0xMjAgOTB6TTI1NyAzMzcKcTAgLTExNSA1MC41IC0xNjMuNXQxNDQuNSAtNDguNWgxOHE5NCAwIDE0NC41IDQ4LjV0NTAuNSAxNjMuNXYxMDYzaDE1MHYtMTA2M3EwIC0xNzIgLTkxLjUgLTI2N3QtMjUzLjUgLTk1aC0xOHEtMTYyIDAgLTI1My41IDk0LjV0LTkxLjUgMjY3LjV2MTA2M2gxNTB2LTEwNjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InV0aWxkZSIgdW5pY29kZT0iJiN4MTY5OyIgCmQ9Ik0xMjkgMTMyM3E5MSAxMTUgMTkzIDExNWgxNnE4NyAwIDE1MSAtNTVsMTkgLTE3cTIyIC0xOCA1MSAtMThoMTdxMjMgMiAzOCAxMS41dDM2IDQxLjVsMTYgMjRsMTI0IC04NGwtMTYgLTI0cS04MCAtMTE5IC0xOTggLTExOWgtMTdxLTMzIDAgLTc2LjUgMTQuNXQtNzQuNSA0MS41bC0yMSAxOHEtMTggMTYgLTQ5IDE2aC0xNnEtMTcgMCAtMzIuNSAtMTEuNXQtNDAuNSAtNDIuNWwtMTkgLTI2bC0xMjAgOTB6TTY2NSAxMDI0aDE1MHYtMTAyNApoLTE1MHY4OHEtMTAwIC0xMTMgLTIxNSAtMTEzaC0xOHEtNjYgMCAtMTIxLjUgMTh0LTEwMi41IDU3LjV0LTc0IDExMi41dC0yNyAxNzR2Njg3aDE1MHYtNjg3cTAgLTEyMCA0My41IC0xNjZ0MTMxLjUgLTQ2aDE4cTQ3IDAgOTkgNTh0ODQgMTM0dDMyIDEzMHY1Nzd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlVtYWNyb24iIHVuaWNvZGU9IiYjeDE2YTsiIApkPSJNMjM0IDE1MDN2MTUwaDQ1M3YtMTUwaC00NTN6TTI1NyAzMzdxMCAtMTE1IDUwLjUgLTE2My41dDE0NC41IC00OC41aDE4cTk0IDAgMTQ0LjUgNDguNXQ1MC41IDE2My41djEwNjNoMTUwdi0xMDYzcTAgLTE3MiAtOTEuNSAtMjY3dC0yNTMuNSAtOTVoLTE4cS0xNjIgMCAtMjUzLjUgOTQuNXQtOTEuNSAyNjcuNXYxMDYzaDE1MHYtMTA2M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW1hY3JvbiIgdW5pY29kZT0iJiN4MTZiOyIgCmQ9Ik0yMzQgMTEzNXYxNTBoNDUzdi0xNTBoLTQ1M3pNNjY1IDEwMjRoMTUwdi0xMDI0aC0xNTB2ODhxLTEwMCAtMTEzIC0yMTUgLTExM2gtMThxLTY2IDAgLTEyMS41IDE4dC0xMDIuNSA1Ny41dC03NCAxMTIuNXQtMjcgMTc0djY4N2gxNTB2LTY4N3EwIC0xMjAgNDMuNSAtMTY2dDEzMS41IC00NmgxOHE0NyAwIDk5IDU4dDg0IDEzNHQzMiAxMzB2NTc3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJVYnJldmUiIHVuaWNvZGU9IiYjeDE2YzsiIApkPSJNNDU4IDE0NjdxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek0yNTcgMzM3cTAgLTExNSA1MC41IC0xNjMuNXQxNDQuNSAtNDguNWgxOHE5NCAwIDE0NC41IDQ4LjV0NTAuNSAxNjMuNXYxMDYzaDE1MHYtMTA2M3EwIC0xNzIgLTkxLjUgLTI2N3QtMjUzLjUgLTk1aC0xOHEtMTYyIDAgLTI1My41IDk0LjUKdC05MS41IDI2Ny41djEwNjNoMTUwdi0xMDYzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1YnJldmUiIHVuaWNvZGU9IiYjeDE2ZDsiIApkPSJNNDU4IDExNjlxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek02NjUgMTAyNGgxNTB2LTEwMjRoLTE1MHY4OHEtMTAwIC0xMTMgLTIxNSAtMTEzaC0xOHEtNjYgMCAtMTIxLjUgMTh0LTEwMi41IDU3LjV0LTc0IDExMi41dC0yNyAxNzR2Njg3aDE1MHYtNjg3cTAgLTEyMCA0My41IC0xNjZ0MTMxLjUgLTQ2aDE4CnE0NyAwIDk5IDU4dDg0IDEzNHQzMiAxMzB2NTc3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJVcmluZyIgdW5pY29kZT0iJiN4MTZlOyIgCmQ9Ik0yNTEgMTQ5MnEwIDg0IDU4IDE0M3QxNDIgNTl0MTQ0IC01OXQ2MCAtMTQzdC02MCAtMTQzdC0xNDQgLTU5dC0xNDIgNTl0LTU4IDE0M3pNMzYxIDE0OTJxMCAtMzggMjYuNSAtNjV0NjQuNSAtMjd0NjUuNSAyN3QyNy41IDY1dC0yNy41IDY1dC02NS41IDI3dC02NC41IC0yN3QtMjYuNSAtNjV6TTI1NyAzMDcuNTJxMCAtMTA1LjYyMiA1MC41IC0xNTAuMTY3cTUwLjUgLTQ0LjU0NTkgMTQ0LjUgLTQ0LjU0NTloMTgKcTk0IDAgMTQ0LjUgNDQuNTQ1OXE1MC41IDQ0LjU0NDkgNTAuNSAxNTAuMTY3djk3Ni4zMmgxNTB2LTk3Ni4zMnEwIC0xNTcuOTc1IC05MS41IC0yNDUuMjI4dC0yNTMuNSAtODcuMjUyOWgtMThxLTE2MiAwIC0yNTMuNSA4Ni43OTM5dC05MS41IDI0NS42ODd2OTc2LjMyaDE1MHYtOTc2LjMyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1cmluZyIgdW5pY29kZT0iJiN4MTZmOyIgCmQ9Ik0yNTEgMTM2OXEwIDg0IDU4IDE0M3QxNDIgNTl0MTQ0IC01OXQ2MCAtMTQzdC02MCAtMTQzdC0xNDQgLTU5dC0xNDIgNTl0LTU4IDE0M3pNMzYxIDEzNjlxMCAtMzggMjYuNSAtNjV0NjQuNSAtMjd0NjUuNSAyN3QyNy41IDY1dC0yNy41IDY1dC02NS41IDI3dC02NC41IC0yN3QtMjYuNSAtNjV6TTY2NSAxMDI0aDE1MHYtMTAyNGgtMTUwdjg4cS0xMDAgLTExMyAtMjE1IC0xMTNoLTE4cS02NiAwIC0xMjEuNSAxOHQtMTAyLjUgNTcuNQp0LTc0IDExMi41dC0yNyAxNzR2Njg3aDE1MHYtNjg3cTAgLTEyMCA0My41IC0xNjZ0MTMxLjUgLTQ2aDE4cTQ3IDAgOTkgNTh0ODQgMTM0dDMyIDEzMHY1Nzd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlVodW5nYXJ1bWxhdXQiIHVuaWNvZGU9IiYjeDE3MDsiIApkPSJNMTk4IDEzODRsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNNjU2IDEzOTBsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNMjU3IDMzN3EwIC0xMTUgNTAuNSAtMTYzLjV0MTQ0LjUgLTQ4LjVoMThxOTQgMCAxNDQuNSA0OC41dDUwLjUgMTYzLjV2MTA2M2gxNTB2LTEwNjNxMCAtMTcyIC05MS41IC0yNjd0LTI1My41IC05NWgtMThxLTE2MiAwIC0yNTMuNSA5NC41dC05MS41IDI2Ny41djEwNjNoMTUwdi0xMDYzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1aHVuZ2FydW1sYXV0IiB1bmljb2RlPSImI3gxNzE7IiAKZD0iTTIwOCAxMTcybC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTY2NiAxMTc4bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTY2NSAxMDI0aDE1MHYtMTAyNGgtMTUwdjg4cS0xMDAgLTExMyAtMjE1IC0xMTNoLTE4cS02NiAwIC0xMjEuNSAxOHQtMTAyLjUgNTcuNXQtNzQgMTEyLjV0LTI3IDE3NHY2ODdoMTUwdi02ODdxMCAtMTIwIDQzLjUgLTE2NnQxMzEuNSAtNDZoMThxNDcgMCA5OSA1OHQ4NCAxMzR0MzIgMTMwdjU3N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVW9nb25layIgdW5pY29kZT0iJiN4MTcyOyIgCmQ9Ik01NTkgLTM4NHEtNTkgLTQ5IC0xMzMgLTQ5cS04NCAwIC0xNDMuNSA2MHQtNTkuNSAxNDRxMCA4MiA1NyAxNDJsMTA1IDEwNXY0MWgxNTB2LTEwM2wtMTQ3IC0xNDdxLTE1IC0xNyAtMTUgLTM4cTAgLTIyIDE2IC0zOHQzNyAtMTZxMTkgMCAzNSAxM2wyNyAyM2w5OCAtMTEzek0yNTcgMzM3cTAgLTExNSA1MC41IC0xNjMuNXQxNDQuNSAtNDguNWgxOHE5NCAwIDE0NC41IDQ4LjV0NTAuNSAxNjMuNXYxMDYzaDE1MHYtMTA2MwpxMCAtMTcyIC05MS41IC0yNjd0LTI1My41IC05NWgtMThxLTE2MiAwIC0yNTMuNSA5NC41dC05MS41IDI2Ny41djEwNjNoMTUwdi0xMDYzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1b2dvbmVrIiB1bmljb2RlPSImI3gxNzM7IiAKZD0iTTgzOSAtMzg0cS01OSAtNDkgLTEzMyAtNDlxLTg0IDAgLTE0My41IDYwdC01OS41IDE0NHEwIDgyIDU3IDE0MmwxMDUgMTA1djQxaDE1MHYtMTAzbC0xNDcgLTE0N3EtMTUgLTE3IC0xNSAtMzhxMCAtMjIgMTYgLTM4dDM3IC0xNnExOSAwIDM1IDEzbDI3IDIzbDk4IC0xMTN6TTY2NSAxMDI0aDE1MHYtMTAyNGgtMTUwdjg4cS0xMDAgLTExMyAtMjE1IC0xMTNoLTE4cS02NiAwIC0xMjEuNSAxOHQtMTAyLjUgNTcuNXQtNzQgMTEyLjUKdC0yNyAxNzR2Njg3aDE1MHYtNjg3cTAgLTEyMCA0My41IC0xNjZ0MTMxLjUgLTQ2aDE4cTQ3IDAgOTkgNTh0ODQgMTM0dDMyIDEzMHY1Nzd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IldjaXJjdW1mbGV4IiB1bmljb2RlPSImI3gxNzQ7IiAKZD0iTTUzOSAxNzAxbDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek0xMjcgMGwtMTAxIDE0MDBoMTUxbDY2IC05MjJsMTc2IDcxMmg4NGwxNzYgLTcxMmw2NiA5MjJoMTUxbC0xMDEgLTE0MDBoLTE1M2wtMTgxIDczNmwtMTgxIC03MzZoLTE1M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0id2NpcmN1bWZsZXgiIHVuaWNvZGU9IiYjeDE3NTsiIApkPSJNNTM5IDE0MDdsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6TTEzNCAwbC0xMDYgMTAyNGgxNTJsNjEgLTU5NGwxNzIgNTE5aDk2bDE3MiAtNTE5bDYxIDU5NGgxNTJsLTEwNiAtMTAyNGgtMTIybC0yMDUgNjE3bC0yMDUgLTYxN2gtMTIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJZY2lyY3VtZmxleCIgdW5pY29kZT0iJiN4MTc2OyIgCmQ9Ik01MzkgMTY5NWwxNjYgLTExN2wtODYgLTEyMWwtMTU3IDEwOGwtMTU3IC0xMDhsLTg2IDEyMWwxNjYgMTE3aDE1NHpNMzg2IC0yNXY1MjZsLTI5NiA4OTloMTU3bDIxNSAtNjQ4bDIxMyA2NDhoMTU3bC0yOTUgLTg5OWwtMSAtNTI2aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InljaXJjdW1mbGV4IiB1bmljb2RlPSImI3gxNzc7IiAKZD0iTTU1OCAxNDA3bDE2NiAtMTE3bC04NiAtMTIxbC0xNTcgMTA4bC0xNTcgLTEwOGwtODYgMTIxbDE2NiAxMTdoMTU0ek04NDEgMTAyNGwtMjYxIC0xMTU0cS0xNSAtNjUgLTQyIC0xMTIuNXQtNTQuNSAtNzF0LTYyIC0zN3QtNTUgLTE2dC00Mi41IC0yLjVxLTc5IDAgLTE0NS41IDUwLjV0LTk1LjUgMTIwLjVsMTM4IDU2cTEzIC0zMSA0MyAtNTR0NjAgLTIzcTM0IDAgNjcgMzcuNXQ0NSA5MS41bDQ0IDE5NWwtMzcyIDkxOWgxNjNsMjY3IC02NjAKbDE0OSA2NjBoMTU0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJZZGllcmVzaXMiIHVuaWNvZGU9IiYjeDE3ODsiIApkPSJNMzI4IDE1OTJxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTgxNyAxNTkycTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTM4NiAtMjV2NTI2bC0yOTYgODk5aDE1N2wyMTUgLTY0OGwyMTMgNjQ4CmgxNTdsLTI5NSAtODk5bC0xIC01MjZoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iWmFjdXRlIiB1bmljb2RlPSImI3gxNzk7IiAKZD0iTTQ3MyAxMzgzbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTkwIDEyNTB2MTUwaDc0MnYtMTM5bC01NjcgLTExMTBoNTY3di0xNTFoLTc0MnYxNDBsNTY3IDExMTBoLTU2N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iemFjdXRlIiB1bmljb2RlPSImI3gxN2E7IiAKZD0iTTQxNCAxMTUxbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTg3IDExM2w1NDcgNzYxaC00OTR2MTUwaDY5N3YtMTI0bC01MzkgLTc1MGg1Mzl2LTE1MGgtNzUwdjExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iWmRvdGFjY2VudCIgdW5pY29kZT0iJiN4MTdiOyIgCmQ9Ik0zMzcgMTU3NXEwIDQ5IDMzLjUgODN0ODIuNSAzNHQ4My41IC0zNHQzNC41IC04M3QtMzQuNSAtODN0LTgzLjUgLTM0dC04Mi41IDM0dC0zMy41IDgzek05MCAxMjUwdjE1MGg3NDJ2LTEzOWwtNTY3IC0xMTEwaDU2N3YtMTUxaC03NDJ2MTQwbDU2NyAxMTEwaC01Njd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Inpkb3QiIHVuaWNvZGU9IiYjeDE3YzsiIApkPSJNMzM4IDEyOTdxMCA0OSAzMy41IDgzdDgyLjUgMzR0ODMuNSAtMzR0MzQuNSAtODN0LTM0LjUgLTgzdC04My41IC0zNHQtODIuNSAzNHQtMzMuNSA4M3pNODcgMTEzbDU0NyA3NjFoLTQ5NHYxNTBoNjk3di0xMjRsLTUzOSAtNzUwaDUzOXYtMTUwaC03NTB2MTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJaY2Fyb24iIHVuaWNvZGU9IiYjeDE3ZDsiIApkPSJNNDU4IDE2MTZsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnpNOTAgMTI1MHYxNTBoNzQydi0xMzlsLTU2NyAtMTExMGg1Njd2LTE1MWgtNzQydjE0MGw1NjcgMTExMGgtNTY3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ6Y2Fyb24iIHVuaWNvZGU9IiYjeDE3ZTsiIApkPSJNNDU5IDEzMjFsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnpNODcgMTEzbDU0NyA3NjFoLTQ5NHYxNTBoNjk3di0xMjRsLTUzOSAtNzUwaDUzOXYtMTUwaC03NTB2MTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzbG9uZyIgdW5pY29kZT0iJiN4MTdmOyIgCmQ9Ik02NjUgNzE5cTAgNzkgLTUxLjUgMTI5LjV0LTE0My41IDUwLjVoLTE4cS05NiAwIC0xNDUuNSAtMzIuNXQtNDkuNSAtNzcuNXYtMTJxMyAtMzUgMTcuNSAtNTYuNXQyOC41IC0yNi41bDM3NyAtMTc1cTU1IC0yNiA5NSAtODJ0NDAgLTEzNnYtNDZxMCAtMTI0IC05OSAtMjAydC0yNDYgLTc4aC00OHEtMTA0IDAgLTE4NSA1NHQtMTIwLjUgMTM1LjV0LTM5LjUgMTcyLjVoMTUwcTAgLTgwIDUzLjUgLTE0NnQxNDEuNSAtNjZoNDgKcTc4IDAgMTM2LjUgMzR0NTguNSA5NnY0NnEwIDI2IC0xNiA0OS41dC0zMyAzMi41bC0zNzUgMTczcS0zNyAxOCAtNjUgNDkuNXQtNDIgNjV0LTIwLjUgNjAuNXQtNi41IDQ2djEycTAgNjYgMzQuNSAxMTh0ODguNSA4MnQxMTEgNDV0MTExIDE1aDE4cTExMyAwIDE5MyAtNDYuNXQxMTYgLTExOS41dDM2IC0xNjRoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmxvcmluIiB1bmljb2RlPSImI3gxOTI7IiAKZD0iTTc2OSAxMjQwcS0yOCAzNSAtOTQgMzVxLTQ2IDAgLTc2LjUgLTI2LjV0LTMyLjUgLTcxLjVsLTEzIC0yNzVoMjE5di0xNTBoLTIyNWwtNDEgLTg4M3EtNCAtOTQgLTc4IC0xNzR0LTE4MSAtODBxLTY0IDAgLTEyNSAzMy41dC05NyA5MS41bDEyOCA4MHExNCAtMjIgNDAuNSAtMzl0NTMuNSAtMTdxNDEgMCA3NCAzNnQzNSA3N2w0MCA4NzVoLTIxNnYxNTBoMjIzbDEzIDI4M3E1IDEwNCA3OC41IDE3MnQxODAuNSA2OHE0NSAwIDg2IC0xMy41CnQ2OSAtMzR0NDIgLTMzLjV0MjMgLTI0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkb3RsZXNzaiIgdW5pY29kZT0iJiN4MjM3OyIgCmQ9Ik00NzYgLTIxOXE1MCAwIDc5LjUgMjh0MjkuNSA4MnY5ODNoLTMxOHYxNTBoNDY4di0xMTMzcTAgLTExNyAtNzMuNSAtMTg4LjV0LTE4NS41IC03MS41cS0xMDcgMCAtMTgzIDc3LjV0LTc2IDE4MS41aDE1MHEwIC00MiAzMi41IC03NS41dDc2LjUgLTMzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNpcmN1bWZsZXgiIHVuaWNvZGU9IiYjeDJjNjsiIApkPSJNNTM4IDE2MzhsMTY2IC0xMTdsLTg2IC0xMjFsLTE1NyAxMDhsLTE1NyAtMTA4bC04NiAxMjFsMTY2IDExN2gxNTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNhcm9uIiB1bmljb2RlPSImI3gyYzc7IiAKZD0iTTQ2MSAxNTUybDE1NyAxMDlsODYgLTEyMmwtMTY2IC0xMTdoLTE1NGwtMTY2IDExN2w4NiAxMjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1hY3Jvbm1vZGlmaWVyIiB1bmljb2RlPSImI3gyYzk7IiAKZD0iTTIzNCAxNDYzdjE1MGg0NTN2LTE1MGgtNDUzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJncmF2ZW1vZGlmaWVyIiB1bmljb2RlPSImI3gyY2I7IiAKZD0iTTY5MCAxNDU0bC0xNDAgLTEzNWwtMjU4IDI3MmwxNDAgMTM1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJicmV2ZSIgdW5pY29kZT0iJiN4MmQ4OyIgCmQ9Ik00NTggMTQwNXEtODQgMCAtMTU4LjUgMzd0LTEyOC41IDEwMmwxMTUgOTZxNzAgLTg1IDE3MiAtODVxMTA1IDAgMTc4IDg2bDExNCAtOTdxLTU1IC02NSAtMTMxIC0xMDJ0LTE2MSAtMzd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRvdGFjY2VudCIgdW5pY29kZT0iJiN4MmQ5OyIgCmQ9Ik0zNDAgMTUwN3EwIDQ5IDMzLjUgODN0ODIuNSAzNHQ4My41IC0zNHQzNC41IC04M3QtMzQuNSAtODN0LTgzLjUgLTM0dC04Mi41IDM0dC0zMy41IDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyaW5nIiB1bmljb2RlPSImI3gyZGE7IiAKZD0iTTI1MSAxNDI1cTAgODQgNTggMTQzdDE0MiA1OXQxNDQgLTU5dDYwIC0xNDN0LTYwIC0xNDN0LTE0NCAtNTl0LTE0MiA1OXQtNTggMTQzek0zNjEgMTQyNXEwIC0zOCAyNi41IC02NXQ2NC41IC0yN3Q2NS41IDI3dDI3LjUgNjV0LTI3LjUgNjV0LTY1LjUgMjd0LTY0LjUgLTI3dC0yNi41IC02NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib2dvbmVrIiB1bmljb2RlPSImI3gyZGI7IiAKZD0iTTYyOSAtMzcxcS01OSAtNDkgLTEzMyAtNDlxLTg0IDAgLTE0My41IDYwdC01OS41IDE0NHEwIDgyIDU3IDE0MmwxMDUgMTA1djQxaDE1MHYtMTAzbC0xNDcgLTE0N3EtMTUgLTE3IC0xNSAtMzhxMCAtMjIgMTYgLTM4dDM3IC0xNnExOSAwIDM1IDEzbDI3IDIzbDk4IC0xMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRpbGRlIiB1bmljb2RlPSImI3gyZGM7IiAKZD0iTTE0MSAxNTcycTkxIDExNSAxOTMgMTE1aDE2cTg3IDAgMTUxIC01NWwxOSAtMTdxMjIgLTE4IDUxIC0xOGgxN3EyMyAyIDM4IDExLjV0MzYgNDEuNWwxNiAyNGwxMjQgLTg0bC0xNiAtMjRxLTgwIC0xMTkgLTE5OCAtMTE5aC0xN3EtMzMgMCAtNzYuNSAxNC41dC03NC41IDQxLjVsLTIxIDE4cS0xOCAxNiAtNDkgMTZoLTE2cS0xNyAwIC0zMi41IC0xMS41dC00MC41IC00Mi41bC0xOSAtMjZsLTEyMCA5MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaHVuZ2FydW1sYXV0IiB1bmljb2RlPSImI3gyZGQ7IiAKZD0iTTEzOCAxMzEzbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTU5NiAxMzE5bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImdyYXZlY29tYiIgdW5pY29kZT0iJiN4MzAwOyIgCmQ9Ik02OTAgMTQ1NGwtMTQwIC0xMzVsLTI1OCAyNzJsMTQwIDEzNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWN1dGVjb21iIiB1bmljb2RlPSImI3gzMDE7IiAKZD0iTTM3MiAxMzE5bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRpbGRlY29tYiIgdW5pY29kZT0iJiN4MzAzOyIgCmQ9Ik0xNDEgMTU3MnE5MSAxMTUgMTkzIDExNWgxNnE4NyAwIDE1MSAtNTVsMTkgLTE3cTIyIC0xOCA1MSAtMThoMTdxMjMgMiAzOCAxMS41dDM2IDQxLjVsMTYgMjRsMTI0IC04NGwtMTYgLTI0cS04MCAtMTE5IC0xOTggLTExOWgtMTdxLTMzIDAgLTc2LjUgMTQuNXQtNzQuNSA0MS41bC0yMSAxOHEtMTggMTYgLTQ5IDE2aC0xNnEtMTcgMCAtMzIuNSAtMTEuNXQtNDAuNSAtNDIuNWwtMTkgLTI2bC0xMjAgOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRpZXJlc2lzY21iIiB1bmljb2RlPSImI3gzMDg7IiAKZD0iTTMyNyAxMzY3cTAgLTQ2IC0zMi41IC04MS41dC03Ny41IC0zNS41dC03OC41IDM0LjV0LTMzLjUgODIuNXQzMy41IDc5LjV0NzYuNSAzMS41cTQ3IDAgNzkuNSAtMzN0MzIuNSAtNzh6TTgxNiAxMzY3cTAgLTUwIC0zMyAtODMuNXQtNzYgLTMzLjVxLTQ1IDAgLTc4IDM0LjV0LTMzIDgyLjV0MzMgNzkuNXQ3OCAzMS41cTQyIDAgNzUuNSAtMzEuNXQzMy41IC03OS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJob29rYWJvdmVjb21iIiB1bmljb2RlPSImI3gzMDk7IiAKZD0iTTc0MSAxNDk1cTAgLTQxIC0xNyAtNzMuNXQtMzkuNSAtNTF0LTUzLjUgLTMxLjV0LTUwIC0xN3QtMzggLTd2LTYwaC0xNTB2MTg3aDc1cTEyMyAwIDEyMyA1M3EwIDI4IC0zMyA0MnQtNzggMTRxLTkxIDAgLTE2MCAtNDVsLTgyIDEwNnExMDYgNjkgMjQyIDY5dDE5OC41IC01My41dDYyLjUgLTEzMi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYXJvbmNvbWIiIHVuaWNvZGU9IiYjeDMwYzsiIApkPSJNNDYxIDE1NTJsMTU3IDEwOWw4NiAtMTIybC0xNjYgLTExN2gtMTU0bC0xNjYgMTE3bDg2IDEyMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29tbWF0dXJuZWRhYm92ZWNtYiIgdW5pY29kZT0iJiN4MzEyOyIgCmQ9Ik02MTIgLTI3MHEwIDM5IC00MC41IDYxdC04Mi41IDIyaC04MGwxNCAxOTB2MTVoMTUwdi0yMWwtNCAtNjBxMTkzIC0zNSAxOTMgLTIwN3EwIC02MiAtMzAgLTEwNy41dC03NSAtNjcuNXQtODQuNSAtMzEuNXQtNzEuNSAtOS41cS0xNDAgMCAtMjUwIDk1bDk4IDk0cTY4IC01OSAxNTIgLTU5cTMzIDAgNzIgMjQuNXQzOSA2MS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb21tYWFib3ZlcmlnaHRjbWIiIHVuaWNvZGU9IiYjeDMxNTsiIApkPSJNODk2IDEyOTBxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRvdGJlbG93Y29tYiIgdW5pY29kZT0iJiN4MzIzOyIgCmQ9Ik0zNDUgLTI1M3EwIDQ5IDMzLjUgODN0ODIuNSAzNHQ4My41IC0zNHQzNC41IC04M3QtMzQuNSAtODN0LTgzLjUgLTM0dC04Mi41IDM0dC0zMy41IDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb21tYXN1Ym5vc3AiIHVuaWNvZGU9IiYjeDMyNjsiIApkPSJNNjIyIC0yMTdxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRvbm9zIiB1bmljb2RlPSImI3gzODQ7IiAKZD0iTTM3MiAxMzE5bC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkFscGhhIiB1bmljb2RlPSImI3gzOTE7IiAKZD0iTTMyOSAzOTloMjY0bC0xMzIgNjA1ek0yNDEgMGgtMTUzbDMxMSAxNDI1aDEyNGwzMTAgLTE0MjVoLTE1M2wtNTQgMjQ5aC0zMzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkJldGEiIHVuaWNvZGU9IiYjeDM5MjsiIApkPSJNNDIwIDE0MDBxMzYgMCA1OSAtMXQ2MyAtN3Q2Ni41IC0xN3Q1OSAtMzMuNXQ1MS41IC01NHQzMi41IC04MXQxMy41IC0xMTEuNXYtNzFxMCAtMTUwIC03MyAtMjI2cTEyMyAtOTMgMTIzIC0zMDN2LTE0OHEwIC0xNjIgLTg2LjUgLTI1NC41dC0yNTguNSAtOTIuNWgtMzYzdjE0MDBoMzEzek02NjUgMzQ3djE0OHEwIDY2IC0xMiAxMDl0LTM4LjUgNjYuNXQtNjAgMzIuNXQtODQuNSA5aC0yMTN2LTU2MmgyMTNxMTA1IDAgMTUwIDQ3LjUKdDQ1IDE0OS41ek02MTUgMTA5NXEwIDEwMCAtMzggMTI3LjV0LTE1NyAyNy41aC0xNjN2LTM4OGgxNjNxMTE3IDAgMTU2IDM0LjV0MzkgMTI3LjV2NzF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkdhbW1hIiB1bmljb2RlPSImI3gzOTM7IiAKZD0iTTEwNyAwdjE0MDBoNzI1di0xNTFoLTU3NXYtMTI0OWgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJEZWx0YSIgdW5pY29kZT0iJiN4Mzk0OyIgCmQ9Ik02NDcgMTUxbC0xODYgODUzbC0xODYgLTg1NHpNODkgMGwzMTAgMTQyNWgxMjRsMzEwIC0xNDI1aC03NDR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkVwc2lsb24iIHVuaWNvZGU9IiYjeDM5NTsiIApkPSJNMjU3IDcxMnYtNTYxaDU3NXYtMTUxaC03MjV2MTQwMGg3MjV2LTE1MGgtNTc1di0zODhoNDgzdi0xNTBoLTQ4M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iWmV0YSIgdW5pY29kZT0iJiN4Mzk2OyIgCmQ9Ik05MCAxMjUwdjE1MGg3NDJ2LTEzOWwtNTY3IC0xMTEwaDU2N3YtMTUxaC03NDJ2MTQwbDU2NyAxMTEwaC01Njd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkV0YSIgdW5pY29kZT0iJiN4Mzk3OyIgCmQ9Ik0yNTcgMGgtMTUwdjE0MDBoMTUwdi01OTNoNDA4djU5M2gxNTB2LTE0MDBoLTE1MHY2NTdoLTQwOHYtNjU3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJUaGV0YSIgdW5pY29kZT0iJiN4Mzk4OyIgCmQ9Ik04MjUgNzY1di02OXEwIC0xNzkgLTI0IC0zMTMuNXQtNjAgLTIxMHQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjUKdDkxLjUgLTQwaDExcTUyIDAgOTEuNSA0MC41dDYxIDk5LjV0MzQuNSAxNDAuNXQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXpNNTgyIDc3NHYtMTUwaC0yNDJ2MTUwaDI0MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iSW90YSIgdW5pY29kZT0iJiN4Mzk5OyIgCmQ9Ik04MzIgMTQwMHYtMTUwaC0yOTZ2LTExMDBoMjk2di0xNTBoLTc0MnYxNTBoMjk2djExMDBoLTI5NnYxNTBoNzQyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJLYXBwYSIgdW5pY29kZT0iJiN4MzlhOyIgCmQ9Ik0xMDggMHYxNDAwaDE1MHYtNjQ4bDM5NyA2NDhoMTc2bC0zNjYgLTU5N2wzODMgLTgwM2gtMTY3bC0zMTAgNjUwbC0xMTMgLTE4NHYtNDY2aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkxhbWJkYSIgdW5pY29kZT0iJiN4MzliOyIgCmQ9Ik0yMzcgMGgtMTUzbDMxNSAxNDI1aDEyM2wzMTMgLTE0MjVoLTE1M2wtMjIxIDEwMDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik11IiB1bmljb2RlPSImI3gzOWM7IiAKZD0iTTI2IDBsMTAxIDE0MDBoMTUzbDE4MSAtNzM1bDE4MSA3MzVoMTUzbDEwMSAtMTQwMGgtMTUxbC02NiA5MjNsLTE3NiAtNzEyaC04NGwtMTc2IDcxMmwtNjYgLTkyM2gtMTUxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJOdSIgdW5pY29kZT0iJiN4MzlkOyIgCmQ9Ik0yNTcgMGgtMTUwdjE0MDBoMTM1bDQyMyAtOTg2djk4NmgxNTB2LTE0MDBoLTEzNmwtNDIyIDk4NXYtOTg1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJYaSIgdW5pY29kZT0iJiN4MzllOyIgCmQ9Ik0yNTcgMTUwaDQwOHYxODdoMTUwdi0zMzdoLTcwOHYzMzdoMTUwdi0xODd6TTY1MCA3NzV2LTE1MGgtMzc4djE1MGgzNzh6TTEwNyAxMDQ5djM1MWg3MDh2LTM1MWgtMTUwdjIwMWgtNDA4di0yMDFoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iT21pY3JvbiIgdW5pY29kZT0iJiN4MzlmOyIgCmQ9Ik04MjUgNzY1di02OXEwIC0xNzkgLTI0IC0zMTMuNXQtNjAgLTIxMHQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjUKdDkxLjUgLTQwaDExcTUyIDAgOTEuNSA0MC41dDYxIDk5LjV0MzQuNSAxNDAuNXQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iUGkiIHVuaWNvZGU9IiYjeDNhMDsiIApkPSJNMTA3IDB2MTQwMGg3MDh2LTE0MDBoLTE1MHYxMjUwaC00MDh2LTEyNTBoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iUmhvIiB1bmljb2RlPSImI3gzYTE7IiAKZD0iTTI1NyA2NDJ2LTY0MmgtMTUwdjE0MDBoMzYzcTc4IDAgMTM3IC0xNXQxMDggLTUxLjV0NzQuNSAtMTA0LjV0MjUuNSAtMTY2di05MXEwIC02NyAtMTYgLTEyMi41dC01Mi41IC0xMDR0LTEwNyAtNzZ0LTE2OS41IC0yNy41aC0yMTN6TTQ3MCA3OTJxMTEwIDAgMTUyLjUgNDF0NDIuNSAxMzl2OTFxMCAxMTAgLTQwLjUgMTQ4LjV0LTE1NC41IDM4LjVoLTIxM3YtNDU4aDIxM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iU2lnbWEiIHVuaWNvZGU9IiYjeDNhMzsiIApkPSJNOTAgMTQwMGg3NDJ2LTE1MGgtNTcybDI4NiAtNTEzbC0yOTUgLTYxMmg1ODF2LTE1MGgtNzQydjE1OWwyODggNTk3bC0yODggNTE1djE1NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVGF1IiB1bmljb2RlPSImI3gzYTQ7IiAKZD0iTTg1MiAxNDAwdi0xNTBoLTMxNnYtMTI1MGgtMTUwdjEyNTBoLTMxNnYxNTBoNzgyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJVcHNpbG9uIiB1bmljb2RlPSImI3gzYTU7IiAKZD0iTTM4NiAtMjV2NTI2bC0yOTYgODk5aDE1N2wyMTUgLTY0OGwyMTMgNjQ4aDE1N2wtMjk1IC04OTlsLTEgLTUyNmgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJQaGkiIHVuaWNvZGU9IiYjeDNhNjsiIApkPSJNMzg2IDIzNXY5MzNxLTkwIC0yNSAtMTM2IC0xMjV0LTQ2IC0yOTB2LTU2cTAgLTM5OSAxODIgLTQ2MnpNNTM2IDExNjh2LTkzM3E1NCAxOCA5MS41IDY2dDU2LjUgMTE2dDI3IDEzNS41dDggMTQ0LjV2NTdxMCAxOTEgLTQ2IDI5MC41dC0xMzcgMTIzLjV6TTUzNiAtMjVoLTE1MHYxMDVxLTUwIDkgLTk0IDMwLjV0LTg5IDY4dC03NyAxMTIuNXQtNTIgMTcwLjV0LTIwIDIzNS41djU2cTAgMTI0IDIwLjUgMjIydDUyLjUgMTU4LjV0NzcgMTAyCnQ4OC41IDYwdDkzLjUgMjYuNXYxMDNoMTUwdi0xMDNxNTAgLTggOTMuNSAtMjZ0ODkgLTU5LjV0NzcuNSAtMTAydDUyLjUgLTE1OHQyMC41IC0yMjIuNXYtNTdxMCAtMTMyIC0yMC41IC0yMzYuNXQtNTIuNSAtMTcwdC03Ny41IC0xMTJ0LTg5IC02OHQtOTMuNSAtMzAuNXYtMTA1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJDaGkiIHVuaWNvZGU9IiYjeDNhNzsiIApkPSJNOTQgMGwyODcgNzAwbC0yODcgNzAwaDE2MWwyMDYgLTUwM2wyMDYgNTAzaDE2MWwtMjg3IC03MDBsMjg3IC03MDBoLTE2MWwtMjA2IDUwM2wtMjA2IC01MDNoLTE2MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iUHNpIiB1bmljb2RlPSImI3gzYTg7IiAKZD0iTTIzNyA3MjhxMCAtNDEgMzAuNSAtOTF0NzguNSAtNTBoNDB2ODM4aDE1MHYtODM4aDQwcTQ4IDAgNzguNSA0MXQzMC41IDEwMHY2MjJoMTUwdi02MjJxMCAtMTE5IC03MyAtMjA1dC0xODYgLTg2aC00MHYtNDYxaC0xNTB2NDYxaC00MHEtNTcgMCAtMTAzIDIydC03NC41IDU1dC00Ny41IDc0dC0yNi41IDc2dC03LjUgNjR2NjIyaDE1MHYtNjIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJPbWVnYSIgdW5pY29kZT0iJiN4M2E5OyIgCmQ9Ik0yNDIgMTUwdjE0M3EtMTQ1IDE2NSAtMTQ1IDUyNHY1NXEwIDU1NCAzNTggNTU0aDEycTM1OCAwIDM1OCAtNTUydi01N3EwIC0zNzUgLTE0NSAtNTI2di0xNDFoMTUydi0xNTBoLTMwMnYzNThsMjcgMjNxNTYgNDYgODcgMTU5LjV0MzEgMjc2LjV2NTdxMCAxMDMgLTEzIDE3OXQtMzMgMTE4dC00OS41IDY2LjV0LTU1IDMxLjV0LTU3LjUgN2gtMTJxLTMyIDAgLTU3LjUgLTd0LTU1IC0zMnQtNDkgLTY3dC0zMyAtMTE4dC0xMy41IC0xODB2LTU1CnEwIC0zMjIgMTIyIC00NDBsMjMgLTIydi0zNTVoLTMwMnYxNTBoMTUyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJb3RhZGllcmVzaXMiIHVuaWNvZGU9IiYjeDNhYTsiIApkPSJNMzI4IDE1OTJxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTgxNyAxNTkycTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTgzMiAxNDAwdi0xNTBoLTI5NnYtMTEwMGgyOTZ2LTE1MGgtNzQydjE1MApoMjk2djExMDBoLTI5NnYxNTBoNzQyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJVcHNpbG9uZGllcmVzaXMiIHVuaWNvZGU9IiYjeDNhYjsiIApkPSJNMzI4IDE1OTBxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTgxNyAxNTkwcTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTM4NiAtMjV2NTI2bC0yOTYgODk5aDE1N2wyMTUgLTY0OGwyMTMgNjQ4CmgxNTdsLTI5NSAtODk5bC0xIC01MjZoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWxwaGF0b25vcyIgdW5pY29kZT0iJiN4M2FjOyIgCmQ9Ik0zNzEgMTE4MWwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek03NDkgNTE2bDEwNyAtNTAwbC0xNDYgLTMybC0zNyAxNzRxLTI2IC05MiAtOTQuNSAtMTQ1dC0xNjcuNSAtNTNxLTcwIDAgLTEyNSAzMy41dC05MCA4Ny41dC01OCAxMjcuNXQtMzIgMTQ4LjV0LTkgMTU2dDkgMTU1LjV0MzIgMTQ4dDU4IDEyN3Q5MCA4Ni41dDEyNSAzM3E5NyAwIDE2NS41IC01MS41dDk1LjUgLTEzOC41bDM1IDE2N2wxNDYgLTMyek01OTYgNTE2bC02NSAzMDAKcS0yMiA5NyAtMTIwIDk3cS03NCAwIC0xMTkgLTExMHQtNDUgLTI5MHEwIC0xODIgNDUgLTI5Mi41dDExOSAtMTEwLjVxOTggMCAxMTkgOTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVwc2lsb250b25vcyIgdW5pY29kZT0iJiN4M2FkOyIgCmQ9Ik00MDEgMTE2MmwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek02NTEgODU2cS0zNyA0MyAtMTYxIDQzaC0zOHEtMTEwIDAgLTE1Mi41IC0zNnQtNDIuNSAtOTlxMCAtNjEgNTAgLTEwOC41dDE0OSAtNDcuNWgxNTJ2LTE1MGgtMTUycS01MyAwIC05NCAtMTZ0LTYyLjUgLTQwdC0zMiAtNDZ0LTEwLjUgLTM5di0xN3EwIC03NyA0NSAtMTI2dDE1MCAtNDloMzhxNzQgMCAxMDcuNSA5LjV0NTUuNSAzNi41bDExNiAtOTQKcS00NyAtNTcgLTExMSAtNzkuNXQtMTY4IC0yMi41aC0zOHEtMTYwIDAgLTI1Mi41IDkwdC05Mi41IDIzNXYxN3EwIDU3IDI5LjUgMTE1dDgzLjUgMTAwcS01NSA0NCAtODQgMTA1LjV0LTI5IDEyNi41cTAgMTM0IDg5LjUgMjA5LjV0MjU1LjUgNzUuNWgzOHE1OSAwIDEwOCAtOS41dDc1IC0xOS41dDUyIC0zMHQzMC41IC0yNXQxNy41IC0yMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZXRhdG9ub3MiIHVuaWNvZGU9IiYjeDNhZTsiIApkPSJNNDEzIDExNzJsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNMjU3IDBoLTE1MHYxMDI0aDE1MHYtNjdxODkgOTIgMTk1IDkyaDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di0xMTA0aC0xNTB2MTEwNHEwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTQ4IDAgLTk0LjUgLTUzLjV0LTczLjUgLTEyMy41dC0yNyAtMTI1di01OTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImlvdGF0b25vcyIgdW5pY29kZT0iJiN4M2FmOyIgCmQ9Ik0zNjAgMTE4MWwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek0xODIgMTAyNGgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1cHNpbG9uZGllcmVzaXN0b25vcyIgdW5pY29kZT0iJiN4M2IwOyIgCmQ9Ik00MzIgMTM4NGwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek0zMjcgMTI1NHEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE2IDEyNTRxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXoKTTgyNSA1MTNxMCAtOTUgLTEyLjUgLTE3NHQtMzMuNSAtMTM0dC01MS41IC05N3QtNjIgLTY2LjV0LTY5IC00MHQtNjkuNSAtMjF0LTY2IC01LjVxLTE2NyAwIC0yNjAuNSAxMzAuNXQtOTMuNSA0MDcuNXY1MTFoMTUwdi01MTFxMCAtMjA3IDUyIC0yOTcuNXQxNTIgLTkwLjVxMjE0IDAgMjE0IDM4OHEwIDIxNiAtNDMgMzAwLjV0LTE0MSA4NC41djE1MHE2OCAwIDEyMS41IC0xOS41dDg5LjUgLTU2LjV0NjAuNSAtODQuNXQzOCAtMTEwLjUKdDE5IC0xMjUuNXQ1LjUgLTEzOC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhbHBoYSIgdW5pY29kZT0iJiN4M2IxOyIgCmQ9Ik03NDkgNTE2bDEwNyAtNTAwbC0xNDYgLTMybC0zNyAxNzRxLTI2IC05MiAtOTQuNSAtMTQ1dC0xNjcuNSAtNTNxLTcwIDAgLTEyNSAzMy41dC05MCA4Ny41dC01OCAxMjcuNXQtMzIgMTQ4LjV0LTkgMTU2dDkgMTU1LjV0MzIgMTQ4dDU4IDEyN3Q5MCA4Ni41dDEyNSAzM3E5NyAwIDE2NS41IC01MS41dDk1LjUgLTEzOC41bDM1IDE2N2wxNDYgLTMyek01OTYgNTE2bC02NSAzMDBxLTIyIDk3IC0xMjAgOTdxLTc0IDAgLTExOSAtMTEwCnQtNDUgLTI5MHEwIC0xODIgNDUgLTI5Mi41dDExOSAtMTEwLjVxOTggMCAxMTkgOTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJldGEiIHVuaWNvZGU9IiYjeDNiMjsiIApkPSJNMjU3IDI1OXEwIC02MyA0MiAtOTguNXQxNTMgLTM1LjVoMzhxMTEwIDAgMTUyIDM1LjV0NDIgOTguNXY2NnEwIDU2IC0zMCA5MXQtNzEgNDYuNXQtOTQgMTEuNWgtODh2MTUwaDU1cTk1IDAgMTQ1IDQ4dDUwIDExMnEwIDExNSAtMTg1IDExNWgtMTRxLTEwOSAwIC0xNTIgLTQxdC00MyAtMTM5di00NjB6TTEwNyA3MTlxMCA1MyA5IDk4dDMzIDg5dDYyIDc0LjV0OTkuNSA0OS41dDE0MS41IDE5aDE0cTY3IDAgMTIxLjUgLTEydDkwIC0zMy41CnQ2MSAtNDd0MzguNSAtNTd0MTguNSAtNTl0NS41IC01Ni41cTAgLTEyNiAtOTMgLTIxNnE2MSAtNDAgOTMuNSAtMTAyLjV0MzIuNSAtMTQwLjV2LTY2cTAgLTM4IC04IC03My41dC0zMSAtNzV0LTU5LjUgLTY4LjV0LTEwMCAtNDh0LTE0NS41IC0xOWgtMzhxLTExNiAwIC0xOTUgMzd2LTMzM2gtMTUwdjEwNDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImdhbW1hIiB1bmljb2RlPSImI3gzYjM7IiAKZD0iTTM4NiAtMzg1djQyNGwtMjgyIDk4NWgxNTZsMjAxIC03MDNsMjAxIDcwM2gxNTZsLTI4MiAtOTg1di00MjRoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGVsdGEiIHVuaWNvZGU9IiYjeDNiNDsiIApkPSJNNjY1IDU5N3EwIDU3IC05IDEwNi41dC0yOS41IDk1LjV0LTYwLjUgNzN0LTk2IDI3aC0xOHEtNTYgMCAtOTYgLTI2LjV0LTYwLjUgLTcyLjV0LTI5LjUgLTk1LjV0LTkgLTEwNy41di0xNzBxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxNTYgMCA5NiAyNi41dDYwLjUgNzJ0MjkuNSA5NS41dDkgMTA4djE3MHpNMTIwIDE0MDBoNjIwdi0xNTBoLTM3OGwyOTUgLTIyNnE3OSAtNjEgMTE4LjUgLTE3NHQzOS41IC0yNTN2LTE3MApxMCAtMjA3IC05MC41IC0zMjkuNXQtMjU0LjUgLTEyMi41aC0xOHEtMTQ4IDAgLTI0Ni41IDEyNy41dC05OC41IDMyNC41djE3MHEwIDE3NSA2Ny41IDI5NXQxOTguNSAxNDlsLTI1MyAyMjF2MTM4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlcHNpbG9uIiB1bmljb2RlPSImI3gzYjU7IiAKZD0iTTY1MSA4NTZxLTM3IDQzIC0xNjEgNDNoLTM4cS0xMTAgMCAtMTUyLjUgLTM2dC00Mi41IC05OXEwIC02MSA1MCAtMTA4LjV0MTQ5IC00Ny41aDE1MnYtMTUwaC0xNTJxLTUzIDAgLTk0IC0xNnQtNjIuNSAtNDB0LTMyIC00NnQtMTAuNSAtMzl2LTE3cTAgLTc3IDQ1IC0xMjZ0MTUwIC00OWgzOHE3NCAwIDEwNy41IDkuNXQ1NS41IDM2LjVsMTE2IC05NHEtNDcgLTU3IC0xMTEgLTc5LjV0LTE2OCAtMjIuNWgtMzhxLTE2MCAwIC0yNTIuNSA5MAp0LTkyLjUgMjM1djE3cTAgNTcgMjkuNSAxMTV0ODMuNSAxMDBxLTU1IDQ0IC04NCAxMDUuNXQtMjkgMTI2LjVxMCAxMzQgODkuNSAyMDkuNXQyNTUuNSA3NS41aDM4cTU5IDAgMTA4IC05LjV0NzUgLTE5LjV0NTIgLTMwdDMwLjUgLTI1dDE3LjUgLTIxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ6ZXRhIiB1bmljb2RlPSImI3gzYjY7IiAKZD0iTTY2NSAtMTA0cTAgNDIgLTQyIDYwLjV0LTE1MyAxOC41aC0xOHEtMTYyIDAgLTI1My41IDk0LjV0LTkxLjUgMjY3LjV2MjBxMCA1NSAyMSAxMDd0NTguNSA5NnQ2NiA3MHQ2Ni41IDU2bDIwNiAxNjJsNTEgMzZxLTE2MiAyNCAtMjU1IDExMGwxMDIgMTEwcTQ5IC00NiAxMjkuNSAtNjN0MjA3LjUgLTE3aDUydi0xMjlxLTYwIC02MSAtMTk3IC0xNjdsLTIwNCAtMTYwcS0xNTQgLTEyMiAtMTU0IC0yMTF2LTIwcTAgLTExNSA1MC41IC0xNjMuNQp0MTQ0LjUgLTQ4LjVoMThxMTI2IDAgMjA2IC0zMnE2NSAtMjYgMTAyIC04NXQzNyAtMTEycTAgLTM3IC04IC03MHQtMzEuNSAtNjkuNXQtNjEuNSAtNjN0LTEwMyAtNDR0LTE1MCAtMTguNXYxNTBxNjkgMCAxMTMgOS41dDYyLjUgMjguNXQyMy41IDM1dDUgNDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImV0YSIgdW5pY29kZT0iJiN4M2I3OyIgCmQ9Ik0yNTcgMGgtMTUwdjEwMjRoMTUwdi02N3E4OSA5MiAxOTUgOTJoMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTExMDRoLTE1MHYxMTA0cTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtNDggMCAtOTQuNSAtNTMuNXQtNzMuNSAtMTIzLjV0LTI3IC0xMjV2LTU5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGhldGEiIHVuaWNvZGU9IiYjeDNiODsiIApkPSJNNjc0IDQzN2gtNDI2cTIgLTQ3IDguNSAtODl0MjEgLTg0dDM1IC03MnQ1My41IC00OC41dDc1IC0xOC41aDM1cTUzIDAgOTIgMjYuNXQ2MSA3M3QzMi41IDk4LjV0MTIuNSAxMTR6TTgyNSA1NjJ2LTkycTAgLTExNiAtMjMuNSAtMjA2LjV0LTU5IC0xNDMuNXQtODMuNSAtODd0LTkyLjUgLTQ2dC05MC41IC0xMmgtMzVxLTE2OCAwIC0yNTYgMTM4dC04OCAzNTh2OTBxMCAxMDAgMTkuNSAxODV0NTkuNSAxNTR0MTA3LjUgMTA4LjUKdDE1NS41IDM5LjVoMzlxODkgMCAxNTcgLTM5dDEwOC41IC0xMDd0NjEgLTE1NHQyMC41IC0xODZ6TTQ3OCA4OThoLTM5cS01MiAwIC05MCAtMjcuNXQtNTkgLTc0LjV0LTMxIC05OC41dC0xMiAtMTEwLjVoNDI3cS0yIDYwIC0xMiAxMTEuNXQtMzEgOTguNXQtNjAuNSA3NHQtOTIuNSAyN3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaW90YSIgdW5pY29kZT0iJiN4M2I5OyIgCmQ9Ik0xODIgMTAyNGgzNTR2LTg3NGgyMDR2LTE1MGgtNTU4djE1MGgyMDR2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJrYXBwYSIgdW5pY29kZT0iJiN4M2JhOyIgCmQ9Ik0yNTcgMGgtMTUwdjEwMjRoMTUwdi02NTdsNDUxIDY1N2wxMjQgLTg1bC0zMzggLTQ5MWwzMzkgLTQ0OGgtMTg4bC0yNDEgMzE3bC0xNDcgLTIxNHYtMTAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsYW1iZGEiIHVuaWNvZGU9IiYjeDNiYjsiIApkPSJNMTA0IDBsMjc5IDk3NmwtMTIwIDQzNGgxNTZsMzk5IC0xNDEwaC0xNTZsLTIwMSA3MDNsLTIwMSAtNzAzaC0xNTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im11IiB1bmljb2RlPSImI3gzYmM7IiAKZD0iTTY2NSA2MHEtOTAgLTg1IC0xOTUgLTg1aC0xOHEtMTEwIDAgLTE5NSA2NnYtNjZxMCAtMTE2IC04IC0xODUuNXQtMzcgLTE2MC41bC0xNDIgNDZxMjQgNzQgMzAuNSAxMzIuNXQ2LjUgMTY3LjV2MTA0OWgxNTB2LTYyN3EwIC0xMTMgNTAuNSAtMTkyLjV0MTQ0LjUgLTc5LjVoMThxNDkgMCA5NS41IDQ2LjV0NzMgMTA5LjV0MjYuNSAxMTZ2NjI3aDE1MHYtOTI1cTAgLTE5IDIuNSAtMzR0NSAtMjMuNXQ5IC0yNi41dDEwLjUgLTMyCmwtMTQ0IC00NnEtNCAxMyAtMTAuNSAzMi41dC0xMCAzMC41dC03LjUgMjd0LTUgMzN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im51IiB1bmljb2RlPSImI3gzYmQ7IiAKZD0iTTQwNSAtMjVsLTMwNSAxMDQ5aDE1NmwyMDUgLTcwNWwyMDUgNzA1aDE1N2wtMzA2IC0xMDQ5aC0xMTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InhpIiB1bmljb2RlPSImI3gzYmU7IiAKZD0iTTQ1OCAtMjE5cTgyIDQgMTQ0LjUgMzkuNXQ2Mi41IDU5LjV2MjdxMCAyMyAtNjUuNSA0NS41dC0xMDkuNSAyMi41aC0zOHEtMTYwIDAgLTI1Mi41IDkwdC05Mi41IDIzNXYxN3EwIDU2IDI5LjUgMTE0dDgzLjUgMTAxcS01NSA0NCAtODQgMTA1dC0yOSAxMjdxMCA1MiAxMC41IDk0dDMyLjUgNzEuNXQ0NSA1MXQ2MCAzOHQ2NCAyNS41dDY5IDIxcS04NiA0NiAtMTY0IDEyN2wxMDggMTA0cTEyOCAtMTM2IDI5MSAtMTQ0bDc3IC0zdi0xMDUKbC0zNSAtMjdxLTQ4IC0zNyAtMTExIC02MHQtMTEyIC0zMy41dC05MyAtMjUuNXQtNjggLTQ3dC0yNCAtODdxMCAtNjEgNTAgLTEwOC41dDE0OSAtNDcuNWgxOTJ2LTE1MGgtMTkycS01MyAwIC05NC41IC0xNnQtNjIuNSAtNDB0LTMxLjUgLTQ2dC0xMC41IC0zOXYtMTdxMCAtNzcgNDUuNSAtMTI2dDE0OS41IC00OWgzOHExMyAwIDQyIC0zLjV0ODAuNSAtMTd0OTQuNSAtMzV0NzUuNSAtNjN0MzIuNSAtOTQuNXYtMzIKcTAgLTk1IC0xMDIuNSAtMTY4LjV0LTI1NC41IC04MC41djE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib21pY3JvbiIgdW5pY29kZT0iJiN4M2JmOyIgCmQ9Ik04MjUgNTYydi05MnEwIC0xMTYgLTIzLjUgLTIwNi41dC01OSAtMTQzLjV0LTgzLjUgLTg3dC05Mi41IC00NnQtOTAuNSAtMTJoLTM1cS0xNjggMCAtMjU2IDEzOHQtODggMzU4djkwcTAgMTAwIDE5LjUgMTg1dDU5LjUgMTU0dDEwNy41IDEwOC41dDE1NS41IDM5LjVoMzlxODkgMCAxNTcgLTM5dDEwOC41IC0xMDd0NjEgLTE1NHQyMC41IC0xODZ6TTQ3OCA4OThoLTM5cS01NSAwIC05NC41IC0zMC41dC01OS41IC04Mi41dC0yOSAtMTA3CnQtOSAtMTE3di05MHEwIC02MyA5IC0xMTkuNXQyOS41IC0xMTB0NjAuNSAtODV0OTUgLTMxLjVoMzVxNDYgMCA4MS41IDIwLjV0NTcuNSA1NHQzNS41IDc5LjV0MTkgOTIuNXQ1LjUgOTguNXY5MnEwIDQ5IC01IDk0dC0xOSA5MHQtMzUuNSA3OHQtNTYuNSA1My41dC04MSAyMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwaSIgdW5pY29kZT0iJiN4M2MwOyIgCmQ9Ik05MCA5OTBxODIgMzQgMjAyIDM0aDMzOHExNDggMCAyMDIgNTd2LTE3NHEtNDggLTE5IC0xMDcgLTI3di03MTJxMCAtODggMzkgLTE2OGgtMTYycS0yNyA4MiAtMjcgMTY4djcwNmgtMjI4di03MDZxMCAtNzcgLTMyIC0xNjhoLTE2MnE0NCA4NiA0NCAxNjh2Njk4cS02NSAtMTIgLTEwNyAtNDh2MTcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyaG8iIHVuaWNvZGU9IiYjeDNjMTsiIApkPSJNNjY1IDQyN3YxNzBxMCAxMzUgLTU3IDIxOC41dC0xMzggODMuNWgtMThxLTU2IDAgLTk2IC0yNi41dC02MC41IC03MnQtMjkuNSAtOTUuNXQtOSAtMTA4di0xNzBxMCAtNTggOSAtMTA3LjV0MjkuNSAtOTUuNXQ2MC41IC03Mi41dDk2IC0yNi41aDE4cTU2IDAgOTYgMjYuNXQ2MC41IDcyLjV0MjkuNSA5NS41dDkgMTA3LjV6TTQ3MCAtMjVoLTE4cS0xMTQgMCAtMTk1IDYydi00MjJoLTE1MHY5ODJxMCAyMDcgOTAuNSAzMjkuNQp0MjU0LjUgMTIyLjVoMThxMTQ4IDAgMjQ2LjUgLTEyNy41dDk4LjUgLTMyNC41di0xNzBxMCAtMTMwIC0zNi41IC0yMzB0LTExNiAtMTYxdC0xOTIuNSAtNjF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNpZ21hZmluYWwiIHVuaWNvZGU9IiYjeDNjMjsiIApkPSJNNjY1IC05MnEwIDEwIC0xNC41IDIzLjV0LTYyIDI3LjV0LTExOC41IDE2aC0xOHEtMTQ4IDAgLTI0Ni41IDEyN3QtOTguNSAzMjV2MTcwcTAgMTk0IDEyNC41IDMyMS41dDMyMy41IDEyNy41cTEwMyAwIDIxMyAtNDJsNDEgLTE1bC01MiAtMTQwbC00MSAxNXEtODYgMzIgLTE2MSAzMnEtMTM4IDAgLTIxOCAtODR0LTgwIC0yMTV2LTE3MHEwIC0xMzUgNTcgLTIxOC41dDEzOCAtODMuNWgxOHE4MCAtMiAxNDIgLTE3LjV0OTkuNSAtMzcuNQp0NjEuNSAtNTF0MzMgLTU2dDkgLTU1di0xOXEwIC0xMDkgLTkwLjUgLTE4My41dC0yNjYuNSAtNzQuNXYxNTBxMzYgMCA2OS41IDV0NjYgMTYuNXQ1MiAzMy41dDE5LjUgNTN2MTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNpZ21hIiB1bmljb2RlPSImI3gzYzM7IiAKZD0iTTgwNSA1NjJ2LTkycTAgLTg3IC0xMiAtMTU4LjV0LTMxLjUgLTEyMnQtNDcuNSAtODl0LTU3LjUgLTYydC02NCAtMzh0LTY0LjUgLTIwdC02MiAtNS41aC0zNXEtNDUgMCAtODcgMTEuNXQtODguNSA0NXQtODAgODZ0LTU2IDE0NHQtMjIuNSAyMDkuNXY5MHEwIDExNiAyMiAyMDUuNXQ1NiAxNDEuNXQ4MCA4NXQ4OCA0NHQ4NiAxMWgzOXE4NiAwIDE1NiAtNDFsMjU4IDF2LTE1MGgtMTI5cTUyIC0xMTUgNTIgLTI5NnpNNDY4IDg5OGgtMzkKcS01MiAwIC04OS41IC0yOXQtNTYuNSAtNzkuNXQtMjcuNSAtMTA2LjV0LTguNSAtMTIydi05MHEwIC02NyA4LjUgLTEyNC41dDI4IC0xMDkuNXQ1NyAtODJ0OTAuNSAtMzBoMzVxMTg5IDAgMTg5IDM0NXY5MnEwIDY3IC04LjUgMTIyLjV0LTI4LjUgMTA2dC01OCA3OXQtOTIgMjguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGF1IiB1bmljb2RlPSImI3gzYzQ7IiAKZD0iTTkwIDk2N3E5MiA1NyAyMDIgNTdoMzM4cTYzIDAgMTE4IDQ0dDg0IDk4di0yMjNxLTk0IC02OSAtMjAyIC02OWgtOTR2LTUxNnEwIC0xODMgLTgyIC0zNThoLTE3MnE0NCA2NyA3NCAxNjIuNXQzMCAxOTUuNXY1MTZoLTk0cS02NyAwIC0xMTkuNSAtMzJ0LTgyLjUgLTc4djIwM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idXBzaWxvbiIgdW5pY29kZT0iJiN4M2M1OyIgCmQ9Ik04MjUgNTEzcTAgLTk1IC0xMi41IC0xNzR0LTMzLjUgLTEzNHQtNTEuNSAtOTd0LTYyIC02Ni41dC02OSAtNDB0LTY5LjUgLTIxdC02NiAtNS41cS0xNjcgMCAtMjYwLjUgMTMwLjV0LTkzLjUgNDA3LjV2NTExaDE1MHYtNTExcTAgLTIwNyA1MiAtMjk3LjV0MTUyIC05MC41cTIxNCAwIDIxNCAzODhxMCAyMTYgLTQzIDMwMC41dC0xNDEgODQuNXYxNTBxNjggMCAxMjEuNSAtMTkuNXQ4OS41IC01Ni41dDYwLjUgLTg0LjV0MzggLTExMC41CnQxOSAtMTI1LjV0NS41IC0xMzguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGhpIiB1bmljb2RlPSImI3gzYzY7IiAKZD0iTTYwNSA4OThxLTM0IDAgLTUxLjUgLTUxLjV0LTE3LjUgLTExMi41di01OTdxNTAgMTcgODcgNTl0NTYgOTd0MjcuNSAxMDl0OC41IDExMXEwIDM4NSAtMTEwIDM4NXpNMzg2IDczNHEwIDE1MiA1NC41IDIzM3QxNjQuNSA4MXE0OCAwIDg1LjUgLTEzLjV0NzEgLTQ5LjV0NTUuNSAtOTV0MzUgLTE1NHQxMyAtMjIzcTAgLTIxOCAtODkgLTM2MHQtMjQwIC0xNzF2LTM2N2gtMTUwdjM2N3EtMTUxIDI5IC0yNDAgMTcxdC04OSAzNjB2NDYwaDE1MAp2LTQ2MHEwIC01NiA4LjUgLTExMC41dDI3LjUgLTEwOS41dDU2IC05N3Q4NyAtNTl2NTk3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaGkiIHVuaWNvZGU9IiYjeDNjNzsiIApkPSJNMTIyIC0zODVsMjU1IDY5M2wtNTcgMjM1cS0yNiAxMDYgLTY4IDIwNy41dC03NiAxNDkuNWwtODggMTI0aDE4NGwyNCAtMzRxNTAgLTcwIDEwMCAtMTk2LjV0NzQgLTIzMi41bDE3MCA0NjNoMTU5bC0yNjUgLTcyM2wzMSAtMTI3cTM0IC0xMzggODEuNSAtMjYydDg5LjUgLTE3MWwxMTMgLTEyNmgtMjAwbC0yNSAyNnEtOTYgMTA5IC0xODIgNDEwbC0xNjEgLTQzNmgtMTU5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwc2kiIHVuaWNvZGU9IiYjeDNjODsiIApkPSJNMzg2IDEwNDloMTUwdi05MTBxODMgMzMgMTMxIDEzM3Q0OCAyNDF2NDYwaDE1MHYtNDYwcTAgLTIwOSAtODkuNSAtMzU0dC0yMzkuNSAtMTc2di0zNjhoLTE1MHYzNjdxLTE1MSAyOSAtMjQwIDE3MXQtODkgMzYwdjQ2MGgxNTB2LTQ2MHEwIC01NiA4LjUgLTExMC41dDI3LjUgLTEwOS41dDU2IC05N3Q4NyAtNTl2OTEyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvbWVnYSIgdW5pY29kZT0iJiN4M2M5OyIgCmQ9Ik0yODggLTI1cS0zNiAwIC03MiAxOHQtNzEgNTd0LTU2LjUgMTEzdC0yMS41IDE3M3YzOThxMCA2MiAyLjUgOTguNXQxNyA5MHQ0My41IDk0LjVsNSA3aDE3OWwtNjAgLTkxcS0yMiAtMzMgLTI5LjUgLTc3dC03LjUgLTEyMnYtMzk4cTAgLTY5IDEyIC0xMTl0MjcuNSAtNzF0MzEuNSAtMjFoMTBxNDAgMCA2NCAyMy41dDI0IDY2LjV2NTE3aDE1MHYtNTI1cTAgLTE3IDIgLTI3LjV0OSAtMjV0MjUuNSAtMjJ0NDcuNSAtNy41aDEwCnEzMCAwIDUyLjUgNjcuNXQyMi41IDE0NC41djM5N3EwIDE0NCAtMzggMjAxbC01OSA4OWgxODFsMiAtM3EzMCAtNDEgNDUgLTk4dDE3IC05M3QyIC05NnYtMzk3cTAgLTczIC0xMCAtMTMxdC0yNC41IC05NXQtMzcgLTY0LjV0LTQxLjUgLTQwLjV0LTQzLjUgLTIwLjV0LTM4LjUgLTl0LTMwIC0xLjVoLTEwcS05NiAwIC0xNTcgNTBxLTU5IC01MCAtMTY1IC01MGgtMTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImlvdGFkaWVyZXNpcyIgdW5pY29kZT0iJiN4M2NhOyIgCmQ9Ik0zMjggMTI1NHEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE3IDEyNTRxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNMTgyIDEwMjRoMzU0di04NzRoMjA0di0xNTBoLTU1OHYxNTBoMjA0CnY3MjRoLTIwNHYxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVwc2lsb25kaWVyZXNpcyIgdW5pY29kZT0iJiN4M2NiOyIgCmQ9Ik0zMjcgMTI1NHEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE2IDEyNTRxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNODI1IDUxM3EwIC05NSAtMTIuNSAtMTc0dC0zMy41IC0xMzQKdC01MS41IC05N3QtNjIgLTY2LjV0LTY5IC00MHQtNjkuNSAtMjF0LTY2IC01LjVxLTE2NyAwIC0yNjAuNSAxMzAuNXQtOTMuNSA0MDcuNXY1MTFoMTUwdi01MTFxMCAtMjA3IDUyIC0yOTcuNXQxNTIgLTkwLjVxMjE0IDAgMjE0IDM4OHEwIDIxNiAtNDMgMzAwLjV0LTE0MSA4NC41djE1MHE2OCAwIDEyMS41IC0xOS41dDg5LjUgLTU2LjV0NjAuNSAtODQuNXQzOCAtMTEwLjV0MTkgLTEyNS41dDUuNSAtMTM4LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im9taWNyb250b25vcyIgdW5pY29kZT0iJiN4M2NjOyIgCmQ9Ik0zODYgMTE1NmwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek04MjUgNTYydi05MnEwIC0xMTYgLTIzLjUgLTIwNi41dC01OSAtMTQzLjV0LTgzLjUgLTg3dC05Mi41IC00NnQtOTAuNSAtMTJoLTM1cS0xNjggMCAtMjU2IDEzOHQtODggMzU4djkwcTAgMTAwIDE5LjUgMTg1dDU5LjUgMTU0dDEwNy41IDEwOC41dDE1NS41IDM5LjVoMzlxODkgMCAxNTcgLTM5dDEwOC41IC0xMDd0NjEgLTE1NHQyMC41IC0xODZ6TTQ3OCA4OThoLTM5CnEtNTUgMCAtOTQuNSAtMzAuNXQtNTkuNSAtODIuNXQtMjkgLTEwN3QtOSAtMTE3di05MHEwIC02MyA5IC0xMTkuNXQyOS41IC0xMTB0NjAuNSAtODV0OTUgLTMxLjVoMzVxNDYgMCA4MS41IDIwLjV0NTcuNSA1NHQzNS41IDc5LjV0MTkgOTIuNXQ1LjUgOTguNXY5MnEwIDQ5IC01IDk0dC0xOSA5MHQtMzUuNSA3OHQtNTYuNSA1My41dC04MSAyMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1cHNpbG9udG9ub3MiIHVuaWNvZGU9IiYjeDNjZDsiIApkPSJNMzkzIDExNTFsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNODI1IDUxM3EwIC05NSAtMTIuNSAtMTc0dC0zMy41IC0xMzR0LTUxLjUgLTk3dC02MiAtNjYuNXQtNjkgLTQwdC02OS41IC0yMXQtNjYgLTUuNXEtMTY3IDAgLTI2MC41IDEzMC41dC05My41IDQwNy41djUxMWgxNTB2LTUxMXEwIC0yMDcgNTIgLTI5Ny41dDE1MiAtOTAuNXEyMTQgMCAyMTQgMzg4cTAgMjE2IC00MyAzMDAuNXQtMTQxIDg0LjV2MTUwCnE2OCAwIDEyMS41IC0xOS41dDg5LjUgLTU2LjV0NjAuNSAtODQuNXQzOCAtMTEwLjV0MTkgLTEyNS41dDUuNSAtMTM4LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im9tZWdhdG9ub3MiIHVuaWNvZGU9IiYjeDNjZTsiIApkPSJNMzk2IDExNjBsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNMjg4IC0yNXEtMzYgMCAtNzIgMTh0LTcxIDU3dC01Ni41IDExM3QtMjEuNSAxNzN2Mzk4cTAgNjIgMi41IDk4LjV0MTcgOTB0NDMuNSA5NC41bDUgN2gxNzlsLTYwIC05MXEtMjIgLTMzIC0yOS41IC03N3QtNy41IC0xMjJ2LTM5OHEwIC02OSAxMiAtMTE5dDI3LjUgLTcxdDMxLjUgLTIxaDEwcTQwIDAgNjQgMjMuNXQyNCA2Ni41djUxN2gxNTB2LTUyNXEwIC0xNyAyIC0yNy41CnQ5IC0yNXQyNS41IC0yMnQ0Ny41IC03LjVoMTBxMzAgMCA1Mi41IDY3LjV0MjIuNSAxNDQuNXYzOTdxMCAxNDQgLTM4IDIwMWwtNTkgODloMTgxbDIgLTNxMzAgLTQxIDQ1IC05OHQxNyAtOTN0MiAtOTZ2LTM5N3EwIC03MyAtMTAgLTEzMXQtMjQuNSAtOTV0LTM3IC02NC41dC00MS41IC00MC41dC00My41IC0yMC41dC0zOC41IC05dC0zMCAtMS41aC0xMHEtOTYgMCAtMTU3IDUwcS01OSAtNTAgLTE2NSAtNTBoLTEweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJEaWdhbW1hIiB1bmljb2RlPSImI3gzZGM7IiAKZD0iTTI1NyA3MTJ2LTYzNmgtMTUwdjEzMjRoNzI1di0xNTBoLTU3NXYtMzg4aDQ4M3YtMTUwaC00ODN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNpZ21hbHVuYXRlIiB1bmljb2RlPSImI3gzZjI7IiAKZD0iTTY2NSAtOTJxMCAxMCAtMTQuNSAyMy41dC02MiAyNy41dC0xMTguNSAxNmgtMThxLTE0OCAwIC0yNDYuNSAxMjd0LTk4LjUgMzI1djE3MHEwIDE5NCAxMjQuNSAzMjEuNXQzMjMuNSAxMjcuNXExMDMgMCAyMTMgLTQybDQxIC0xNWwtNTIgLTE0MGwtNDEgMTVxLTg2IDMyIC0xNjEgMzJxLTEzOCAwIC0yMTggLTg0dC04MCAtMjE1di0xNzBxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxODAgLTIgMTQyIC0xNy41dDk5LjUgLTM3LjUKdDYxLjUgLTUxdDMzIC01NnQ5IC01NXYtMTlxMCAtMTA5IC05MC41IC0xODMuNXQtMjY2LjUgLTc0LjV2MTUwcTM2IDAgNjkuNSA1dDY2IDE2LjV0NTIgMzMuNXQxOS41IDUzdjE5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ5b3RncmVlayIgdW5pY29kZT0iJiN4M2YzOyIgCmQ9Ik01MzMgMTI5N3EwIDQ5IDMzLjUgODN0ODIuNSAzNHQ4My41IC0zNHQzNC41IC04M3QtMzQuNSAtODN0LTgzLjUgLTM0dC04Mi41IDM0dC0zMy41IDgzek00NzYgLTIxOXE1MCAwIDc5LjUgMjh0MjkuNSA4MnY5ODNoLTMxOHYxNTBoNDY4di0xMTMzcTAgLTExNyAtNzMuNSAtMTg4LjV0LTE4NS41IC03MS41cS0xMDcgMCAtMTgzIDc3LjV0LTc2IDE4MS41aDE1MHEwIC00MiAzMi41IC03NS41dDc2LjUgLTMzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik5hbWVNZS40MzIiIHVuaWNvZGU9IiYjeDQwMDsiIApkPSJNNjQ3IDE1MTdsLTE0MCAtMTM1bC0yNTggMjcybDE0MCAxMzV6TTI1NyA3MTJ2LTU2MWg1NzV2LTE1MWgtNzI1djE0MDBoNzI1di0xNTBoLTU3NXYtMzg4aDQ4M3YtMTUwaC00ODN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IklvY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQwMTsiIApkPSJNMzI3IDE1OTBxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTgxNiAxNTkwcTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTI1NyA3MTJ2LTU2MWg1NzV2LTE1MWgtNzI1djE0MDBoNzI1di0xNTAKaC01NzV2LTM4OGg0ODN2LTE1MGgtNDgzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJEamVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDAyOyIgCmQ9Ik02MjUgMTUwcTE3IDAgMzEgMTN0MjYuNSA1N3QxMi41IDExNnYzODNxMCA2NSAtMjMuNSA4Ny41dC03MS41IDIyLjVxLTE2MyAwIC0xNjMgLTQxMnYtNDE3aC0xNTB2MTI1MGgtMjE3djE1MGg2NzJ2LTE1MGgtMzA1di0zNTJxNzEgODEgMTQ1IDgxaDE4cTcwIDAgMTIwLjUgLTI0dDc2IC02NHQzNyAtODIuNXQxMS41IC04OS41di0zODNxMCAtODEgLTE0LjUgLTE0M3QtMzcgLTk3LjV0LTUzLjUgLTU4dC01OCAtMzB0LTU3IC03LjVoLTE4CnYxNTBoMTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkdqZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MDM7IiAKZD0iTTQ3NiAxMzgzbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTEwNyAwdjE0MDBoNzI1di0xNTFoLTU3NXYtMTI0OWgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQwNDsiIApkPSJNNDYxIC0yNXEtNTYgMCAtMTAzIDE4dC04MS41IDQ4dC02Mi41IDc0LjV0LTQ2LjUgOTF0LTMyIDEwNnQtMjAuNSAxMTAuNXQtMTEuNSAxMTJ0LTUuNSAxMDR0LTEgOTNxMCA3NCAzIDEzNXQxMiAxMzV0MjQuNSAxMzEuNXQ0My41IDExNHQ2NS41IDk0dDkyLjUgNjAuNXQxMjMgMjNxMzAgMCA1Ny41IC00LjV0NzAgLTI0LjV0NzcgLTUzdDY5IC05Ny41dDU1LjUgLTE1MS41bC0xNDYgLTM2cS0xNSA2MCAtMzYgMTAzLjV0LTM5LjUgNjQuNQp0LTQyLjUgMzN0LTM2LjUgMTR0LTI4LjUgMnEtMTAyIDAgLTE1MyAtMTA0LjV0LTU5IC0zMzkuNWwzMTEgLTF2LTE0OWgtMzEzcTkgLTU1NiAyMTQgLTU1NnExNSAwIDI3LjUgMnQzNS41IDEzdDQxIDMxdDM5IDYxdDM2IDk3bDE0NCAtMzhxLTE2IC02MSAtMzkgLTExMC41dC00NyAtODEuNXQtNTIuNSAtNTZ0LTUyLjUgLTM2LjV0LTUxIC0yMHQtNDUgLTkuNXQtMzYgLTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkR6ZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MDU7IiAKZD0iTTQ1MiAxMjVoMThxODQgMCAxNDkuNSA2My41dDY1LjUgMTQ4LjV2MzBxMCA3NSAtMzYuNSAxNTN0LTEwMC41IDExMGwtMjYyIDEzM3EtODQgNDMgLTEyOC41IDExNnQtNDQuNSAxNTR2MzBxMCAxNDkgOTQuNSAyNTUuNXQyNDAuNSAxMDYuNWgyN3ExMjQgMCAyMTUuNSAtNTd0MTI1LjUgLTE2OXExNSAtNDkgMTUgLTEzNmgtMTUwcTAgNjEgLTkgOTJxLTM2IDEyMCAtMTk3IDEyMGgtMjdxLTgxIDAgLTEzMyAtNjEuNXQtNTIgLTE1MC41di0zMApxMCAtMzQgMjAgLTcydDcxIC02NGwyNjQgLTEzNXExMDMgLTUzIDE2MCAtMTY3LjV0NTcgLTIyNy41di0zMHEwIC0xNDggLTExMCAtMjU1dC0yNTUgLTEwN2gtMThxLTk2IDAgLTE4NiA1My41dC0xNDYgMTQyLjV0LTU2IDE4NmgxNTBxMCAtODYgNzYgLTE1OXQxNjIgLTczeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQwNjsiIApkPSJNODMyIDE0MDB2LTE1MGgtMjk2di0xMTAwaDI5NnYtMTUwaC03NDJ2MTUwaDI5NnYxMTAwaC0yOTZ2MTUwaDc0MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iWWljeXJpbGxpYyIgdW5pY29kZT0iJiN4NDA3OyIgCmQ9Ik0zMjggMTU5MnEwIC00NiAtMzIuNSAtODAuNXQtNzcuNSAtMzQuNXEtNDYgMCAtNzkgMzMuNXQtMzMgODEuNXEwIDQ5IDMzLjUgODF0NzYuNSAzMnE0NyAwIDc5LjUgLTMzLjV0MzIuNSAtNzkuNXpNODE3IDE1OTJxMCAtNDkgLTMzIC04MnQtNzYgLTMzcS00NSAwIC03OCAzNHQtMzMgODFxMCA0OCAzMyA4MC41dDc4IDMyLjVxNDIgMCA3NS41IC0zMnQzMy41IC04MXpNODMyIDE0MDB2LTE1MGgtMjk2di0xMTAwaDI5NnYtMTUwaC03NDJ2MTUwCmgyOTZ2MTEwMGgtMjk2djE1MGg3NDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkplY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQwODsiIApkPSJNODUyIDE0MDB2LTE1MGgtMTcydi05MTNxMCAtMTY1IC04MyAtMjYzLjV0LTIxNyAtOTguNWgtMThxLTU1IDAgLTEwMCAxMnQtNzQuNSAzMy41dC01MC41IDQzdC0zNCA1MHQtMTguNSA0NHQtOS41IDMzLjVsMTQ2IDM0cTEyIC01MyA0NC41IC03Ni41dDk2LjUgLTIzLjVoMThxNDMgMCA3NCAxOS41dDQ2LjUgNTJ0MjIuNSA2N3Q3IDczLjV2OTEzaC0yMTJ2MTUwaDUzNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iTGplY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQwOTsiIApkPSJNMTQ3IDEwODFxNCA1MiAxOCAxMDUuNXQzNi41IDEwMi41dDU3IDgwdDc0LjUgMzFoMjE0di01MjhxMTYyIC0yIDI1MCAtOTUuNXQ4OCAtMjYxLjV2LTE1OHEwIC01NSAtOSAtMTAzLjV0LTMzIC05NnQtNjIgLTgxLjV0LTk5LjUgLTU1dC0xNDEuNSAtMjFoLTE0M3YxMjUwaC00MnEtNDggLTYzIC01OCAtMTgxbC05MyAtMTA2OWgtMTUyek01NDcgNzIydi01NzJxMTAzIDEgMTQ1LjUgNTJ0NDIuNSAxNTV2MTU4cTAgOTQgLTQyIDE0OS41CnQtMTQ2IDU3LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik5qZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MGE7IiAKZD0iTTU0NyA3MjJ2LTU3MnExMDMgMSAxNDUuNSA1M3Q0Mi41IDE1NnYxNThxMCA5NCAtNDEuNSAxNDguNXQtMTQ2LjUgNTYuNXpNMjA3IDBoLTE0OXYxNDAwaDE1MHYtNTI4aDE4OXY1MjhoMTUwdi01MjhxMTYyIC0yIDI1MCAtOTV0ODggLTI2MHYtMTU4cTAgLTU1IC05IC0xMDMuNXQtMzMgLTk2LjV0LTYyIC04Mi41dC05OS41IC01NS41dC0xNDEuNSAtMjFoLTE0M3Y3MjJoLTE4OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVHNoZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MGI7IiAKZD0iTTY5NSA3MTlxMCA1OCAtMTcuNSA4NHQtNzcuNSAyNmgtMTZxLTEwIDAgLTI2IC0xMi41dC0zNy41IC00NHQtNDAgLTc2dC0zMSAtMTE4dC0xMi41IC0xNjEuNXYtNDE3aC0xNTB2MTI1MGgtMjE3djE1MGg2NzJ2LTE1MGgtMzA1di0zNDRxMzQgNDIgNzQuNSA1Ny41dDcwLjUgMTUuNWgxOHE1NyAwIDEwMC41IC0xNXQ3MC41IC0zOS41dDQ0IC01OXQyMy41IC03MHQ2LjUgLTc2LjV2LTcxOWgtMTUwdjcxOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iS2plY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQwYzsiIApkPSJNMzU0IDEzODNsLTE0MCAxMzVsMjU4IDI3MmwxNDAgLTEzNXpNMTA4IDB2MTQwMGgxNTB2LTY0OGwzOTcgNjQ4aDE3NmwtMzY2IC01OTdsMzgzIC04MDNoLTE2N2wtMzEwIDY1MGwtMTEzIC0xODR2LTQ2NmgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJaWN5cmlsbGljX2dyYXZlbW9kaWZpZXIiIHVuaWNvZGU9IiYjeDQwZDsiIApkPSJNNzExIDE1MThsLTE0MCAtMTM1bC0yNTggMjcybDE0MCAxMzV6TTEwNyAwdjE0MDBoMTUwdi05ODZsNDIzIDk4NmgxMzV2LTE0MDBoLTE1MHY5ODVsLTQyMiAtOTg1aC0xMzZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlVzaG9ydGN5cmlsbGljIiB1bmljb2RlPSImI3g0MGU7IiAKZD0iTTQ3OSAxNDY2cS04NCAwIC0xNTguNSAzN3QtMTI4LjUgMTAybDExNSA5NnE3MCAtODUgMTcyIC04NXExMDUgMCAxNzggODZsMTE0IC05N3EtNTUgLTY1IC0xMzEgLTEwMnQtMTYxIC0zN3pNNTUyIDE5NnEtNSAtMjEgLTEwLjUgLTM4LjV0LTI1IC01NC41dC00NC41IC02MnQtNzAgLTQ1LjV0LTEwMSAtMjAuNWgtMjlxLTQ4IDAgLTg1IDE1bC0zMyAxM2w1NiAxNDBsMjcgLTExcTIxIC03IDM1IC03aDI3cTUxIDAgNzIgMjUuNXQzNSA4MS41Cmw1MCAyMTJsLTM2NCA5NTZoMTYxbDI2NSAtNjk3bDE2NiA2OTdoMTU0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJEemhlY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQwZjsiIApkPSJNMjU3IDE1MGg0MDh2MTI1MGgxNTB2LTE0MDBoLTI3OXYtMzg1aC0xNTB2Mzg1aC0yNzl2MTQwMGgxNTB2LTEyNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkFjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDEwOyIgCmQ9Ik0zMjkgMzk5aDI2NGwtMTMyIDYwNXpNMjQxIDBoLTE1M2wzMTEgMTQyNWgxMjRsMzEwIC0xNDI1aC0xNTNsLTU0IDI0OWgtMzMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJCZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MTE7IiAKZD0iTTI1NyA3MTJ2LTU4N2gyMTNxMTA4IDAgMTUxLjUgNTF0NDMuNSAxNTZ2MTczcTAgOTYgLTQzIDE1MS41dC0xNTIgNTUuNWgtMjEzek00NzAgODYycTE2NSAwIDI1NSAtOTR0OTAgLTI2M3YtMTczcTAgLTU1IC05IC0xMDMuNXQtMzMgLTk2dC02MiAtODEuNXQtOTkuNSAtNTV0LTE0MS41IC0yMWgtMzYzdjE0MjVoNjM1di0xNTBoLTQ4NXYtMzg4aDIxM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iVmVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDEyOyIgCmQ9Ik00MjAgMTQwMHEzNiAwIDU5IC0xdDYzIC03dDY2LjUgLTE3dDU5IC0zMy41dDUxLjUgLTU0dDMyLjUgLTgxdDEzLjUgLTExMS41di03MXEwIC0xNTAgLTczIC0yMjZxMTIzIC05MyAxMjMgLTMwM3YtMTQ4cTAgLTE2MiAtODYuNSAtMjU0LjV0LTI1OC41IC05Mi41aC0zNjN2MTQwMGgzMTN6TTY2NSAzNDd2MTQ4cTAgNjYgLTEyIDEwOXQtMzguNSA2Ni41dC02MCAzMi41dC04NC41IDloLTIxM3YtNTYyaDIxM3ExMDUgMCAxNTAgNDcuNQp0NDUgMTQ5LjV6TTYxNSAxMDk1cTAgMTAwIC0zOCAxMjcuNXQtMTU3IDI3LjVoLTE2M3YtMzg4aDE2M3ExMTcgMCAxNTYgMzQuNXQzOSAxMjcuNXY3MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iR2VjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDEzOyIgCmQ9Ik0xMDcgMHYxNDAwaDcyNXYtMTUxaC01NzV2LTEyNDloLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iRGVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDE0OyIgCmQ9Ik0yODEgOTc4cTcgNDQgMjkuNSAxMDEuNXQ1OS41IDEyMXQ5NC41IDExOXQxMjMuNSA4MC41aDIwN3YtMTI0OWg4MHYtMTk0bC0zNSAtMTE5aC0xMTV2MTYyaC01Mjh2LTE2MmgtMTExbC0zOSAxMjh2MTg1aDEwMXpNMzAwIDE1MWgzNDV2MTA5OWgtMjdxLTYwIC0zMSAtMTE4LjUgLTEyNnQtNzAuNSAtMTcweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MTU7IiAKZD0iTTI1NyA3MTJ2LTU2MWg1NzV2LTE1MWgtNzI1djE0MDBoNzI1di0xNTBoLTU3NXYtMzg4aDQ4M3YtMTUwaC00ODN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlpoZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MTY7IiAKZD0iTTM4NiA3NDV2NjA1aDE1MHYtNjA1bDE4OSA2NTVoMTU2bC0yMDMgLTcwM2wyMDcgLTY5N2gtMTU2bC0xMjggNDMwbC02NSAtMjI1di0yMDVoLTE1MHYyMDVsLTY1IDIyNmwtMTI4IC00MzFoLTE1NmwyMDYgNjk5bC0yMDIgNzAxaDE1NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iWmVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDE3OyIgCmQ9Ik00MzIgMTQyNWgzOHExMzMgMCAyMTYuNSAtOTd0ODMuNSAtMjQ1di0zOXEwIC02MyAtMjUuNSAtMTI5dC02OS41IC0xMDVxMTQwIC0xMjQgMTQwIC0zNzN2LTIwcTAgLTIwMSAtOTAuNSAtMzIxLjV0LTI1NC41IC0xMjAuNWgtMzhxLTgzIDAgLTE2MSA0M3QtMTMxIDEyOHQtNTMgMTkxaDE1MHEwIC02NiAzMyAtMTE2LjV0NzYuNSAtNzN0ODUuNSAtMjIuNWgzOHE5MSAwIDE0MyA3Mi41dDUyIDIxOS41djIwcTAgNTYgLTkgMTA1dC0yOS41IDk0CnQtNjAuNSA3MS41dC05NiAyNi41aC0xNjh2MTUwaDE2OXE2NSAwIDEwNyA1MS41dDQyIDEwOC41djM5cTAgODYgLTQxLjUgMTM5dC0xMDguNSA1M2gtMzhxLTYzIDAgLTExMi41IC0yOS41dC02OS41IC04MS41bC0xNDAgNTJxMzggMTAxIDEyOCAxNTV0MTk0IDU0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJaWN5cmlsbGljIiB1bmljb2RlPSImI3g0MTg7IiAKZD0iTTEwNyAwdjE0MDBoMTUwdi05ODZsNDIzIDk4NmgxMzV2LTE0MDBoLTE1MHY5ODVsLTQyMiAtOTg1aC0xMzZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Iklpc2hvcnRjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDE5OyIgCmQ9Ik00NzYgMTQ2N3EtODQgMCAtMTU4LjUgMzd0LTEyOC41IDEwMmwxMTUgOTZxNzAgLTg1IDE3MiAtODVxMTA1IDAgMTc4IDg2bDExNCAtOTdxLTU1IC02NSAtMTMxIC0xMDJ0LTE2MSAtMzd6TTEwNyAwdjE0MDBoMTUwdi05ODZsNDIzIDk4NmgxMzV2LTE0MDBoLTE1MHY5ODVsLTQyMiAtOTg1aC0xMzZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkthY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQxYTsiIApkPSJNMTA4IDB2MTQwMGgxNTB2LTY0OGwzOTcgNjQ4aDE3NmwtMzY2IC01OTdsMzgzIC04MDNoLTE2N2wtMzEwIDY1MGwtMTEzIC0xODR2LTQ2NmgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFbGN5cmlsbGljIiB1bmljb2RlPSImI3g0MWI7IiAKZD0iTTI3MiA5ODJxMTcgODMgNTggMTY1dDEwOS41IDE1MnQxNDguNSAxMDFoMjI3di0xNDAwaC0xNTB2MTI1MGgtNDdxLTYyIC0zMSAtMTIxIC0xMTcuNXQtNzkgLTE4Mi41bC0xOTggLTk1MGgtMTUzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFbWN5cmlsbGljIiB1bmljb2RlPSImI3g0MWM7IiAKZD0iTTI2IDBsMTAxIDE0MDBoMTUzbDE4MSAtNzM1bDE4MSA3MzVoMTUzbDEwMSAtMTQwMGgtMTUxbC02NiA5MjNsLTE3NiAtNzEyaC04NGwtMTc2IDcxMmwtNjYgLTkyM2gtMTUxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFbmN5cmlsbGljIiB1bmljb2RlPSImI3g0MWQ7IiAKZD0iTTI1NyAwaC0xNTB2MTQwMGgxNTB2LTU5M2g0MDh2NTkzaDE1MHYtMTQwMGgtMTUwdjY1N2gtNDA4di02NTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik9jeXJpbGxpYyIgdW5pY29kZT0iJiN4NDFlOyIgCmQ9Ik04MjUgNzY1di02OXEwIC0xNzkgLTI0IC0zMTMuNXQtNjAgLTIxMHQtODYuNSAtMTIydC05NC41IC02MXQtOTMgLTE0LjVoLTExcS00OSAwIC05MyAxNHQtOTUgNjAuNXQtODcgMTIydC02MCAyMTAuNXQtMjQgMzE0djY3cTAgNjYyIDM1OCA2NjJoMTJxMzU4IDAgMzU4IC02NjB6TTQ2NyAxMjc1aC0xMnEtMTA1IDAgLTE1Ni41IC0xMjV0LTUxLjUgLTM4N3YtNjdxMCAtNzMgNCAtMTQxdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjUKdDkxLjUgLTQwaDExcTUyIDAgOTEuNSA0MC41dDYxIDk5LjV0MzQuNSAxNDAuNXQxNyAxNDkuNXQ0IDE0MXY2OXEwIDI2MSAtNTEgMzg1LjV0LTE1NyAxMjQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iUGVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDFmOyIgCmQ9Ik0xMDcgMHYxNDAwaDcwOHYtMTQwMGgtMTUwdjEyNTBoLTQwOHYtMTI1MGgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJFcmN5cmlsbGljIiB1bmljb2RlPSImI3g0MjA7IiAKZD0iTTI1NyA2NDJ2LTY0MmgtMTUwdjE0MDBoMzYzcTc4IDAgMTM3IC0xNXQxMDggLTUxLjV0NzQuNSAtMTA0LjV0MjUuNSAtMTY2di05MXEwIC02NyAtMTYgLTEyMi41dC01Mi41IC0xMDR0LTEwNyAtNzZ0LTE2OS41IC0yNy41aC0yMTN6TTQ3MCA3OTJxMTEwIDAgMTUyLjUgNDF0NDIuNSAxMzl2OTFxMCAxMTAgLTQwLjUgMTQ4LjV0LTE1NC41IDM4LjVoLTIxM3YtNDU4aDIxM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iRXNjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDIxOyIgCmQ9Ik00ODcgLTI1aC0zMXEtNDkgMCAtOTMgMTR0LTk1IDYwLjV0LTg3IDEyMnQtNjAgMjEwLjV0LTI0IDMxNHY2N3EwIDY2MiAzNTggNjYyaDMycTU0IDAgMTAwLjUgLTE2dDc4IC0zOHQ1OCAtNTd0NDEgLTYydDI3IC02NXQxNiAtNTN0OC41IC0zOWwtMTQ2IC0zMHEtMTMgNjQgLTMzIDEwNy41dC00NS41IDY1dC01MCAyOS41dC01NC41IDhoLTMycS0xMDUgMCAtMTU2LjUgLTEyNXQtNTEuNSAtMzg3di02N3EwIC03MyA0IC0xNDEKdDE3LjUgLTE0OS41dDM1IC0xNDF0NjEgLTk5LjV0OTEuNSAtNDBoMzFxMTYgMCAyOS41IDIuNXQzNS41IDE0dDM5LjUgMzJ0MzYuNSA2MS41dDMyIDk3bDE0NiAtMzRxLTIwIC04NSAtNTMuNSAtMTQ4dC02Ni41IC05NS41dC03NCAtNTEuNXQtNjguNSAtMjMuNXQtNTYuNSAtNC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJUZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MjI7IiAKZD0iTTg1MiAxNDAwdi0xNTBoLTMxNnYtMTI1MGgtMTUwdjEyNTBoLTMxNnYxNTBoNzgyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJVY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQyMzsiIApkPSJNNTUyIDE5NnEtNSAtMjEgLTEwLjUgLTM4LjV0LTI1IC01NC41dC00NC41IC02MnQtNzAgLTQ1LjV0LTEwMSAtMjAuNWgtMjlxLTQ4IDAgLTg1IDE1bC0zMyAxM2w1NiAxNDBsMjcgLTExcTIxIC03IDM1IC03aDI3cTUxIDAgNzIgMjUuNXQzNSA4MS41bDUwIDIxMmwtMzY0IDk1NmgxNjFsMjY1IC02OTdsMTY2IDY5N2gxNTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkVmY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQyNDsiIApkPSJNMzg2IDIzNXY5MzNxLTkwIC0yNSAtMTM2IC0xMjV0LTQ2IC0yOTB2LTU2cTAgLTM5OSAxODIgLTQ2MnpNNTM2IDExNjh2LTkzM3E1NCAxOCA5MS41IDY2dDU2LjUgMTE2dDI3IDEzNS41dDggMTQ0LjV2NTdxMCAxOTEgLTQ2IDI5MC41dC0xMzcgMTIzLjV6TTUzNiAtMjVoLTE1MHYxMDVxLTUwIDkgLTk0IDMwLjV0LTg5IDY4dC03NyAxMTIuNXQtNTIgMTcwLjV0LTIwIDIzNS41djU2cTAgMTI0IDIwLjUgMjIydDUyLjUgMTU4LjV0NzcgMTAyCnQ4OC41IDYwdDkzLjUgMjYuNXYxMDNoMTUwdi0xMDNxNTAgLTggOTMuNSAtMjZ0ODkgLTU5LjV0NzcuNSAtMTAydDUyLjUgLTE1OHQyMC41IC0yMjIuNXYtNTdxMCAtMTMyIC0yMC41IC0yMzYuNXQtNTIuNSAtMTcwdC03Ny41IC0xMTJ0LTg5IC02OHQtOTMuNSAtMzAuNXYtMTA1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJLaGFjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDI1OyIgCmQ9Ik05NCAwbDI4NyA3MDBsLTI4NyA3MDBoMTYxbDIwNiAtNTAzbDIwNiA1MDNoMTYxbC0yODcgLTcwMGwyODcgLTcwMGgtMTYxbC0yMDYgNTAzbC0yMDYgLTUwM2gtMTYxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJUc2VjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDI2OyIgCmQ9Ik0yNTcgMTUwaDMzOHYxMjUwaDE1MHYtMTI0OWgxMjV2LTkxbC0xNDQgLTI4NWwtMTMxIDcybDc1IDE1M2gtNTYzdjE0MDBoMTUwdi0xMjUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJDaGVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDI3OyIgCmQ9Ik04MTUgMGgtMTUwdjQzN2gtMjEzcS0xNjIgMCAtMjUzLjUgMTAyLjV0LTkxLjUgMjc0LjV2NTg2aDE1MHYtNTg2cTAgLTIyNyAxOTUgLTIyN2gyMTN2ODEzaDE1MHYtMTQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iU2hhY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQyODsiIApkPSJNNTM2IDE1MGgxNzl2MTI1MGgxNTB2LTE0MDBoLTgwOHYxNDAwaDE1MHYtMTI1MGgxNzl2MTAzNGgxNTB2LTEwMzR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IlNoY2hhY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQyOTsiIApkPSJNNzE5IDBoLTY2MnYxNDAwaDE1MHYtMTI1MGgxNTR2MTAzNGgxNTB2LTEwMzRoMTU0djEyNTBoMTUwdi0xMjUxaDg1di0xMzFsLTE0NiAtMjQ3bC0xMjggODB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IkhhcmRzaWduY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQyYTsiIApkPSJNNTMwIDgyMnExMjcgMCAyMDYgLTk3LjV0NzkgLTI1OS41di0xMDhxMCAtMTYzIC04MSAtMjYwdC0yMDQgLTk3aC0yNzN2MTIzMGgtNTRsLTg3IC0yNzFoLTU2djQ0MWgzNDd2LTU3OGgxMjN6TTQwNyA2NzJ2LTUyMmgxMjNxMzkgMCA2Ni41IDE5dDQyIDUwLjV0MjAuNSA2NS41dDYgNzJ2MTA4cTAgOTUgLTM3IDE1MXQtOTggNTZoLTEyM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iWWVyaWN5cmlsbGljIiB1bmljb2RlPSImI3g0MmI7IiAKZD0iTTIyNyA4NzJxMTYyIC0yIDI1MCAtOTUuNXQ4OCAtMjYxLjV2LTE1OHEwIC01NSAtOSAtMTAzLjV0LTMzIC05NnQtNjIgLTgxLjV0LTk5LjUgLTU1dC0xNDEuNSAtMjFoLTE0M3YxNDAwaDE1MHYtNTI4ek0yMjcgNzIydi01NzJxMTAzIDEgMTQ1LjUgNTJ0NDIuNSAxNTV2MTU4cTAgOTQgLTQyIDE0OS41dC0xNDYgNTcuNXpNODQ1IDBoLTE1MHYxNDAwaDE1MHYtMTQwMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iU29mdHNpZ25jeXJpbGxpYyIgdW5pY29kZT0iJiN4NDJjOyIgCmQ9Ik0yNTcgNjcydi01MjJoMjEzcTEwOCAwIDE1MS41IDUxdDQzLjUgMTU2djEwOHEwIDk2IC00MyAxNTEuNXQtMTUyIDU1LjVoLTIxM3pNNDcwIDgyMnExNjUgMCAyNTUgLTk0dDkwIC0yNjN2LTEwOHEwIC01NSAtOSAtMTAzLjV0LTMzIC05NnQtNjIgLTgxLjV0LTk5LjUgLTU1dC0xNDEuNSAtMjFoLTM2M3YxNDAwaDE1MHYtNTc4aDIxM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iRXJldmVyc2VkY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQyZDsiIApkPSJNNjc1IDgzMHEtOCAyMzUgLTYwIDM0MHQtMTU0IDEwNXEtMjEgMCAtMzguNSAtNXQtNDYgLTIzLjV0LTU0LjUgLTY3dC00NCAtMTIzLjVsLTE0NiAzNnEyMSA4NyA1NS41IDE1MnQ2OSA5OC41dDc2LjUgNTMuNXQ3MCAyNC41dDU4IDQuNXE2OCAwIDEyMyAtMjN0OTIuNSAtNjAuNXQ2NS41IC05NC41dDQzLjUgLTExNC41dDI0LjUgLTEzMXQxMiAtMTM1dDMgLTEzNC41cTAgLTUwIC0xIC05M3QtNS41IC0xMDR0LTExLjUgLTExMgp0LTIwLjUgLTExMC41dC0zMiAtMTA2dC00Ni41IC05MXQtNjIuNSAtNzQuNXQtODEuNSAtNDh0LTEwMyAtMThxLTI3IDAgLTUyLjUgMy41dC02Ny41IDIydC03Ni41IDUwLjV0LTcwLjUgOTUuNXQtNTggMTQ5LjVsMTQ2IDM4cTE1IC01NyAzNS41IC05OXQzOSAtNjIuNXQ0MSAtMzJ0MzUuNSAtMTMuNXQyOCAtMnEyMDUgMCAyMTQgNTU2aC0zMTN2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJVWN5cmlsbGljIiB1bmljb2RlPSImI3g0MmU7IiAKZD0iTTM1OCA3NzVxMSA4MiAzIDE0MC41dDguNSAxMzF0MTcgMTIzdDI5LjUgMTAydDQ1IDgzdDY0IDUxdDg2IDE5LjVxNTQgMCA5NSAtMjIuNXQ2OC41IC02OHQ0NiAtMTAzdDI4IC0xNDAuNXQxMyAtMTY2dDMuNSAtMTkzcTAgLTc1NyAtMjU0IC03NTdxLTgzIDAgLTEzNS41IDYwLjV0LTgyLjUgMjA0LjV0LTM1IDM4NWgtMTUxdi02MjVoLTE1MHYxNDAwaDE1MHYtNjI1aDE1MXpNNzE1IDczMnEwIDU0MyAtMTA0IDU0MwpxLTU0IDAgLTc5IC0xNTYuNXQtMjUgLTM4Ni41cTAgLTI3NiAyNiAtNDQxLjV0NzggLTE2NS41cTI5IDAgNTAuNSA1NnQzMi41IDE1MHQxNiAxOTMuNXQ1IDIwNy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJJQWN5cmlsbGljIiB1bmljb2RlPSImI3g0MmY7IiAKZD0iTTY2NSA2NDJoLTE1M2wtMjg1IC02NDJoLTE2NGwyODggNjUxcS0yNDQgNDYgLTI0NCAzMjJ2OTBxMCA5OCAyNS41IDE2NnQ3NC41IDEwNC41dDEwOCA1MS41dDEzNyAxNWgzNjN2LTE0MDBoLTE1MHY2NDJ6TTY2NSA3OTJ2NDU4aC0yMTNxLTExNCAwIC0xNTQuNSAtMzguNXQtNDAuNSAtMTQ4LjV2LTkwcTAgLTk4IDQyLjUgLTEzOS41dDE1Mi41IC00MS41aDIxM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWN5cmlsbGljIiB1bmljb2RlPSImI3g0MzA7IiAKZD0iTTQ1MiA0ODZxLTUwIDAgLTkwIC0xN3QtNjEuNSAtNDJ0LTMyLjUgLTQ4LjV0LTExIC00MS41di03OHEwIC00MyA0OS41IC04OC41dDE0NS41IC00NS41aDE4cTc0IDAgMTM0LjUgNjYuNXQ2MC41IDExMC41djE4NGgtMjEzek00NTIgMTA0OWgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NDlxLTg3IC02NiAtMTk1IC03NGgtMThxLTc4IDAgLTE0NC41IDI1dC0xMDkuNSA2Ngp0LTY3IDkxdC0yNCAxMDJ2NzhxMCA1MSAyNCAxMDMuNXQ2Ni41IDk2LjV0MTA5LjUgNzEuNXQxNDUgMjcuNWgyMTN2ODNxMCA5OCAtNDMgMTM5dC0xNTIgNDFoLTE4cS04MiAwIC0xMjEuNSAtMTcuNXQtNTUuNSAtNTYuNWwtMTM4IDU4cTM3IDkwIDExNi41IDEyOHQxOTguNSAzOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDMxOyIgCmQ9Ik00NTIgMTA0OWgxOHExMTMgMCAxOTIuNSAtNjF0MTE2IC0xNjF0MzYuNSAtMjMwdi0xOTBxMCAtMjA1IC04OS41IC0zMTguNXQtMjU1LjUgLTExMy41aC0xOHEtMTUwIDAgLTI0Ny41IDExOC41dC05Ny41IDMxMy41djU0NnEwIDExMiAyOS41IDIwMHQ4MCAxNDAuNXQxMTIuNSA3OS41dDEzMSAyN3E3MCAwIDEyMCAxMi41dDEzNCA0My41bDUyIC0xNDBxLTk4IC0zNyAtMTU5IC01MS41dC0xNDcgLTE0LjVxLTM3IDAgLTcxIC0xMy41CnQtNjQuNSAtNDIuNXQtNDguNSAtODJ0LTE4IC0xMjRxODAgNjEgMTk0IDYxek0yNTcgNTk3di0xOTBxMCAtMTMzIDU2IC0yMDcuNXQxMzkgLTc0LjVoMThxMTk1IDAgMTk1IDI4MnYxOTBxMCA1OCAtOSAxMDcuNXQtMjkuNSA5NS41dC02MC41IDcyLjV0LTk2IDI2LjVoLTE4cS01NiAwIC05NiAtMjYuNXQtNjAuNSAtNzIuNXQtMjkuNSAtOTUuNXQtOSAtMTA3LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InZlY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQzMjsiIApkPSJNMTA3IDB2MTAyNGgzMjlxODQgMCAxNDggLTE3dDEwMC41IC00Mi41dDU5IC02MC41dDMwIC02Ni41dDcuNSAtNjUuNXEwIC0xMTYgLTgxIC0xOTlxMTM0IC04MSAxMzQgLTI0OHYtOXEwIC0xMzUgLTkwLjUgLTIyNS41dC0yNTMuNSAtOTAuNWgtMzgzek0yNTcgMTUwaDIzM3E5NiAwIDE0NSA0NC41dDQ5IDEyMS41djlxMCA1NiAtMzAgOTF0LTcxIDQ2LjV0LTk0IDExLjVoLTIzMnYtMzI0ek00MzYgNjI0cTk3IDAgMTQ2IDQzLjUKdDQ5IDEwNC41cTAgNTEgLTU0LjUgNzYuNXQtMTQwLjUgMjUuNWgtMTc5di0yNTBoMTc5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJnZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MzM7IiAKZD0iTTc3IDcxOXEwIDEzMyA5OS41IDIzMS41dDIzNS41IDk4LjVoMThxMjQgMCA0Ni41IC0xdDYwLjUgLTd0NjkgLTE2dDY1LjUgLTI5LjV0NTguNSAtNDZ0MzkuNSAtNjh0MTUuNSAtOTIuNXYtMTJxMCAtMjQgLTUuNSAtNTAuNXQtMTguNSAtNTkuNXQtNDIgLTYyLjV0LTY5IC00OC41bC0zNzQgLTE3M3EtMTkgLTkgLTM0IC0zMy41dC0xNSAtNTguNXYtNDZxMCAtNDIgMzAgLTcwdDcyIC0zOXQ5MyAtMTFoNDhxNjggMCAxMzEuNSA2OS41CnQ2My41IDE0Mi41aDE1MHEwIC04NCAtNDcuNSAtMTY4dC0xMjguNSAtMTM5dC0xNjkgLTU1aC00OHEtMTQ4IDAgLTI0Ni41IDczLjV0LTk4LjUgMTk2LjV2NDZxMCA3NCAzNi41IDEzNnQ5OC41IDkybDM3OCAxNzVxMTQgNSAyNy41IDI1LjV0MTcuNSA1Ny41djEycTAgNjMgLTQ2IDg1LjV0LTE1OSAyNC41aC0xOHEtNzkgMCAtMTMyIC01NnQtNTMgLTEyNGgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MzQ7IiAKZD0iTTIyMSA2MThxMTIgODAgNzAuNSAxNzAuNXQxNDIuNSAxNTcuNXQxNjEgNzhoMjAwdi04NzNoODB2LTE5NGwtMzUgLTExOWgtMTE1djE2MmgtNTI4di0xNjJoLTExMWwtMzkgMTI4djE4NWgxMDF6TTMwMCAxNTFoMzQ1djcyM2gtMzVxLTcxIC0xOCAtMTUwIC0xMTIuNXQtOTEgLTE2OS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MzU7IiAKZD0iTTI1NyA0ODZ2LTE0OXEwIC05MCA0OS41IC0xNTF0MTQ1LjUgLTYxaDE4cTk1IDAgMTM0IDI0LjV0NTIgNzIuNWwxNDQgLTQwcS01NiAtMjA3IC0zMzAgLTIwN2gtMThxLTE2MCAwIC0yNTIuNSAxMDZ0LTkyLjUgMjU2djM4MnEwIDUzIDkgOTh0MzMgODl0NjIgNzQuNXQ5OS41IDQ5LjV0MTQxLjUgMTloMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTIzM2gtNTU4ek02NjUgNjM2djgzCnEwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTEwOSAwIC0xNTIgLTQxdC00MyAtMTM5di04M2g0MDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InpoZWN5cmlsbGljIiB1bmljb2RlPSImI3g0MzY7IiAKZD0iTTM4NiA1MjR2NTAwaDE1MHYtNTAwbDIyNyA1NDNsMTM4IC01OGwtMjIxIC01MzFsMTc5IC00NzhoLTE2MGwtMTAzIDI3N2wtNjAgLTE0M3YtMTM0aC0xNTB2MTM0bC02MCAxNDRsLTEwMyAtMjc4aC0xNjBsMTc4IDQ4MWwtMjIwIDUyOGwxMzggNTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InplY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQzNzsiIApkPSJNNjIwIDc5OHEwIDM2IC0zNS41IDY4dC0xMTQuNSAzMmgtMzhxLTYzIDAgLTExMi41IC0yOS41dC02OS41IC04MS41bC0xNDAgNTJxMzggMTAxIDEyOCAxNTV0MTk0IDU0aDM4cTY3IDAgMTIwLjUgLTE3dDg2LjUgLTQzdDU0LjUgLTYwLjV0MzAgLTY2LjV0OC41IC02M3YtMTFxMCAtMTE1IC04OCAtMjA5cTY0IC00MSA5OC41IC0xMDUuNXQzNC41IC0xMzguNXYtMjBxMCAtODIgLTQwIC0xNTguNXQtMTIxIC0xMjguNXQtMTg0IC01MmgtMTgKcS02MCAwIC0xMjAgMTl0LTExMSA1NHQtODIuNSA5MS41dC0zMS41IDEyNS41aDE1MHEwIC02NCA2MS41IC0xMDJ0MTMzLjUgLTM4aDE4cTQ4IDAgODcgMTl0NjEuNSA0OC41dDM0LjUgNjF0MTIgNjAuNXYyMHEwIDYyIC00OS41IDEwNi41dC0xNDUuNSA0NC41aC0xMDh2MTUwaDEwOXE2NCAwIDEwNi41IDQ3LjV0NDIuNSAxMDQuNXYxMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaWljeXJpbGxpYyIgdW5pY29kZT0iJiN4NDM4OyIgCmQ9Ik0xMDcgMHYxMDI0aDE1MHYtNzA2bDQyNiA3MDZoMTMydi0xMDI0aC0xNTB2NzA0bC00MjUgLTcwNGgtMTMzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpaXNob3J0Y3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQzOTsiIApkPSJNNDU4IDExNjlxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek0xMDcgMHYxMDI0aDE1MHYtNzA2bDQyNiA3MDZoMTMydi0xMDI0aC0xNTB2NzA0bC00MjUgLTcwNGgtMTMzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJrYWN5cmlsbGljIiB1bmljb2RlPSImI3g0M2E7IiAKZD0iTTI1NyAwaC0xNTB2MTAyNGgxNTB2LTY1N2w0NTEgNjU3bDEyNCAtODVsLTMzOCAtNDkxbDMzOSAtNDQ4aC0xODhsLTI0MSAzMTdsLTE0NyAtMjE0di0xMDN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVsY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQzYjsiIApkPSJNMjMyIDYyMnEzMSAxMjAgMTMwLjUgMjM3dDIyNS41IDE2NWgyMjd2LTEwMjRoLTE1MHY4NzNoLTQ4cS03NiAtMzUgLTE0NyAtMTIxLjV0LTkyIC0xNjUuNWwtMTUxIC01ODZoLTE1NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZW1jeXJpbGxpYyIgdW5pY29kZT0iJiN4NDNjOyIgCmQ9Ik0yNyAwbDgxIDEwMjRoMTU1bDE5OCAtNjQ4bDIwMCA2NDhoMTU1bDgwIC0xMDI0aC0xNTFsLTQ5IDYyOGwtMTcwIC01NTJoLTEzMGwtMTY5IDU1MmwtNTAgLTYyOGgtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlbmN5cmlsbGljIiB1bmljb2RlPSImI3g0M2Q7IiAKZD0iTTI1NyAwaC0xNTB2MTAyNGgxNTB2LTQ3OWg0MDh2NDc5aDE1MHYtMTAyNGgtMTUwdjM5NWgtNDA4di0zOTV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im9jeXJpbGxpYyIgdW5pY29kZT0iJiN4NDNlOyIgCmQ9Ik04MjUgNTYydi05MnEwIC0xMTYgLTIzLjUgLTIwNi41dC01OSAtMTQzLjV0LTgzLjUgLTg3dC05Mi41IC00NnQtOTAuNSAtMTJoLTM1cS0xNjggMCAtMjU2IDEzOHQtODggMzU4djkwcTAgMTAwIDE5LjUgMTg1dDU5LjUgMTU0dDEwNy41IDEwOC41dDE1NS41IDM5LjVoMzlxODkgMCAxNTcgLTM5dDEwOC41IC0xMDd0NjEgLTE1NHQyMC41IC0xODZ6TTQ3OCA4OThoLTM5cS01NSAwIC05NC41IC0zMC41dC01OS41IC04Mi41dC0yOSAtMTA3CnQtOSAtMTE3di05MHEwIC02MyA5IC0xMTkuNXQyOS41IC0xMTB0NjAuNSAtODV0OTUgLTMxLjVoMzVxNDYgMCA4MS41IDIwLjV0NTcuNSA1NHQzNS41IDc5LjV0MTkgOTIuNXQ1LjUgOTguNXY5MnEwIDQ5IC01IDk0dC0xOSA5MHQtMzUuNSA3OHQtNTYuNSA1My41dC04MSAyMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwZWN5cmlsbGljIiB1bmljb2RlPSImI3g0M2Y7IiAKZD0iTTI1NyAwaC0xNTB2MTAyNGgxNTB2LTY3cTg5IDkyIDE5NSA5MmgxOHE4MCAwIDE0MS41IC0xOXQ5OS41IC00OS41dDYyIC03NC41dDMzIC04OXQ5IC05OHYtNzE5aC0xNTB2NzE5cTAgOTggLTQzIDEzOXQtMTUyIDQxaC0xOHEtNDggMCAtOTQuNSAtNTMuNXQtNzMuNSAtMTIzLjV0LTI3IC0xMjV2LTU5N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZXJjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDQwOyIgCmQ9Ik0yNTcgNDI3cTAgLTEzNSA1NyAtMjE4LjV0MTM4IC04My41aDE4cTU2IDAgOTYgMjYuNXQ2MC41IDcydDI5LjUgOTUuNXQ5IDEwOHYxNzBxMCA1OCAtOSAxMDcuNXQtMjkuNSA5NS41dC02MC41IDcyLjV0LTk2IDI2LjVoLTE4cS01NiAwIC05NiAtMjYuNXQtNjAuNSAtNzIuNXQtMjkuNSAtOTUuNXQtOSAtMTA3LjV2LTE3MHpNMjU3IC0zODVoLTE1MHYxNDA5aDE1MHYtMzdxODEgNjIgMTk1IDYyaDE4cTExMyAwIDE5Mi41IC02MQp0MTE2IC0xNjF0MzYuNSAtMjMwdi0xNzBxMCAtMjA3IC05MC41IC0zMjkuNXQtMjU0LjUgLTEyMi41aC0xOHEtMTEwIDAgLTE5NSA3M3YtNDMzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlc2N5cmlsbGljIiB1bmljb2RlPSImI3g0NDE7IiAKZD0iTTQ3MCA4OThoLTE4cS01NiAwIC05NiAtMjYuNXQtNjAuNSAtNzJ0LTI5LjUgLTk1dC05IC0xMDcuNXYtMTcwcTAgLTEzNSA1NyAtMjE4LjV0MTM4IC04My41aDE4cTgzIDAgMTI1IDE5LjV0NTggNjcuNWwxNDIgLTQ4cS02MyAtMTg5IC0zMjUgLTE4OWgtMThxLTE0OCAwIC0yNDYuNSAxMjd0LTk4LjUgMzI1djE3MHEwIDEzMCAzNi41IDIzMHQxMTYgMTYwLjV0MTkyLjUgNjAuNWgxOHEyNjggMCAzMjcgLTE5NmwtMTQ0IC00NApxLTkgMjkgLTI1IDQ3LjV0LTU1IDMwLjV0LTEwMyAxMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDQyOyIgCmQ9Ik04NTIgMTAyNHYtMTQ5aC0zMTZ2LTg3NWgtMTUwdjg3NWgtMzE2djE0OWg3ODJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDQzOyIgCmQ9Ik04NDEgMTAyNGwtMjYxIC0xMTU0cS0xNSAtNjUgLTQyIC0xMTIuNXQtNTQuNSAtNzF0LTYyIC0zN3QtNTUgLTE2dC00Mi41IC0yLjVxLTc5IDAgLTE0NS41IDUwLjV0LTk1LjUgMTIwLjVsMTM4IDU2cTEzIC0zMSA0MyAtNTR0NjAgLTIzcTM0IDAgNjcgMzcuNXQ0NSA5MS41bDQ0IDE5NWwtMzcyIDkxOWgxNjNsMjY3IC02NjBsMTQ5IDY2MGgxNTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVmY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ0NDsiIApkPSJNMzg2IDEzMHY2ODJxLTUyIC0xMCAtODkgLTQxdC01Ni41IC03NS41dC0yOCAtOTAuNXQtOC41IC05N3YtODFxMCAtNTMgOC41IC05OC41dDI4IC04OHQ1Ni41IC03MS41dDg5IC0zOXpNNTM2IDgxMnYtNjgycTE4MiAzNSAxODIgMjk2djgzcTAgNTAgLTguNSA5NS41dC0yOCA5MHQtNTYuNSA3NS41dC04OSA0MnpNNTM2IC0zODVoLTE1MHYzNjNxLTE2MyAxOCAtMjQ3LjUgMTQwLjV0LTg0LjUgMzA4LjV2ODFxMCAxOTYgOTAgMzE3CnQyNDIgMTM5djg1aDE1MHYtODVxMTUyIC0yMCAyNDIgLTE0MXQ5MCAtMzE0di04M3EwIC0xODYgLTg1IC0zMDd0LTI0NyAtMTQxdi0zNjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImtoYWN5cmlsbGljIiB1bmljb2RlPSImI3g0NDU7IiAKZD0iTTk3IDBsMjc4IDUxMmwtMjc4IDUxMmgxNzFsMTkzIC0zNTVsMTkzIDM1NWgxNzFsLTI3OSAtNTEybDI3OSAtNTEyaC0xNzFsLTE5MyAzNTRsLTE5MyAtMzU0aC0xNzF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRzZWN5cmlsbGljIiB1bmljb2RlPSImI3g0NDY7IiAKZD0iTTYyMCAtMTY0cTMzIDIwIDQ4IDMxLjV0MjcgMzF0MTIgNDUuNXEwIDM1IC04IDU3dC0zNCA0NXY0MnEtMTAwIC0xMTMgLTIxNSAtMTEzaC0xOHEtNjYgMCAtMTIxLjUgMTh0LTEwMi41IDU3LjV0LTc0IDExMi41dC0yNyAxNzR2Njg3aDE1MHYtNjg3cTAgLTEyMCA0My41IC0xNjZ0MTMxLjUgLTQ2aDE4cTQ3IDAgOTkgNTh0ODQgMTM0dDMyIDEzMHY1NzdoMTUwdi05MTZxMTkgLTIzIDMwLjUgLTY4LjV0MTEuNSAtOTUuNQpxMCAtNzUgLTQ2LjUgLTEzNXQtMTEwLjUgLTEwMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2hlY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ0NzsiIApkPSJNNjY1IDQ3MHEtMTAxIC0xMTggLTIxNSAtMTE4aC0xOHEtNjEgMCAtMTE1IDE3LjV0LTEwMyA1OHQtNzggMTE3LjV0LTI5IDE4NHYyOTVoMTUwdi0yOTVxMCAtMTI0IDQ0LjUgLTE3NS41dDEzMC41IC01MS41aDE4cTU0IDAgMTA2IDY1LjV0ODAuNSAxNDMuNXQyOC41IDEyOHYxODVoMTUwdi0xMDI0aC0xNTB2NDcweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzaGFjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDQ4OyIgCmQ9Ik02MDYgMTI1cTM2IDUgNjcuNSA3Mi41dDMxLjUgMTM5LjV2Njg3aDE1MHYtMTAyNGgtMTUwdjVxLTQ3IC0zMCAtOTkgLTMwaC0xMHEtMTEwIDAgLTE2NCA3MHEtNDEgLTQ0IC03NC41IC01N3QtNzAuNSAtMTNoLTEwcS01NCAwIC05My41IDE1dC02MS41IDM3LjV0LTM1IDU2dC0xNi41IDYzLjV0LTMuNSA2OHY4MDloMTUwdi04MDhxMCAtNTIgMTMgLTcxLjV0NDcgLTE5LjVoMTBxMzYgNSA2Ny41IDcyLjV0MzEuNSAxMzkuNXY2ODdoMTUwCnYtODA4cTAgLTUwIDE1IC03MC41dDQ1IC0yMC41aDEweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzaGNoYWN5cmlsbGljIiB1bmljb2RlPSImI3g0NDk7IiAKZD0iTTYwNiAxMjVxMzYgNSA2Ny41IDcyLjV0MzEuNSAxMzkuNXY2ODdoMTUwdi05MTdxNDQgLTU3IDQ0IC0xMzJxMCAtNzcgLTQzLjUgLTE0OXQtMTE1LjUgLTExN2wtODAgMTI2cTQzIDI3IDY2IDY2LjV0MjMgNzMuNXEwIDI5IC0yMCA0OXEtMzUgLTMxIC02Mi41IC00MHQtNjAuNSAtOWgtMTBxLTExMCAwIC0xNjQgNzBxLTQxIC00NCAtNzQgLTU3dC03MSAtMTNoLTEwcS01NSAwIC05NSAxNS41dC02MS41IDM4LjV0LTM0IDU3LjV0LTE2IDYzCnQtMy41IDY1LjV2ODA5aDE1MHYtODA4cTAgLTUxIDEzLjUgLTcxdDQ2LjUgLTIwaDEwcTM2IDUgNjcuNSA3Mi41dDMxLjUgMTM5LjV2Njg3aDE1MHYtODA4cTAgLTkxIDYwIC05MWgxMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaGFyZHNpZ25jeXJpbGxpYyIgdW5pY29kZT0iJiN4NDRhOyIgCmQ9Ik00NzAgNjM2cTE0MyAwIDI0NCAtNzUuNXQxMDEgLTE5OC41di03OHEwIC04NiAtNDkuNSAtMTUydC0xMjcgLTk4LjV0LTE2OC41IC0zMy41aC0yMTN2ODI4aC03MGwtNzQgLTI1NmgtNTN2NDI2aDM0N3YtMzYyaDYzek00MDcgNDg2di0zMzZoNjNxNzYgMSAxMzUuNSAzNi41dDU5LjUgOTcuNXY3OHEwIDYwIC01OCA5MnQtMTM3IDMyaC02M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ieWVyaWN5cmlsbGljIiB1bmljb2RlPSImI3g0NGI7IiAKZD0iTTU2NSAyNzlxMCAtMzYgLTYuNSAtNjkuNXQtMjggLTczdC01NS41IC02OC41dC05NC41IC00OC41dC0xNDAuNSAtMTkuNWgtMTgzdjEwMjRoMTUwdi0zODhoMzNxMTQ0IDAgMjM0LjUgLTc1dDkwLjUgLTIwNHYtNzh6TTcxNSAxMDI0aDE1MHYtMTAyNGgtMTUwdjEwMjR6TTI0MCAxNTBxNzggMCAxMjYuNSAzM3Q0OC41IDk2djc4cTAgNjUgLTQ2IDk3dC0xMjkgMzJoLTMzdi0zMzZoMzN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNvZnRzaWduY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ0YzsiIApkPSJNODE1IDI3OXEwIC0zNSAtNy41IC02OXQtMzEgLTczdC02MCAtNjguNXQtMTAwIC00OXQtMTQ2LjUgLTE5LjVoLTM2M3YxMDQ4aDE1MHYtNDEyaDIxM3ExNDQgMCAyNDQuNSAtNzV0MTAwLjUgLTIwNHYtNzh6TTQ3MCAxNTBxNDYgMCA4OSAxMy41dDc0LjUgNDR0MzEuNSA3MS41djc4cTAgNjMgLTU1LjUgOTZ0LTEzOS41IDMzaC0yMTN2LTMzNmgyMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVyZXZlcnNlZGN5cmlsbGljIiB1bmljb2RlPSImI3g0NGQ7IiAKZD0iTTQzNyAxMDUwaDE4cTE2OCAwIDI1Ni41IC0xMjYuNXQ4OC41IC0zMjYuNXYtMTcwcTAgLTE5OCAtOTguNSAtMzI1dC0yNDYuNSAtMTI3aC0xOHEtMTM1IDAgLTIxNC41IDU2dC0xMTAuNSAxNDlsMTQyIDQ4cTYgLTE4IDE0LjUgLTMydDI3IC0zMi41dDU1IC0yOC41dDg2LjUgLTEwaDE4cTgxIDAgMTM4IDgzLjV0NTcgMjE4LjV2MTBoLTMzM3YxNTBoMzMzdjEwcTAgNTggLTkgMTA3LjV0LTI5LjUgOTZ0LTYwLjUgNzN0LTk2IDI2LjVoLTE4CnEtNTEgMCAtODcgLTEwdC01NSAtMjguNXQtMjcgLTMyLjV0LTE0IC0zNGwtMTQ0IDQ0cTI4IDk1IDEwNy41IDE1M3QyMTkuNSA1OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaXVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDRlOyIgCmQ9Ik0zMjggNTg3cTIgNjkgOS41IDEyOXQyNiAxMjR0NDYuNSAxMDkuNXQ3NC41IDc0LjV0MTA2LjUgMjlxNTYgMCAxMDAuNSAtMjN0NzIuNSAtNjZ0NDcgLTkyLjV0MjggLTExNXQxMi41IC0xMjEuNXQzLjUgLTEyMnEwIC03OCAtMy41IC0xMzcuNXQtMTMgLTEyNXQtMjggLTExMnQtNDcgLTg1LjV0LTcyIC01OC41dC0xMDAuNSAtMTkuNXEtMTI4IDAgLTE5MS41IDExMnQtNzEuNSAzNTBoLTExMXYtNDM3aC0xNTB2MTAyNGgxNTB2LTQzN2gxMTF6Ck01OTEgMTI1cTExNCAwIDExNCAzODhxMCAzOTAgLTExNCAzOTBxLTI2IDAgLTQ2IC0xN3QtMzIgLTUwdC0xOS41IC02OHQtMTEgLTg0LjV0LTQuNSAtODUuNXQtMSAtODVxMCAtMzcgMC41IC02Mi41dDIgLTY0LjV0NC41IC02NnQ4LjUgLTU5LjV0MTQgLTU0LjV0MjAgLTQydDI4IC0yOS41dDM2LjUgLTkuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaWFjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDRmOyIgCmQ9Ik0yNTcgNjc5cTAgLTE5IDYuNSAtMzZ0MjQuNSAtMzd0NjAgLTMydDEwNCAtMTJoMjEzdjMxMmgtMjEzcS00OCAwIC05MC41IC0xMnQtNzMuNSAtNDF0LTMxIC03MXYtNzF6TTM0NCA0MjBxLTczIDEyIC0xMjIuNSA0MHQtNzMgNjZ0LTMyLjUgNzR0LTkgNzl2NzFxMCAxMjggMTAyIDIwMXQyNDMgNzNoMzYzdi0xMDI0aC0xNTB2NDEyaC0xNDZsLTI3OCAtNDEyaC0xODF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ik5hbWVNZS41MTIiIHVuaWNvZGU9IiYjeDQ1MDsiIApkPSJNNjM1IDEzMDlsLTE0MCAtMTM1bC0yNTggMjcybDE0MCAxMzV6TTI1NyA0ODZ2LTE0OXEwIC05MCA0OS41IC0xNTF0MTQ1LjUgLTYxaDE4cTk1IDAgMTM0IDI0LjV0NTIgNzIuNWwxNDQgLTQwcS01NiAtMjA3IC0zMzAgLTIwN2gtMThxLTE2MCAwIC0yNTIuNSAxMDZ0LTkyLjUgMjU2djM4MnEwIDUzIDkgOTh0MzMgODl0NjIgNzQuNXQ5OS41IDQ5LjV0MTQxLjUgMTloMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNQp0MzMgLTg5dDkgLTk4di0yMzNoLTU1OHpNNjY1IDYzNnY4M3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTEwOSAwIC0xNTIgLTQxdC00MyAtMTM5di04M2g0MDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImlvY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ1MTsiIApkPSJNMzU1IDEyNTZxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTg0NCAxMjU2cTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTI1NyA0ODZ2LTE0OXEwIC05MCA0OS41IC0xNTF0MTQ1LjUgLTYxaDE4CnE5NSAwIDEzNCAyNC41dDUyIDcyLjVsMTQ0IC00MHEtNTYgLTIwNyAtMzMwIC0yMDdoLTE4cS0xNjAgMCAtMjUyLjUgMTA2dC05Mi41IDI1NnYzODJxMCA1MyA5IDk4dDMzIDg5dDYyIDc0LjV0OTkuNSA0OS41dDE0MS41IDE5aDE4cTgwIDAgMTQxLjUgLTE5dDk5LjUgLTQ5LjV0NjIgLTc0LjV0MzMgLTg5dDkgLTk4di0yMzNoLTU1OHpNNjY1IDYzNnY4M3EwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTEwOSAwIC0xNTIgLTQxdC00MyAtMTM5CnYtODNoNDA4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkamVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDUyOyIgCmQ9Ik00NzUgLTIxOWg1MXE2MiAwIDEwMC41IDU1dDM4LjUgMTM2djU4MXEwIDEzNSAtMzMgMTgxdC0xMTIgNDZoLTE4cS00NyAwIC05NCAtNTcuNXQtNzQgLTEzMXQtMjcgLTEyOC41di00NjNoLTE1MHYxMTEwaC0xMjd2MTUwaDEyN3YxNjRoMTUwdi0xNjRoMjk4di0xNTBoLTI5OHYtMjc2cTg5IDk2IDE5NSA5NmgxOHE2OSAwIDEyMSAtMTkuNXQ4NSAtNTIuNXQ1MyAtODIuNXQyOCAtMTAzdDggLTExOS41di01ODFxMCAtMTQ0IC04MSAtMjQyLjUKdC0yMDggLTk4LjVoLTUxcS0xMjggMCAtMjAzIDk0bDExOCA5NHEzMCAtMzggODUgLTM4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJnamVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDUzOyIgCmQ9Ik00MzAgMTE1MmwtMTQwIDEzNWwyNTggMjcybDE0MCAtMTM1ek03NyA3MTlxMCAxMzMgOTkuNSAyMzEuNXQyMzUuNSA5OC41aDE4cTI0IDAgNDYuNSAtMXQ2MC41IC03dDY5IC0xNnQ2NS41IC0yOS41dDU4LjUgLTQ2dDM5LjUgLTY4dDE1LjUgLTkyLjV2LTEycTAgLTI0IC01LjUgLTUwLjV0LTE4LjUgLTU5LjV0LTQyIC02Mi41dC02OSAtNDguNWwtMzc0IC0xNzNxLTE5IC05IC0zNCAtMzMuNXQtMTUgLTU4LjV2LTQ2cTAgLTQyIDMwIC03MAp0NzIgLTM5dDkzIC0xMWg0OHE2OCAwIDEzMS41IDY5LjV0NjMuNSAxNDIuNWgxNTBxMCAtODQgLTQ3LjUgLTE2OHQtMTI4LjUgLTEzOXQtMTY5IC01NWgtNDhxLTE0OCAwIC0yNDYuNSA3My41dC05OC41IDE5Ni41djQ2cTAgNzQgMzYuNSAxMzZ0OTguNSA5MmwzNzggMTc1cTE0IDUgMjcuNSAyNS41dDE3LjUgNTcuNXYxMnEwIDYzIC00NiA4NS41dC0xNTkgMjQuNWgtMThxLTc5IDAgLTEzMiAtNTZ0LTUzIC0xMjRoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZWN5cmlsbGljIiB1bmljb2RlPSImI3g0NTQ7IiAKZD0iTTQ4NiA4OThoLTE4cS01NiAwIC05NiAtMjYuNXQtNjAuNSAtNzJ0LTI5LjUgLTk1dC05IC0xMDcuNXYtMTBoMzMzdi0xNTBoLTMzM3YtMTBxMCAtMTM1IDU3IC0yMTguNXQxMzggLTgzLjVoMThxODMgMCAxMjUgMTkuNXQ1OCA2Ny41bDE0MiAtNDhxLTYzIC0xODkgLTMyNSAtMTg5aC0xOHEtMTQ4IDAgLTI0Ni41IDEyN3QtOTguNSAzMjV2MTcwcTAgMTMwIDM2LjUgMjMwdDExNiAxNjAuNXQxOTIuNSA2MC41aDE4cTI2OCAwIDMyNyAtMTk2CmwtMTQ0IC00NHEtOSAyOSAtMjUgNDcuNXQtNTUgMzAuNXQtMTAzIDEyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkemVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDU1OyIgCmQ9Ik02NjUgNzE5cTAgNzkgLTUxLjUgMTI5LjV0LTE0My41IDUwLjVoLTE4cS05NiAwIC0xNDUuNSAtMzIuNXQtNDkuNSAtNzcuNXYtMTJxMyAtMzUgMTcuNSAtNTYuNXQyOC41IC0yNi41bDM3NyAtMTc1cTU1IC0yNiA5NSAtODJ0NDAgLTEzNnYtNDZxMCAtMTI0IC05OSAtMjAydC0yNDYgLTc4aC00OHEtMTA0IDAgLTE4NSA1NHQtMTIwLjUgMTM1LjV0LTM5LjUgMTcyLjVoMTUwcTAgLTgwIDUzLjUgLTE0NnQxNDEuNSAtNjZoNDgKcTc4IDAgMTM2LjUgMzR0NTguNSA5NnY0NnEwIDI2IC0xNiA0OS41dC0zMyAzMi41bC0zNzUgMTczcS0zNyAxOCAtNjUgNDkuNXQtNDIgNjV0LTIwLjUgNjAuNXQtNi41IDQ2djEycTAgNjYgMzQuNSAxMTh0ODguNSA4MnQxMTEgNDV0MTExIDE1aDE4cTExMyAwIDE5MyAtNDYuNXQxMTYgLTExOS41dDM2IC0xNjRoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaWN5cmlsbGljIiB1bmljb2RlPSImI3g0NTY7IiAKZD0iTTM1MiAxMjk3cTAgNDkgMzMuNSA4M3Q4Mi41IDM0dDgzLjUgLTM0dDM0LjUgLTgzdC0zNC41IC04M3QtODMuNSAtMzR0LTgyLjUgMzR0LTMzLjUgODN6TTE4MiAxMDI0aDM1NHYtODc0aDIwNHYtMTUwaC01NTh2MTUwaDIwNHY3MjRoLTIwNHYxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InlpY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ1NzsiIApkPSJNMzM4IDEyNTRxMCAtNDYgLTMyLjUgLTgwLjV0LTc3LjUgLTM0LjVxLTQ2IDAgLTc5IDMzLjV0LTMzIDgxLjVxMCA0OSAzMy41IDgxdDc2LjUgMzJxNDcgMCA3OS41IC0zMy41dDMyLjUgLTc5LjV6TTgyNyAxMjU0cTAgLTQ5IC0zMyAtODJ0LTc2IC0zM3EtNDUgMCAtNzggMzR0LTMzIDgxcTAgNDggMzMgODAuNXQ3OCAzMi41cTQyIDAgNzUuNSAtMzJ0MzMuNSAtODF6TTE4MiAxMDI0aDM1NHYtODc0aDIwNHYtMTUwaC01NTh2MTUwaDIwNAp2NzI0aC0yMDR2MTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJqZWN5cmlsbGljIiB1bmljb2RlPSImI3g0NTg7IiAKZD0iTTUzMyAxMjk3cTAgNDkgMzMuNSA4M3Q4Mi41IDM0dDgzLjUgLTM0dDM0LjUgLTgzdC0zNC41IC04M3QtODMuNSAtMzR0LTgyLjUgMzR0LTMzLjUgODN6TTQ3NiAtMjE5cTUwIDAgNzkuNSAyOHQyOS41IDgydjk4M2gtMzE4djE1MGg0Njh2LTExMzNxMCAtMTE3IC03My41IC0xODguNXQtMTg1LjUgLTcxLjVxLTEwNyAwIC0xODMgNzcuNXQtNzYgMTgxLjVoMTUwcTAgLTQyIDMyLjUgLTc1LjV0NzYuNSAtMzMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGplY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ1OTsiIApkPSJNOTAgNjE5cTEyIDE4NyA2NSAyODIuNXQxNTYgMTM1LjVoMjI3di00MDFoNjJxNjMgMCAxMTEuNSAtMjN0NzQuNSAtNTZ0NDIuNSAtNzQuNXQyMS41IC03MS41dDUgLTU0di03OHEwIC0zNCAtNiAtNjguNXQtMjMgLTczLjV0LTQ0IC02OC41dC03NCAtNDl0LTEwOCAtMTkuNWgtMjEydjg4N2gtNDdxLTQ5IC0yNSAtNzEuNSAtOTV0LTI5LjUgLTE4MWwtMzYgLTYxMWgtMTUwek03MDUgMzU3cTAgNjIgLTM2IDk1LjV0LTY5IDMzLjVoLTYzCnYtMzM2aDYzcTQxIDAgNzMgMzB0MzIgOTl2Nzh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im5qZWN5cmlsbGljIiB1bmljb2RlPSImI3g0NWE7IiAKZD0iTTIxNyAwaC0xNTB2MTAyNGgxNTB2LTM4OGgxNzB2Mzg4aDE1MHYtMzg4aDYzcTEwMiAwIDE3OC41IC03OHQ3Ni41IC0xODV2LTc4cTAgLTEzMyAtNzYuNSAtMjE0dC0xNzguNSAtODFoLTIxM3Y0ODZoLTE3MHYtNDg2ek01MzcgMTUwaDYzcTQxIDAgNzMgMzh0MzIgMTA3djc4cTAgNDQgLTMyIDc4LjV0LTczIDM0LjVoLTYzdi0zMzZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRzaGVjeXJpbGxpYyIgdW5pY29kZT0iJiN4NDViOyIgCmQ9Ik0yIDExNzh2MTUwaDQ1M3YtMTUwaC00NTN6TTI1NyAwaC0xNTB2MTQwMGgxNTB2LTQ0M3E4OSA5MiAxOTUgOTJoMThxODAgMCAxNDEuNSAtMTl0OTkuNSAtNDkuNXQ2MiAtNzQuNXQzMyAtODl0OSAtOTh2LTcxOWgtMTUwdjcxOXEwIDk4IC00MyAxMzl0LTE1MiA0MWgtMThxLTQ4IDAgLTk0LjUgLTUzLjV0LTczLjUgLTEyMy41dC0yNyAtMTI1di01OTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImtqZWN5cmlsbGljIiB1bmljb2RlPSImI3g0NWM7IiAKZD0iTTQwMSAxMTYxbC0xNDAgMTM1bDI1OCAyNzJsMTQwIC0xMzV6TTI1NyAwaC0xNTB2MTAyNGgxNTB2LTY1N2w0NTEgNjU3bDEyNCAtODVsLTMzOCAtNDkxbDMzOSAtNDQ4aC0xODhsLTI0MSAzMTdsLTE0NyAtMjE0di0xMDN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImlpY3lyaWxsaWNfZ3JhdmVtb2RpZmllciIgdW5pY29kZT0iJiN4NDVkOyIgCmQ9Ik02NjUgMTI5NWwtMTQwIC0xMzVsLTI1OCAyNzJsMTQwIDEzNXpNMTA3IDB2MTAyNGgxNTB2LTcwNmw0MjYgNzA2aDEzMnYtMTAyNGgtMTUwdjcwNGwtNDI1IC03MDRoLTEzM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idXNob3J0Y3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ1ZTsiIApkPSJNNDc4IDExNjlxLTg0IDAgLTE1OC41IDM3dC0xMjguNSAxMDJsMTE1IDk2cTcwIC04NSAxNzIgLTg1cTEwNSAwIDE3OCA4NmwxMTQgLTk3cS01NSAtNjUgLTEzMSAtMTAydC0xNjEgLTM3ek04NDEgMTAyNGwtMjYxIC0xMTU0cS0xNSAtNjUgLTQyIC0xMTIuNXQtNTQuNSAtNzF0LTYyIC0zN3QtNTUgLTE2dC00Mi41IC0yLjVxLTc5IDAgLTE0NS41IDUwLjV0LTk1LjUgMTIwLjVsMTM4IDU2cTEzIC0zMSA0MyAtNTR0NjAgLTIzCnEzNCAwIDY3IDM3LjV0NDUgOTEuNWw0NCAxOTVsLTM3MiA5MTloMTYzbDI2NyAtNjYwbDE0OSA2NjBoMTU0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkemhlY3lyaWxsaWMiIHVuaWNvZGU9IiYjeDQ1ZjsiIApkPSJNMjU3IDE1MGg0MDh2ODc0aDE1MHYtMTAyNGgtMjc5di0zODVoLTE1MHYzODVoLTI3OXYxMDI0aDE1MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icXVvdGVsZWZ0IiB1bmljb2RlPSImI3gyMDE4OyIgCmQ9Ik0zMTAgMTEwOHEwIDM0NiAyOTggMzgwbDE1IC01NXEtNDkgLTE4IC05Ni41IC01OXQtNDcuNSAtODVxMCAtNTYgMzQgLTY2cTQ1IC0xMyA2Ny41IC00NC41dDIyLjUgLTcwLjVxMCAtNTkgLTQxLjUgLTEwMnQtMTA0LjUgLTQzdC0xMDUgNDJ0LTQyIDEwM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icXVvdGVyaWdodCIgdW5pY29kZT0iJiN4MjAxOTsiIApkPSJNNjQzIDEzNjNxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InF1b3Rlc2luZ2xiYXNlIiB1bmljb2RlPSImI3gyMDFhOyIgCmQ9Ik02MDcgMjY4cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDJ0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhcG9zdHJvcGhlcmV2ZXJzZSIgdW5pY29kZT0iJiN4MjAxYjsiIApkPSJNMzIwIDEzMTNxMCA2MSA0MiAxMDN0MTA1IDQydDEwNC41IC00M3Q0MS41IC0xMDJxMCAtMzkgLTIyLjUgLTcwLjV0LTY3LjUgLTQ0LjVxLTM0IC0xMCAtMzQgLTY2cTAgLTQ0IDQ3LjUgLTg1dDk2LjUgLTU5bC0xNSAtNTVxLTI5OCAzNCAtMjk4IDM4MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icXVvdGVkYmxsZWZ0IiB1bmljb2RlPSImI3gyMDFjOyIgCmQ9Ik01NTcgMTEwOHEwIDM0NiAyOTggMzgwbDE1IC01NXEtNDkgLTE4IC05Ni41IC01OXQtNDcuNSAtODVxMCAtNTYgMzQgLTY2cTQ1IC0xMyA2Ny41IC00NC41dDIyLjUgLTcwLjVxMCAtNTkgLTQxLjUgLTEwMnQtMTA0LjUgLTQzdC0xMDUgNDJ0LTQyIDEwM3pNMTI5IDExMDhxMCAzNDYgMjk4IDM4MGwxNSAtNTVxLTQ5IC0xOCAtOTYuNSAtNTl0LTQ3LjUgLTg1cTAgLTU2IDM0IC02NnE0NSAtMTMgNjcuNSAtNDQuNXQyMi41IC03MC41CnEwIC01OSAtNDEuNSAtMTAydC0xMDQuNSAtNDN0LTEwNSA0MnQtNDIgMTAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJxdW90ZWRibHJpZ2h0IiB1bmljb2RlPSImI3gyMDFkOyIgCmQ9Ik00MTkgMTI4OHEwIC0zNDYgLTI5OCAtMzgwbC0xNSA1NXE0OSAxOCA5Ni41IDU5dDQ3LjUgODVxMCA1NiAtMzQgNjZxLTQ1IDEzIC02Ny41IDQ0LjV0LTIyLjUgNzAuNXEwIDU5IDQxLjUgMTAydDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3pNODQ4IDEyODdxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMgp0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJxdW90ZWRibGJhc2UiIHVuaWNvZGU9IiYjeDIwMWU7IiAKZD0iTTM5NSAyNzdxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6TTgyNCAyNzZxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMgp0MTA0LjUgNDN0MTA1IC00MnQ0MiAtMTAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYWdnZXIiIHVuaWNvZGU9IiYjeDIwMjA7IiAKZD0iTTgzMiAxMDI0di0xNDloLTI5NnYtMTI2MGgtMTUwdjEyNjBoLTI5NnYxNDloMjk2djQwMWgxNTB2LTQwMWgyOTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRhZ2dlcmRibCIgdW5pY29kZT0iJiN4MjAyMTsiIApkPSJNODMyIDEwMjR2LTE0OWgtMjk2di03MTFoMjk2di0xNTBoLTI5NnYtMzk5aC0xNTB2Mzk5aC0yOTZ2MTUwaDI5NnY3MTFoLTI5NnYxNDloMjk2djQwMWgxNTB2LTQwMWgyOTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJ1bGxldCIgdW5pY29kZT0iJiN4MjAyMjsiIApkPSJNNjUwIDY2OXEwIC03NSAtNTcgLTEzNi41dC0xMzMgLTYxLjV0LTEzMi41IDYyLjV0LTU2LjUgMTM1LjVxMCA3NiA1NyAxMzUuNXQxMzIgNTkuNXQxMzIuNSAtNTkuNXQ1Ny41IC0xMzUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZWxsaXBzaXMiIHVuaWNvZGU9IiYjeDIwMjY7IiAKZD0iTTg0NSAxMTNxMCAtMzIgLTIyLjUgLTU2LjV0LTU0LjUgLTI0LjVxLTMxIDAgLTUzLjUgMjR0LTIyLjUgNTdxMCAzMiAyMiA1NnQ1NCAyNHEzMyAwIDU1IC0yNC41dDIyIC01NS41ek0yMjkgMTEzcTAgLTMyIC0yMiAtNTYuNXQtNTQgLTI0LjV0LTU0IDI0dC0yMiA1N3EwIDMyIDIyIDU2dDU0IDI0dDU0IC0yNC41dDIyIC01NS41ek01MzcgMTEzcTAgLTMyIC0yMi41IC01Ni41dC01NC41IC0yNC41cS0zMSAwIC01MyAyNHQtMjIgNTcKcTAgMzIgMjEuNSA1NnQ1My41IDI0cTMzIDAgNTUgLTI0LjV0MjIgLTU1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1pbnV0ZSIgdW5pY29kZT0iJiN4MjAzMjsiIApkPSJNNjE2IDEzNjNxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNlY29uZCIgdW5pY29kZT0iJiN4MjAzMzsiIApkPSJNNDE5IDEyODhxMCAtMzQ2IC0yOTggLTM4MGwtMTUgNTVxNDkgMTggOTYuNSA1OXQ0Ny41IDg1cTAgNTYgLTM0IDY2cS00NSAxMyAtNjcuNSA0NC41dC0yMi41IDcwLjVxMCA1OSA0MS41IDEwMnQxMDQuNSA0M3QxMDUgLTQydDQyIC0xMDN6TTg0OCAxMjg3cTAgLTM0NiAtMjk4IC0zODBsLTE1IDU1cTQ5IDE4IDk2LjUgNTl0NDcuNSA4NXEwIDU2IC0zNCA2NnEtNDUgMTMgLTY3LjUgNDQuNXQtMjIuNSA3MC41cTAgNTkgNDEuNSAxMDIKdDEwNC41IDQzdDEwNSAtNDJ0NDIgLTEwM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ3VpbHNpbmdsbGVmdCIgdW5pY29kZT0iJiN4MjAzOTsiIApkPSJNOTAgNjM2bDc0MiA2MTF2LTE5NWwtNTUwIC00NTJsNTUwIC00NTJ2LTE5NWwtNzQyIDYxMXY3MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ3VpbHNpbmdscmlnaHQiIHVuaWNvZGU9IiYjeDIwM2E7IiAKZD0iTTkwIDEyNDdsNzQyIC02MTF2LTcybC03NDIgLTYxMXYxOTVsNTUwIDQ1MmwtNTUwIDQ1MnYxOTV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZyYWN0aW9uIiB1bmljb2RlPSImI3gyMDQ0OyIgCmQ9Ik02NzAgMTQ1MmwxNDAgLTUybC01NTggLTE0NTJsLTE0MCA1MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pMjA3NCIgdW5pY29kZT0iJiN4MjA3NDsiIApkPSJNNTI2IDExNzdsLTE5OCAtMjYzaDE5OHYyNjN6TTExOCA4ODRsNDA4IDU0MWgxNTB2LTUxMWgxMTZ2LTE1MGgtMTE2di0yMjBoLTE1MHYyMjBoLTQwOHYxMjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im5zdXBlcmlvciIgdW5pY29kZT0iJiN4MjA3ZjsiIApkPSJNNDUzIDEyNzRxLTQyIDAgLTc2LjUgLTQ3LjV0LTUxIC0xMDR0LTE2LjUgLTk4LjV2LTQ4MGgtMTUwdjg4MGgxNTB2LTU3cTMxIDMzIDYzIDQ1dDgxIDEyaDE2cTYwIDAgMTA4IC0xMi41dDc4LjUgLTMxdDUyIC00N3QzMiAtNTJ0MTYuNSAtNTYuNXQ2LjUgLTQ5LjV0MC41IC00MC41di01OTFoLTE1MHY1OTFxMCA2NiAtMzAgMTAyLjV0LTExNCAzNi41aC0xNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZXVybyIgdW5pY29kZT0iJiN4MjBhYzsiIApkPSJNOTAgODMydjE1MGgxMDBxNTIgNDQzIDM1NCA0NDNxOTcgMCAxNzYgLTM5dDEyMSAtMTE5bC0xMzIgLTcwcS00MSA3OCAtMTY1IDc4cS04NCAwIC0xMzMgLTcwdC02OCAtMjIzaDQwMHYtMTUwaC00MTFsLTEgLTE5MmgyODJ2LTE1MGgtMjcycTM3IC0zNjUgMjAzIC0zNjVxMTIzIDAgMTY0IDgxbDEzNCAtNjhxLTQyIC04MiAtMTIxLjUgLTEyMi41dC0xNzYuNSAtNDAuNXEtMzAzIDAgLTM1NCA1MTVoLTEzMHYxNTBoMTIxbDEgMTkyaC05MnoKIiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im51bWVybyIgdW5pY29kZT0iJiN4MjExNjsiIApkPSJNNzA5IDYyMnEzMiAwIDUwIDcyLjV0MTggMjA5LjVxMCAxMzYgLTE4IDIwNy41dC01MCA3MS41dC01MCAtNzF0LTE4IC0yMDh0MTggLTIwOS41dDUwIC03Mi41ek05MDcgOTA0cTAgLTY0IC0zLjUgLTExN3QtMTUuNSAtMTE0LjV0LTMzIC0xMDMuNXQtNTggLTcwdC04OCAtMjh0LTg4IDI4dC01OCA3MHQtMzMgMTAzLjV0LTE1LjUgMTE0LjV0LTMuNSAxMTdxMCA0MjkgMTk4IDQyOXE0OSAwIDg1LjUgLTI1LjV0NTcuNSAtNjV0MzQgLTk4CnQxNyAtMTE1dDQgLTEyNS41ek0xNSAwdjE0MDBoMTU0bDE3NCAtODA1djgwNWgxNTB2LTE0MDBoLTE1NGwtMTc0IDgwNXYtODA1aC0xNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRyYWRlbWFyayIgdW5pY29kZT0iJiN4MjEyMjsiIApkPSJNNDEzIDQ2NnY3ODRoLTEwMnYtNzgxaC0xNTB2NzgxaC0xMjV2MTUwaDM3N2gxNTJsOTYgLTQzNmw5NyA0MzZoMTUxbC0xIC05MzRoLTE1MHYyNDJsLTQxIC0xODloLTExMmwtNDIgMTkydi0yNDVoLTE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXJyb3dsZWZ0IiB1bmljb2RlPSImI3gyMTkwOyIgCmQ9Ik04NzIgNjgwdi0xNjBoLTU4NWwyMzAgLTIyM2wtMTEyIC0xMTRsLTM1NSAzNDR2MTQ2bDM1NSAzNDRsMTEyIC0xMTRsLTIzMCAtMjIzaDU4NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idXBhcnJvdyIgdW5pY29kZT0iJiN4MjE5MTsiIApkPSJNNTQxIDIwOWgtMTYwdjU4NWwtMjIzIC0yMzBsLTExNCAxMTJsMzU3IDM2OGgxMjBsMzU3IC0zNjhsLTExNCAtMTEybC0yMjMgMjMwdi01ODV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFycm93cmlnaHQiIHVuaWNvZGU9IiYjeDIxOTI7IiAKZD0iTTUwIDUyMHYxNjBoNTg1bC0yMzAgMjIzbDExMiAxMTRsMzU1IC0zNDR2LTE0NmwtMzU1IC0zNDRsLTExMiAxMTRsMjMwIDIyM2gtNTg1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkb3duYXJyb3ciIHVuaWNvZGU9IiYjeDIxOTM7IiAKZD0iTTM4MSA5OTFoMTYwdi01ODVsMjIzIDIzMGwxMTQgLTExMmwtMzU3IC0zNjhoLTEyMGwtMzU3IDM2OGwxMTQgMTEybDIyMyAtMjMwdjU4NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXJyb3dib3RoIiB1bmljb2RlPSImI3gyMTk0OyIgCmQ9Ik05MjIgNTM2bC0zMTEgLTM0OWwtMTIwIDEwNmwyMDMgMjI3aC00NjZsMjAzIC0yMjdsLTEyMCAtMTA2bC0zMTEgMzQ5djEyOGwzMTEgMzQ5bDEyMCAtMTA2bC0yMDMgLTIyN2g0NjZsLTIwMyAyMjdsMTIwIDEwNmwzMTEgLTM0OXYtMTI4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhcnJvd2JvdGh2IiB1bmljb2RlPSImI3gyMTk1OyIgCmQ9Ik00MDAgODdsLTM1NiAzNjdsMTE0IDExMmwyMjMgLTIzMHY1MjhsLTIyMyAtMjMwbC0xMTQgMTEybDM1NiAzNjdoMTIybDM1NiAtMzY3bC0xMTQgLTExMmwtMjIzIDIzMHYtNTI4bDIyMyAyMzBsMTE0IC0xMTJsLTM1NiAtMzY3aC0xMjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVwZG93bmFycm93YmFyIiB1bmljb2RlPSImI3gyMWE4OyIgCmQ9Ik04NzIgMTM4di0xNjBoLTgyMnYxNjBoMzAwbC0zMDYgMzE2bDExNCAxMTJsMjIzIC0yMzB2NTI4bC0yMjMgLTIzMGwtMTE0IDExMmwzNTYgMzY3aDEyMmwzNTYgLTM2N2wtMTE0IC0xMTJsLTIyMyAyMzB2LTUyOGwyMjMgMjMwbDExNCAtMTEybC0zMDYgLTMxNmgzMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1pbnVzIiB1bmljb2RlPSImI3gyMjEyOyIgCmQ9Ik04NzIgNjc1di0xNTBoLTgyMnYxNTBoODIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJidWxsZXRvcGVyYXRvciIgdW5pY29kZT0iJiN4MjIxOTsiIApkPSJNNjA2IDc0N3EwIC02MCAtNDEgLTEwM3QtMTA1IC00M3EtNjIgMCAtMTA0IDQzdC00MiAxMDNxMCA1OSA0MS41IDEwM3QxMDQuNSA0NHQxMDQuNSAtNDMuNXQ0MS41IC0xMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icmFkaWNhbCIgdW5pY29kZT0iJiN4MjIxYTsiIApkPSJNNDQxIC0yNWwtMjQ1IDkzMGgtMTQ4djE1MGgyNjRsMTg2IC03MDZsMjM1IDEyODRoMTUzbC0zMDQgLTE2NThoLTE0MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaW5maW5pdHkiIHVuaWNvZGU9IiYjeDIyMWU7IiAKZD0iTTUzNiA2MThxMCAtNTYgMjcuNSAtMTAzLjV0ODIuNSAtNDcuNXE0OCAwIDc2LjUgNDYuNXQyOC41IDEwOC41cTAgNjAgLTI3LjUgMTAzdC03Ny41IDQzcS00OCAwIC03OSAtNDl0LTMxIC0xMDF6TTIxIDYxOHEwIDc3IDI4LjUgMTQ0dDg4IDExMS41dDEzOC41IDQ0LjVxMTExIDAgMTg2IC05MHE3NSA5MCAxODQgOTBxMTEzIDAgMTg0IC04NS41dDcxIC0yMTQuNXEwIC01MSAtMTUuNSAtMTAydC00NSAtOTYuNXQtODAgLTc0CnQtMTE0LjUgLTI4LjVxLTExNCAwIC0xODUgODRxLTcxIC04NCAtMTg1IC04NHEtMTEyIDAgLTE4My41IDkwLjV0LTcxLjUgMjEwLjV6TTE3MSA2MThxMCAtNjIgMjYgLTEwNi41dDc5IC00NC41dDgxLjUgNDUuNXQyOC41IDEwNS41cTAgNTQgLTMwIDEwMnQtODAgNDhxLTQ1IDAgLTc1IC00Ni41dC0zMCAtMTAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImludGVyc2VjdGlvbiIgdW5pY29kZT0iJiN4MjIyOTsiIApkPSJNMTA3IDEwNjNxMCA5OCA0NS41IDE4NC41dDEyNS41IDEzOS41dDE3NCA1M2gxOHExNDQgMCAyNDQuNSAtMTEydDEwMC41IC0yNjV2LTEwNjNoLTE1MHYxMDYzcTAgOTEgLTU3IDE1OXQtMTM4IDY4aC0xOHEtODAgMCAtMTM3LjUgLTY5LjV0LTU3LjUgLTE1Ny41di0xMDYzaC0xNTB2MTA2M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWxtb3N0ZXF1YWwiIHVuaWNvZGU9IiYjeDIyNDg7IiAKZD0iTTY3IDgwOXEyMSA2MSA0OS41IDEwNS41dDU1IDY4dDU3IDM3LjV0NTAgMTd0MzguNSAzaDE1cTcyIDAgMTM4IC02Nmw5MyAtOTJxNiAtNiAxOS41IC0xMnQxNy41IC02aDE1cTI3IDAgNTQgMzd0NDQgODdsMTQyIC00NnEtMTEgLTMyIC0yOSAtNjZ0LTQ3LjUgLTczdC03NSAtNjR0LTk4LjUgLTI1aC0xNXEtNzAgMCAtMTMzIDYybC05MyA5MnEtNiA2IC0yMS41IDE0dC0yMC41IDhoLTE1cS01MyAwIC05NiAtMTIzek02NyAzNjEKcTIxIDYxIDQ5LjUgMTA1LjV0NTUgNjh0NTcgMzcuNXQ1MCAxN3QzOC41IDNoMTVxNzIgMCAxMzggLTY2bDkzIC05MnE2IC02IDE5LjUgLTEydDE3LjUgLTZoMTVxMzAgMCA1NS41IDM2dDQyLjUgODhsMTQyIC00NnEtNzggLTIyOCAtMjUwIC0yMjhoLTE1cS03MCAwIC0xMzMgNjJsLTkzIDkycS02IDYgLTIxLjUgMTR0LTIwLjUgOGgtMTVxLTUzIDAgLTk2IC0xMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVxdWl2YWxlbmNlIiB1bmljb2RlPSImI3gyMjYxOyIgCmQ9Ik04NzIgOTk1di0xNTBoLTgyMnYxNTBoODIyek04NzIgNjc1di0xNTBoLTgyMnYxNTBoODIyek04NzIgMzUzdi0xNTBoLTgyMnYxNTBoODIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsZXNzZXF1YWwiIHVuaWNvZGU9IiYjeDIyNjQ7IiAKZD0iTTkwIDkxN2w3NDIgMzYwdi0xNjZsLTUyNCAtMjU1bDUyNCAtMjc3di0xNjlsLTc0MiAzOTJ2MTE1ek05MCA2NDNsNzQyIC0zOTB2LTE2OWwtNzQyIDM5MHYxNjl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImdyZWF0ZXJlcXVhbCIgdW5pY29kZT0iJiN4MjI2NTsiIApkPSJNOTAgMTExMXYxNjZsNzQyIC0zNjB2LTExNWwtNzQyIC0zOTJ2MTY5bDUyNCAyNzd6TTkwIDg0djE2OWw3NDIgMzkwdi0xNjl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJldmxvZ2ljYWxub3QiIHVuaWNvZGU9IiYjeDIzMTA7IiAKZD0iTTI1NyA1MjV2LTMxMWgtMTUwdjQ2MWg3NjV2LTE1MGgtNjE1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpbnRlZ3JhbHRwIiB1bmljb2RlPSImI3gyMzIwOyIgCmQ9Ik0zODEgMTQxNHEwIDg5IDU5IDE1MS41dDE2MCA2Mi41aDEwcTkzIDAgMTUxLjUgLTYxdDU4LjUgLTE1M3YtMTA2aC0xNjB2MTA2cTAgNTQgLTUwIDU0aC0xMHEtNTkgMCAtNTkgLTU0di0yMDI5aC0xNjB2MjAyOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaW50ZWdyYWxidCIgdW5pY29kZT0iJiN4MjMyMTsiIApkPSJNNTQxIC0zMjRxMCAtODkgLTU5IC0xNTEuNXQtMTYwIC02Mi41aC0xMHEtOTMgMCAtMTUxLjUgNjF0LTU4LjUgMTUzdjEwNmgxNjB2LTEwNnEwIC01NCA1MCAtNTRoMTBxNTkgMCA1OSA1NHYyMDk5aDE2MHYtMjA5OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3BhY2VvcGVuYm94IiB1bmljb2RlPSImI3gyNDIzOyIgCmQ9Ik04MTUgMTI0di0yOTFoLTcwOHYyOTFoMTUwdi0xNDFoNDA4djE0MWgxNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imx0aG9yaXpmb3JtIiB1bmljb2RlPSImI3gyNTAwOyIgCmQ9Ik0wIDQ0M3YxNjBoOTIydi0xNjBoLTkyMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibHR2ZXJ0Zm9ybSIgdW5pY29kZT0iJiN4MjUwMjsiIApkPSJNNTQxIC02MTVoLTE2MHYyMzkwaDE2MHYtMjM5MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icmlnaHRhbmdsZW53IiB1bmljb2RlPSImI3gyNTBjOyIgCmQ9Ik0zODEgLTYxNXYxMjE4aDU0MXYtMTYwaC0zODF2LTEwNThoLTE2MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icmlnaHRhbmdsZW5lIiB1bmljb2RlPSImI3gyNTEwOyIgCmQ9Ik0zODEgNDQzaC0zODF2MTYwaDU0MXYtMTIxOGgtMTYwdjEwNTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJpZ2h0YW5nbGVzdyIgdW5pY29kZT0iJiN4MjUxNDsiIApkPSJNNTQxIDYwM2gzODF2LTE2MGgtNTQxdjEzMzJoMTYwdi0xMTcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyaWdodGFuZ2xlc2UiIHVuaWNvZGU9IiYjeDI1MTg7IiAKZD0iTTU0MSAxNzc1di0xMzMyaC01NDF2MTYwaDM4MXYxMTcyaDE2MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibHR2ZXJ0cmlnaHRmb3JtIiB1bmljb2RlPSImI3gyNTFjOyIgCmQ9Ik01NDEgLTYxNWgtMTYwdjIzOTBoMTYwdi0xMTcyaDM4MXYtMTYwaC0zODF2LTEwNTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imx0dmVydGxlZnRmb3JtIiB1bmljb2RlPSImI3gyNTI0OyIgCmQ9Ik0wIDQ0M3YxNjBoMzgxdjExNzJoMTYwdi0yMzkwaC0xNjB2MTA1OGgtMzgxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsdGRuaG9yaXpmb3JtIiB1bmljb2RlPSImI3gyNTJjOyIgCmQ9Ik0wIDQ0M3YxNjBoOTIydi0xNjBoLTM4MXYtMTA1OGgtMTYwdjEwNThoLTM4MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibHR1cGhvcml6Zm9ybSIgdW5pY29kZT0iJiN4MjUzNDsiIApkPSJNMCA0NDN2MTYwaDM4MXYxMTcyaDE2MHYtMTE3MmgzODF2LTE2MGgtOTIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsdHZlcnRob3JpemZvcm0iIHVuaWNvZGU9IiYjeDI1M2M7IiAKZD0iTTAgNDQzdjE2MGgzODF2MTE3MmgxNjB2LTExNzJoMzgxdi0xNjBoLTM4MXYtMTA1OGgtMTYwdjEwNThoLTM4MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaG9yaXpkYmxiYXIiIHVuaWNvZGU9IiYjeDI1NTA7IiAKZD0iTTAgNjAzdjE2MGg5MjJ2LTE2MGgtOTIyek0wIDI4M3YxNjBoOTIydi0xNjBoLTkyMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idmVydGRibGJhciIgdW5pY29kZT0iJiN4MjU1MTsiIApkPSJNNzAxIC02MTVoLTE2MHYyMzkwaDE2MHYtMjM5MHpNMzgxIC02MTVoLTE2MHYyMzkwaDE2MHYtMjM5MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZG5ydGRibGZvcm0iIHVuaWNvZGU9IiYjeDI1NTI7IiAKZD0iTTU0MSAyODN2LTg5OGgtMTYwdjEzNzhoNTQxdi0xNjBoLTM4MXYtMTYwaDM4MXYtMTYwaC0zODF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRuZGJscnRmb3JtIiB1bmljb2RlPSImI3gyNTUzOyIgCmQ9Ik03MDEgLTYxNWgtMTYwdjEwNThoLTE2MHYtMTA1OGgtMTYwdjEyMThoNzAxdi0xNjBoLTIyMXYtMTA1OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGJsZG5ydGZvcm0iIHVuaWNvZGU9IiYjeDI1NTQ7IiAKZD0iTTM4MSA2MDN2LTEyMThoLTE2MHYxMzc4aDcwMXYtMTYwaC01NDF6TTcwMSAyODN2LTg5OGgtMTYwdjEwNThoMzgxdi0xNjBoLTIyMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZG5sZWZ0ZGJsZm9ybSIgdW5pY29kZT0iJiN4MjU1NTsiIApkPSJNMCA3NjNoNTQxdi0xMzc4aC0xNjB2ODk4aC0zODF2MTYwaDM4MXYxNjBoLTM4MXYxNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRuZGJsbGVmdGZvcm0iIHVuaWNvZGU9IiYjeDI1NTY7IiAKZD0iTTM4MSAtNjE1aC0xNjB2MTA1OGgtMjIxdjE2MGg3MDF2LTEyMThoLTE2MHYxMDU4aC0xNjB2LTEwNTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRibGRubGVmdGZvcm0iIHVuaWNvZGU9IiYjeDI1NTc7IiAKZD0iTTAgNzYzaDcwMXYtMTM3OGgtMTYwdjEyMThoLTU0MXYxNjB6TTAgNDQzaDM4MXYtMTA1OGgtMTYwdjg5OGgtMjIxdjE2MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idXBydGRibGZvcm0iIHVuaWNvZGU9IiYjeDI1NTg7IiAKZD0iTTkyMiAyODNoLTU0MXYxNDkyaDE2MHYtMTAxMmgzODF2LTE2MGgtMzgxdi0xNjBoMzgxdi0xNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVwZGJscnRmb3JtIiB1bmljb2RlPSImI3gyNTU5OyIgCmQ9Ik03MDEgNjAzaDIyMXYtMTYwaC03MDF2MTMzMmgxNjB2LTExNzJoMTYwdjExNzJoMTYwdi0xMTcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYmx1cHJ0Zm9ybSIgdW5pY29kZT0iJiN4MjU1YTsiIApkPSJNOTIyIDYwM2gtMzgxdjExNzJoMTYwdi0xMDEyaDIyMXYtMTYwek05MjIgMjgzaC03MDF2MTQ5MmgxNjB2LTEzMzJoNTQxdi0xNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVwbGVmdGRibGZvcm0iIHVuaWNvZGU9IiYjeDI1NWI7IiAKZD0iTTAgNjAzdjE2MGgzODF2MTAxMmgxNjB2LTE0OTJoLTU0MXYxNjBoMzgxdjE2MGgtMzgxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1cGRibGxlZnRmb3JtIiB1bmljb2RlPSImI3gyNTVjOyIgCmQ9Ik03MDEgMTc3NXYtMTMzMmgtNzAxdjE2MGgyMjF2MTE3MmgxNjB2LTExNzJoMTYwdjExNzJoMTYweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYmx1cGxlZnRmb3JtIiB1bmljb2RlPSImI3gyNTVkOyIgCmQ9Ik0yMjEgNzYzdjEwMTJoMTYwdi0xMTcyaC0zODF2MTYwaDIyMXpNNTQxIDQ0M3YxMzMyaDE2MHYtMTQ5MmgtNzAxdjE2MGg1NDF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InZlcnRydGRibGZvcm0iIHVuaWNvZGU9IiYjeDI1NWU7IiAKZD0iTTU0MSAtNjE1aC0xNjB2MjM5MGgxNjB2LTEwMTJoMzgxdi0xNjBoLTM4MXYtMTYwaDM4MXYtMTYwaC0zODF2LTg5OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idmVydGRibHJ0Zm9ybSIgdW5pY29kZT0iJiN4MjU1ZjsiIApkPSJNMzgxIDE3NzV2LTIzOTBoLTE2MHYyMzkwaDE2MHpNNTQxIDE3NzVoMTYwdi0xMTcyaDIyMXYtMTYwaC0yMjF2LTEwNThoLTE2MHYyMzkweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYmx2ZXJ0cnRmb3JtIiB1bmljb2RlPSImI3gyNTYwOyIgCmQ9Ik0zODEgLTYxNWgtMTYwdjIzOTBoMTYwdi0yMzkwek05MjIgNjAzaC0zODF2MTE3MmgxNjB2LTEwMTJoMjIxdi0xNjB6TTcwMSAyODN2LTg5OGgtMTYwdjEwNThoMzgxdi0xNjBoLTIyMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idmVydGxlZnRkYmxmb3JtIiB1bmljb2RlPSImI3gyNTYxOyIgCmQ9Ik01NDEgLTYxNWgtMTYwdjg5OGgtMzgxdjE2MGgzODF2MTYwaC0zODF2MTYwaDM4MXYxMDEyaDE2MHYtMjM5MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idmVydGRibGxlZnRmb3JtIiB1bmljb2RlPSImI3gyNTYyOyIgCmQ9Ik0wIDQ0M3YxNjBoMjIxdjExNzJoMTYwdi0yMzkwaC0xNjB2MTA1OGgtMjIxek03MDEgLTYxNWgtMTYwdjIzOTBoMTYwdi0yMzkweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYmx2ZXJ0bGVmdGZvcm0iIHVuaWNvZGU9IiYjeDI1NjM7IiAKZD0iTTcwMSAtNjE1aC0xNjB2MjM5MGgxNjB2LTIzOTB6TTIyMSA3NjN2MTAxMmgxNjB2LTExNzJoLTM4MXYxNjBoMjIxek0wIDQ0M2gzODF2LTEwNThoLTE2MHY4OThoLTIyMXYxNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRuaG9yaXpkYmxmb3JtIiB1bmljb2RlPSImI3gyNTY0OyIgCmQ9Ik01NDEgLTYxNWgtMTYwdjg5OGgtMzgxdjE2MGg5MjJ2LTE2MGgtMzgxdi04OTh6TTAgNjAzdjE2MGg5MjJ2LTE2MGgtOTIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkbmRibGhvcml6Zm9ybSIgdW5pY29kZT0iJiN4MjU2NTsiIApkPSJNMCA0NDN2MTYwaDkyMnYtMTYwaC0yMjF2LTEwNThoLTE2MHYxMDU4aC0xNjB2LTEwNThoLTE2MHYxMDU4aC0yMjF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRibGRuaG9yaXpmb3JtIiB1bmljb2RlPSImI3gyNTY2OyIgCmQ9Ik0wIDYwM3YxNjBoOTIydi0xNjBoLTkyMnpNMCA0NDNoMzgxdi0xMDU4aC0xNjB2ODk4aC0yMjF2MTYwek03MDEgMjgzdi04OThoLTE2MHYxMDU4aDM4MXYtMTYwaC0yMjF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVwaG9yaXpkYmxmb3JtIiB1bmljb2RlPSImI3gyNTY3OyIgCmQ9Ik0wIDYwM3YxNjBoMzgxdjEwMTJoMTYwdi0xMDEyaDM4MXYtMTYwaC05MjJ6TTAgMjgzdjE2MGg5MjJ2LTE2MGgtOTIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1cGRibGhvcml6Zm9ybSIgdW5pY29kZT0iJiN4MjU2ODsiIApkPSJNMCA0NDN2MTYwaDIyMXYxMTcyaDE2MHYtMTE3MmgxNjB2MTE3MmgxNjB2LTExNzJoMjIxdi0xNjBoLTkyMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGJsdXBob3JpemZvcm0iIHVuaWNvZGU9IiYjeDI1Njk7IiAKZD0iTTIyMSA3NjN2MTAxMmgxNjB2LTExNzJoLTM4MXYxNjBoMjIxek05MjIgNjAzaC0zODF2MTE3MmgxNjB2LTEwMTJoMjIxdi0xNjB6TTAgMjgzdjE2MGg5MjJ2LTE2MGgtOTIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ2ZXJ0aG9yaXpkYmxmb3JtIiB1bmljb2RlPSImI3gyNTZhOyIgCmQ9Ik0wIDYwM3YxNjBoMzgxdjEwMTJoMTYwdi0xMDEyaDM4MXYtMTYwaC05MjJ6TTAgNDQzaDkyMnYtMTYwaC0zODF2LTg5OGgtMTYwdjg5OGgtMzgxdjE2MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idmVydGRibGhvcml6Zm9ybSIgdW5pY29kZT0iJiN4MjU2YjsiIApkPSJNNTQxIDE3NzVoMTYwdi0xMTcyaDIyMXYtMTYwaC0yMjF2LTEwNThoLTE2MHYyMzkwek0zODEgLTYxNWgtMTYwdjEwNThoLTIyMXYxNjBoMjIxdjExNzJoMTYwdi0yMzkweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkYmx2ZXJ0aG9yaXpmb3JtIiB1bmljb2RlPSImI3gyNTZjOyIgCmQ9Ik0yMjEgNzYzdjEwMTJoMTYwdi0xMTcyaC0zODF2MTYwaDIyMXpNOTIyIDYwM2gtMzgxdjExNzJoMTYwdi0xMDEyaDIyMXYtMTYwek0wIDQ0M2gzODF2LTEwNThoLTE2MHY4OThoLTIyMXYxNjB6TTcwMSAyODN2LTg5OGgtMTYwdjEwNThoMzgxdi0xNjBoLTIyMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idXBibG9jayIgdW5pY29kZT0iJiN4MjU4MDsiIApkPSJNOTIyIDUyM2gtOTIydjEyNTJoOTIydi0xMjUyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkbmJsb2NrIiB1bmljb2RlPSImI3gyNTg0OyIgCmQ9Ik05MjIgLTYxNWgtOTIydjExMzhoOTIydi0xMTM4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJibG9jayIgdW5pY29kZT0iJiN4MjU4ODsiIApkPSJNMCAtNjE1djIzOTBoOTIydi0yMzkwaC05MjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxmYmxvY2siIHVuaWNvZGU9IiYjeDI1OGM7IiAKZD0iTTAgLTYxNXYyMzkwaDQ2MXYtMjM5MGgtNDYxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJydGJsb2NrIiB1bmljb2RlPSImI3gyNTkwOyIgCmQ9Ik00NjEgLTYxNXYyMzkwaDQ2MXYtMjM5MGgtNDYxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzaGFkZWxpZ2h0IiB1bmljb2RlPSImI3gyNTkxOyIgCmQ9Ik0wIDEzNzhoNzd2LTEwMGgtNzd2MTAwek0zMDcgMTM3OGg3OHYtMTAwaC03OHYxMDB6TTYxNiAxMzc4aDc3di0xMDBoLTc3djEwMHpNMTUzIDExNzloNzd2LTk5aC03N3Y5OXpNNDYxIDExNzloNzl2LTk5aC03OXY5OXpNNzY5IDExNzloNzd2LTk5aC03N3Y5OXpNNjE2IDk4MGg3N3YtOTloLTc3djk5ek0zMDcgOTgwaDc4di05OWgtNzh2OTl6TTAgOTgwaDc3di05OWgtNzd2OTl6TTc2OSA3ODFoNzd2LTEwMGgtNzd2MTAwek00NjEgNzgxaDc5CnYtMTAwaC03OXYxMDB6TTE1MyA3ODFoNzd2LTEwMGgtNzd2MTAwek0wIDU4MWg3N3YtOTloLTc3djk5ek0zMDcgNTgxaDc4di05OWgtNzh2OTl6TTYxNiA1ODFoNzd2LTk5aC03N3Y5OXpNNzY5IDM4Mmg3N3YtOTloLTc3djk5ek00NjEgMzgyaDc5di05OWgtNzl2OTl6TTE1MyAzODJoNzd2LTk5aC03N3Y5OXpNMCAxODNoNzd2LTEwMGgtNzd2MTAwek0zMDcgMTgzaDc4di0xMDBoLTc4djEwMHpNNjE2IDE4M2g3N3YtMTAwaC03N3YxMDB6Ck0xNTMgLTE2aDc3di05OWgtNzd2OTl6TTQ2MSAtMTZoNzl2LTk5aC03OXY5OXpNNzY5IC0xNmg3N3YtOTloLTc3djk5ek02MTYgLTIxNWg3N3YtMTAwaC03N3YxMDB6TTMwNyAtMjE1aDc4di0xMDBoLTc4djEwMHpNMCAtMjE1aDc3di0xMDBoLTc3djEwMHpNMTUzIC00MTRoNzd2LTEwMGgtNzd2MTAwek00NjEgLTQxNGg3OXYtMTAwaC03OXYxMDB6TTc2OSAtNDE0aDc3di0xMDBoLTc3djEwMHpNMTUzIDE1NzdoNzd2LTEwMGgtNzd2MTAwegpNNDYxIDE1NzdoNzl2LTEwMGgtNzl2MTAwek03NjkgMTU3N2g3N3YtMTAwaC03N3YxMDB6TTAgMTc3NWg3N3YtOThoLTc3djk4ek0zMDcgMTc3NWg3OHYtOThoLTc4djk4ek02MTYgMTc3NWg3N3YtOThoLTc3djk4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzaGFkZW1lZGl1bSIgdW5pY29kZT0iJiN4MjU5MjsiIApkPSJNNzcgMTM3OGg3NnYtMTAwaC03NnYxMDB6TTIzMCAxMzc4aDc3di0xMDBoLTc3djEwMHpNMzg0IDEzNzhoNzd2LTEwMGgtNzd2MTAwek01MzkgMTM3OGg3N3YtMTAwaC03N3YxMDB6TTY5MiAxMzc4aDc3di0xMDBoLTc3djEwMHpNODQ2IDEzNzhoNzZ2LTEwMGgtNzZ2MTAwek0wIDExNzloNzd2LTk5aC03N3Y5OXpNMTUzIDExNzloNzd2LTk5aC03N3Y5OXpNMzA3IDExNzloNzd2LTk5aC03N3Y5OXpNNDYxIDExNzloNzh2LTk5aC03OHY5OXoKTTYxNiAxMTc5aDc2di05OWgtNzZ2OTl6TTc2OSAxMTc5aDc3di05OWgtNzd2OTl6TTc3IDk4MGg3NnYtOTloLTc2djk5ek0yMzAgOTgwaDc3di05OWgtNzd2OTl6TTM4NCA5ODBoNzd2LTk5aC03N3Y5OXpNNTM5IDk4MGg3N3YtOTloLTc3djk5ek02OTIgOTgwaDc3di05OWgtNzd2OTl6TTg0NiA5ODBoNzZ2LTk5aC03NnY5OXpNMCA3ODFoNzd2LTEwMGgtNzd2MTAwek0xNTMgNzgxaDc3di0xMDBoLTc3djEwMHpNMzA3IDc4MWg3N3YtMTAwaC03Nwp2MTAwek00NjEgNzgxaDc4di0xMDBoLTc4djEwMHpNNjE2IDc4MWg3NnYtMTAwaC03NnYxMDB6TTc2OSA3ODFoNzd2LTEwMGgtNzd2MTAwek03NyA1ODFoNzZ2LTk5aC03NnY5OXpNMjMwIDU4MWg3N3YtOTloLTc3djk5ek0zODQgNTgxaDc3di05OWgtNzd2OTl6TTUzOSA1ODFoNzd2LTk5aC03N3Y5OXpNNjkyIDU4MWg3N3YtOTloLTc3djk5ek04NDYgNTgxaDc2di05OWgtNzZ2OTl6TTAgMzgyaDc3di05OWgtNzd2OTl6TTMwNyAzODJoNzd2LTk5CmgtNzd2OTl6TTQ2MSAzODJoNzh2LTk5aC03OHY5OXpNNjE2IDM4Mmg3NnYtOTloLTc2djk5ek03NjkgMzgyaDc3di05OWgtNzd2OTl6TTE1MyAzODJoNzd2LTk5aC03N3Y5OXpNODQ2IDE4M2g3NnYtMTAwaC03NnYxMDB6TTY5MiAxODNoNzd2LTEwMGgtNzd2MTAwek01MzkgMTgzaDc3di0xMDBoLTc3djEwMHpNMzg0IDE4M2g3N3YtMTAwaC03N3YxMDB6TTIzMCAxODNoNzd2LTEwMGgtNzd2MTAwek03NyAxODNoNzZ2LTEwMGgtNzZ2MTAwegpNMCAtMTZoNzd2LTk5aC03N3Y5OXpNMTUzIC0xNmg3N3YtOTloLTc3djk5ek0zMDcgLTE2aDc3di05OWgtNzd2OTl6TTQ2MSAtMTZoNzh2LTk5aC03OHY5OXpNNjE2IC0xNmg3NnYtOTloLTc2djk5ek03NjkgLTE2aDc3di05OWgtNzd2OTl6TTg0NiAtMjE1aDc2di0xMDBoLTc2djEwMHpNNjkyIC0yMTVoNzd2LTEwMGgtNzd2MTAwek01MzkgLTIxNWg3N3YtMTAwaC03N3YxMDB6TTM4NCAtMjE1aDc3di0xMDBoLTc3djEwMHpNMjMwIC0yMTVoNzcKdi0xMDBoLTc3djEwMHpNNzcgLTIxNWg3NnYtMTAwaC03NnYxMDB6TTAgLTQxNGg3N3YtMTAwaC03N3YxMDB6TTE1MyAtNDE0aDc3di0xMDBoLTc3djEwMHpNMzA3IC00MTRoNzd2LTEwMGgtNzd2MTAwek00NjEgLTQxNGg3OHYtMTAwaC03OHYxMDB6TTYxNiAtNDE0aDc2di0xMDBoLTc2djEwMHpNNzY5IC00MTRoNzd2LTEwMGgtNzd2MTAwek0wIDE1NzdoNzd2LTEwMGgtNzd2MTAwek0xNTMgMTU3N2g3N3YtMTAwaC03N3YxMDB6TTMwNyAxNTc3Cmg3N3YtMTAwaC03N3YxMDB6TTQ2MSAxNTc3aDc4di0xMDBoLTc4djEwMHpNNjE2IDE1NzdoNzZ2LTEwMGgtNzZ2MTAwek03NjkgMTU3N2g3N3YtMTAwaC03N3YxMDB6TTc3IDE3NzVoNzZ2LTk4aC03NnY5OHpNMjMwIDE3NzVoNzd2LTk4aC03N3Y5OHpNMzg0IDE3NzVoNzd2LTk4aC03N3Y5OHpNNTM5IDE3NzVoNzd2LTk4aC03N3Y5OHpNNjkyIDE3NzVoNzd2LTk4aC03N3Y5OHpNODQ2IDE3NzVoNzZ2LTk4aC03NnY5OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2hhZGVkYXJrIiB1bmljb2RlPSImI3gyNTkzOyIgCmQ9Ik05MjIgMTU3N2gtNzZ2LTk5aDc2di0yOTloLTc2di05OWg3NnYtMjk5aC03NnYtMTAwaDc2di0yOTloLTc2di05OWg3NnYtMjk5aC03NnYtOTloNzZ2LTI5OWgtNzZ2LTEwMGg3NnYtMTAxaC05MjJ2MzAwaDc3djEwMGgtNzd2Mjk4aDc3djEwMGgtNzd2Mjk5aDc3djk5aC03N3YzMDBoNzd2OTloLTc3djI5OWg3N3Y5OWgtNzd2Mjk5aDc3djk4aDc2di05OGg3N3Y5OGg3N3YtOThoNzd2OThoNzd2LTk4aDc4djk4aDc3di05OGg3NnY5OGg3Nwp2LTk4aDc3djk4aDc2di0xOTh6TTc3IDExNzl2LTk5aDc2djk5aC03NnpNMjMwIDExNzl2LTk5aDc3djk5aC03N3pNMzg0IDExNzl2LTk5aDc3djk5aC03N3pNNTM5IDExNzl2LTk5aDc3djk5aC03N3pNNjkyIDExNzl2LTk5aDc3djk5aC03N3pNODQ2IDk4MGgtNzd2LTEwMGg3N3YxMDB6TTY5MiA5ODBoLTc2di0xMDBoNzZ2MTAwek01MzkgOTgwaC03OHYtMTAwaDc4djEwMHpNMzg0IDk4MGgtNzd2LTEwMGg3N3YxMDB6TTIzMCA5ODBoLTc3CnYtMTAwaDc3djEwMHpNNzcgNzgxdi0xMDBoNzZ2MTAwaC03NnpNMjMwIDc4MXYtMTAwaDc3djEwMGgtNzd6TTM4NCA3ODF2LTEwMGg3N3YxMDBoLTc3ek01MzkgNzgxdi0xMDBoNzd2MTAwaC03N3pNNjkyIDc4MXYtMTAwaDc3djEwMGgtNzd6TTIzMCA1ODFoLTc3di05OWg3N3Y5OXpNMzA3IDU4MXYtOTloNzd2OTloLTc3ek00NjEgNTgxdi05OWg3OHY5OWgtNzh6TTYxNiA1ODF2LTk5aDc2djk5aC03NnpNNzY5IDU4MXYtOTloNzd2OTloLTc3egpNNzcgMzgydi05OWg3NnY5OWgtNzZ6TTM4NCAzODJ2LTk5aDc3djk5aC03N3pNMzA3IDI4M3Y5OWgtNzd2LTk5aDc3ek01MzkgMzgydi05OWg3N3Y5OWgtNzd6TTY5MiAzODJ2LTk5aDc3djk5aC03N3pNODQ2IDg0djk5aC03N3YtOTloNzd6TTY5MiA4NHY5OWgtNzZ2LTk5aDc2ek01MzkgODR2OTloLTc4di05OWg3OHpNMzg0IDg0djk5aC03N3YtOTloNzd6TTIzMCA4NHY5OWgtNzd2LTk5aDc3ek03NyAtMTZ2LTk5aDc2djk5aC03NnpNMjMwIC0xNgp2LTk5aDc3djk5aC03N3pNMzg0IC0xNnYtOTloNzd2OTloLTc3ek01MzkgLTE2di05OWg3N3Y5OWgtNzd6TTY5MiAtMTZ2LTk5aDc3djk5aC03N3pNODQ2IC0zMTV2MTAwaC03N3YtMTAwaDc3ek02OTIgLTMxNXYxMDBoLTc2di0xMDBoNzZ6TTUzOSAtMzE1djEwMGgtNzh2LTEwMGg3OHpNMzg0IC0zMTV2MTAwaC03N3YtMTAwaDc3ek0yMzAgLTMxNXYxMDBoLTc3di0xMDBoNzd6TTc3IC00MTR2LTEwMGg3NnYxMDBoLTc2ek0yMzAgLTQxNHYtMTAwCmg3N3YxMDBoLTc3ek0zODQgLTQxNHYtMTAwaDc3djEwMGgtNzd6TTUzOSAtNDE0di0xMDBoNzd2MTAwaC03N3pNNjkyIC00MTR2LTEwMGg3N3YxMDBoLTc3ek04NDYgMTM3OGgtNzd2LTk5aDc3djk5ek02OTIgMTM3OGgtNzZ2LTk5aDc2djk5ek01MzkgMTM3OGgtNzh2LTk5aDc4djk5ek0zODQgMTM3OGgtNzd2LTk5aDc3djk5ek0yMzAgMTM3OGgtNzd2LTk5aDc3djk5ek03NjkgMTU3N2gtNzd2LTk5aDc3djk5ek02MTYgMTU3N2gtNzd2LTk5aDc3CnY5OXpNNDYxIDE1NzdoLTc3di05OWg3N3Y5OXpNMzA3IDE1NzdoLTc3di05OWg3N3Y5OXpNMTUzIDE1NzdoLTc2di05OWg3NnY5OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmxhY2tzcXVhcmUiIHVuaWNvZGU9IiYjeDI1YTA7IiAKZD0iTTAgMTEwOGg5MjJ2LTk5MmgtOTIydjk5MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0id2hpdGVzcXVhcmUiIHVuaWNvZGU9IiYjeDI1YTE7IiAKZD0iTTAgMTEwOWg5MjJ2LTk5M2gtOTIydjk5M3pNMTg3IDkxN3YtNjA5aDU0N3Y2MDloLTU0N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmxhY2tzbWFsbHNxdWFyZSIgdW5pY29kZT0iJiN4MjVhYTsiIApkPSJNNjk3IDQwMGgtNDczdjQ3M2g0NzN2LTQ3M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0id2hpdGVzbWFsbHNxdWFyZSIgdW5pY29kZT0iJiN4MjVhYjsiIApkPSJNNjk3IDQwMGgtNDczdjQ3M2g0NzN2LTQ3M3pNNTc5IDUxNHYyNDVoLTIzN3YtMjQ1aDIzN3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmxhY2tyZWN0YW5nbGUiIHVuaWNvZGU9IiYjeDI1YWM7IiAKZD0iTTAgNjI2aDkyMnYtMjMxaC05MjJ2MjMxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0cmlhZ3VwIiB1bmljb2RlPSImI3gyNWIyOyIgCmQ9Ik0wIDExNGw0NjAgODAwbDQ2MiAtODAwaC05MjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRyaWFncnQiIHVuaWNvZGU9IiYjeDI1YmE7IiAKZD0iTTYzIC02M2wtMiA5MjNsODAwIC00NjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRyaWFnZG4iIHVuaWNvZGU9IiYjeDI1YmM7IiAKZD0iTTkyMiA5MTRsLTQ2MCAtODAwbC00NjIgODAwaDkyMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idHJpYWdsZiIgdW5pY29kZT0iJiN4MjVjNDsiIApkPSJNNjIgMzk4bDc5OCA0NjN2LTkyNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibG96ZW5nZSIgdW5pY29kZT0iJiN4MjVjYTsiIApkPSJNNTAxIDEyODdsMzMzIC01NzhsLTMzMyAtNTc0aC05MGwtMzIyIDU3NGwzMjIgNTc4aDkwek00NTggMTA1OWwtMTk3IC0zNDlsMTk3IC0zNDlsMTk5IDM0OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0id2hpdGVjaXJjbGUiIHVuaWNvZGU9IiYjeDI1Y2I7IiAKZD0iTTQ2MSA5MzRxMTUwIDAgMjUzLjUgLTEwNXQxMDMuNSAtMjUxcTAgLTE1MCAtMTA0LjUgLTI1My41dC0yNTIuNSAtMTAzLjVxLTE1MSAwIC0yNTQgMTA0dC0xMDMgMjUzcTAgMTQzIDEwMiAyNDkuNXQyNTUgMTA2LjV6TTQ2MSA3ODRxLTg4IDAgLTE0Ny41IC02MXQtNTkuNSAtMTQ1cTAgLTkxIDYyIC0xNDl0MTQ1IC01OHE4NyAwIDE0NyA2MC41dDYwIDE0Ni41cTAgODIgLTU5IDE0NHQtMTQ4IDYyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJibGFja2NpcmNsZSIgdW5pY29kZT0iJiN4MjVjZjsiIApkPSJNNDYxIDkzNHExNTAgMCAyNTMuNSAtMTA1dDEwMy41IC0yNTFxMCAtMTUwIC0xMDQuNSAtMjUzLjV0LTI1Mi41IC0xMDMuNXEtMTUxIDAgLTI1NCAxMDR0LTEwMyAyNTNxMCAxNDMgMTAyIDI0OS41dDI1NSAxMDYuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYnVsbGV0aW52ZXJzZSIgdW5pY29kZT0iJiN4MjVkODsiIApkPSJNNjMgOTN2Nzk0aDc5NHYtNzk0aC03OTR6TTQ2MCA2NTRxLTY3IDAgLTExNSAtNDd0LTQ4IC0xMTd0NDkgLTExN3QxMTQgLTQ3cTY4IDAgMTE2IDQ4dDQ4IDExNnQtNDcuNSAxMTZ0LTExNi41IDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ3aGl0ZWNpcmNsZWludmVyc2UiIHVuaWNvZGU9IiYjeDI1ZDk7IiAKZD0iTTAgMTEwdjkzNWg5MjJ2LTkzNWgtOTIyek00NjEgOTM0cS0xNDUgMCAtMjUwLjUgLTEwMy41dC0xMDUuNSAtMjUzLjVxMCAtMTQ5IDEwMyAtMjUyLjV0MjUzIC0xMDMuNXExNDYgMCAyNTEuNSAxMDEuNXQxMDUuNSAyNTQuNXEwIDE0OCAtMTAzLjUgMjUyLjV0LTI1My41IDEwNC41ek00NjIgNzg0cTg2IDAgMTQ2IC02MC41dDYwIC0xNDYuNXEwIC04NyAtNjAuNSAtMTQ2LjV0LTE0NS41IC01OS41cS04NiAwIC0xNDYuNSA1OXQtNjAuNSAxNDcKcTAgODcgNjEuNSAxNDd0MTQ1LjUgNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IndoaXRlYnVsbGV0IiB1bmljb2RlPSImI3gyNWU2OyIgCmQ9Ik02OTEgNjM3cTAgLTEwMCAtNjkgLTE2NS41dC0xNjIgLTY1LjVxLTk2IDAgLTE2MyA2N3QtNjcgMTY0cTAgOTYgNjcgMTYzdDE2MyA2N3E5OCAwIDE2NC41IC02N3Q2Ni41IC0xNjN6TTU3OSA2MzdxMCA1MCAtMzUgODMuNXQtODQgMzMuNXEtNDcgMCAtODIgLTMzdC0zNSAtODRxMCAtNTIgMzUgLTg1dDgyIC0zM3E1MCAwIDg0LjUgMzQuNXQzNC41IDgzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNtaWxlZmFjZSIgdW5pY29kZT0iJiN4MjYzYTsiIApkPSJNOTIxIDU4NHEwIC0xOTMgLTEzMy41IC0zMjYuNXQtMzI3LjUgLTEzMy41cS0xOTMgMCAtMzI2LjUgMTM0dC0xMzMuNSAzMjZxMCAxMzAgNjMgMjM2LjV0MTY4LjUgMTY1LjV0MjI4LjUgNTlxMTk0IDAgMzI3LjUgLTEzNHQxMzMuNSAtMzI3ek03OTUgNTg0cTAgMTQxIC05NyAyMzh0LTIzOCA5N3EtMTQwIDAgLTIzNi41IC05Ny41dC05Ni41IC0yMzcuNXEwIC0xNDMgOTguNSAtMjM4LjV0MjM0LjUgLTk1LjVxMTM4IDAgMjM2LjUgOTYKdDk4LjUgMjM4ek0zNjggNjY2cTAgLTI0IC0xNi41IC00MXQtNDEuNSAtMTdxLTIzIDAgLTM5LjUgMTcuNXQtMTYuNSA0MC41cTAgMjIgMTYgMzl0NDAgMTdxMjUgMCA0MS41IC0xN3QxNi41IC0zOXpNNjY3IDY2NnEwIC0yNCAtMTUuNSAtNDF0LTM5LjUgLTE3cS0yNSAwIC00MS41IDE3dC0xNi41IDQxcTAgMjMgMTYgMzkuNXQ0MiAxNi41cTI0IDAgMzkuNSAtMTYuNXQxNS41IC0zOS41ek0yODAgNDU4bDM5IDIycTQ5IC04OCAxNDEgLTg4CnE5MyAwIDE0MiA4OGwzOSAtMjJxLTYxIC0xMjAgLTE4MSAtMTIwcS0xMTcgMCAtMTgwIDEyMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaW52c21pbGVmYWNlIiB1bmljb2RlPSImI3gyNjNiOyIgCmQ9Ik05MjEgNTg0cTAgLTE5MyAtMTMzLjUgLTMyNi41dC0zMjcuNSAtMTMzLjVxLTE5MyAwIC0zMjYuNSAxMzR0LTEzMy41IDMyNnEwIDEzMCA2MyAyMzYuNXQxNjguNSAxNjUuNXQyMjguNSA1OXExOTQgMCAzMjcuNSAtMTM0dDEzMy41IC0zMjd6TTM0MyA2ODBxMCAyMyAtMTcgNDAuNXQtNDIgMTcuNXQtNDEuNSAtMTcuNXQtMTYuNSAtNDAuNXQxNyAtNDF0NDEgLTE4cTI1IDAgNDIgMTcuNXQxNyA0MS41ek02OTUgNjgwcTAgMjQgLTE2IDQxCnQtNDEgMTdxLTI2IDAgLTQyLjUgLTE3dC0xNi41IC00MXQxNyAtNDEuNXQ0MiAtMTcuNXEyNCAwIDQwLjUgMTcuNXQxNi41IDQxLjV6TTI0OCA0MzZxNzQgLTE0MSAyMTIgLTE0MXQyMTMgMTQxbC00NiAyNnEtNTcgLTEwNCAtMTY3IC0xMDRxLTEwOSAwIC0xNjYgMTA0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb21wYXNzIiB1bmljb2RlPSImI3gyNjNjOyIgCmQ9Ik00MzYgOTMyaDUwdi0xNjNxODAgMCAxNjggLTY4bDE0MSAxMzdsMzMgLTM0bC0xMzggLTEzOXE3MCAtOTIgNzAgLTE3M2gxNjJ2LTQ0aC0xNjJxLTExIC05NCAtNjkgLTE2OGwxMzcgLTE0M2wtMzUgLTMybC0xMzkgMTM3cS03OCAtNTkgLTE2OCAtNjl2LTE2M2gtNTB2MTYzcS05MiAxMyAtMTY3IDY3bC0xNDIgLTEzNGwtMzIgMzNsMTM3IDEzOXEtNjAgNzYgLTcwIDE3MGgtMTYydjQ2aDE2MnEwIDg0IDY5IDE2OWwtMTM2IDEzOWwzMCAzNwpsMTQzIC0xMzdxODQgNTggMTY4IDY3djE2M3pNNDYwIDcyMnEtMTA3IDAgLTE3OC41IC03My41dC03MS41IC0xNzcuNXEwIC0xMDUgNzIgLTE3Ny41dDE3OCAtNzIuNXExMDcgMCAxNzguNSA3My41dDcxLjUgMTc2LjVxMCAxMDUgLTczIDE3OHQtMTc3IDczeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmZW1hbGUiIHVuaWNvZGU9IiYjeDI2NDA7IiAKZD0iTTQyNiA1NzdxLTEwNSAxNSAtMTc0IDk1dC02OSAxOTBxMCAxMjcgODMgMjA5dDE5NiA4MnQxOTYgLTgyLjV0ODMgLTIwOC41cTAgLTExNSAtNzAuNSAtMTkzLjV0LTE3MS41IC05MS41di0xNjVoMjQ4di02OWgtMjQ4di0yNjNoLTczdjI2M2gtMjUxdjY5aDI1MXYxNjV6TTQ2MSAxMDY5cS04MyAwIC0xNDEgLTU5LjV0LTU4IC0xNDUuNXEwIC04NyA1OC41IC0xNDYuNXQxNDAuNSAtNTkuNXQxNDEgNTl0NTkgMTQ3dC01OSAxNDYuNQp0LTE0MSA1OC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtYWxlIiB1bmljb2RlPSImI3gyNjQyOyIgCmQ9Ik00NzQgNzgybDI1MSAyNjFxLTIyIDExIC03NSAzMnQtOTMuNSAzNi41dC00MC41IDE3LjVsMjEgMjRoMzI3bDE2IC0xNXYtMzQ1bC0yMyAtMjFxLTIgMCAtMTggNDQuNXQtMzcgMTAxLjV0LTMxIDc4bC0yNDYgLTI1NnE4MSAtODEgODEgLTE5MnEwIC0xMjYgLTgzIC0yMTJ0LTIwMCAtODZxLTExOSAwIC0yMDAgODR0LTgxIDIwMXEwIDEyMCA4MS41IDIwNXQyMDEuNSA4NXE2OSAwIDE0OSAtNDN6TTMyNSA3NTBxLTg3IDAgLTE0NyAtNjEuNQp0LTYwIC0xNTAuNXEwIC05MCA2MS41IC0xNTEuNXQxNDUuNSAtNjEuNXE4MyAwIDE0NC41IDU5LjV0NjEuNSAxNTMuNXEwIDkyIC02MSAxNTJ0LTE0NSA2MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3BhZGUiIHVuaWNvZGU9IiYjeDI2NjA7IiAKZD0iTTQ2MSAxMDc5cTE0IC02MCA0Mi41IC0xMTJ0NjEuNSAtOTB0NjkuNSAtNzIuNXQ3MC41IC02NS41dDYxIC02MnQ0My41IC02OXQxNi41IC04MXEwIC03MyAtNDggLTEyMC41dC0xMTYgLTQ3LjVxLTExNyAwIC0xOTIgMTQ0cTAgLTkzIDI0IC0xNTl0NjYgLTEwMC41dDg5LjUgLTQ5dDEwNC41IC0xNC41bDUgLTI4aC01OTdsNiAyOHEyODggMCAyODggMzIzcS02NiAtMTQ0IC0xOTYgLTE0NHEtNjggMCAtMTE2LjUgNDh0LTQ4LjUgMTE3CnEwIDQ1IDE2LjUgODR0NDQgNjkuNXQ2MiA2MC41dDcxLjUgNjMuNXQ3MCA3MXQ2MC41IDkxdDQxLjUgMTE1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNsdWIiIHVuaWNvZGU9IiYjeDI2NjM7IiAKZD0iTTc3OSAxNTFoLTYzNGw1IDI1cTEgMCA2IDFxMTcgMiAzMSA1dDQ3IDEzdDU4LjUgMjMuNXQ1NyAzOXQ1MyA1N3QzNiA3OXQxNC41IDEwNC41djM1cS00MiAtODUgLTEwNyAtMTMxLjV0LTEzOSAtNDYuNXEtODQgMCAtMTQ1LjUgNTcuNXQtNjEuNSAxNTEuNXQ1NyAxNTAuNXQxMjIgNTYuNXE0NyAwIDEyMyAtMzlxLTMxIDUyIC00MC41IDc4LjV0LTkuNSA1OC41cTAgODUgNTggMTQzLjV0MTQ5IDU4LjVxODkgMCAxNDguNSAtNTguNQp0NTkuNSAtMTQxLjVxMCAtNjggLTUyIC0xMzlxNTggMjcgNzUuNSAzM3Q0Ni41IDZxNzUgMCAxMzAgLTU4dDU1IC0xNDZxMCAtOTEgLTYwLjUgLTE1MS41dC0xNDQuNSAtNjAuNXEtMTQ3IDAgLTI0NiAxNzJxLTIgNSAtMyA2cTAgLTYwIDEwIC0xMDl0MjQuNSAtODN0NDAuNSAtNjF0NDguNSAtNDIuNXQ1OC41IC0yOC41dDYwIC0xOXQ2MyAtMTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImhlYXJ0IiB1bmljb2RlPSImI3gyNjY1OyIgCmQ9Ik00NjMgMTIycS0yMiA4MyAtNzAuNSAxNjcuNXQtMTAwLjUgMTUxdC0xMDEgMTMwdC04MC41IDEyNi41dC0zMS41IDExOXEwIDgxIDUyIDEzMnQxMjkgNTFxMTQyIDAgMjAzIC0xNzVxMjUgOTEgNzkgMTMzLjV0MTE5IDQyLjVxNzggMCAxMjkuNSAtNTJ0NTEuNSAtMTIzcTAgLTY1IC0zMS41IC0xMzJ0LTgwIC0xMzAuNXQtOTkuNSAtMTI4dC05OC41IC0xNDd0LTY5LjUgLTE2NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkaWFtb25kIiB1bmljb2RlPSImI3gyNjY2OyIgCmQ9Ik00NjAgMTA2OHE1NCAtMTI3IDE0OCAtMjUyLjV0MTk3IC0yMTUuNXEtODMgLTY0IC0xODMgLTE5OXQtMTYyIC0yNzFxLTUyIDExOCAtMTU2LjUgMjYzdC0xODUuNSAyMDdxMjA0IDE3NyAzNDIgNDY4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtdXNpY2Fsbm90ZSIgdW5pY29kZT0iJiN4MjY2YTsiIApkPSJNNDE5IDM1OHY2ODhoNjF2LTgybDEyNSAtMTU0cTg4IC0xMjUgODggLTI1OHEwIC0xMjQgLTc3IC0yMTloLTM4cTQ4IDEwNSA0OCAyMDFxMCA5NyAtNDYgMTYxdC0xMDAgNzN2LTQxMHEwIC05OCAtNTcuNSAtMTYwdC0xNDYuNSAtNjJxLTkzIDAgLTkzIDgwcTAgNjIgNDcuNSAxMDkuNXQxMTUuNSA0Ny41cTM2IDAgNzMgLTE1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtdXNpY2Fsbm90ZWRibCIgdW5pY29kZT0iJiN4MjY2YjsiIApkPSJNODM5IDM2OHEwIC0xMDMgLTYwIC0xNjJ0LTE0MyAtNTlxLTUyIDAgLTcyLjUgMjR0LTIwLjUgNTZxMCA2MiA0NyAxMDguNXQxMTYgNDYuNXEzNSAwIDczIC0xNHYzNjRsLTQ0NiAtMTIxdi0zMTlxMCAtMTAzIC02MCAtMTYydC0xNDQgLTU5cS01MiAwIC03Mi41IDI0dC0yMC41IDU2cTAgNjEgNDcuNSAxMDh0MTE2LjUgNDdxNDIgMCA3MiAtMTR2NjA4bDU2NyAxNDV2LTY3N3pNMzMzIDcxNGw0NDYgMTIxdjkzbC00NDYgLTEyMXYtOTN6IiAvPgogIDwvZm9udD4KPC9kZWZzPjwvc3ZnPgo="},function(A,e){A.exports="data:application/x-font-ttf;base64,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Gk4aWhpmGnIafhqyGr4ayhrWGuIa7hr6GwYbEhseGyobNhtCG04bWhtmG3IbgBuIG8wb2BvkG/Ab/BwIHBQcIBwsHDgcRBxQHFwcaBx0HIAcjByYHKQcsBy8HOIdEB0cHSgdNB1AHUwdWB1kHXAdfB2QHbgdxB3QHdwd6B30HfweCB4WHiIeLh46HkYeUh5eHnwenB6oHrQewB7MHtge5B7wHyAfVB9gH2wfeB+EH5AfnB/YICQgMCA8IEggVCBgIGwgeCCEIJAgnCCoILQgwCDMINgg5CDwIPwhGiFQIVwhaCF0IYAhjCGYIaYhsiG+Icoh1iHiIe4h+iIGIhIiHiIqIjYiQiJOIloiZiJuIqgixiLaIuwi+iMKIyQjNiNUI3gjqiO4I8gj2CQKJC4kUiRkJIoklCSmJLAkuCTAJMgk0CTmJO4k9iT+JUIlSiVSJWQlbCV0JZoloiWqJbIlziXWJd4l5iXuJhwmWiZmJnImfiaKJpYmoiauJuYnMidKJ4on0CgWKDwogiiKKJIoqCiwKLgpECkYKUQpfim8KgQqKipYKpQqxCrwK0YrUiteK2ordiuCK4orkiuaK6YrsivoK/QsPixGLE4sWixiLJYsxiz2LQItDi0aLTItOi1kLWwtfC2mLa4t1C4aLjAuPC5ELmIuai5yLnoujC6ULpwupC7OLxYvHi84L1Ivai+IL7Qv4DAIME4wjDC4MMAxCjFAMY4xtjG+MeYyMjJIMlQycDKMMqgywDLIMtAy2DLgMvQy/DM8M0QzejOgM9o0IDRMNHo0pDTgNSY1VjViNW41rDW4NfA1+DYANgw2FDZONno2hjaSNp42qjbCNsw21jbgNv43DDcWNyQ3PDdgN3Y3qjeyN7o3wjfKN9I37jgYOFA4jjiyOMo44jj6ORI5NjlaOYI5kDmYOa458joUOnA6jDqqOsY61jryOw47IDssOzo7TDtcO2w7fjuSO6Q7tjvIO+A79DwIPB48NDxOPGQ8ejySPKg8vjzYPOw9Aj0cPTQ9TD1uPYY9nj2+Pdg97j4OPig+Pj5ePnw+mD7EPtI+4D7uPvw/Cj/mQYBC+kMIQx5DLENAQ05DXENqQ3hDhkOkQ8pD4kP+RCxEUkSqRPBFPkVwRa5F4kYwRlRGbkaWRswAAAACAEQAAAJkBVUAAwAHAC6xAQAvPLIHBArtMrEGBdw8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AHIAYwBoACAAMgAwADEAMAAAQ29weXJpZ2h0IChjKSAyMDEwLCBBbmRyZXkgTWFrYXJvdiAobWFrYXJvdkBibXN0dS5ydSwgbWthLWF0LW1haWxydUBtYWlsLnJ1KSwKd2l0aCBSZXNlcnZlZCBGb250IE5hbWUgQW5rYS9Db2RlciBOYXJyb3cuCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpUaGUgQW5rYS8qIGFyZSBtZW1iZXJzIG9mIEFubmEgU2h1Z29sIG5hbWUgZm9udCBmYW1pbHk7IE1hcmNoIDIwMTAAAEEAbgBrAGEAQwBvAGQAZQByAEMANwA1AFIAZQBnAHUAbABhAHIAAEFua2FDb2RlckM3NVJlZ3VsYXIAAFIAZQBnAHUAbABhAHIAAFJlZ3VsYXIAAEYAbwBuAHQARgBvAHIAZwBlACAAMgAuADAAIAA6ACAAQQBuAGsAYQAvAEMAbwBkAGUAcgAgAE4AYQByAHIAbwB3ACAAUgBlAGcAdQBsAGEAcgAgADoAIAAxADYALQA1AC0AMgAwADEANwAARm9udEZvcmdlIDIuMCA6IEFua2EvQ29kZXIgTmFycm93IFJlZ3VsYXIgOiAxNi01LTIwMTcAAEEAbgBrAGEALwBDAG8AZABlAHIAIABOAGEAcgByAG8AdwAgAFIAZQBnAHUAbABhAHIAAEFua2EvQ29kZXIgTmFycm93IFJlZ3VsYXIAAFYAZQByAHMAaQBvAG4AIAAwADAAMQAuADEAMAAwACAAAFZlcnNpb24gMDAxLjEwMCAAAEEAbgBrAGEAQwBvAGQAZQByAEMANwA1AFIAZQBnAHUAbABhAHIAAEFua2FDb2RlckM3NVJlZ3VsYXIAAEMAbwBwAHkAcgBpAGcAaAB0ACAAKABjACkAIAAyADAAMQAwACwAIABBAG4AZAByAGUAeQAgAE0AYQBrAGEAcgBvAHYAIAAoAG0AYQBrAGEAcgBvAHYAQABiAG0AcwB0AHUALgByAHUALAAgAG0AawBhAC0AYQB0AC0AbQBhAGkAbAByAHUAQABtAGEAaQBsAC4AcgB1ACkALAAKAHcAaQB0AGgAIABSAGUAcwBlAHIAdgBlAGQAIABGAG8AbgB0ACAATgBhAG0AZQAgAEEAbgBrAGEALwBDAG8AZABlAHIAIABOAGEAcgByAG8AdwAuAAoACgBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuAAoAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABjAG8AcABpAGUAZAAgAGIAZQBsAG8AdwAsACAAYQBuAGQAIABpAHMAIABhAGwAcwBvACAAYQB2AGEAaQBsAGEAYgBsAGUAIAB3AGkAdABoACAAYQAgAEYAQQBRACAAYQB0ADoACgBoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwACgAKAAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAAoAUwBJAEwAIABPAFAARQBOACAARgBPAE4AVAAgAEwASQBDAEUATgBTAEUAIABWAGUAcgBzAGkAbwBuACAAMQAuADEAIAAtACAAMgA2ACAARgBlAGIAcgB1AGEAcgB5ACAAMgAwADAANwAKAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAKAAoAUABSAEUAQQBNAEIATABFAAoAVABoAGUAIABnAG8AYQBsAHMAIABvAGYAIAB0AGgAZQAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAgACgATwBGAEwAKQAgAGEAcgBlACAAdABvACAAcwB0AGkAbQB1AGwAYQB0AGUAIAB3AG8AcgBsAGQAdwBpAGQAZQAKAGQAZQB2AGUAbABvAHAAbQBlAG4AdAAgAG8AZgAgAGMAbwBsAGwAYQBiAG8AcgBhAHQAaQB2AGUAIABmAG8AbgB0ACAAcAByAG8AagBlAGMAdABzACwAIAB0AG8AIABzAHUAcABwAG8AcgB0ACAAdABoAGUAIABmAG8AbgB0ACAAYwByAGUAYQB0AGkAbwBuAAoAZQBmAGYAbwByAHQAcwAgAG8AZgAgAGEAYwBhAGQAZQBtAGkAYwAgAGEAbgBkACAAbABpAG4AZwB1AGkAcwB0AGkAYwAgAGMAbwBtAG0AdQBuAGkAdABpAGUAcwAsACAAYQBuAGQAIAB0AG8AIABwAHIAbwB2AGkAZABlACAAYQAgAGYAcgBlAGUAIABhAG4AZAAKAG8AcABlAG4AIABmAHIAYQBtAGUAdwBvAHIAawAgAGkAbgAgAHcAaABpAGMAaAAgAGYAbwBuAHQAcwAgAG0AYQB5ACAAYgBlACAAcwBoAGEAcgBlAGQAIABhAG4AZAAgAGkAbQBwAHIAbwB2AGUAZAAgAGkAbgAgAHAAYQByAHQAbgBlAHIAcwBoAGkAcAAKAHcAaQB0AGgAIABvAHQAaABlAHIAcwAuAAoACgBUAGgAZQAgAE8ARgBMACAAYQBsAGwAbwB3AHMAIAB0AGgAZQAgAGwAaQBjAGUAbgBzAGUAZAAgAGYAbwBuAHQAcwAgAHQAbwAgAGIAZQAgAHUAcwBlAGQALAAgAHMAdAB1AGQAaQBlAGQALAAgAG0AbwBkAGkAZgBpAGUAZAAgAGEAbgBkAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGYAcgBlAGUAbAB5ACAAYQBzACAAbABvAG4AZwAgAGEAcwAgAHQAaABlAHkAIABhAHIAZQAgAG4AbwB0ACAAcwBvAGwAZAAgAGIAeQAgAHQAaABlAG0AcwBlAGwAdgBlAHMALgAgAFQAaABlAAoAZgBvAG4AdABzACwAIABpAG4AYwBsAHUAZABpAG4AZwAgAGEAbgB5ACAAZABlAHIAaQB2AGEAdABpAHYAZQAgAHcAbwByAGsAcwAsACAAYwBhAG4AIABiAGUAIABiAHUAbgBkAGwAZQBkACwAIABlAG0AYgBlAGQAZABlAGQALAAgAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGEAbgBkAC8AbwByACAAcwBvAGwAZAAgAHcAaQB0AGgAIABhAG4AeQAgAHMAbwBmAHQAdwBhAHIAZQAgAHAAcgBvAHYAaQBkAGUAZAAgAHQAaABhAHQAIABhAG4AeQAgAHIAZQBzAGUAcgB2AGUAZAAKAG4AYQBtAGUAcwAgAGEAcgBlACAAbgBvAHQAIAB1AHMAZQBkACAAYgB5ACAAZABlAHIAaQB2AGEAdABpAHYAZQAgAHcAbwByAGsAcwAuACAAVABoAGUAIABmAG8AbgB0AHMAIABhAG4AZAAgAGQAZQByAGkAdgBhAHQAaQB2AGUAcwAsAAoAaABvAHcAZQB2AGUAcgAsACAAYwBhAG4AbgBvAHQAIABiAGUAIAByAGUAbABlAGEAcwBlAGQAIAB1AG4AZABlAHIAIABhAG4AeQAgAG8AdABoAGUAcgAgAHQAeQBwAGUAIABvAGYAIABsAGkAYwBlAG4AcwBlAC4AIABUAGgAZQAKAHIAZQBxAHUAaQByAGUAbQBlAG4AdAAgAGYAbwByACAAZgBvAG4AdABzACAAdABvACAAcgBlAG0AYQBpAG4AIAB1AG4AZABlAHIAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGQAbwBlAHMAIABuAG8AdAAgAGEAcABwAGwAeQAKAHQAbwAgAGEAbgB5ACAAZABvAGMAdQBtAGUAbgB0ACAAYwByAGUAYQB0AGUAZAAgAHUAcwBpAG4AZwAgAHQAaABlACAAZgBvAG4AdABzACAAbwByACAAdABoAGUAaQByACAAZABlAHIAaQB2AGEAdABpAHYAZQBzAC4ACgAKAEQARQBGAEkATgBJAFQASQBPAE4AUwAKACIARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAiACAAcgBlAGYAZQByAHMAIAB0AG8AIAB0AGgAZQAgAHMAZQB0ACAAbwBmACAAZgBpAGwAZQBzACAAcgBlAGwAZQBhAHMAZQBkACAAYgB5ACAAdABoAGUAIABDAG8AcAB5AHIAaQBnAGgAdAAKAEgAbwBsAGQAZQByACgAcwApACAAdQBuAGQAZQByACAAdABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABhAG4AZAAgAGMAbABlAGEAcgBsAHkAIABtAGEAcgBrAGUAZAAgAGEAcwAgAHMAdQBjAGgALgAgAFQAaABpAHMAIABtAGEAeQAKAGkAbgBjAGwAdQBkAGUAIABzAG8AdQByAGMAZQAgAGYAaQBsAGUAcwAsACAAYgB1AGkAbABkACAAcwBjAHIAaQBwAHQAcwAgAGEAbgBkACAAZABvAGMAdQBtAGUAbgB0AGEAdABpAG8AbgAuAAoACgAiAFIAZQBzAGUAcgB2AGUAZAAgAEYAbwBuAHQAIABOAGEAbQBlACIAIAByAGUAZgBlAHIAcwAgAHQAbwAgAGEAbgB5ACAAbgBhAG0AZQBzACAAcwBwAGUAYwBpAGYAaQBlAGQAIABhAHMAIABzAHUAYwBoACAAYQBmAHQAZQByACAAdABoAGUACgBjAG8AcAB5AHIAaQBnAGgAdAAgAHMAdABhAHQAZQBtAGUAbgB0ACgAcwApAC4ACgAKACIATwByAGkAZwBpAG4AYQBsACAAVgBlAHIAcwBpAG8AbgAiACAAcgBlAGYAZQByAHMAIAB0AG8AIAB0AGgAZQAgAGMAbwBsAGwAZQBjAHQAaQBvAG4AIABvAGYAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAYwBvAG0AcABvAG4AZQBuAHQAcwAgAGEAcwAKAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGIAeQAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAuAAoACgAiAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AIgAgAHIAZQBmAGUAcgBzACAAdABvACAAYQBuAHkAIABkAGUAcgBpAHYAYQB0AGkAdgBlACAAbQBhAGQAZQAgAGIAeQAgAGEAZABkAGkAbgBnACAAdABvACwAIABkAGUAbABlAHQAaQBuAGcALAAKAG8AcgAgAHMAdQBiAHMAdABpAHQAdQB0AGkAbgBnACAALQAtACAAaQBuACAAcABhAHIAdAAgAG8AcgAgAGkAbgAgAHcAaABvAGwAZQAgAC0ALQAgAGEAbgB5ACAAbwBmACAAdABoAGUAIABjAG8AbQBwAG8AbgBlAG4AdABzACAAbwBmACAAdABoAGUACgBPAHIAaQBnAGkAbgBhAGwAIABWAGUAcgBzAGkAbwBuACwAIABiAHkAIABjAGgAYQBuAGcAaQBuAGcAIABmAG8AcgBtAGEAdABzACAAbwByACAAYgB5ACAAcABvAHIAdABpAG4AZwAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAHQAbwAgAGEACgBuAGUAdwAgAGUAbgB2AGkAcgBvAG4AbQBlAG4AdAAuAAoACgAiAEEAdQB0AGgAbwByACIAIAByAGUAZgBlAHIAcwAgAHQAbwAgAGEAbgB5ACAAZABlAHMAaQBnAG4AZQByACwAIABlAG4AZwBpAG4AZQBlAHIALAAgAHAAcgBvAGcAcgBhAG0AbQBlAHIALAAgAHQAZQBjAGgAbgBpAGMAYQBsAAoAdwByAGkAdABlAHIAIABvAHIAIABvAHQAaABlAHIAIABwAGUAcgBzAG8AbgAgAHcAaABvACAAYwBvAG4AdAByAGkAYgB1AHQAZQBkACAAdABvACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlAC4ACgAKAFAARQBSAE0ASQBTAFMASQBPAE4AIAAmACAAQwBPAE4ARABJAFQASQBPAE4AUwAKAFAAZQByAG0AaQBzAHMAaQBvAG4AIABpAHMAIABoAGUAcgBlAGIAeQAgAGcAcgBhAG4AdABlAGQALAAgAGYAcgBlAGUAIABvAGYAIABjAGgAYQByAGcAZQAsACAAdABvACAAYQBuAHkAIABwAGUAcgBzAG8AbgAgAG8AYgB0AGEAaQBuAGkAbgBnAAoAYQAgAGMAbwBwAHkAIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALAAgAHQAbwAgAHUAcwBlACwAIABzAHQAdQBkAHkALAAgAGMAbwBwAHkALAAgAG0AZQByAGcAZQAsACAAZQBtAGIAZQBkACwAIABtAG8AZABpAGYAeQAsAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUALAAgAGEAbgBkACAAcwBlAGwAbAAgAG0AbwBkAGkAZgBpAGUAZAAgAGEAbgBkACAAdQBuAG0AbwBkAGkAZgBpAGUAZAAgAGMAbwBwAGkAZQBzACAAbwBmACAAdABoAGUAIABGAG8AbgB0AAoAUwBvAGYAdAB3AGEAcgBlACwAIABzAHUAYgBqAGUAYwB0ACAAdABvACAAdABoAGUAIABmAG8AbABsAG8AdwBpAG4AZwAgAGMAbwBuAGQAaQB0AGkAbwBuAHMAOgAKAAoAMQApACAATgBlAGkAdABoAGUAcgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAG4AbwByACAAYQBuAHkAIABvAGYAIABpAHQAcwAgAGkAbgBkAGkAdgBpAGQAdQBhAGwAIABjAG8AbQBwAG8AbgBlAG4AdABzACwACgBpAG4AIABPAHIAaQBnAGkAbgBhAGwAIABvAHIAIABNAG8AZABpAGYAaQBlAGQAIABWAGUAcgBzAGkAbwBuAHMALAAgAG0AYQB5ACAAYgBlACAAcwBvAGwAZAAgAGIAeQAgAGkAdABzAGUAbABmAC4ACgAKADIAKQAgAE8AcgBpAGcAaQBuAGEAbAAgAG8AcgAgAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AcwAgAG8AZgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAG0AYQB5ACAAYgBlACAAYgB1AG4AZABsAGUAZAAsAAoAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGEAbgBkAC8AbwByACAAcwBvAGwAZAAgAHcAaQB0AGgAIABhAG4AeQAgAHMAbwBmAHQAdwBhAHIAZQAsACAAcAByAG8AdgBpAGQAZQBkACAAdABoAGEAdAAgAGUAYQBjAGgAIABjAG8AcAB5AAoAYwBvAG4AdABhAGkAbgBzACAAdABoAGUAIABhAGIAbwB2AGUAIABjAG8AcAB5AHIAaQBnAGgAdAAgAG4AbwB0AGkAYwBlACAAYQBuAGQAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAuACAAVABoAGUAcwBlACAAYwBhAG4AIABiAGUACgBpAG4AYwBsAHUAZABlAGQAIABlAGkAdABoAGUAcgAgAGEAcwAgAHMAdABhAG4AZAAtAGEAbABvAG4AZQAgAHQAZQB4AHQAIABmAGkAbABlAHMALAAgAGgAdQBtAGEAbgAtAHIAZQBhAGQAYQBiAGwAZQAgAGgAZQBhAGQAZQByAHMAIABvAHIACgBpAG4AIAB0AGgAZQAgAGEAcABwAHIAbwBwAHIAaQBhAHQAZQAgAG0AYQBjAGgAaQBuAGUALQByAGUAYQBkAGEAYgBsAGUAIABtAGUAdABhAGQAYQB0AGEAIABmAGkAZQBsAGQAcwAgAHcAaQB0AGgAaQBuACAAdABlAHgAdAAgAG8AcgAKAGIAaQBuAGEAcgB5ACAAZgBpAGwAZQBzACAAYQBzACAAbABvAG4AZwAgAGEAcwAgAHQAaABvAHMAZQAgAGYAaQBlAGwAZABzACAAYwBhAG4AIABiAGUAIABlAGEAcwBpAGwAeQAgAHYAaQBlAHcAZQBkACAAYgB5ACAAdABoAGUAIAB1AHMAZQByAC4ACgAKADMAKQAgAE4AbwAgAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABtAGEAeQAgAHUAcwBlACAAdABoAGUAIABSAGUAcwBlAHIAdgBlAGQAIABGAG8AbgB0AAoATgBhAG0AZQAoAHMAKQAgAHUAbgBsAGUAcwBzACAAZQB4AHAAbABpAGMAaQB0ACAAdwByAGkAdAB0AGUAbgAgAHAAZQByAG0AaQBzAHMAaQBvAG4AIABpAHMAIABnAHIAYQBuAHQAZQBkACAAYgB5ACAAdABoAGUAIABjAG8AcgByAGUAcwBwAG8AbgBkAGkAbgBnAAoAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAuACAAVABoAGkAcwAgAHIAZQBzAHQAcgBpAGMAdABpAG8AbgAgAG8AbgBsAHkAIABhAHAAcABsAGkAZQBzACAAdABvACAAdABoAGUAIABwAHIAaQBtAGEAcgB5ACAAZgBvAG4AdAAgAG4AYQBtAGUAIABhAHMACgBwAHIAZQBzAGUAbgB0AGUAZAAgAHQAbwAgAHQAaABlACAAdQBzAGUAcgBzAC4ACgAKADQAKQAgAFQAaABlACAAbgBhAG0AZQAoAHMAKQAgAG8AZgAgAHQAaABlACAAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAgAG8AcgAgAHQAaABlACAAQQB1AHQAaABvAHIAKABzACkAIABvAGYAIAB0AGgAZQAgAEYAbwBuAHQACgBTAG8AZgB0AHcAYQByAGUAIABzAGgAYQBsAGwAIABuAG8AdAAgAGIAZQAgAHUAcwBlAGQAIAB0AG8AIABwAHIAbwBtAG8AdABlACwAIABlAG4AZABvAHIAcwBlACAAbwByACAAYQBkAHYAZQByAHQAaQBzAGUAIABhAG4AeQAKAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4ALAAgAGUAeABjAGUAcAB0ACAAdABvACAAYQBjAGsAbgBvAHcAbABlAGQAZwBlACAAdABoAGUAIABjAG8AbgB0AHIAaQBiAHUAdABpAG8AbgAoAHMAKQAgAG8AZgAgAHQAaABlAAoAQwBvAHAAeQByAGkAZwBoAHQAIABIAG8AbABkAGUAcgAoAHMAKQAgAGEAbgBkACAAdABoAGUAIABBAHUAdABoAG8AcgAoAHMAKQAgAG8AcgAgAHcAaQB0AGgAIAB0AGgAZQBpAHIAIABlAHgAcABsAGkAYwBpAHQAIAB3AHIAaQB0AHQAZQBuAAoAcABlAHIAbQBpAHMAcwBpAG8AbgAuAAoACgA1ACkAIABUAGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALAAgAG0AbwBkAGkAZgBpAGUAZAAgAG8AcgAgAHUAbgBtAG8AZABpAGYAaQBlAGQALAAgAGkAbgAgAHAAYQByAHQAIABvAHIAIABpAG4AIAB3AGgAbwBsAGUALAAKAG0AdQBzAHQAIABiAGUAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABlAG4AdABpAHIAZQBsAHkAIAB1AG4AZABlAHIAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAsACAAYQBuAGQAIABtAHUAcwB0ACAAbgBvAHQAIABiAGUACgBkAGkAcwB0AHIAaQBiAHUAdABlAGQAIAB1AG4AZABlAHIAIABhAG4AeQAgAG8AdABoAGUAcgAgAGwAaQBjAGUAbgBzAGUALgAgAFQAaABlACAAcgBlAHEAdQBpAHIAZQBtAGUAbgB0ACAAZgBvAHIAIABmAG8AbgB0AHMAIAB0AG8ACgByAGUAbQBhAGkAbgAgAHUAbgBkAGUAcgAgAHQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAZABvAGUAcwAgAG4AbwB0ACAAYQBwAHAAbAB5ACAAdABvACAAYQBuAHkAIABkAG8AYwB1AG0AZQBuAHQAIABjAHIAZQBhAHQAZQBkAAoAdQBzAGkAbgBnACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlAC4ACgAKAFQARQBSAE0ASQBOAEEAVABJAE8ATgAKAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAYgBlAGMAbwBtAGUAcwAgAG4AdQBsAGwAIABhAG4AZAAgAHYAbwBpAGQAIABpAGYAIABhAG4AeQAgAG8AZgAgAHQAaABlACAAYQBiAG8AdgBlACAAYwBvAG4AZABpAHQAaQBvAG4AcwAgAGEAcgBlAAoAbgBvAHQAIABtAGUAdAAuAAoACgBEAEkAUwBDAEwAQQBJAE0ARQBSAAoAVABIAEUAIABGAE8ATgBUACAAUwBPAEYAVABXAEEAUgBFACAASQBTACAAUABSAE8AVgBJAEQARQBEACAAIgBBAFMAIABJAFMAIgAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQAWQAgAE8ARgAgAEEATgBZACAASwBJAE4ARAAsAAoARQBYAFAAUgBFAFMAUwAgAE8AUgAgAEkATQBQAEwASQBFAEQALAAgAEkATgBDAEwAVQBEAEkATgBHACAAQgBVAFQAIABOAE8AVAAgAEwASQBNAEkAVABFAEQAIABUAE8AIABBAE4AWQAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAEYACgBNAEUAUgBDAEgAQQBOAFQAQQBCAEkATABJAFQAWQAsACAARgBJAFQATgBFAFMAUwAgAEYATwBSACAAQQAgAFAAQQBSAFQASQBDAFUATABBAFIAIABQAFUAUgBQAE8AUwBFACAAQQBOAEQAIABOAE8ATgBJAE4ARgBSAEkATgBHAEUATQBFAE4AVAAKAE8ARgAgAEMATwBQAFkAUgBJAEcASABUACwAIABQAEEAVABFAE4AVAAsACAAVABSAEEARABFAE0AQQBSAEsALAAgAE8AUgAgAE8AVABIAEUAUgAgAFIASQBHAEgAVAAuACAASQBOACAATgBPACAARQBWAEUATgBUACAAUwBIAEEATABMACAAVABIAEUACgBDAE8AUABZAFIASQBHAEgAVAAgAEgATwBMAEQARQBSACAAQgBFACAATABJAEEAQgBMAEUAIABGAE8AUgAgAEEATgBZACAAQwBMAEEASQBNACwAIABEAEEATQBBAEcARQBTACAATwBSACAATwBUAEgARQBSACAATABJAEEAQgBJAEwASQBUAFkALAAKAEkATgBDAEwAVQBEAEkATgBHACAAQQBOAFkAIABHAEUATgBFAFIAQQBMACwAIABTAFAARQBDAEkAQQBMACwAIABJAE4ARABJAFIARQBDAFQALAAgAEkATgBDAEkARABFAE4AVABBAEwALAAgAE8AUgAgAEMATwBOAFMARQBRAFUARQBOAFQASQBBAEwACgBEAEEATQBBAEcARQBTACwAIABXAEgARQBUAEgARQBSACAASQBOACAAQQBOACAAQQBDAFQASQBPAE4AIABPAEYAIABDAE8ATgBUAFIAQQBDAFQALAAgAFQATwBSAFQAIABPAFIAIABPAFQASABFAFIAVwBJAFMARQAsACAAQQBSAEkAUwBJAE4ARwAKAEYAUgBPAE0ALAAgAE8AVQBUACAATwBGACAAVABIAEUAIABVAFMARQAgAE8AUgAgAEkATgBBAEIASQBMAEkAVABZACAAVABPACAAVQBTAEUAIABUAEgARQAgAEYATwBOAFQAIABTAE8ARgBUAFcAQQBSAEUAIABPAFIAIABGAFIATwBNAAoATwBUAEgARQBSACAARABFAEEATABJAE4ARwBTACAASQBOACAAVABIAEUAIABGAE8ATgBUACAAUwBPAEYAVABXAEEAUgBFAC4AAENvcHlyaWdodCAoYykgMjAxMCwgQW5kcmV5IE1ha2Fyb3YgKG1ha2Fyb3ZAYm1zdHUucnUsIG1rYS1hdC1tYWlscnVAbWFpbC5ydSksCndpdGggUmVzZXJ2ZWQgRm9udCBOYW1lIEFua2EvQ29kZXIgTmFycm93LgoKVGhpcyBGb250IFNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBTSUwgT3BlbiBGb250IExpY2Vuc2UsIFZlcnNpb24gMS4xLgpUaGlzIGxpY2Vuc2UgaXMgY29waWVkIGJlbG93LCBhbmQgaXMgYWxzbyBhdmFpbGFibGUgd2l0aCBhIEZBUSBhdDoKaHR0cDovL3NjcmlwdHMuc2lsLm9yZy9PRkwKCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpTSUwgT1BFTiBGT05UIExJQ0VOU0UgVmVyc2lvbiAxLjEgLSAyNiBGZWJydWFyeSAyMDA3Ci0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpQUkVBTUJMRQpUaGUgZ29hbHMgb2YgdGhlIE9wZW4gRm9udCBMaWNlbnNlIChPRkwpIGFyZSB0byBzdGltdWxhdGUgd29ybGR3aWRlCmRldmVsb3BtZW50IG9mIGNvbGxhYm9yYXRpdmUgZm9udCBwcm9qZWN0cywgdG8gc3VwcG9ydCB0aGUgZm9udCBjcmVhdGlvbgplZmZvcnRzIG9mIGFjYWRlbWljIGFuZCBsaW5ndWlzdGljIGNvbW11bml0aWVzLCBhbmQgdG8gcHJvdmlkZSBhIGZyZWUgYW5kCm9wZW4gZnJhbWV3b3JrIGluIHdoaWNoIGZvbnRzIG1heSBiZSBzaGFyZWQgYW5kIGltcHJvdmVkIGluIHBhcnRuZXJzaGlwCndpdGggb3RoZXJzLgoKVGhlIE9GTCBhbGxvd3MgdGhlIGxpY2Vuc2VkIGZvbnRzIHRvIGJlIHVzZWQsIHN0dWRpZWQsIG1vZGlmaWVkIGFuZApyZWRpc3RyaWJ1dGVkIGZyZWVseSBhcyBsb25nIGFzIHRoZXkgYXJlIG5vdCBzb2xkIGJ5IHRoZW1zZWx2ZXMuIFRoZQpmb250cywgaW5jbHVkaW5nIGFueSBkZXJpdmF0aXZlIHdvcmtzLCBjYW4gYmUgYnVuZGxlZCwgZW1iZWRkZWQsIApyZWRpc3RyaWJ1dGVkIGFuZC9vciBzb2xkIHdpdGggYW55IHNvZnR3YXJlIHByb3ZpZGVkIHRoYXQgYW55IHJlc2VydmVkCm5hbWVzIGFyZSBub3QgdXNlZCBieSBkZXJpdmF0aXZlIHdvcmtzLiBUaGUgZm9udHMgYW5kIGRlcml2YXRpdmVzLApob3dldmVyLCBjYW5ub3QgYmUgcmVsZWFzZWQgdW5kZXIgYW55IG90aGVyIHR5cGUgb2YgbGljZW5zZS4gVGhlCnJlcXVpcmVtZW50IGZvciBmb250cyB0byByZW1haW4gdW5kZXIgdGhpcyBsaWNlbnNlIGRvZXMgbm90IGFwcGx5CnRvIGFueSBkb2N1bWVudCBjcmVhdGVkIHVzaW5nIHRoZSBmb250cyBvciB0aGVpciBkZXJpdmF0aXZlcy4KCkRFRklOSVRJT05TCiJGb250IFNvZnR3YXJlIiByZWZlcnMgdG8gdGhlIHNldCBvZiBmaWxlcyByZWxlYXNlZCBieSB0aGUgQ29weXJpZ2h0CkhvbGRlcihzKSB1bmRlciB0aGlzIGxpY2Vuc2UgYW5kIGNsZWFybHkgbWFya2VkIGFzIHN1Y2guIFRoaXMgbWF5CmluY2x1ZGUgc291cmNlIGZpbGVzLCBidWlsZCBzY3JpcHRzIGFuZCBkb2N1bWVudGF0aW9uLgoKIlJlc2VydmVkIEZvbnQgTmFtZSIgcmVmZXJzIHRvIGFueSBuYW1lcyBzcGVjaWZpZWQgYXMgc3VjaCBhZnRlciB0aGUKY29weXJpZ2h0IHN0YXRlbWVudChzKS4KCiJPcmlnaW5hbCBWZXJzaW9uIiByZWZlcnMgdG8gdGhlIGNvbGxlY3Rpb24gb2YgRm9udCBTb2Z0d2FyZSBjb21wb25lbnRzIGFzCmRpc3RyaWJ1dGVkIGJ5IHRoZSBDb3B5cmlnaHQgSG9sZGVyKHMpLgoKIk1vZGlmaWVkIFZlcnNpb24iIHJlZmVycyB0byBhbnkgZGVyaXZhdGl2ZSBtYWRlIGJ5IGFkZGluZyB0bywgZGVsZXRpbmcsCm9yIHN1YnN0aXR1dGluZyAtLSBpbiBwYXJ0IG9yIGluIHdob2xlIC0tIGFueSBvZiB0aGUgY29tcG9uZW50cyBvZiB0aGUKT3JpZ2luYWwgVmVyc2lvbiwgYnkgY2hhbmdpbmcgZm9ybWF0cyBvciBieSBwb3J0aW5nIHRoZSBGb250IFNvZnR3YXJlIHRvIGEKbmV3IGVudmlyb25tZW50LgoKIkF1dGhvciIgcmVmZXJzIHRvIGFueSBkZXNpZ25lciwgZW5naW5lZXIsIHByb2dyYW1tZXIsIHRlY2huaWNhbAp3cml0ZXIgb3Igb3RoZXIgcGVyc29uIHdobyBjb250cmlidXRlZCB0byB0aGUgRm9udCBTb2Z0d2FyZS4KClBFUk1JU1NJT04gJiBDT05ESVRJT05TClBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZwphIGNvcHkgb2YgdGhlIEZvbnQgU29mdHdhcmUsIHRvIHVzZSwgc3R1ZHksIGNvcHksIG1lcmdlLCBlbWJlZCwgbW9kaWZ5LApyZWRpc3RyaWJ1dGUsIGFuZCBzZWxsIG1vZGlmaWVkIGFuZCB1bm1vZGlmaWVkIGNvcGllcyBvZiB0aGUgRm9udApTb2Z0d2FyZSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CgoxKSBOZWl0aGVyIHRoZSBGb250IFNvZnR3YXJlIG5vciBhbnkgb2YgaXRzIGluZGl2aWR1YWwgY29tcG9uZW50cywKaW4gT3JpZ2luYWwgb3IgTW9kaWZpZWQgVmVyc2lvbnMsIG1heSBiZSBzb2xkIGJ5IGl0c2VsZi4KCjIpIE9yaWdpbmFsIG9yIE1vZGlmaWVkIFZlcnNpb25zIG9mIHRoZSBGb250IFNvZnR3YXJlIG1heSBiZSBidW5kbGVkLApyZWRpc3RyaWJ1dGVkIGFuZC9vciBzb2xkIHdpdGggYW55IHNvZnR3YXJlLCBwcm92aWRlZCB0aGF0IGVhY2ggY29weQpjb250YWlucyB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBsaWNlbnNlLiBUaGVzZSBjYW4gYmUKaW5jbHVkZWQgZWl0aGVyIGFzIHN0YW5kLWFsb25lIHRleHQgZmlsZXMsIGh1bWFuLXJlYWRhYmxlIGhlYWRlcnMgb3IKaW4gdGhlIGFwcHJvcHJpYXRlIG1hY2hpbmUtcmVhZGFibGUgbWV0YWRhdGEgZmllbGRzIHdpdGhpbiB0ZXh0IG9yCmJpbmFyeSBmaWxlcyBhcyBsb25nIGFzIHRob3NlIGZpZWxkcyBjYW4gYmUgZWFzaWx5IHZpZXdlZCBieSB0aGUgdXNlci4KCjMpIE5vIE1vZGlmaWVkIFZlcnNpb24gb2YgdGhlIEZvbnQgU29mdHdhcmUgbWF5IHVzZSB0aGUgUmVzZXJ2ZWQgRm9udApOYW1lKHMpIHVubGVzcyBleHBsaWNpdCB3cml0dGVuIHBlcm1pc3Npb24gaXMgZ3JhbnRlZCBieSB0aGUgY29ycmVzcG9uZGluZwpDb3B5cmlnaHQgSG9sZGVyLiBUaGlzIHJlc3RyaWN0aW9uIG9ubHkgYXBwbGllcyB0byB0aGUgcHJpbWFyeSBmb250IG5hbWUgYXMKcHJlc2VudGVkIHRvIHRoZSB1c2Vycy4KCjQpIFRoZSBuYW1lKHMpIG9mIHRoZSBDb3B5cmlnaHQgSG9sZGVyKHMpIG9yIHRoZSBBdXRob3Iocykgb2YgdGhlIEZvbnQKU29mdHdhcmUgc2hhbGwgbm90IGJlIHVzZWQgdG8gcHJvbW90ZSwgZW5kb3JzZSBvciBhZHZlcnRpc2UgYW55Ck1vZGlmaWVkIFZlcnNpb24sIGV4Y2VwdCB0byBhY2tub3dsZWRnZSB0aGUgY29udHJpYnV0aW9uKHMpIG9mIHRoZQpDb3B5cmlnaHQgSG9sZGVyKHMpIGFuZCB0aGUgQXV0aG9yKHMpIG9yIHdpdGggdGhlaXIgZXhwbGljaXQgd3JpdHRlbgpwZXJtaXNzaW9uLgoKNSkgVGhlIEZvbnQgU29mdHdhcmUsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQsIGluIHBhcnQgb3IgaW4gd2hvbGUsCm11c3QgYmUgZGlzdHJpYnV0ZWQgZW50aXJlbHkgdW5kZXIgdGhpcyBsaWNlbnNlLCBhbmQgbXVzdCBub3QgYmUKZGlzdHJpYnV0ZWQgdW5kZXIgYW55IG90aGVyIGxpY2Vuc2UuIFRoZSByZXF1aXJlbWVudCBmb3IgZm9udHMgdG8KcmVtYWluIHVuZGVyIHRoaXMgbGljZW5zZSBkb2VzIG5vdCBhcHBseSB0byBhbnkgZG9jdW1lbnQgY3JlYXRlZAp1c2luZyB0aGUgRm9udCBTb2Z0d2FyZS4KClRFUk1JTkFUSU9OClRoaXMgbGljZW5zZSBiZWNvbWVzIG51bGwgYW5kIHZvaWQgaWYgYW55IG9mIHRoZSBhYm92ZSBjb25kaXRpb25zIGFyZQpub3QgbWV0LgoKRElTQ0xBSU1FUgpUSEUgRk9OVCBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELApFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gQU5ZIFdBUlJBTlRJRVMgT0YKTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5UCk9GIENPUFlSSUdIVCwgUEFURU5ULCBUUkFERU1BUkssIE9SIE9USEVSIFJJR0hULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUKQ09QWVJJR0hUIEhPTERFUiBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksCklOQ0xVRElORyBBTlkgR0VORVJBTCwgU1BFQ0lBTCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIE9SIENPTlNFUVVFTlRJQUwKREFNQUdFUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HCkZST00sIE9VVCBPRiBUSEUgVVNFIE9SIElOQUJJTElUWSBUTyBVU0UgVEhFIEZPTlQgU09GVFdBUkUgT1IgRlJPTQpPVEhFUiBERUFMSU5HUyBJTiBUSEUgRk9OVCBTT0ZUV0FSRS4AAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAAAaHR0cDovL3NjcmlwdHMuc2lsLm9yZy9PRkwAAEEAbgBuAGEAIABTAGgAdQBnAG8AbAAgAG4AYQBtAGUAIABmAG8AbgB0ACAAZgBhAGMAZQA7AAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ACgBUAGgAZQAgAHEAdQBpAGMAawAgAGIAcgBvAHcAbgAgAGYAbwB4ACAAagB1AG0AcABzACAAbwB2AGUAcgAgAHQAaABlACAAbABhAHoAeQAgAGQAbwBnAC4ACgAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAKACMAaQBmACAAKABQAEwAQQBUAEYATwBSAE0AIAAmACAAKABQAEwAQQBUAEYATwBSAE0AXwBNAFMAQwB8AFAATABBAFQARgBPAFIATQBfAEEAUwBNAF8ASQBOAFQARQBMACkAKQA9AD0AKABQAEwAQQBUAEYATwBSAE0AXwBNAFMAQwB8AFAATABBAFQARgBPAFIATQBfAEEAUwBNAF8ASQBOAFQARQBMACkACgAJAC8AKgAgAGMAbwBtAHAAaQBsAGUAcgAgAGIAYQByAHIAaQBlAHIAIABwAHIAZQB2AGUAbgB0AHMAIABvAHAAdABpAG0AaQB6AGUAcgAgAGYAcgBvAG0AIABtAG8AdgBpAG4AZwAgAGMAbwBkAGUAIABsAGkAbgBlAHMAIABvAHYAZQByACAAdABoAGkAcwAgAGIAYQByAHIAaQBlAHIAIAAqAC8ACgAJACMAZABlAGYAaQBuAGUAIABDAEIAKAApAAkACQAJAAkAXwBfAGEAcwBtACAAewB9AAoACQAvACoAIABtAGUAbQBvAHIAeQAgAGIAYQByAHIAaQBlAHIAIABlAG4AZgBvAHIAYwBlAHMAIABhAGwAbAAgAHAAcgBvAGMAZQBzAHMAbwByACAAbABvAGEAZAAgAG8AcABlAHIAYQB0AGkAbwBuAHMAIAB0AG8AIABiAGUAIABlAG4AZABlAGQAIABiAGUAZgBvAHIAZQAgAHQAaABpAHMAIABsAGkAbgBlACAAKgAvAAoACQAjAGQAZQBmAGkAbgBlACAATQBCACgAKQAJAAkACQAJAF8AXwBhAHMAbQAgAGwAbwBjAGsAIABhAGQAZAAgAHEAdwBvAHIAZAAgAHAAdAByACAAWwByAHMAcABdACwAIAAwADsACgAKAAkAXwBfAGYAbwByAGMAZQBpAG4AbABpAG4AZQAgAGMAaABhAHIAIABpAG4AbABpAG4AZQBfAGUAeABjAGgAZwBfAG8AbgBlACgAdgBvAGwAYQB0AGkAbABlACAAYwBoAGEAcgAqACAAcAByAHYAKQAKAAkAewAKAAkACQBfAF8AYQBzAG0AIAB7AAoACQAJAAkAbQBvAHYACQAJAF8AXwBQAG8AaQBuAHQAZQByAFIARQBHAF8AXwAsACAAcAByAHYACgAJAAkACQBtAG8AdgAJAAkAYQBsACwAIAAxAAoACQAJAAkAbABvAGMAawAgAHgAYwBoAGcACQBbAF8AXwBQAG8AaQBuAHQAZQByAFIARQBHAF8AXwBdACwAIABhAGwACgAJAAkAfQAKAAkAfQAKACMAZQBsAGkAZgAgACgAUABMAEEAVABGAE8AUgBNACAAJgAgACgAUABMAEEAVABGAE8AUgBNAF8ARwBDAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEEAVABUACkAKQA9AD0AKABQAEwAQQBUAEYATwBSAE0AXwBHAEMAQwB8AFAATABBAFQARgBPAFIATQBfAEEAUwBNAF8AQQBUAFQAKQAKAAkAIwBkAGUAZgBpAG4AZQAgAEMAQgAoACkACQAJAAkACQBhAHMAbQAgAHYAbwBsAGEAdABpAGwAZQAoACIAIgA6ADoAOgAiAG0AZQBtAG8AcgB5ACIAKQAKAAkAIwBkAGUAZgBpAG4AZQAgAE0AQgAoACkACQAJAAkACQBhAHMAbQAgAHYAbwBsAGEAdABpAGwAZQAoACIAbABvAGMAawAgAGEAZABkAHEAXAB0ACQAMAAsACAAKAAlAHIAcwBwACkAIgA6ADoAOgAiAG0AZQBtAG8AcgB5ACIAKQAKAAkAIwBkAGUAZgBpAG4AZQAgAG0AYQBjAHIAbwBfAHMAbQBwAF8AZQB4AGMAaABnAF8AMQAoAHIAdgApAAkACQAoAHsAdAB5AHAAZQBvAGYAKAByAHYAKQAgAHQAbQBwADsAIABcAAoACQAJAGEAcwBtACAAdgBvAGwAYQB0AGkAbABlACgAIgBtAG8AdgBcAHQAJAAxACwAIAAlADAAXABuAFwAdABsAG8AYwBrACAAeABjAGgAZwAgACUAMAAsACAAKAAlADIAKQAiADoAIgA9AHIAIgAoAHQAbQBwACkAOgAiADAAIgAoAHQAbQBwACkALAAiAHIAIgAoACYAKAByAHYAKQApADoAIgAwACIAKQA7ACAAXAAKAAkACQB0AG0AcAA7AH0AKQAKACMAZQBuAGQAaQBmAABBbm5hIFNodWdvbCBuYW1lIGZvbnQgZmFjZTsKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tClRoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojaWYgKFBMQVRGT1JNICYgKFBMQVRGT1JNX01TQ3xQTEFURk9STV9BU01fSU5URUwpKT09KFBMQVRGT1JNX01TQ3xQTEFURk9STV9BU01fSU5URUwpCgkvKiBjb21waWxlciBiYXJyaWVyIHByZXZlbnRzIG9wdGltaXplciBmcm9tIG1vdmluZyBjb2RlIGxpbmVzIG92ZXIgdGhpcyBiYXJyaWVyICovCgkjZGVmaW5lIENCKCkJCQkJX19hc20ge30KCS8qIG1lbW9yeSBiYXJyaWVyIGVuZm9yY2VzIGFsbCBwcm9jZXNzb3IgbG9hZCBvcGVyYXRpb25zIHRvIGJlIGVuZGVkIGJlZm9yZSB0aGlzIGxpbmUgKi8KCSNkZWZpbmUgTUIoKQkJCQlfX2FzbSBsb2NrIGFkZCBxd29yZCBwdHIgW3JzcF0sIDA7CgoJX19mb3JjZWlubGluZSBjaGFyIGlubGluZV9leGNoZ19vbmUodm9sYXRpbGUgY2hhciogcHJ2KQoJewoJCV9fYXNtIHsKCQkJbW92CQlfX1BvaW50ZXJSRUdfXywgcHJ2CgkJCW1vdgkJYWwsIDEKCQkJbG9jayB4Y2hnCVtfX1BvaW50ZXJSRUdfX10sIGFsCgkJfQoJfQojZWxpZiAoUExBVEZPUk0gJiAoUExBVEZPUk1fR0NDfFBMQVRGT1JNX0FTTV9BVFQpKT09KFBMQVRGT1JNX0dDQ3xQTEFURk9STV9BU01fQVRUKQoJI2RlZmluZSBDQigpCQkJCWFzbSB2b2xhdGlsZSgiIjo6OiJtZW1vcnkiKQoJI2RlZmluZSBNQigpCQkJCWFzbSB2b2xhdGlsZSgibG9jayBhZGRxXHQkMCwgKCVyc3ApIjo6OiJtZW1vcnkiKQoJI2RlZmluZSBtYWNyb19zbXBfZXhjaGdfMShydikJCSh7dHlwZW9mKHJ2KSB0bXA7IFwKCQlhc20gdm9sYXRpbGUoIm1vdlx0JDEsICUwXG5cdGxvY2sgeGNoZyAlMCwgKCUyKSI6Ij1yIih0bXApOiIwIih0bXApLCJyIigmKHJ2KSk6IjAiKTsgXAoJCXRtcDt9KQojZW5kaWYABBMEQARDBD8EPwQwACAESARABDgERARCBD4EMgAgBDgEPAQ1BD0EOAAgBBAEPQQ9BEsAIAQoBEMEMwQ+BDsETAA7AAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ACgQoBDgEQAQ+BDoEMARPACAETQQ7BDUEOgRCBEAEOAREBDgEOgQwBEYEOARPACAETgQ2BD0ESwRFACAEMwRDBDEENQRABD0EOAQ5ACAENAQwBEEEQgAgBDwEPgRJBD0ESwQ5ACAEQgQ+BDsERwQ+BDoAIAQ/BD4ENARKBFEEPARDACAEQQQ1BDsETARBBDoEPgQzBD4AIARFBD4ENwRPBDkEQQRCBDIEMAAuAAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ACgAjAGkAZgAgACgAUABMAEEAVABGAE8AUgBNACAAJgAgACgAUABMAEEAVABGAE8AUgBNAF8ATQBTAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEkATgBUAEUATAApACkAPQA9ACgAUABMAEEAVABGAE8AUgBNAF8ATQBTAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEkATgBUAEUATAApAAoACQAvACoAIABjAG8AbQBwAGkAbABlAHIAIABiAGEAcgByAGkAZQByACAAcAByAGUAdgBlAG4AdABzACAAbwBwAHQAaQBtAGkAegBlAHIAIABmAHIAbwBtACAAbQBvAHYAaQBuAGcAIABjAG8AZABlACAAbABpAG4AZQBzACAAbwB2AGUAcgAgAHQAaABpAHMAIABiAGEAcgByAGkAZQByACAAKgAvAAoACQAjAGQAZQBmAGkAbgBlACAAQwBCACgAKQAJAAkACQAJAF8AXwBhAHMAbQAgAHsAfQAKAAkALwAqACAAbQBlAG0AbwByAHkAIABiAGEAcgByAGkAZQByACAAZQBuAGYAbwByAGMAZQBzACAAYQBsAGwAIABwAHIAbwBjAGUAcwBzAG8AcgAgAGwAbwBhAGQAIABvAHAAZQByAGEAdABpAG8AbgBzACAAdABvACAAYgBlACAAZQBuAGQAZQBkACAAYgBlAGYAbwByAGUAIAB0AGgAaQBzACAAbABpAG4AZQAgACoALwAKAAkAIwBkAGUAZgBpAG4AZQAgAE0AQgAoACkACQAJAAkACQBfAF8AYQBzAG0AIABsAG8AYwBrACAAYQBkAGQAIABxAHcAbwByAGQAIABwAHQAcgAgAFsAcgBzAHAAXQAsACAAMAA7AAoACgAJAF8AXwBmAG8AcgBjAGUAaQBuAGwAaQBuAGUAIABjAGgAYQByACAAaQBuAGwAaQBuAGUAXwBlAHgAYwBoAGcAXwBvAG4AZQAoAHYAbwBsAGEAdABpAGwAZQAgAGMAaABhAHIAKgAgAHAAcgB2ACkACgAJAHsACgAJAAkAXwBfAGEAcwBtACAAewAKAAkACQAJAG0AbwB2AAkACQBfAF8AUABvAGkAbgB0AGUAcgBSAEUARwBfAF8ALAAgAHAAcgB2AAoACQAJAAkAbQBvAHYACQAJAGEAbAAsACAAMQAKAAkACQAJAGwAbwBjAGsAIAB4AGMAaABnAAkAWwBfAF8AUABvAGkAbgB0AGUAcgBSAEUARwBfAF8AXQAsACAAYQBsAAoACQAJAH0ACgAJAH0ACgAjAGUAbABpAGYAIAAoAFAATABBAFQARgBPAFIATQAgACYAIAAoAFAATABBAFQARgBPAFIATQBfAEcAQwBDAHwAUABMAEEAVABGAE8AUgBNAF8AQQBTAE0AXwBBAFQAVAApACkAPQA9ACgAUABMAEEAVABGAE8AUgBNAF8ARwBDAEMAfABQAEwAQQBUAEYATwBSAE0AXwBBAFMATQBfAEEAVABUACkACgAJACMAZABlAGYAaQBuAGUAIABDAEIAKAApAAkACQAJAAkAYQBzAG0AIAB2AG8AbABhAHQAaQBsAGUAKAAiACIAOgA6ADoAIgBtAGUAbQBvAHIAeQAiACkACgAJACMAZABlAGYAaQBuAGUAIABNAEIAKAApAAkACQAJAAkAYQBzAG0AIAB2AG8AbABhAHQAaQBsAGUAKAAiAGwAbwBjAGsAIABhAGQAZABxAFwAdAAkADAALAAgACgAJQByAHMAcAApACIAOgA6ADoAIgBtAGUAbQBvAHIAeQAiACkACgAJACMAZABlAGYAaQBuAGUAIABtAGEAYwByAG8AXwBzAG0AcABfAGUAeABjAGgAZwBfADEAKAByAHYAKQAJAAkAKAB7AHQAeQBwAGUAbwBmACgAcgB2ACkAIAB0AG0AcAA7ACAAXAAKAAkACQBhAHMAbQAgAHYAbwBsAGEAdABpAGwAZQAoACIAbQBvAHYAXAB0ACQAMQAsACAAJQAwAFwAbgBcAHQAbABvAGMAawAgAHgAYwBoAGcAIAAlADAALAAgACgAJQAyACkAIgA6ACIAPQByACIAKAB0AG0AcAApADoAIgAwACIAKAB0AG0AcAApACwAIgByACIAKAAmACgAcgB2ACkAKQA6ACIAMAAiACkAOwAgAFwACgAJAAkAdABtAHAAOwB9ACkACgAjAGUAbgBkAGkAZgAAAAAAAAIAAAAAAAD9+wCWAAAAAQAAAAAAAAAAAAAAAAAAAAACbAAAAAEAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEArACjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAECAIoA2gCDAJMA8gDzAI0BAwCIAMMA3gDxAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAM8AzADNAM4A6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBBAEFAQYBBwEIAQkA/QD+AQoBCwEMAQ0A/wEAAQ4BDwEQAQEBEQESARMBFAEVARYBFwEYARkBGgEbARwA+AD5AR0BHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwA+gDXAS0BLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7AOIA4wE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgCwALEBSwFMAU0BTgFPAVABUQFSAVMBVAD7APwA5ADlAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoAuwFrAWwBbQFuAOYA5wFvAKYBcADYAOEBcQFyANsA3ADdAOAA2QDfAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgACoAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMAnwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQCXAaYBpwGoAJsBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZALYAtwDEAhoAtAC1AMUAggDCAIcAqwIbAhwAvgC/ALwCHQIeAh8CIACMAiECIgIjAiQCJQImAicA7wIoAKUAkgIpAioCKwCUAJUCLAItAi4CLwIwAjECMgIzAjQCNQI2AjcCOAI5AjoCOwI8Aj0CPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAC5AmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngKc29mdGh5cGhlbgVtaWNybwdBbWFjcm9uB2FtYWNyb24GQWJyZXZlBmFicmV2ZQdBb2dvbmVrB2FvZ29uZWsLQ2NpcmN1bWZsZXgLY2NpcmN1bWZsZXgKQ2RvdGFjY2VudApjZG90YWNjZW50BkRjYXJvbgZkY2Fyb24GRGNyb2F0B0VtYWNyb24HZW1hY3JvbgZFYnJldmUGZWJyZXZlCkVkb3RhY2NlbnQKZWRvdGFjY2VudAdFb2dvbmVrB2VvZ29uZWsGRWNhcm9uBmVjYXJvbgtHY2lyY3VtZmxleAtnY2lyY3VtZmxleApHZG90YWNjZW50Cmdkb3RhY2NlbnQIR2NlZGlsbGEIZ2NlZGlsbGELSGNpcmN1bWZsZXgLaGNpcmN1bWZsZXgESGJhcgRoYmFyBkl0aWxkZQZpdGlsZGUHSW1hY3JvbgdpbWFjcm9uBklicmV2ZQZpYnJldmUHSW9nb25lawdpb2dvbmVrAklKAmlqC0pjaXJjdW1mbGV4C2pjaXJjdW1mbGV4CEtjZWRpbGxhCGtjZWRpbGxhDGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlCExjZWRpbGxhCGxjZWRpbGxhBkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUITmNlZGlsbGEIbmNlZGlsbGEGTmNhcm9uBm5jYXJvbgtuYXBvc3Ryb3BoZQNFbmcDZW5nB09tYWNyb24Hb21hY3JvbgZPYnJldmUGb2JyZXZlDU9odW5nYXJ1bWxhdXQNb2h1bmdhcnVtbGF1dAZSYWN1dGUGcmFjdXRlCFJjZWRpbGxhCHJjZWRpbGxhBlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAhUY2VkaWxsYQh0Y2VkaWxsYQZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50BHpkb3QFc2xvbmcIZG90bGVzc2oObWFjcm9ubW9kaWZpZXINZ3JhdmVtb2RpZmllcglncmF2ZWNvbWIJYWN1dGVjb21iCXRpbGRlY29tYgtkaWVyZXNpc2NtYg1ob29rYWJvdmVjb21iCWNhcm9uY29tYhNjb21tYXR1cm5lZGFib3ZlY21iEmNvbW1hYWJvdmVyaWdodGNtYgxkb3RiZWxvd2NvbWIMY29tbWFzdWJub3NwBXRvbm9zBUFscGhhBEJldGEFR2FtbWEHRXBzaWxvbgRaZXRhA0V0YQVUaGV0YQRJb3RhBUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQxJb3RhZGllcmVzaXMPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGECbnUCeGkHb21pY3JvbgNyaG8Kc2lnbWFmaW5hbAVzaWdtYQN0YXUHdXBzaWxvbgNwaGkDY2hpA3BzaQVvbWVnYQxpb3RhZGllcmVzaXMPdXBzaWxvbmRpZXJlc2lzDG9taWNyb250b25vcwx1cHNpbG9udG9ub3MKb21lZ2F0b25vcwdEaWdhbW1hC3NpZ21hbHVuYXRlCHlvdGdyZWVrCk5hbWVNZS40MzIKSW9jeXJpbGxpYwtEamVjeXJpbGxpYwtHamVjeXJpbGxpYwlFY3lyaWxsaWMLRHplY3lyaWxsaWMJSWN5cmlsbGljCllpY3lyaWxsaWMKSmVjeXJpbGxpYwtMamVjeXJpbGxpYwtOamVjeXJpbGxpYwxUc2hlY3lyaWxsaWMLS2plY3lyaWxsaWMYSWljeXJpbGxpY19ncmF2ZW1vZGlmaWVyDlVzaG9ydGN5cmlsbGljDER6aGVjeXJpbGxpYwlBY3lyaWxsaWMKQmVjeXJpbGxpYwpWZWN5cmlsbGljCkdlY3lyaWxsaWMKRGVjeXJpbGxpYwpJZWN5cmlsbGljC1poZWN5cmlsbGljClplY3lyaWxsaWMKSWljeXJpbGxpYw9JaXNob3J0Y3lyaWxsaWMKS2FjeXJpbGxpYwpFbGN5cmlsbGljCkVtY3lyaWxsaWMKRW5jeXJpbGxpYwlPY3lyaWxsaWMKUGVjeXJpbGxpYwpFcmN5cmlsbGljCkVzY3lyaWxsaWMKVGVjeXJpbGxpYwlVY3lyaWxsaWMKRWZjeXJpbGxpYwtLaGFjeXJpbGxpYwtUc2VjeXJpbGxpYwtDaGVjeXJpbGxpYwtTaGFjeXJpbGxpYw1TaGNoYWN5cmlsbGljEEhhcmRzaWduY3lyaWxsaWMMWWVyaWN5cmlsbGljEFNvZnRzaWduY3lyaWxsaWMRRXJldmVyc2VkY3lyaWxsaWMKSVVjeXJpbGxpYwpJQWN5cmlsbGljCWFjeXJpbGxpYwpiZWN5cmlsbGljCnZlY3lyaWxsaWMKZ2VjeXJpbGxpYwpkZWN5cmlsbGljCmllY3lyaWxsaWMLemhlY3lyaWxsaWMKemVjeXJpbGxpYwppaWN5cmlsbGljD2lpc2hvcnRjeXJpbGxpYwprYWN5cmlsbGljCmVsY3lyaWxsaWMKZW1jeXJpbGxpYwplbmN5cmlsbGljCW9jeXJpbGxpYwpwZWN5cmlsbGljCmVyY3lyaWxsaWMKZXNjeXJpbGxpYwp0ZWN5cmlsbGljCXVjeXJpbGxpYwplZmN5cmlsbGljC2toYWN5cmlsbGljC3RzZWN5cmlsbGljC2NoZWN5cmlsbGljC3NoYWN5cmlsbGljDXNoY2hhY3lyaWxsaWMQaGFyZHNpZ25jeXJpbGxpYwx5ZXJpY3lyaWxsaWMQc29mdHNpZ25jeXJpbGxpYxFlcmV2ZXJzZWRjeXJpbGxpYwppdWN5cmlsbGljCmlhY3lyaWxsaWMKTmFtZU1lLjUxMgppb2N5cmlsbGljC2RqZWN5cmlsbGljC2dqZWN5cmlsbGljCWVjeXJpbGxpYwtkemVjeXJpbGxpYwlpY3lyaWxsaWMKeWljeXJpbGxpYwpqZWN5cmlsbGljC2xqZWN5cmlsbGljC25qZWN5cmlsbGljDHRzaGVjeXJpbGxpYwtramVjeXJpbGxpYxhpaWN5cmlsbGljX2dyYXZlbW9kaWZpZXIOdXNob3J0Y3lyaWxsaWMMZHpoZWN5cmlsbGljEWFwb3N0cm9waGVyZXZlcnNlBm1pbnV0ZQZzZWNvbmQHdW5pMjA3NAluc3VwZXJpb3IEZXVybwZudW1lcm8JYXJyb3dsZWZ0B3VwYXJyb3cKYXJyb3dyaWdodAlkb3duYXJyb3cJYXJyb3dib3RoCmFycm93Ym90aHYOdXBkb3duYXJyb3diYXIOYnVsbGV0b3BlcmF0b3IMaW50ZXJzZWN0aW9uC2FsbW9zdGVxdWFsC2VxdWl2YWxlbmNlDXJldmxvZ2ljYWxub3QKaW50ZWdyYWx0cAppbnRlZ3JhbGJ0DHNwYWNlb3BlbmJveAtsdGhvcml6Zm9ybQpsdHZlcnRmb3JtDHJpZ2h0YW5nbGVudwxyaWdodGFuZ2xlbmUMcmlnaHRhbmdsZXN3DHJpZ2h0YW5nbGVzZQ9sdHZlcnRyaWdodGZvcm0ObHR2ZXJ0bGVmdGZvcm0NbHRkbmhvcml6Zm9ybQ1sdHVwaG9yaXpmb3JtD2x0dmVydGhvcml6Zm9ybQtob3JpemRibGJhcgp2ZXJ0ZGJsYmFyC2RucnRkYmxmb3JtC2RuZGJscnRmb3JtC2RibGRucnRmb3JtDWRubGVmdGRibGZvcm0NZG5kYmxsZWZ0Zm9ybQ1kYmxkbmxlZnRmb3JtC3VwcnRkYmxmb3JtC3VwZGJscnRmb3JtC2RibHVwcnRmb3JtDXVwbGVmdGRibGZvcm0NdXBkYmxsZWZ0Zm9ybQ1kYmx1cGxlZnRmb3JtDXZlcnRydGRibGZvcm0NdmVydGRibHJ0Zm9ybQ1kYmx2ZXJ0cnRmb3JtD3ZlcnRsZWZ0ZGJsZm9ybQ92ZXJ0ZGJsbGVmdGZvcm0PZGJsdmVydGxlZnRmb3JtDmRuaG9yaXpkYmxmb3JtDmRuZGJsaG9yaXpmb3JtDmRibGRuaG9yaXpmb3JtDnVwaG9yaXpkYmxmb3JtDnVwZGJsaG9yaXpmb3JtDmRibHVwaG9yaXpmb3JtEHZlcnRob3JpemRibGZvcm0QdmVydGRibGhvcml6Zm9ybRBkYmx2ZXJ0aG9yaXpmb3JtB3VwYmxvY2sHZG5ibG9jawVibG9jawdsZmJsb2NrB3J0YmxvY2sKc2hhZGVsaWdodAtzaGFkZW1lZGl1bQlzaGFkZWRhcmsLYmxhY2tzcXVhcmULd2hpdGVzcXVhcmUQYmxhY2tzbWFsbHNxdWFyZRB3aGl0ZXNtYWxsc3F1YXJlDmJsYWNrcmVjdGFuZ2xlB3RyaWFndXAHdHJpYWdydAd0cmlhZ2RuB3RyaWFnbGYLd2hpdGVjaXJjbGULYmxhY2tjaXJjbGUNYnVsbGV0aW52ZXJzZRJ3aGl0ZWNpcmNsZWludmVyc2ULd2hpdGVidWxsZXQJc21pbGVmYWNlDGludnNtaWxlZmFjZQdjb21wYXNzBmZlbWFsZQRtYWxlBXNwYWRlBGNsdWIFaGVhcnQHZGlhbW9uZAttdXNpY2Fsbm90ZQ5tdXNpY2Fsbm90ZWRibAAAAAADAAgAAgARAAH//wADAAEAAAAMAAAAFgAAAAIAAQABAmsAAQAEAAAAAgAAAAAAAQAAAAgAAAAAAAQAAAAAAAAAAQAAAADUGBYRAAAAAMdG5I4AAAAAzK7WNg=="},function(A,e){A.exports="data:application/font-woff;base64,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"},function(A,e){A.exports="data:application/font-woff2;base64,d09GMgABAAAAAGcsABEAAAABAFAAAGbGAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQ4/RkZUTRwaHgZgAIk2CBgJgUcREAqCmxSB6UwLiVoAATYCJAOJYAQgBYGZdQencwwoG4LhN9Db9gjF7QB2/1x/19kI2+1ASkRb8oLp5uK5HfQ94v4Zs////6wEFWOsvRNnARJTzf4LJAQSjAPBWMgVtdpQDbhTK8jDLxpNIGub2t9W1XH2rvMaY4wRW8vQnU07swtM7YRLzNOh8sG7kyFuIYvkdrB2yj2PZsYSVjohQwCBrMlexqKx+KbYRvqtTnok/qmF84qEThxi8UOY4d/F+i/O8MOZRcbpAi5FCg+JSWE1VZ+0p5R3mS2rxzup+S/9ruIaCW08CRYR7Z89zq5BOEps6SrAbskOkSK3UtzTRJjaSbIdwBFnwFk7QuT2nxsPz7utp6WVmsp3oSJuEAUXKqCgrKEiwhZRHCDiHjlWpabpy2w5y2xfY9uVrbtrLO+urlt1dWt1s7vioX4Nfbv/7gKlm6rYEqgqQEWgqmQtOcu6qrIu4wvkGqGzGwAmqqY/OpMgALGLcmtySq3LkCnLmnn7LUv4q0nnZlVnK+6RmrOvarnAHqFujAlTE8SqDB6hdMVvdu1rKySMpL1+v4VogybT3UJ+hvcVhk5JhPjflgohi91559KhzLn+BNH//zE3sdCWRENRKVX6zk5fFKTT8IRnqKJ+3xdE/A/MM8QwhirqxsTNiAIMLNGEJ3kc6Vrz1757EGCbEKrLENHH8GE6Pd6db4SIKSyh8QIVD4EouS+dfVWtXNWNzE/5mDeEdN99LYk0lhlsHBgv38OfRaIuktmIdo4bU8awIR7OsQkAJkBeU1WyKRIPuNRlSlv23J4p94hXiVE5CWxnHbNlcF6oL3HWLXh65+z7bnVqYw3syZYvg1wKaPyM75+/Zvz6fr7e0GOgE1C714mKlvGssMfpRAiYbUhoErDH9v9sWqXdann43sqLnuMFLfDsBYnnEJL4Xn7Vv6q6u6q6BS3JtrqtGY095PaAJS/Ynp17lodk2Hv2EqFhwTPLhOndZocURHdBilHMHGTJRcB+/9P6xJrePrO0zwK0ZwkMDhEgI66uqvuq9evXfxtSf1luhzjjEFF8QZqvVs/MxoQcsAE35cYwZMZ8/3P/ZjN3Mucl/5WmlAKlgLr+t1a9Sy/NmzufOEVaAEqFXyeIVF2PX7vOrFt4/rl3GvW+hZne2oh/7tbCgDqevexjGHl7WbOaEAQbOzLYUKkRfO5dv99P6w2kbHNbM6wiIo44lKCXmFxp+d26jC0q76PCSEoFZLCBu3sTex+TnXd5lNCFEIKIiMvE9Z9dd9ym/pvpfm2v9LR1exAEQRgwcwRD0zxCedl8JhayWSaKaI3Q8qbJzG4hJ4cKAuAEACgA4B7u7iRGLXq8cOftEABw9cP90dJ5vQASM4bFEneBDdRxAZQsji1WwclZ1W2AUjycHrnFlIi2Y492sWZmNZLtD2DQHri8YEo9T4sB7wo4bbU3RUyAQ3OHkgAs2NUAKOiBAAiZnOBYpOSF4K2Clj+KV/NMACttYI+Qtmin0aTwjXwvP8hPh42IuMQr8cVDggUn3WN63BlPx+8qJ4QNCArABZADEgO4ATUB7QEHj56BQYHjx4UTEuQThA0iBAmDjEEao/gvDpMYwcdwKBg4JNTM3Pz5kaxoZOP2ev+rZjzgl6kojolj43Jx+TgTzvr2LSBkipxyvfDjAYZ2Fo6M2UX+pkBoJyDgA2MDaMqWvt5ywZsX0DdjoS3T1LQoX5Yf9i0cKMQVn7X9z16xR9sbGV6t1VIVlV5pJSpBsYtZ5EiuCqV21aJaUMOqX3XI6a9QE5LktlyTs7JFbpI54k9xJ2qiRKzicfyXP/NtPszPcGdmqcidB+bo3CNHchfykkYEX3gGYRkLmMUUxvEOFjGP3dgFiBEMoRdNwGchWXBmDwUBdAYIl4MNu9EK0ZyLwG8+a0Yh2Tf/GRBOuOCGB1744EcAQSgIN+48ePKC5s2HLww/WP4CBAoSLEQoHLwwBOEiEJFEihItRiyyOPESUFDRJEpCx5AsBRMLGwcXD5+AkIiYRKo06aQyyGSSU1BSUdPQ0smil80gRy4jgPH6DNhkqwm7zZoxZ695++x3wKKDDjnisKOOOe6kE04547QLzrtoKQF6K1DIkrYYaFoFa65Hf8UAJppMNKoTw34wqwcAgCYA6KolKrDgnA75ytKL2OwDgG5acxVa69RjW7iTBwBAcfSG/qF/cTazcDkSeS172LADAJgwKF7TWwBjbdZl0EbDthgxZBwEMNdOu+zwe3ApFZUhJBGJ0RRpJCFe5JSNyMD0aA6lhonsVOuHuDNq54z4aeb28Gi2DM3Ryv21RxF8C33URDRkaItHsVUb8GgnuUWhSUdviKGAJ9E7bURTzb4wQTDfWBxQsyCP6hsYqDWdaklHbxGrZGp4wdpA1WVH7IQOOPqlpibw6JekDWJ7dQKDA5s0n/peK1RL0pr/fb/tRjBlzKOvOlq+vxZNETTJSxN9+sZr74a462TT/6zh0VD/36a+R2daJVnl0rfkJESMjwqgRZEG56ROMOKxsXbLXAju+lJAPQT4IJDhBgB5/gF4GXBeBBA1+PPy1V6g5THBIQAqOrOvCdhOEGAGqFyt+XOlyChnJMiASYYb2C7QWMtOsSpj1UZB8kvxaXTxNZC8JN5ITIlWzqdeTteoU4Hk02iqKi8A81wmoVzlZWUcCEIqYFmJhhB6AeW6rBPRcbDmzHBOYzm3Wb6EXgEvld5llEBe8fOHV0NG9z0ZuRLngmlgme1xrE6txPUBPB+NUsiTcU4ruZFsyrq8Dt3NGWVO8E6Ggh9lIETVznHVcKOhFlhlkv0BrccMTlLCxtk7mZBJTyFF/1wjDNzcOYhEByEB7RwdX3XysE2aD7lMFrAHDo87qsrPSlB+orpR03NtkceB6wuqtlfHBLJIYWrl1Mqe9zm+WirfXo6rVlopr/YL2+vIV0zrHf85xCUQP4qUMCAciQw4xSoKPTzCNfGCED1RB6Er6FUHmZexV9e/Une/HcDS61bGtkY98srn07SKbufjZcrWAkpEbQ/sWZpdUIfaYAmk+/ujLg+uDc+fLftR6dum5Qf7YdzJern6NL1aErWDcjLF1hccaGn50AdNUT2Bw/NNH/lYkri32dY3rL5XUlenxZ2niQM4yL1d7dPD64Yra9TKytrJ5uwKV2bmGCucjjKc9gAsLEzOBBhjDE39FRHmS85FREGqCtdBvakMAUdtaPRNhcv33S/IXcBAXwOGnuWsLO6ONt7o5c0oyw3kfyj/mUi9BUmTBQUt6vynahetNKwNbkSzlYLJTmvudFurQNV+24saDtyngszAjAdyZ6AlNXVUxfmpBFCpcatsvzAQ67UINxoym5d66UafYMOR4V+K6tuVvtRoW3KhAFSSSA+eG/PmDW5UVnmlS7ulU3kELVJF5d7V9redpTE39AbMURPj3Ep0yW8iuO1ultpulnQSu1jpOZR/ol8JjVztW/EjZ6fzA7UbrYtw+ZEn68LR8wJJtx9hXWTZxYeDbwNV/2q0GsjIR9GqbyOsO3H2YR+sK268xE0ZteqQJwBU9hbcPO9wCVTNvYkArcjRaBxW0/ONPRMG1qOfRGFtPErADjwlJOBbCPlljAyMdNOtGAhvBsZbCIrkkd38FjctgJlQyXHpEKEJhxMP+Fa8uYzd3Eg3vx3cwvl5zK14yzbVJK51VtJW0Z2bdTF8mYVWjKSZCkO3uKE8sRfk6AI3UThN4jhF9hWHtwp83QaVnLq/JjG0cGvsjlhEkUC+kbaWiLuYmFyMqgIeB2XJd1g5Fi5Jj2jS5mENzHxDGx6ZPWGfgWImBCcrj0F3tmnMPXFYdpHwWCLfJZoqHVCpQqkxvUBMrGmCl/jIhd62nRS171aeCABb/ssva1oYwxMKP64UbprWBlDdup/c4oGwzcjomn3Jg5SOtbUNPACxmSlMmc3X6EVXrrjeoD1wXbDeddFwjfI5PHoGrxoVrDTdyTV4DGdXD2vO2yx9EA2sH9ckZA2Auo3j1q7h6x1sYtyh3LDyeq811DCXqTfu3Tr4/jW9yPkH0cMbY6cZiVZFa/1CHIpcwq8eC0fJbkHCJaVamsfqnYrgk7DNSkuJtU5pRC435oRvXBG2h+SUVIy+poTXSar76loHUnmLv+4ndh7Ps+pehkwv6m8sLoJoZPaRSItZM+52CtcZWWbqnW4MLTFlysBp0UJIrKa5o/PAjLAIjSFh13hckqcFdGighSbSKED+OMhOBR9c78i99YdIGwMDQg5M+KjixKpRDxgHZZdy5t5iQLtFe3YZnG+NQFWQvel4fWMPiCdsyU1y0QSDJ4RDq6MS3Yx+jCdbq9nocZv+FHPiF3BOhIEokLT5cskxnZA7GnPt5l8eXsuj7wNUdxzC5WresL7+DQjhGE+RxsMhWx5xeKHaesMFl8IFt8mcL8ExoN0BT0642+ejY+p1ht6CZxcDwRiKTb9zkdKAFgOSlRZnUWo0ouXA9jrpYalKfwxUfvZQBm4OwnpIE24mOdwy3NxZHhdz10cXAVzCNcE6YMelfhjpzC5UTOogmu/iw02f7SUDJKy24jCO7EZlu6gAU+3D65S83ad3wjQqz6AWl4RAW7fkGIF6DBW1FFKQSEqdwwYZAAa0T240Dusqk9+H5XwKnNa+4IXqm7f4BQsgjsUtbe8MOg+HVX+dmH+3xs1J/qbrI0qUDWPTWV7QO9WAhf1Jsn9MY6vEhAwt5IhkJYFLEX9jfOjTQ+S+9xbwKah9kgn3OzP5VmHCsECvKJqGNoc3G1t3e7KmbdD7lfJJpta1m8rdkGExR5drJCWfTkkUmm/AVt7VUrbpnYvrpt1xX9/NL3K6UuAImKLbDb8XhPC0Tk5IZA7egB5AlcXCIaGRUx67otlw6PbYM+RL/nzA4bj//kFtKdayTT4K69G3Jfkse/ETfJxnc40xPBZDa/0bqEou/J0CakQTXArU5SgodzafQxBGQq8n3Ru9iK349X0RIhSH0o/Bl9uNSjNG2ccXnH7txEa58oFrjetCVNeOwLCmjGyYTYXp4FsFNaDvswhuxtFLupp2QpXsyy4XVo4dy+x7s+MMIT/p074ImKGofbsWj1xqUwFgGbBmCGkWJhAtbbZ3IZjN2hoINZqPZF2zYMIuyX1TrS2W8njyM42d4U81aPZRuuT3QqmDfuDyPqOe/H/oD7zAG4ztAiq+OXkK5YZQmWsTa5KSj/9vg1M0bOxUCmjh4ZyodWXzVfksB6ZihM3bNIwdhNnbw37Sge6Vr53lsSKnNQeNk1LWemNHGhHtVWrR12u0knykCtwCq7oJBDSVNaJEaJ7UBORGnHla57bvPYXIIZ86HjtQcnFoCWjcTuFNVchrQH37FayGsiuteWKhG5geIZVj62N5XHYQSXqYTAOuqBBJOxh5yBF57FfXrt0qI5dvX7++8wnuWaEpSaikXbA9+1dr2Rky3KfAC5tx3RsInzz7ouxWE1tzzdQJO5n43WaJhgel9RrsZV3opLOvx2dqeZEU6ajPioGAkBbTCIfNa9r3a4/nzLYcvCVafXGyr5bSYX3h0VduxEI9xNJBoTBQRPldKe9l6x2IQd9ITxFaEZTemqHHCcviNcVZk04hooIboH8w92u0RwOh2+olhewRIbUhzdnNR2upRbLpSIIXxSeNjXP3YJhAvl1EYhZdLR1MBQ8I9BUNLBRnG6Dnh5asNvCPSJ+lL6f+7mBrba42wZK+hNMvdBTkA7hMWldKH0K1PU9Lavy+4RfHPf4nmyTU/cEe2b894k/h4y6wIXX06GtRI7walOyd34YMnfDrIYUoa1OHrLa1fLBOCaVKC1s6JNVUxhQMNTvBwEBhtHeEcVARpO5ShtrhnjZ/rwrQcTFm/Ag71qNZA2ct2VZgG4jo92uLc6STh+I8JeUBu6NkTxKrOkQc63seoXETuQIJEG6g+Slipi3QVFLObdFIDOQk5kE7k1UMf6qaFFQSv8p2U4JURsC2N6po1czb6OjYraGTw6th2jWQkvY0jjLGqGZYohMtjSZmhJwlUm4/RuXTVbU6r8RARegyp6dFu5tog0NYV8mGsk2ePAw0mu9NAccUbi9J1NJaAw2IHTe48EPC43QtPzvOMKd0P/agnVlP3pVz78/YFV8RWPrZt2Y34KbCToXZIssGXGrzR5rsnWh7YZ2BA2vDn9u/Pxt5taWHbfRiK7zJjSEAe/63j3qDIwbeAikgcUpJPVUQZ/0l8e5p74nCCpc5BV+1BC7UjtliZJBVy+FD0NhzYkWooVyKHh/NFTg5yZ3fDdjfPMH24ipyxgdUMybDjVViLBswaOeh33gKz5VUkXhGHSSAczrApnHetWnkkTVcwMNH7fc2KF6Wckek1sMNqfIINaey973pW/fpkTY6cNJ+ezWniI08d0OLGHT+QlgkN5Vvj6uRo7A/mxhjp2FJBKRfk2pL75KXynZjhIYmP4Ev2bDsV32H/dbauYCPwkLtDIKNCd04bKUh+WHZTL/LsyLCtZmj4nT3kvfracVYelzS7mAIQ03I5sVCJjHGoatoAs/wl7cSVqnklWLKet9i06wAX535RUVdaAM92iUibd31xIPjNonFxcr1tQLmQYay3XWj0MC9qqGjyGhJ1VdropH7By5UEZqQ8JttcY+mcQq+a7sFiPgLK8hi+TwzAqxJsP5oq94p/U6EaK9oOazcBTCsiXEP5yb8F3udWm50gXcPoCoQRc6mCLui6dTO6+bpRk9m+JELRft8lFyoSRQ9uFndEfa3pk2T7flQZpy5ZQ6pwPaTEsQgYIrQYRh57dpjTKmzpjO++VOKcM9KyvCzeDWi1fIMmjZNlRdEK5uKAcNi0OVWCVCwjsfH73TeDO8WUt77dfBFLWszegj6bzzIpHdluO1Z/JGoMmK+e641aUTfJQVN3O0T6+hX/j0a7sheJ8+jeR2FIyPshIFUhKyIbGKqHpmIS5CuFJ64XolXWh+OUtCeM1Q4obzHii80DhksYQsoRWYT0U8lmXjs5jy4RD0LhGmH8l0mkk2UWvSSizdC+myP4Rbgyg0KmQdZPHZVQSyxytbh9K03ZWakqtGjeZ8aYcYKJ5dHQQhKia9+Ecc3fIzwx27I5gCstKYUm/mtQYvanTRrCbehDu8zhMH6U4643BE43AbGLfpxPNhUGrarXkQdcowLPJF+yBY3MjxsBd0W+fDUGNZhVwh87FEbORbm7Bq/w430tBV0QKq796nA8xrcbGiH0gnODcjrScCr0UoXGeVD/YavEQUOT81nH6Ujmmws7TGtTgSO/+KNacx3kiKBm1SpMikT33bCSb6FiGI4Qp9hL+nPS4M4zyp1i0EePnRmMPuuzIzdWH0PReJNB/Sgg663YPSW1m4FG0gk8s1u7rtVoUfrpTqs8mTQHdPfzcReqI/l3S/48KVRWc9jZ8eandkccXdZIXlHhn7wpBiP2dyhbQoWKhkQmyfv8kEbTxmHw8OBT20mahx5Pwxlc25wt2s6Rs6tCxqC06ffaGrFdrcHMgS52Q//2AaXLJzVzO2wqoEc0vQrm+zF8KvcDu5QN6grYcB+1dJAA/7un4rvZVjSNzZ1PfDZ284JPHG9gyQUkCXHKFCcbEIzcLFZee6Wcg7p8lkkqSnQxl40lL/A73qpnXpbQ+ApoGfNdmz/1eLR2gl5OfYNPWxSy4kDnA6RTZIRr9JZLS3PdzpvjcUdmxwOupsscadDcmifhpg2X+HvVhT9pYwfNEwt64ctQahhAS8AHGp4AEDugGaqYgqM12e4w0rt4Q4dBLLqkQk4BFQnYiFvHqjCIx8xrIn7fudUSbadi5LJ36l5JfMdQ1TgW09jQ7iJ7DpxhXj+pv9MEB3emxSQcS36ewHDZxKKj09GWtSt4sMT5L+UnHVABLcI4jb/RI4d9Mb1VFz8338REfthy56QKG4uDRg6xmlX+ocBMZfccFm9FYSWUhBoJXaMh/PSpuTZ9JAPlpZjnGYHsL80YTdL9mnMxLF0J2YINgq1rtAMmV9r5tEbLgjNGbOYMy6qKEIruUvPPkBYmo0aPK9VPgHPdDo2JAhJvmDSiaeVlL6p5jZAnF6lZM5y9mbqvgpkZWPOM3zlhX4cQmZw5QyuwgkQPINHcVbgDCaKnBiERglCt6NBSWe4NMlQxSugsGDybDDoYBsixEyPoxh0eKgxDmluoEXy8ooEMCCvCg1o54T9IejCCAIRSukDLjIvbRVYrDDOzKfddxRMEI0o68VAkzDrqeNTZMCLSwp+tyaOvztQSU68ImqBmQ6zpCXsm8apOcN+sJ/opM/KyS5jD03ABDnSJDtJng99B89EVnKNTDNBS0liJPyyzI5RlBiEgnVtAW0xB8FH9a5gHzCWUFRAB1xnV2eIgUwh8hkrRYwFlKBTUeg02nkTWsQqyHUds71tt4Qa/IgFTXJ0c7CrZOfbdmmKXGkfLzTlcVAYaJS/l8vWugz5JeRbdfFkpVqM/ATasuCytJbdtKWQfaNc0X1jI/mV8mlrKWuLxfhIJqwtC2jLVdgmIWB180HBjsVI74qhtaKkX0ItpdCa1ZGvtJQVNaygRYLR1nWRgHguTE+d1oRaa7NiRdT2d26WIV/E3kw7JquDBF5723fsypcvSikWffHl+IhOJkmn25epmPzOLkR/S66KHNlYHrT9kzSeIc6gk7/QKk6so4+wjRdkQid1an8+P0erv+H0n79K5m6u/HtGqXV0YJOzOU+2bJxAlPFxkucY1dzqCrr9zoAYH9ri8qFnb6M6xcfvSo6CYGgofy5RgIHWJHkGm5cGhBtmH8fvKiHXnD2eGv4IbbHzFzvc+ziBAxTUWyJXgp9J0f8wdPGQuVndv9K6I0HduWYkUvx9u1wzWyXYT80Tb2/ded06xEWdDOFlNxV1dSaRP6gitP4tk0sfPGhrYQpUJPGUmicvlzvV+Ofq8agtP4HiXac+n7UUF4quC2RTZFuHx5CYckTDnq1Otb+E4HBKZkOjrD0lXIP7fDndH+HeS8BL7gNe8pcZb01eHdy5xm2/OQMu3efh0jN9Lf8n48iaNFJGklaWRFPJkxnAwe3bu1G+6iBHeVpyjzgmIpYhjg76u9/7LhFTH2QvTEsel8SElxyVgH8B/7tP4uHTNfmd24iKPrfxvt7oX9L9eBJsxVOAVRFXgrJqd9P7BKCDK9tnUkxSbEhU2vzJ1a/+IOUc7JWxQSjqR84cG4OZuTliZ25+bCo+Z0yGHdt2tsFDAkW4EBbEIt9f29p7X0YopRQ/bMd2Hnq/xQtQv1xT3LOzsKylp4MeYAhjhhzyTdSE2vtJBsdTdSRO+geO66wquNguiSz4kq9mzCPd73fA+tXzwwL+OVIhA2tuLslCanoIedZtyPaHV+exp4Y3lVqbbw94hiUMhf6jcWscG6/DU5hNdTVV54z864MxtcKCpS4e8sKdSuZFeMrlUK3qi1G44uMTmQzg2/XtpUiMOgihpyf3SGLCyXRxdNA3YOH+s7sbtzdm18rZI0frHnPt+1f9dfloubR1JOveBtB7f+3PN45tzq7d3nh305dPApRASUQgsnPwuf6+T9gjhhe+bPsDfVaW4b0Yj8J87m9/+LfUdBPtlGja7OU0+3eGvf/55PP+9n9nzDp5bTYlOqFvmvouQULnbIAwoyfsWRPWHI4lDLd1hMCXZKhFpHrfuo4vkqlsk8tr9JYAZzaZ2Yn9qhfb85Mhosx5xCZB2lWrFe/atHWSdrPTfVTUh21ZhWxWLMTHZGlR7JdRratGOUjRQ+JO6tdvYGxNZrIn4SM0eeVgyhzDNvMH1uZpW8FMlivoSTIlMwUQXhzcRA6a/ygCmEevKwr/Dyxdk9fOiVr8Fqu224xMY5spdeLUkkjuiayTZXvZ++qOBez6SWzXiNqKraJUiMWlJO553WLZXsbhikXvju2MFgb5dL1EVxbl9FwH8CdHgN0ITFqq0QYOoQCGN4JovcMiki9NCu4zdX6mQHjiAkbK6VqT9vhAYGVAWKoxwYgoJQkYzgAtomi0VPsvZRunpyGBQp06I0nhzTS6C1FtUW0SbRMlA9FOigomzJCMF796F4sss90dlxfgfv/DIcwsV8IMRFLyEsmbyKEFx60gVBEcTYz5NyGw60HjDjmU58Lc18AvP8QzsFiN0YxUCkZp8HhIVjpZgKh7JRmdhLkcemXkfm62kZbpGs01nGwkFGxQuwpr1Qlc4l+Dfs16Og1lCjNKEwF4SaeijGF6aQIVoUrjwnSo/ET6gYIRA0KVJoYZUaYr2xEc31kWxOZS8rATufS7J17NIdsv/fBRMLh28b9JpH63OFQzQPtDGpiJUDLo+DwkO0olZYElSvij1FmLB3yZUH2i7wtNIhFgyDXu7MwsmlAllfORJJ0+NdXx368+ND0V0qPr9vVXouJyaJO5xiYyB9l67d6luLUjzfmMlkTh2PxiL8I0BygEkW3h77tTpJSwbFQBNa7Z0qZFsgs7GuL25w8AwtYZSU95vxxZdpZkBjfSWRz/UEfiX0N+zZ8UEeSe2SkCY+RMkWTl1J0ZZPr0Z9cyC0g7+dkGhtqThNQ5cHQyAjMQtXV4qCk9oQZom1/kLYdqY3nrAiR0jcMESDaeE2lgN/e5bwkVf1gBHZ93qks7p5OEPEGwb48US0WK1WaQOm4Dxs4e341MnTm1VVCTXb9hmsJLLYA3q8gCcYlAVMQTUyl8Ecj7n3RpNdPfQIor1JFX689a/vz8cza6Kr4wP5Fn8MPyX7/+1Cu9wkI94H1Y57hN3hT5XOe73WI5MEsovfJiY3GR++nE81ndE/L8Y4+WVu36AoafjP0bCIfWdunXL/+w3a12pMWtcGR7/N9i4MNrCLkvdeQxiQafvGQBFEqa9A/GZg6eOWgFdg1BX/mNsb2U6WwUeSV2xaI1rArOLJAk1M92z9amcbPBS7R/jNq3UC+AUeuPc6ApIEHv/30c7xpaUioY8buLV4W7YAMspn/sOaI1fT4z4XXp0jh/17lTYaGyGyOBbgp2K4spCy0C5K1rihrRNwh9dPP34tDvg/OAXUOepDYqTRdf4bvVYbO191bqLSKPSMzwN7o025clFx2LfpClAuBGTMq2lZsZKzCl+zl0Iy1QFBD317G//NW//3ivld6xSDFkMJBpSAE2ENg1QNmE7GHEyASI49VhqWHw5eycAvG8BnhwZH7+ai9C0XotTk4cjhkJPMGMZCIRH2KZ67n4kUcQlJgdh/7NfUdLFV6/B++LH6g4/QAA2O+6EPjYKxu2n/hMs+17zW2rg3ccuaEY1J5Y9vp8qp884U9rv0/+Y0Ae/Z93PMpJAAv0akyMo1tb52QqHHdyo45jXHpGeK33zNBQxLMr/BuAjk74GGxNr/UzCmP78rI4/mXC3M0J+bBMIcvLKstIrVp5H/jFvW6lO29h3csejuYgbTRwvned5y1dHP2xhiT7t/Ix3lTrO8AvH92QlaXVWXSyxq/fX5ePBnYNrckFKAOJKcbVSXUUdC4ly8ISOfkPzGE6DnSC5RZE0dmmxEqEO97akfJwzYgMO37h0ahvy6nKwPIv1JAxFFw/7SszN2mxQXgJYU2vKa7yq0rs2CcrI0ju8eLyY0ao2jaSjN7oz+AzOgQgo7og14AY5vOgGg/xB09dnEFmTl04hIegF+3mMbJ9/VfOzqudt7vFj4D2sBdMxia3pcP4XBcBA/Z8YPr2n+Hpp5MNOtDOSFfXrg/7HvXtQqq7wHpgN/cMvtwUXKOibHu5uT0hwGe8Fdh1JsH7wP7wfQjW2DXskcodTW4lPKmyExCwMuI+0Sz/OFmjBdk7GYgDKPgSgvBHklVov7cYr4ykP68mx/96l8JkgOUXsdLAaQOSHpGny0XEDd3EM49ikYymUAk9So3Sxt+FMSqWdQ2S3h2jlEXlx6WTo4oU6p6E9BV5nlJWimSmB/05QAvR7pYAsNhXuVc2tddYTETlhWW9yWRvZEFPiVeWkcrdjcIbnYvb9soyhTD6G6D2rgwG8Mvv1JF1BKNXuRz3djA6+YI9Mnb1/+uLnU8eN7sbKhGnxOXhiM2v0rwAUNiqfWUAqcpg7GpfCmVVOPDNtZPeCMCLcV1eYy6SkxZ9dxhPuYMgU2cewrZ4lDZKLaE33W3sfvm34+N+GqX9j748OSCMTYesRCAxjYH/R8Go9XD9NXjtf6+xQD4/B5eMCDtEWK4+DkyoHCr3Sn2iEXGDMNSdZJFpEfYGbqIT+SeE31LGo4qamwWIoLlZROW1lHmt4jFTtOy89LT0wiJqx/2bfUhprkBEzYTYGbxATN346F43kiYJH8UJQn8W+YgRWV9MZjpRE+5eeXduAFFvTEhX4vVEdzGwyTZ6XpNVnD5xl3qDaH1x/CYKsP6ocS1hLthV5/CHCs1HMN+X9xUAx8KGvGe3YCS8lXoLuC13EWjl3LsQwG/iHKxxTB5T6hAt9p2+cjDGlQAJ5FMBDhGUUv7dZ+hw1UPO4kuL5NFYfU3kCb4lh6PxigxeOOL2VFeA2y8d6E3X4LV9aRl9YQd03+Mp6XS8GVWarEtBVYQVS5MpwZH8sAi2T5aDPk4fs07rqw1n8cIGWfWHENh1pLvJwTZdRowINW5hL2Anv++21o2PIjfE4z0c5B4dYbR0p79nABN3pKYCPZKbxyQ5Bb3/qOGwRVqeEdlybcfW6KJpa/pMFswo7tJEp9dwkiN93qytO8hq82Vfc3Nic83WpEq/BKRyj14wkgV8W0KZpAgojtBtEPgL0Yhx10ajK7buHvzIfQq6TWFgsH/bWr+FSEAYAxBATX5FNcIuC85Ojx8pPAKPNKiyNEiUuTplWwIYQ7u5e++89a7ubZdbiDfotZ8DE3TZAfvcBq1swilrulWERcDo8TZw4GRe4IDn28CBk8abAogbA66KTmdmvKGM69PtKe0uwPAGKHcuYoNY4pMRV7w422Ydto5tBaqKoL9/gmdbfH70hT8B3LVWVYkq1ZVD69JzE3eoXVOtKnUDbIBXDm1yjQ8oEApjsBArkhUyXDf5aqpngA69BoE9AsF6nJuGwcgw0fgaYeag8trZoLaqUl3ViTu4eloXxzW1RKVqgMDtEcYlg58oTh53dcGUfz9I8tP1FKlc6ByqOAX6uWR464YJvsbeAhAYd2Crtw+0RobUDUdsie36TGAjwv+3TSmzRxnjy0eKcqIrP9s6sUz0mvIZ894G3aIPaeQAP7YQl1mGLL+LJ4SIGE0lkIQScCM7FZvx2Tgucd7HG81HkStzFFlbvP04Lr78SEiIbQ/4xF3a+opH7L2TGynyYl+G9TfdfFy5gfjZpXcmEXyGiyFaKInrXqUYt1uPkoEYMgatjEptbrZYmpvTYlSu6tSYlWW3tERLlGiZtG5TkzRO6apKj9uhDooYjKE+o7g0Ec20muk2bWaiE68zB3E270F8KR6G3Ru/R4CEUrMmIrJ1p1KLCDrUcD7ivfdA4JffjIgbyllRwqYiITKf7WZRFKuhXDeO6r93rSNqbMDyqaSN69W+vNTkmjvTG6QcoKVkZRBdky1FKV607rKUkk6udEelirbCo4KO5lCbr11pcFXNNBKy+hgGbXpE7/4P4ZXc0wDc64L0TC4pksWOjmGnREQRUvJYrAgSixMVzWKSwgH1ikyTOGftOiQtLjqYVtqRNJ+lp8+Xb1iUmAfubDDdXXqwbf/y4OaF6xPSVpokF1/H0rHHxowlgtK+TY96N5VVcgR5WbfiqYboqBwqZSkviycCcTYb4UvYhIovtEZVL0ayMTfvOESEZUqEc4tMpZiX4VKB4Q7QOFMPXTbPTUwUQTw3WrnGJcHsr6NTLBx8IMIlCjiU4iCwrFxidCwlt0sWMKQF32CJcC0EMTP/34YUMzg/Az+DYEaR6D+D8nX41jfRs0bH2zaWZ5K2JkqM+HomG1eXamhJyBg7uLRZeZUq9U3+zstfmxqaWVuS1nLYvb+v6ksNba6kx/1FpZd2Ju3VyW3nbPEBSemGxDkQNaZomz3sOnuofcPcgb6N0wciPCRi5QaxCorVKb6f//QJSNhw+qeHDnm//XL9G57fyoiDpbZF7okLqPA8ee9ugi2EJ7HZXifv2f7v4pkocgh6MD6QhOXl0QGm1o5/vJ8x9NWcKijGKb95g8FLGMVNSxxy7BgYr3bST8EiGMZjBjqZOxwLzOWwwmtdkFeAMAR4n5jfVWlbvKsSTCRpFRakTMFi17hsxOgGSV4ip5pSb1hdWbDbgMTo9XGt8dVwl1sac5kxTKJfL2wH0UdPicJ4UvyQkb/nwIXKa8BuGQI70gNgR4Ig9Dm+QaZkJsuV9KRMdRvIX4+XEQkZ6y+4QI+kd4MOJlK0SlKmR8jmUoPRzElUBEvCQOj4iCtM08b+fehczBiocTz1xeJL4qf3F3XhR5kFOkYaoklDdAxmwbWX9fdM/KQg03ozfVY1ugCRWfqBWOfgzYO0gGmXLCV3LDHWDqm+J5ODpVeiDWJbD+r3X+dSycRv8z0fBMLAI/DIM8e9UgcYpWM8W/rKFdwe8efqU9UOpZUNpuDP6tSDyW9fwxte2dj6JP6JO8vDi/gx3MERdb17MLQTWV2gwluTYwKpjWuAjccJj07mNSk20kHd2JbqKHSUcCsdOf6mb1nBkwGOls68HNvtfjJHb+raQg9HsimcB8Yy0V5ujs4JXg6ULUHcPqqvUtI2xQ2Fu0kA3+eCHdlrnBSRDBRH4PBqx3rDQKNpVT38csdheNj3S1h/7FjhUUAefSpY3YCaxDYntIgzy+J4ifst0EJL5JYQxNyEIv9SZNCu2Xp2bnYH3OE2V1qEIWDzvwYRs3et5l/f6KKd5h/+aZS/dGBlzfLzz02KzLKV5rUQ2K+G369opZ8fPHVrZgXYnxDGJUHDTsfmyeMzeBmhm7Oh4N7Y/NzVvrVVfI7ZejZ+bTl0TMYiUeIwjjSUyoVIpUyVg393hKhdskZgdwuCjgeFkT9GbSJOR+LYCfjxwQcXSFOReFZ8mDicRcYTLxOhday/2CIRSoRm69Z+66aScVhaeKGmX8T9miWwr6hYLNBGEexlX0lmEQA3sfjBwjIc+dSTjKPKMZErlNW/5VMGrst2C+g51QapMv8n4zXrhuxJrN1lLIJRxWTYHMK8rLNXzHV9lLjyMlO4pGgGP53BjyatXpUUkcyJJDF5BHwKR5/MAeMXaYFDcYRoTeKrdpjp4ahdRQz81mM3O8RqyGw9i7fuUo4oOrmkQ6Se4HXcwF2fJimSxANQW1Xaa/iwu+NDQ2lBBeVADnoXoZQu/0KM/TeoVpWyAIH9PxAq4utjNR4mnrAi+jqCuqef4CGeBElRMOok+q7v6oafCJgQQAExYgfcMWFUywXZcNIGnjzUKrW27X9jymrHApBXjFilR6fNdgf97OCL1I+hA9yZuhOK4a5BuW8rgXeO6KeBmXFnN4fIg/pAF/jY1LHXmBwDkasCuftaN9Pfsd4Q/CIxE3l7KHRAoMl5GZw+fWmRs2X6ajt5gzi7NnuFQk5OLZVxqgqMBiQquyp+lIJ+W/6+c7PvpT5nUCsN1Ph4z3r45fnD8PDrL2G9Fy6BWjwxVLjFPLHZ9vctIY+jqLbKt9hg19TomyCwK/TCgwuko6REfqXVikd2CS/Gia3j/RYnHVAymjLLxBZPnZzksafSvB6ufwFfuEAXMx2CqQd+3b8jAYaFPgaW0yER0s099XX6cx4edPgMdaLLVboc1ju9AdHuH7/DjryKcUI+gV/abq1elb11j5XZyKa1S1dYvgSWAG3bZf0Yfu7ks9o82mclyXwazm4EnzyJ3ZfwUTJ8VFo7OlRh3TZZBMOZbBC41zRfo2zYadURZcPX0gDmQ9edJcpGY5KhtTfgPH8aXoMgIvTwpl4bl/ZUA8x8q2JMFM+syuEpTBahsjI3gblNBDx47+SxOXnc6g2By0nGQnXtQn2G3c+pvNRC/tkQ1FRNiRV19YrMTUVFBGgeHf3Cw/Oth9t/e40VYO2HIboqk6v6zwCZH8r4QPpXs/wvaV0dKlCF+Y7l7++KejlEqNcKkfLi4b9Pj34f79xr1ZFMvo7NzWUnR0QxWd8QY1nsCBKLm8tKJoWzk0Gk8iNCIPPqY3UQHZ6XNMdjWL6kLC5RZrFwXVuKVwUiYCAjIrzg4jKSk3TaiHQkQM7e0cC0aKAhGWRsL3ScVX6qVWfH3QpP6mYo51O09hX87X8xP253OznS7DY+sn39w18AGJ84D2VXZbD/JGyCc6icqznwvYn3gN18w0tI9wO4fB58ucdf4W8LfviIQM+PDuNDflg0XZZUBsvqRw5Uht2Gt8NoWRFUVqjMmedXBsGv1vCWOTMl3ORkCqPVb4GDEzDStLeV8WyWZvbehpdPkQKcAkjTOLnPtiIKu7G2MD8Sgh9WFf8+4h9yyDur35LPL2XzrKRR1PgMaow0yisuZfGN/SYfVdDeEX/wPTPCIzdPrP3kxCntU3Geey4AtilyfjmuTM5PYVOTeDLPeA2k5OTnMKvPOpcqZXmQHzhLnTklXvzwoN17/dr02hvMlnQ2zoVPShfS2kIzcTXpIWkQdGxYQM0+3nlzSbOde/UCmFDQYLJvfAuJMHokQW63S2AT7st0evqXmxejxLVv8Ujvz52Y/56CsOMacQuuTCFIYeQb8ifgRLzM/4gEhUrTGi04MRvRVWd/004swk2dOT6CoiVWa620JlbvO3AvLsmIkCkDd8GEOVweUn5qdardKQSzWN2VfXs6eNpLrywsXT8V2B7XcaHf8sGe7Y1ad6arlzapP9NbVBsf6sKKFEqIfRqkAJCnRnh7IG8tGTAD4p6np08sYp3kGPkmVkh4cHxaXITe3TxxjgfoJE6SQMh2M/kc8J3R3nN6PChCVd+rP7YT/UenKQ8cvPdEtqqFj/b16iQSNZWoku4caGTHucvPPREFyHYoSWkZVnN738yaVFtL+KtWktFd7feWYrRFvwvfjc/03/OpvM5YhFsPTT7KcGZmfEDOrdFt9sBu9jNZYEPmmObwb/tuanBSMOMjU1356kqavw7MRCgzzzEdt4KJxRiY2gs/3EI98a1oIsvhfYMv3+Zc6zhc+fvNG3MpYYi8aUjpL9m4Z19X9feE1KYZK474xwPjVnpi7CgMYa9jelr9QWxmrF7tNYQroKQe5mLOBQST5J56NruIeKpOVxPxDsecxZJ7EPEqXpgNgB3kqoxJfJyYFlrgWs7WcVyrcGZxUnzwRa2e41qGL5BQgd3sjSxqWWZKqfra59ncEsPq07LDByPYSUsFqw2copRPAXnUBhH8s2rfudUeb6G925wo+LD7Y+VCHuQW4wSiaINPq0MLCH3YGRRkYihdRfLQUlcrrUM4O1EyXRYt9mELImq9L254cswXYsphOcQc831yC96iupaElorkrqBxw5sT1O+8LfL3/dXNZypjePn/eVn239mz9gG2LXDA8NfuitabAzklSuLUcYAO8YZDmQE5NwZvwVv33wkcx1ZMZvjf+ceCIJiXFr41fyh5tRBTfJN/PEmX4axOH+J55X/r6hD2JsIOrkfFPU33c8ASe9MGt2gSNSeRj/0qVwnogyK3aozoutb5HVeH3MvTxaBiHHUWrRa2s36Int05DZ89hlMwJpefIUb4BVGxUk9FVLsM00zkPzVgEQhuoanZwdwkiiZE71O3vnBto40y9nbgrQRbpMBzWdwN7qqR4O8JKtFfXa6mwntrvksA47S1EbddulYoBNnXw6H/kfLeDv9tIIN1cTSybzHRyGWEfeg6bXPk3MJuCio3yiDhNBEyhp+Fv1lXa/eINPHTfboJKAqLdhvkZSDoF9nsZZZcuDtOaCpcL7rCvgPP7ps9R8I94gcXwak7icF0V4e/D4do0KMa7Wat8c7AYhGayi8jkOvEJ9yFIZ4/o0aeVwfs8JrsKQHghmSlRFVoOZSrLCuF88fP7z8kFXCNVc3wRTfY/2ZoWNmW8iVAbX1gJVaJ2qrKWOi7X2ZcCaqrnnGdKce1ny2c0Ep8l2ouOopBxzfZMPvC0M73l+6c2dl+iPnFbXib+WX74Z23z713YSfwtRvB9ey9PIZPie06tan5H/f3Tvwyh5PvUFr2F0M2q0BFDMdlmbdsdaeijGFaaRx1Ae5nyU00vCrTwsFd88QSZcEnPtVP+h744+sh3aJWfeiaKZvt3yTFPv9HT8+iPqs96JbjlH9qe1tx9f5HwMQzgF/mzuBEKG0Y1S863YmyaZHv7Ese/Sjmoefyhem1Z+bPTIKO7+a16KwbS9Rh92XTvEycE9rn0ptGu5R13e7ECLSg1eFafUoX/l4XtSVsOaVBm6kK8TJDs5cqWJeZ0hB2pZXWHXYvpVOnV4WjARjPfAa/bM0axnQKxBPkdT9WUfDkysypWwfFUPx8eYUEgdf48a0RYRLWOu4AwV34Q5r8eOww+Qw+V3aN/NkuBYHBCe27rsyUzE5fbkbdSVA5U89msaFDM77wjiMHV5IjKmcAZ3KRlcE0eXvti9tMDPs/cI9D35LiJVB/K2eDcHLymu/M900ehG5yLko8Euyu4nZw2XJ8A5ZbShKLKZXYKtSoXZMo1ka5tnF9oU9diJ6i4SZlB1N9cfIQboqgzUM5EvpNmFx4favL7bURNAg889cA2aoapy3uBaGmZAkuOkFGTNCFVCHz9vNlf7xZUdSQ5L/6l22VEp57la/D/YsSYqgv3cniOL/wco/z666DiY7tmI45/42/k9x1ebF9RmGtX7qwh4t+f6UqI7VMl6fILAMYrjeT/PFw6fY7z/Yi8MoPy0EViUcKiprjefx8tBxL3mQMacSoQjk+7wVbBFJ6xvJST/mYHFn2WUoKpxlYgUjRHiiMJfJ+CqrJyOzJ2Leu78SJ2W/Gv801atLWkY6vj755Z9xoVDHIJbGq4/+C1Ds916/2I+jLEseHXNwrbCbZCT3nzZqsqj0Ydi8oMvy03IMczW3bKIIKw77pUk302NXR5kixsPnTxsOPFuKcUrKIFTaI1FLOBU8tjtKaE/t6Uh1uWnwv62EwH7XrwuWkOb6Cr55hB2hPkXc+nTK5Jw31wt6kYZPH1LEvPnGJ7SnALWND+CnSY3TLK8JxigNZ5HCui79jtTr7b+4GsXumdGLabEbo9aGFvOQKHmQ2SYRIdFro+21+7sl5mtwSWMpUGGjACuCV/Ze7AXx34RKwgQCOXNnSrJB9l3npwi/00RXwdSm2/vq3rVHPAbRES4IGD7qnQ1EIOHbuYMe1vht9O+xWg23R1fvxnQv4mOrByc8nPl/Ovk0TIJ4LxulWaKWPg46ORZqIgdO4ZpFl8a46nEJEe2/P4skgO3msc5Q1IsYq7gy0zqAWXp2TXT3+6zaUEiq3ue3PgZfl5/b/Ou0GrLOrPqzzCX4Nw3n36yALjuE8dbESff3fYGKloLYKYViDjBm07VY8xLdoTCokwdxJ3RF7FgIIslviknuFRyCAdj/GOZTF8zaxvUMdEtL9LnizrTgCDIuDQQ71Y8JiP8Z2PTbjZyRpqmEBUdq6SEoP8iNHGgMHdsnyxjlQpNhDaG5R6Gtu8r7AH2JZdLDSPPwebE5X5XVNMnVghc4XvY1fzCqGGSkSUMdPTqdXp0hBnGeIEzs8nUNrwGWcBrA7cMuJ8Y7xSQjgk/H0XFZKOisrRR6YAWJ/9Qp25kSmCRPbcHIrGu5c2XJzvENzJ1Lp8wMhPaWMpVjJAL4KH2Th6H83F69f/X8M6dtdjtUPRskcuUK3WERWubfPIQ2mORwMn/5HAlngpngtH47wNeyuBgKxDde5PqSdotPT6FQNiaIMzUN12pez0+3rkM4QPTVNhaNtaPt8zY/lJyGAJ2tvV3X3VvlUerGcefZ5NoKYUFvbNKUD09FsC8Bet8sUuVfyCnUlWuH1OFwlEjrmUSIlKEGEYMMHI4NWAHeOeuw4CZ48ydTH8/pYWdLcvvu7UNUO2+fgXDgMd2cD7irPjGOx8HkuxWxegd8eYK9fYpWm/RrmNVdb7HjOsmTCPx9JTsklkVkBmTvQ6UGO3MA0XTaO8ag+ai1xk31ZcB7cWJAsYAemZKQQXvPAYwhg92I37E4xTeywpvdMTJtWXi6mSFMIKRJeOjGFS0iJ0VIxsaDFebUNuNsFMuTytkxlEv7OLW8q0SCzeUkIBHGrwXjYD/CHsPGwETiymnkjDIYNw+HFulF2tgzslFQ2TVS0iFIr62BVHYi7VxnwboD/3cCASwGBR83YgKPMS2cF8ygZe6oCOwI/LUHAV9uv2V/f5rcNA9/WwJqn8OkEwCj+DecaAirCv4AVkPbFXzGu9Bz01YV0RxZAS6GUnSRUALtZJiwgn4s07kojSLt4YWktCuMmZGIL3AEu+UDXkJK9zWEZPRyCbHeGMSrWthM2gktgrpQZvGWgP3iIGTyIrOtn2lu8mghyEcUkohDkXk32Fuah6zHCWEK6d82aCsrybWDXMOnwPDQUPp6VYOd9V9N6uL4VNk7kHM89vg247YW/hV2oIFz6AyR0LkyJXnxWXpmnHs1TC6TKAOZeUPezF5XlBeUNBeUMsbUFMWvUa+v18PN5J7QZdIK+3vL+swefSL0Fm2849sCwKr9Mh7saIGzexO8jIGHDxqmEKWJMUjWKagfN/UP8DNpFPjMG15697Hxy9XY3+ybgZaEmGCjRVH0yPUEZG80w2pLTqD11Gmm5WCvWllYOLnaQsYWJugIqs4ov58urKoZOjNcnkzXFVB09ISknlpSkB/Yn8Hm6g3ssBmTLzc+34yE+q7JPhmRUbdTgIVhNJqRSNekfFLq5CFksfZbywGoX33iRzSDpSDAnMU0XE+/C/1GfpfzZziU+vGl4vGYRNlawai1pzw/qVIKErucHRAnmnczuHdjNjr8w73V84+i+/0Xfnhc9rxo9wG5OvTdiVLvG/mFwwPLq/S8LADhR4O3/YRXTeKneXG1LoUNZbtQXTxUn+CkRBvM/KzWYGct+lhEzif2/stlgcrC9SXO+q7PE2G76rWMzaSle8aNagzSV4dYpvyhjq7chgHFkFwjUP6uZ0FhNY2xMtoIRDx+JoFZQHTxCUSV0hiWskHNiXqYl/wXmbnygPqbj+ZTGbrOt6x5WsCDd4MrFLgKV/BUpOiJIyTN3JvradnW6Oqv1oqDCy36aGsszd9Q3holndnUSiHl9cU658j06mhfgAxvTaQ2tMqtHcYfEWDW4FIGCZK8sl/ZjIMJPZ2yKNL1mzdPf99MoZkoE1OFjsQJkvGTWYuKJke0NquJBYcTVbqAcs2OD9x6M6DnuzDh/j4bO7eq6H7XAuFjr3aJg+kKbSJNRTGbBcZYpfDeq5l2nxUUL2BUgRoNtnXcDaFFXQBv3CuV9X+iM37VQ0TnVWF3f1BE29TOG5lMwy2NahJiOcJTzzStrYCu7qiGUXkuLM9+z5JHOuw5xNGy6ZNn2yRpvV7Rm9dCR67FoQGxRfbRku5F2hjS4DZBj0MTg64b7kNNwWtqVGBS+rhTknKy1uK+J6Xa2asjMLli0fbC1Q7Ff1Kxb4P7WJ3RVjTr9F+FDJ8LfQg8NuS8RrCYO9EQUKKrXhGpUGeaW8C0QTAjZmsaGOCBT6JBvgR/bsHxPaZ/JKsCq1jhbKdpsqk/WfTtX8ydQ0QhR5f7WJ3RVjZaFJjXlkq7dyNwoT26kXsuqbN6aIVNXagHUSBYlFoW07n8ta1COcmalT4dO68wMCOk+GchRS6+YlbK2C+cwNENjFZPtzNnK/9yXl/QRV1SqLF2TXK2iIgKi2oWluyG8VWV9WMyEEi2C5Ohrq6RQSZ1eJDpHKbSUl0Aof8KHcFhvDDaCM8OPJ3J3OmtNf/z4B6ia/HoSVGGWAzDPA8BPIHhHrM0dQJsdLXyiYwzGfHl3J/BXrkllpTJ0LAaLFfn8qv6q/roeYB7uhXfuj8J7d8a23b47PvzBo4lxTV2jIqu5Wq6ub1Bl1jar0yBZ74NXg83RnJzszcZsFjcnp9+QA8r2Te7DPKSOPLgDx2/fgaMP3t8+dufe2LiqvkGlbqhTqhpqNeqmevBOS8FAZ3ZuT4+xO8tz87p7ynNieeyYKB6LHMdjRcVyuYC2dV2ng8OVyw6O73a2PnpQ23xl863By5cHN7+7H+3hq0v9G69eWvwcbePtZevl+Sva2ybcA/2l6Bzt9YsP+ovOl4XRan0226ZCen1DLc4fJhNKvJBY20g3tDeS44X+1dvHJhrxRtsufSLa7C7e/JhqLiulmoEvZy52NkPN2dxvM7CRlyWbIc44ZNNE/UNRG/vTErXrZmNns5zE8YM9v/RvTJKsy56JnFFwFX0bHw31y2nytW3WodEiy/CWYuvQqNkyMgL2M4ucB/aUtc/PPpufa6vevLPAaf5v3t9rRGte814HbZFX16nUNXVztbVHa2uA36zzv6t1FkIG1lYgeKMtsPXXECrH/nj7ZZS3zR+orZ/eV9sws7+BxxWr65u0uqYmhbypzqBvrAeYR5RPqGaWRMjlMLIDJBGiHAO3VjycHdUl5xowNIkyK4DDGu7k5ubwSAFpJdwkEZslTigG0Ue3NQltmDYnWW7hzw5jDLRggqJDL1Y0VV2orGBFSXDPQwKU1TVZ2roaOZfMn4zwk5RWa7IaGhRb8w64A7qbEcOJvyPwfm0Gdxo9MnMXzN3GtuRWqsxcmDZEP4zWWRWsdJNZwEruyW0r3GCYA5irxPi28/+atJkpN9Yz+si19wIzGB8cBTOFRxmZLdvVLT0tqQZcVFGuMatdM5lX1azNzkg2GLghIK6ywlxfK48bDkjO1vOCs0suNqR4sqIzhiGbF/5pbsKWf8QRI7vrLlstXM8AFCCNg2seEpgqZoSC9iAAoqaNCE42Kv64F6cYc7m0KfPnR4CSRXP1SeC6YVPe/vd/PqjTjcm57NFpG8HaEg8WMsgraSdWxSXu/tTY5DlQXNws9ouJeRA0bf+LmViwplTKgtfryPdzwTkMinGDfcf7YaCwgzxsQsNUgJdymZlNee7V7sy84hr2auq/6lVQLOsWkIAolJxekAp6HqHHUZedmFI0xicE9patXgRlhXNSeHfxOS7c2/tsKtZaxyWgmHv99jEsE97My5ZHftfyyHzXFlHFGxFdws5y4dW+BSieqthowldtI8XcqGkLnOFinU3mQNZRCPI61b6y67QWAl/sgVRbcvC0NqCT1jaRN35RbXTS2ozPdzdqyOIuoIYItCFDMNZiZmtebBorbMp8ipAMZy0/OXswijeExIFMOGx3x98kwQN2wSwKRf/epIyHsTUTML/LU/kRoJmlnirEjqESZeaBaBDZ5+lfyWMeWJj5dUoIIiAoLhS8R+IWE2m2ZyXCKAt71eG84iqSeSbc2Z6VCBwQDaIPSmLtXUO+evMPPp0HvIHvAjc3w2w11z61IVi5EuZmgHDgX4lyc0E0oFXqIo5n/oET7o8ngpSdlwNZ/SobtoZHFf6XYqJiiMKyLuUU44DCsg6CdK/kiK/JseqsaFr5wBmQ5h/Iyso3NMUdrDmSbW4ObcqwmjxTFDecVbdEGjUlmPyz0VPILj6Q3i4p+a0muKM85KlG+p/bpuhVelD5s22Fz28BjZ72U30v3A1XAHkzQWmukcpxnduvhTubKx/L9vKQ7BONQGqh1g6RiwoXaz2LrjGUG53y2qVhUm50wto30qK40lNp8O1MTxEWbwf5OLh1eT2QCOfU1hGJK94d9ibP/p+lekgmPeVnfMuw/g1uQjY7ywWmfQ+Dpp9/+Bz+R+2Kl5B5FV75bX1eoLz4b96gBFsLJIxXiNNvsGfUgmMVX+UNDagggryhARUEEKUX2IjBOcp/8ua2xK/i7M3sRlpRgcG5NPC7upMcjuHNtBaBuZSiheMiNtOQNmZAo6Lo3m+6n8WiLG3H1GIRl/DpWJrBDVEcV3pOZN/YyIoXxwRe7u3j6zFeZz3tv0HHdgBfABeBAKVV770Bgcj71aQUTOCbC8i4ccnWgmThk2IwBNkxjFGYE3LFffuizUHAPFKAY1E81ivi57JNqxzY0hUeaezbfqHygQfh1/k0lAldqsO18BWMzE7PF2UhzA6TzwjwjhkwBRo1+0hjs2wzMkOgU9HZ2TbT8TDxiHkjZ3QbZSaOZI2NTMqlmnUW3EtJ270xdPt0NMuMIubvh72XFZByaJnvsiefEiTCXSxMxICjn09Ms2fphPGTuU8GBD1gdswtee4wExbAIlj2hYoDvbBsc4uTC1gL62B5bKpN6sXkvd/WyzbXKTKmYvF6LUVia/Wq9dy1Vm1Rx9rjpqmaQ09YdOTNqlX62K/z9M4E+Zq53gJEd3laruuAzJvGnX03M8zI903gSt5N/rL3KK9saCU/b5F0/B7MDFxsGI9qPvjIw9XY/PvOKBEekgYkrTiJP2aD7gAwIfO+P4ip/eXnl0qIH90zwv5s3976YL+OiVGj7n/5ouz+6vazHU+0793ILFAF2Me+g3W3PrAhwdm/ToWRkDkKR7jIucyRH5wC+O3c63HN4Ld6fFDst5ynu7yMe3kgTbD2pxKln9MAUsr8H+gtLdIKHfyjHYzlLtF6hBWQkqVfBvv2s6Duam8H+x18MNo8ZeyvhUaFQG9ogT7mfRwnWygt7Isyb+jtCMHSRj8B3SwTKCaFwbJuH3B3x9XqkAW/o9avSqXQgXAUjh1bAq3VdHGhxO7zgtf4ze2oAqQQ1jyAOsVZE4acsl234+5ZOrVGwGwQRy/FUm+X17CIjGe0buiBNtSoXaCDWevtMo48jeZKui0qb4o90Q6w4WdI0cUAFgPQLuqlSwKl1IXMEucnN5bzwiVqQ6+1llLXpLSP2mlH1l9UnmuZKxksK+8SvasTlO1+aNtLdGNKe6mfdmYjC/unLBjARad5tFRX0OyzGD9V16XWu1Ot7ZXaAe9zYtdfunWhLNxGVFmn3jfuQK1V8jeAJFM4L/2E9M/tKNm/PDKk2E0ZXthXSgF9YxF5W/KYo81C1OyW/kAF63oa7xQbtHvJW9pHwbZqFIXXzOf0vMUun+hYABlhsFSrdint51YQ6+4NWyT7ZKVxhRaQJhR1lEFDC1nAhMhQyi+NYB7zScsplWoWVZc0Xyh0R1EuhR6xm+MYSnTxjyfwCy8K3QBduQtOj2ABFOaShU5pPrM+rejuQLVkR/uodVzDwUgsRjeg7ObOJSZ4zbwH1gGSQz1ymYfphuv2OUL3eCqmzdzEb6DuyhlPyHc2ltCLkKC0f0B52zc6UFRmKQUyNDbMOyI+bguX2TO+mfFcZ5Y8Gi3iOHn4/NDXpdOjoQRqeu6fK8WeNljN4DUd6gYX2gRoC0vAAEXj3BultvvgyceiMXEabtqZtF5yc1GwbhcHy9zs09UJWPxR+RoUMbRtsaWA53JQoVG8lUurW+xmjIeNL6zsCc471cYfVqlzAQzPeP6Oit7p/ofFm9FLwUrLekSTRkLw5FgjW+JqIRr035tv9mrurfTNtY0pREdotEzW3jdDqJ1t1QKsPuc0jTXud4y3nNOsBBIIQ0OC1OCxGS9rxcC9aqDIWKu+raR9pUyA+lv6VVopQZazXN8LsXyUXfNXgbNbMod26UgVw/QSisemkaG3y+yJQaW9EVWSFTXwXl3fF6b6fHjFir4l4fpgJLKWDdK2i0D09Xfsave3S7uM3dOu7Gw3cGzcZuajzJq95/9TbnL/RRsAlGzRR8azVzkB+h9Ofyf4POwfsq/ivPztsAOAwK8HCHDoxE0AWTwUdsZNvnh2TSVv4wLFcPnSVADuPDChMINIbuiDFxu4198looIjfmphpaPYzazzkUho4erEJslQGuDGHB3m1ZEosXwg00iLiY9MFTKDaqALN1Q4xZbW0ybFCtdznPI4n4Mp0vLJAphgkXJquugUHObVVrGSYEgrC2c0ZmSf2cB700cz1uGy//GlRSJeBw06Kqs0A+ZrIOxKJFsIiHB6DdZcw7HYkhXyfUZxCkQV6K0LiiUlywvlNNrlGzO6Vs7UUzzKraOB0VlSp07Kp+QTyqkPD0Ml8VgJLwpKxVqcMR61Y7/iOySRNx8+tNBBWbtWprQ4D5+uSY6pRFxdGIZgcpxHR52ZxttjT8TMvosQHAgFXkcomvqNk/mNJhY/YebrFJCW4gOhwbG0JmFGSJVQaI4DZeAmMKDDuWWUKyyb/CL1xKk0xVeAE7YOSRqNSXEUNygc+bFrwa8QTNzaEnES8VWV9ZYGRJQnhHp0S3DYkR3ZqOiFlaKKhi4NWLcNp9hcjgp7sBwu4NsqW2W5Yizk4Mg0URYBZCxrNpmn1HgsIaXYHrqcNRJITDhiokOxTA9WuaBaRDmy7tAq1NmDzgUZxCJGGQjiLCCi2XCO42F3cLTCZIBNlSFwqe/M+yxa8akPTHGcBmhP1w7ZS5DBkMUAFKdVND4FwPvSvDuEyzlPa6hzWggbgLtSEITewLIFAXABBESxhQBIFBnC0rowBgkJ8kqQ4eD3QUG+oQsqJBtXgxrBCQQNEky0oC9eBdynQT+SX87qJsF4cDslWAVSTFKHAQgSMuVkkOHn+0FB5/wpqJB7bAlqhMZnQYNMEyroSzcdaUE/8l4OnT/BxtzlOinZ5bppe4owPo2qude8Olj0ch8vB8MBwUgWmt3jcqap1qqrbl5PCj/vM41tQynadlEXRTBziqDa5aIQ/pyQSubL8xqO3B5wywzTHStwqqTFFa0ZP4wu+oJEEUmJaf2hq44hBFsH2YHMvUAKyAATt95TMyNTqqyTZX1MD22VkkVYcg+XcpQStEjdv9N6yzo/dCTPKSqYs537elNQYXvr3uOS3lCtuqhZnxzzz/va2DbULcH6hgbUBjXlQrefl9QyxydgxYOG4g6IAtgRDC+SN7TvnCfT4m6ltTqGEOykICs9acsXSDVzGA8lJpUU00NbKeHMCC8jITZCiHc89DgdYadY9d6oPrmvXgwG1VUrioM7YeC4pcavXmDOtOjsUWzrD1HD4O+urs6rLsMBrPS35mkBx9Ke5PAlk18QZaRXoF7RVOlqGy7DAb5l2NBxBNqmL4YvgxfBDwO5bWf69Zyhg+Mw+zW8kTYAs9A6JNed//zNbjDuQvaxDdD5M/8H64kETwPv5mZAl9qmjMenA9n8c4LnTJqph1aOJWbGOn85WeC6acuGHi+6G1L68eJH6yFUbaaCWK6Ucwh6qDIhiRCNIoWmPRWbqRfecb2ge4GUHoxi9tH175f2LRhgbxvo+ro3uTH2jWVDaDSSv4q/3F9PF/Dxfy/4OAf2j23i1WPrVdYn4wc+WBofegzMbi/7era3INnA713Qiv/VV+L2sBn/0jhajhbx89lQKa3xrAVLTrbigJ56c/+50KxpyLsDr8PD7QX1vBeFfcgDBl+9s2Hf1GPdYohdXRiP2owOXOqeO61xZ/cPm/ydhgB0LWHNRbSysvMmdzaSpntgysvmhMglzSmo1fLhFzjNZEw6F+z5hdXSN5L/MWfmADhge8dC/GQlTmRtAygd+GGJK5C0G8eaJGuHufEgjdE5GP3e7aSGH1SaFRgEemhYGGdN22Cl5Qn9uAlWU99lQ8ORSGAK2nERMtHQr8ai4goXPXi76cRQXcsiv9PX6sbLt8oL8lgPjp9u/8jsTULXBBWngUnUXh0HyPm9qRtp9sWgRIDG+yarEU3QIx0cb+YgygnVIRcSwjSTQzgX2NyZyaEyei1vDGR8nydR0Ag/iR6K4u54EqBl/QmZMFVY0RZMypWt6wUJYp50LOn0jfAT8LIhC61xPo1HTvlTUAXVe5liDwdDSvTMNFdAgC4xY7InaYKrPPUAi7d7ryI2SjZXVChit6FBGw0+RE/ND2hx6s28SozL/qFQnIMoo4FIxncYyRLQNuQtRh6OKjway56yzGeq2LCkOv0QFPgfvmySVZcZW+fsBwW3WrnLwMqRykVBSHCSH5uSE1lNx9y9p7DMDnDlBaLpPHkrPnM1n+fzXEeN1b/HG+e5SSmat2GMV/LzY4gLZx7sWz0pE+ckDJy7N69eClNRWLMPitzQLcxjNYCNcodvTON5SNdEU8oKZ8X4/SBfL9zAqltEE8X2dSMp1tBSZZtmHRQORgUTNdI4Q2reW7M5ZxH0vgZid7r1PguqxKVl7k0/n5Y0XlccYPERUgrdTs5JHbcPbgi41tL3JcisSPRxES2VCo0KrS8sNLLGgKm1dCTlfPtmYIBIxJHxjB4AieglFTTOQqMWyTz+JphCmRuc90cEpt+YpjtgYVXVImZ2mDJZwcYcKplhkQlxdjektFfVMdYPmbW4HSqq5ZTobzvTL6gM4Xm6eYMxU4pBkUVpb6BOZuThmtLF8heXSZqmQY/nzqBxaZIStsGw2lvQVZdYQXWmmsh2iXRESjZDwAT4e6IFQrks+Adqb1NYbHAAumLDrpMl6xTUnrzk2v0RxqHsOoPTolcpwtw2svCdE8fCek1Ro5F1pY18N+F6RuhnBcQDlrWyOZoS6wKowlZErWHcm7dWsWEa26poqDmnO7KRyzpenPvd+Syptd7GRzV0nKTzCYwbDJ8S0tyfL2nFBUOQoJOXLvnYLv15V2VOYI1aOP46V4ubkBcDo7UhuMPBJHBltm7KDgISrlwptBhLfQPw2GqnFZ6P8pUsK2sKnFtTa4/bGRboxoZCHL/3na11zcHqZg8K+bzYlfPDneQfIVxDZPK9oUnXxhlCWzpGXtQG88HtXRoEy5iO0byQboVXANu/CPthKmj84u2KajajtPqixjsv1dY1nTzWKsSqa9+snn3IlXLJld9gkraPrdLnkC4WIEO7pKE3tjM+EclMu6hRI9NP867IQx3gejX3JlyRY9NqaL6kSD98XyjMUe6weCPhBKvbMOKsNgfI6AKhJdqbOSS7Xi5UZTcvVs8921iSpHNdJwlOOz5Va1XTzSvKQuzHIX+zfQeIKO8UHmqV4CtGlGw1TTMrLCYVlR9EvN4IjI6BdhdysyaZORrsBs2PkT+rzF0tfhhVZXEbwBgBPO3tsU4S3XeY6pzPCrDM+sXE6lauTQAacbgVsgBxqlptALXDqISFF0gw9jSn71DMVBLyQqfkBqyurZP3wMZm5e3intd/F5x9IfFT4KrWmHVGj22dR+NO04E210uF9jYUgkIXneIbNlNeXOs1p16bdc91Dch23ZGj/7x+ebyIkqUAYvzuq/jUWJfaZnrxLdoec4/hqabL9ddkb6+f4Drr6Za5hrNvK1xzZV/GSH+/jcY+8gMNj2nH5gRt4oc+/j7e4vWwwWZLLC82i4SOL6maBPRfJr93s9BHsw6r9ek9W2II5CFbTywB8VBPoRyYDOOrjYtolGAx+oYgjXGF6NMXmwgJlfD68RfKtn2g+dJtSoY0RvAJqK3wh+lWhsXTidSBk41PYNqPzf3sanQyxbJLObZMik16ifAwJ/x8rTCNyQAPOQpCh9Tha6w/Se8W2rHvFCAYqjwsJmOHUczdo9ORSkYv1HqM1k8i1Djjn5/roMLFadAfw3mMrTqbiAgs3Xs4jJM7VE9Ntn0oZnebsU8IoI1xsEfB2g3XXzZl1AIIgAeIu16AsUdf4zgwCPl8yvopimVTT2VE7JvbVjH1mRIhYGAiX5MVB2K8uty/GDCuoXK2mKotU8MBY3TuMai3mcS+gPN03uSR/6vhv44ytuwYKt8dFFcOrq0m0Af302TBP8kPvLvYgCIjTw1DLS+E7hyi8pdaIbvWjnK4p68iqn2X4jS6xsG+BQd3ofllb7hwVfWr6+kCpi9SYJD0+5t41abt8DmFbOFHGODlS54Fcoz2wYX2yzbbOFqOFvHPlzErDBVjuQh/Gr31dOFjwUNj6K9bXreW9Kq4BSWHViuga979VFogXywwQ+CeoPsBIGADVVPiMG8KyUhLifw6ZAkr3fIMqAwoVys75spRvcKgFhKC4R4wY1PnY6VfFaEuDXLqm+vpAmGidEDkQCkhEOkHlssGqD9K1Cs1c/eXWu4nAa3LAElIdMTUGudd1huEVGQh0PapSoHnWBewIjZMK+7LQsSCfnjwmaI4zeIgsfpyX+mwKL0cVLAvOCgZRDcHtRHYSWHEFdyNxURIjFdI4aSemeRg664iFsLVWgzfyt4BV/YfEpITqXokoScIXp6aiGTUVywL1nChLaPgA88FcOqUqgPBPas0DEcae+onUil8Xw2uqTp2HTkHXiG7mRwUYKQ7tJJ9Fq6mScnrGT/ZnHuw1luFu8FbCuGbNb2HgUIU4uPQGE0RmgXk1FnvA9xqWZOPApLyVsQ/DXmG7H0vQJ4KhdbYHlPAwaZomLV0oyCoQJaPCRD3gRoYcGtFt0aJLkA1PV5pmAGopgAHfNMqgvKAbFeeJrBpJIqgvxAEFQUNEu3BTCF0EwUIQ5rEGNcWIf0d6SxQjACTo13pJqoiw8CX5wQnewcwP2J/UEoFFLyYvgBrGqBNg6vJdK6CSUCsEAqbhzaBEKR01VxwzpOz5UnbBc7OuyLBDJgG2pXIRp7f30/9OaIXEo2GJMYIV3AUW3hnBRT6JV+XJ9xpx/dMVEpop2mLkqDKQxXcJvJq74wQFUtmoKnSCRcVk0XD/BRIUDHUIutEif1vgaFP31krx69IpQeWV3ALnZP0OT8icIkr29rFProlUaNpfSEykf4O4NJ/Vj03EZDWG1c2rlggi4StwqVxBLyTTMGemAnRxEBNXTDv7Yrx2D2wzFu8YYSthraA/5FI2MXQMXPLncCyZpqQE5BJGq62gUwFcwVzY/JQhpskd5qF7VHALfnF6em7fUONMA6nUHcPyrDHI7nCbSnIEjBUJPXBnw6e+bhSJTJuAXQauYk+A6or4K54ojsQgCISUcFlpNNE5FyCRQOKGqVEsUduxkPIv9Qmbq4luX6gClrhx0OKaWz57HO/MeAyzshoMVy+eaXFpOFx5VHQsF3dIZEg9Gb6SSYLpQ3DUVAaGlgXIc9Fwh2qfmIOVFLjtkmScAqSi/43XQfzKxoOxbJZg9S/9qJYSqZNDRO9TLJ2ktQ/zxOwRT8bXoOD6+XJCVSA9ATkX4QnVZpf+Sh5LWx2fUHgc8EV1McwZ5l0FIz8MzrwkBDsINkX/yIva2M1OGqYudl6Bs/UrPZMtIH+JmRX8ediQWbn1D8O9m6Uii+4xIsYtsqntlHhwz9wh1vLqXPiOXgB9vPr7Tu7hqo+jTcrVKKOND8NL7NLxm12D5SPxscrArrmBqtJnU2lSHg0dvtu8adW61WymioszQJR70Bo56FrK6i7l7EA0eRbeJQ4VieavYixFT2u1h5HwNOtcquI8HzyVYat5sUoxkUiTzTFhRPORXeXvBXCYhokPQSJj5B5fjDeHRHQ6TKocMTzM7iYnkomVJfNtijUnPhaGl9/ebHVcXh5J2/vMEruc9HqTRC19Tb4d9kuqzzKvOsOfvNxBzpWWdIWk7svSA/L9K/m68W+gR9Bz7wLqSNVrNuKp2fpSz6q1L31ofP2jWs6jzfcrvM2uP8HOXsHb9jDKsM+vxl9/0oel3TdnbB/S/7erJcvdc8e6QTEh/WBj7cKOfnJor15C9VDlC16dkt5+jzX75ZL8af+HzcRDZYsinUx1fm6+fCAMQbovc0Rz3mhux3a+P51Uc5TWZNdd6KjN68AGfhDRVMSiqyWHXfP7fFCa5qeYp0wDkXK/qLP0U5avdy5xPHoe4d777zZ9dTQHh6fZOGtm3xfPnGPzVKsLHjOiNdpIdZVxs2qVSMGWginZn1ebeFVDUC14pgnIJgzoarEWImf0xJM2PLMh3b99lnzVnA3y7f7tXTG2fwhNnCdA4qKZiplos+SO8ac71aNLw/VTu6jzOtcaHAsGv1CQe9s9p6PwF+n3jNLKHUbcL7+b3r512a5SPDKLdy1hsRhUHWU8wfu/cIWhQgFYXiC6+4Eb1v4+kuYjTkTM08/uPbpPoHu5a7tPVev3h67nrmOi/oFWhaNuhU/+G1PX0E6eGcWvT2fHs9rYp/ajnipsegw9OzX9A7e46s3aCfke7Rt3Tv2oX6DEDEc2K+G+7OBa3JatpyUVKRfCvye+0FL94jNnx4Pdhqy0vGcaVJz5LNV/sOTb9ZeFrvXcl6n/Tvm7B289ZtjsdEYbcV1TqnuUNTCBhTNEfSh2byaqjAYPrIGrc1I887PJ+6W6fj/4v0vSpe7ZJXFC9//8OH+LUP9C2yRvwTTbNkUMLrEoAjYXs0fmGZXI/RLbq4KdStoGkq5ed64iz50QuBSNR55fu8yvdtRo2KPTxERQhe6RAG4uflyvI5tB9wtjaRyEHsJLyhwB4SJ45C7NdQSqGI8WhR4S9wxs8Zq/KVN84fg4B2ogUMmyBP4S1cmnod2elyXVTslXK9TANSmuPaqg7nARnc+9AjowCp6tepE+qGUlG3jmeJES5dHqEA+ZLg3gLsyvV+68/4hSEX0CT7r7oSJRL+z2RgdVnY21copJAQWmmNpz3XfTqablny35pteaiGtf/vbng4IemdtW3xjq/5UBYxdazVs8qGnO7+X9/hRV4GwN9HWzTv8DV10Xqvutz0dEjwb/JZWj5vqQofsUlS5H7Tr1Rq+NQezAHE1P28TF00/A/Sj8eTDmCx46Yg0nVGrq0S3OV0Fk0FDdbHIwqoFVm0I2akYKGaa3ICz6zvwowkIOo1EeLtbZh1roCGClC0ACufhCETNUtZMliU7NcqRmTHZG0R10dhBjmIgylcLqiO3CJOHvyA59mJu/VA3IyXBKzVksy3z3of99d+jVBGwSXoNeWOb1F8ahiB+lf7c9Vs5gWlP/rJx0KxuPS6CvtFryCa77DcXtpjsiS5b/eZ3g7EKEy37zK92W/SHV/4045D33HBYnnxbFPhAoZved9ctt93xLZOH7rnvCLNfjPjQIyuKfO9HA4pZWJUqUWZKuUoVqlSrVaNOve80aNKoWasWZ0xr12aDDj/4yblYTZoMOchJLsR5Ew7kIS/5YGUI6zmiTyJTqDQ6g8lic/r2EwCPLxCKxBJIZXKFUqXu10GAWp3eYDSZLVab3eF0daoNyOP1+eHwBCJAInOlFA62+dORwWSxOVweX9Cff+f6gEViiVQmVyhVao1Wpwch/wYj7NQIwGyxdmkMpAFoh+rAnDuRyVViZRAo5uLq5u7h6eXt4+tXC4MjkCg0BovDE4gkMoVKozNKmCw2h8vjC4QisUQqkyuUqhy1Rlug0xuMJrPFamNrZ+/g6OTs4urm7uHp5Y3GYHF4ApFEplBpdAaTxeZweXyBUCSWSGVyhVKl1mh1eoPRZLZYbXYHRydnF1c3dw9PL28fXz92GPZnDQFnZmHFeuNXVHayi93sYS/72M8BDjKKEXZjd/ZgT/ZiNHvjlNOupg9OOOmaTlf0OZC+jMGSSy6kH2PZnwOwOQM5iIM5hEMZx3j8nGGYN5oE/ggI7DX7Zw2FwRFIFBqDxeEJRBKZQk1DS8fxgggkWVE13TAt23E9PwijOEmzvCirulEGWjp6IIh/Bkbv0okTEzMLKxs7B2cIFMaFKzefaB3b36mlgYNLxST3CVr5INtjR3DhZ/8x0a4hgitzlHQj8x1BUKpMUwS/HfTn2UqIx4iVOFnhnt6sQogRtifgveogPgqjBJ0VID9QUDsFWumLUDntgx8hIGgC3bcHuUfFh2Jy3yFSyGy5vgsBi+GxPSimxcZMpoQ4s3GeVKhVFzwJvExIlXwB9qsmDleB6sd7ulJvK/wGDb/YqaTQiRRMMT29gSj69WilK2EEvDKSmO9LCqNmwYwoEgRlzmRGPEY2z3FhmfjXPlaf1W8pqwNr8GalkD3oqaU1sM0a2UbaDhZsflvZHpaxJQ0NzqkPmKLZhLjw7PrPfbw+Z7+nnOPC11RIe/BDVJz0CUIUwR8o1GbBevJRf+hnBWEB84cKs3n4KrZszu46mtCboRhCuj4ttgEUj/OvefG02D0uMv+UR6nKxmGUPQ6bk/89YUUP//sR/7Ek6X8IjJ3NUCBoglLmfqSsosTBT+AlBgNuNKd3edOo1GRm1PGGbtTEEQIIHd7FNPImv0gV4mJfxAI+EEL1KzXUeGA16Cu6iyW5YVwmTnUV/NW9c/aq5ZNcDoguJHBLF8aBZX50DWLRQGySqdocWz2YJhRG0DuPK7NeWfUqMdLe+nQ6rByz9mTkvmnkstZBkGTYTsbakW4tmAqn7PS55pq1qdREW7U9wZTiGpXjlfICVZJUifVpZY51M+KI0vo63yD4m0hLSOSO7yEjhfqwMvlnaTVurX+LrM9sgCL4FY3FOPFJpgVM3uVe2veCbz9qUGPP3gizNOYT3IwsUQ2dbCdFQzoBS09CGjBScdf4VtKcg4v+fNLLcjH3r1r9zl14nUF8Uw65UQKlGiRt9aRS86w0Y20gwXrQQdmWQl9dr23cfo/vmQ1fMVnQ2BCHgIBwHT5R0TNkiKLeQSZlkinVk3DDrm2flB7AFPjiV9i+iQ2nAQqQUgUOqVCl0jCtBPNuUNKUIMpXhwZUtYy3r3Df/p/RIIJhCkWnsA/FuYLF7vjG3pQPhro/F1uS0qrON3VhGAAFN+ERejyA+2FMQEBAsmEHAgIVBsSJlD1JL+krPfe+Zf+kgWuQwJMdhY3VDIaQgyBCwbjjxJlrD+U0lOnDCIvdxIaf7lQA6KWCwu6DZLb7mG6WE4v8FzPwv0LIQpeUv19kw9KZJYk7T9ShU3PFJUKdc9F9iC3DWnBa3m1xcGfL5VYqSh+YL9HfkPGY71KA03Og9RQoxnFRkTknd9zDh2GMSma6U4jT2c5FTX2Hhl9iSbvxCelG7TwLgq+hE36AEVSfCE11p3BoAg2PrDi9w/KI06YpvMTmpj2HOMCJZGJ+sENPZksTbaZnAp6yvQsOZyUlz3MAtFCtnqogRBkAlONW0Q7WqIZi9O5xpgkpYA4Jn+XCK9I0G3OYh2fAOsrYb9VCj+MMXMVwtgGiimnWbLKguV2grll3NExmT5PVdtCawoqQhty3C9TFiyxrtnlSqFzJHBoc0JXQHpv8UnxOZweeK1NNfzhBxIACVglHoCgXgXtQAFIgYRYUABeoLGJ7GyYOpFfIHY1mhb23fKaqnxNSG5LyJk3Hg+Y4yA/xUL8w1bhQAXJumiGLwl7m7x9BrypAZu2SoDzCt9WZVugXmkt1YMuXRWAocnaQzYlDTwzZUHAiREtiP1oArQj0hvl27Rh5F/7JUuforPn6I5LTofIkbmXjX+pHE3qP6V9qG3un+P4FAAAA"},function(A,e){A.exports="data:application/font-woff;base64,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"},function(A,e){A.exports="data:application/font-woff2;base64,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"},function(A,e){A.exports="data:application/font-woff;base64,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"},function(A,e){A.exports="data:application/font-woff2;base64,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"},function(A,e){A.exports="data:application/font-woff;base64,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"},function(A,e){A.exports="data:application/font-woff2;base64,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"},function(A,e){A.exports="data:application/font-woff;base64,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"},function(A,e){A.exports="data:application/font-woff2;base64,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"},function(A,e){A.exports=require("brace")},function(A,e){A.exports=require("brace/ext/language_tools")},function(A,e){A.exports=require("brace/ext/searchbox")},function(A,e){A.exports=require("brace/mode/javascript")},function(A,e){A.exports=require("brace/snippets/javascript")},function(A,e){A.exports=require("brace/theme/monokai")},function(A,e){A.exports=require("brace/theme/solarized_light")},function(A,e){A.exports=require("brace/theme/tomorrow_night_eighties")},function(A,e){A.exports=require("buckets-js")},function(A,e){A.exports=require("chroma-js")},function(A,e){A.exports=require("classnames")},function(A,e){A.exports=require("electron")},function(A,e){A.exports=require("lodash.pick")},function(A,e){A.exports=require("lodash.sample")},function(A,e){A.exports=require("lodash.union")},function(A,e){A.exports=require("lodash.without")},function(A,e){A.exports=require("material-ui/Dialog")},function(A,e){A.exports=require("material-ui/IconMenu")},function(A,e){A.exports=require("material-ui/LinearProgress")},function(A,e){A.exports=require("material-ui/RaisedButton")},function(A,e){A.exports=require("material-ui/Snackbar")},function(A,e){A.exports=require("material-ui/Table")},function(A,e){A.exports=require("material-ui/svg-icons/av/fast-forward")},function(A,e){A.exports=require("material-ui/svg-icons/av/fast-rewind")},function(A,e){A.exports=require("material-ui/svg-icons/av/pause")},function(A,e){A.exports=require("material-ui/svg-icons/av/play-arrow")},function(A,e){A.exports=require("material-ui/svg-icons/av/skip-next")},function(A,e){A.exports=require("material-ui/svg-icons/av/skip-previous")},function(A,e){A.exports=require("material-ui/svg-icons/hardware/keyboard-arrow-left")},function(A,e){A.exports=require("material-ui/svg-icons/hardware/keyboard-arrow-right")},function(A,e){A.exports=require("material-ui/svg-icons/navigation/arrow-back")},function(A,e){A.exports=require("material-ui/svg-icons/navigation/more-vert")},function(A,e){A.exports=require("material-ui/svg-icons/navigation/refresh")},function(A,e){A.exports=require("node-localstorage")},function(A,e){A.exports=require("path")},function(A,e){A.exports=require("react-ace")},function(A,e){A.exports=require("react-dom")},function(A,e){A.exports=require("react-hot-loader")},function(A,e){A.exports=require("react-tap-event-plugin")},function(A,e,n){A.exports=n(38)}]);