!function(e){function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}var t={};n.m=e,n.c=t,n.i=function(e){return e},n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="dist/",n(n.s=258)}([function(e,n){e.exports=function(e){"undefined"!=typeof execScript?execScript(e):eval.call(null,e)}},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e){var n=e.emptyCopy();return n.importNodes(e.exportNodes()),n.importEdges(e.exportUndirectedEdges()),e.directedEdges().forEach(function(t){var r=e.extremities(t),a=p(r,2),i=a[0],o=a[1];n.addDirectedEdgeWithKey(t,o,i,e.getAttributes(t))}),S(n.export())}t.d(n,"m",function(){return f}),t.d(n,"l",function(){return m}),t.d(n,"k",function(){return b}),t.d(n,"h",function(){return y}),t.d(n,"c",function(){return v}),n.p=a,t.d(n,"n",function(){return x}),t.d(n,"j",function(){return w}),t.d(n,"o",function(){return _}),t.d(n,"b",function(){return T}),t.d(n,"a",function(){return k}),t.d(n,"f",function(){return C}),t.d(n,"d",function(){return S}),t.d(n,"q",function(){return A}),t.d(n,"e",function(){return N}),t.d(n,"i",function(){return I}),t.d(n,"g",function(){return O});var i=t(27),o=t.n(i),s=t(26),d=t.n(s),l=t(13),c=t.n(l),u=t(11),h=(t.n(u),t(222)),g=t.n(h),p=function(){function e(e,n){var t=[],r=!0,a=!1,i=void 0;try{for(var o,s=e[Symbol.iterator]();!(r=(o=s.next()).done)&&(t.push(o.value),!n||t.length!==n);r=!0);}catch(e){a=!0,i=e}finally{try{!r&&s.return&&s.return()}finally{if(a)throw i}}return t}return function(n,t){if(Array.isArray(n))return n;if(Symbol.iterator in Object(n))return e(n,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),f=function(e){if(!e.isCanceled)throw e},m=function(e){var n=!1;return{promise:new Promise(function(t,r){e.then(function(e){return n?r({isCanceled:!0}):t(e)}),e.catch(function(e){return r(n?{isCanceled:!0}:e)})}),cancel:function(){n=!0}}},b=function(e){return{toString:function(){return"AlgorithmError: "+e},message:e,name:"AlgorithmError"}},y=function(e){return parseFloat(e.slice(0,-2))},v=function(e,n,t){return n.app.settings("options")("enabled-modules")(e).get()?t:null},x=function(e){return Object.keys(e).map(function(n){return!0!==e[n]?-1:n}).filter(function(e){return-1!==e})},w=function(e){return{Infinity:"âˆž"}[e.toString()]||e.toString()},_=g.a,T=function(e){return function(n){if(!u.themes[e][n])throw new ReferenceError(n+" is a non-existent style");return u.themes[e][n]}},k=function(e){if(!e)throw new ReferenceError("themedStyle: unknown style "+e);return function(n,t){var r=e[n+(t?"-"+t:"")]+(e[n]?" "+e[n]:"");if(!r)throw new ReferenceError("themedStyle: could'nt find: "+n+" in ["+Object.keys(e).join(" ,")+"]");return r}},E=function(){return!c.a.apply(void 0,arguments)},C={edgeKeyGenerator:function(e){return e.source+"->"+e.target+": "+j(0,1e5)}},S=function(e){var n=e.edges.find(function(e){return e.undirected})?"UndirectedGraph":"DirectedGraph",t=new d.a[n](C);return t.import(e),"undirected"===t.type&&(t.inNeighbors=t.outNeighbors=t.neighbors),t},A=function(e){return o()(e,function(e,n){return n.startsWith("on")})},j=function(e,n){return Math.random()*(n-e)+e},N=function(e,n){return Math.floor(Math.random()*(n-e))+e},I=function e(n){return n.reduce(function(n,t){return n.concat(Array.isArray(t)?e(t):t)},[])},O=function e(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];r(this,e),this.pushNode=function(t){return e.push(n.nodesList,[t])},this.pushNodes=function(t){return e.push(n.nodesList,t)},this.pushEdge=function(t){return e.push(n.edgesList,[t])},this.pushEdges=function(t){return e.push(n.edgesList,t)},this.setNode=function(t,r){return e.set(n.nodesList,r,[t])},this.setNodes=function(t,r){return e.set(n.nodesList,r,t)},this.setEdge=function(t,r){return e.set(n.edgesList,r,[t])},this.setEdges=function(t,r){return e.set(n.edgesList,r,t)},this.neededColorVariety=function(){return Math.max(n.edgesList.length,n.nodesList.length)},this.forEachEdge=function(t){return e.forEach(n.edgesList,t)},this.forEachNode=function(t){return e.forEach(n.nodesList,t)},this.nodesList=t,this.edgesList=a};O.revive=function(e){return new O(e.nodesList,e.edgesList)},O.push=function(e,n){return e.push(n.filter(E))},O.set=function(e,n,t){return e[n]=t.filter(E)},O.forEach=function(e,n){e.forEach(function(e,t){Array.isArray(e)&&e.forEach(function(e){return n(e,t)})})}},function(e,n){e.exports=require("react")},function(e,n){e.exports=require("prop-types")},function(e,n){e.exports=require("material-ui/FlatButton")},function(e,n,t){"use strict";function r(e){if(Array.isArray(e)){for(var n=0,t=Array(e.length);n<e.length;n++)t[n]=e[n];return t}return Array.from(e)}t.d(n,"c",function(){return l}),t.d(n,"a",function(){return c}),t.d(n,"b",function(){return u});var a=t(74),i=t(56),o=t(73),s=t(24),d=t(1),l=function(e,n){var r=function(){return c.reduce(function(e,n,t){return e[t]=n._internals.getSnap(),e},{})},a={create:function(){return t.i(i.a)(l)},set logic(e){l.logic=e},asView:function(){return{name:e,view:t.i(i.a)(l)}},algorithm:{},dryRun:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:l.logic;return t.i(i.b)(e,function(){return r()})(l.input)}},l={info:{name:e},input:{},inputType:{},snap:function(){return r()},modules:function(e){return c.reduce(function(n,t,r){return n[r]=t._internals.getModule(e),n},{})}},c=[],u=a.addInput=function(e,n,r){return l.input[e]=n,r&&(l.inputType[e]=l.inputType[e]||[],l.inputType[e].push(t.i(s.a)(r.description,r.invalid))),u},h=a.addModule=function(e){return c.push(e),e._internals.getInputType(c.length-1).forEach(function(e){var n=e.id,t=e.inputType;l.inputType[n]=l.inputType[n]||[],l.inputType[n].push(t)}),h};if(a.addDescription=function(e){h(v(e))},a.addCode=function(e){a.algorithm.code=f(e),h(a.algorithm.code)},a.addTable=function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),r=1;r<n;r++)t[r-1]=arguments[r];a.algorithm[e]=b.apply(void 0,t),h(a.algorithm[e])},a.addNodedTable=function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),r=1;r<n;r++)t[r-1]=arguments[r];a.algorithm[e]=y.apply(void 0,t),h(a.algorithm[e])},a.addText=function(e){a.algorithm[e]=m(),h(a.algorithm[e])},a.algorithm.explanation=m(),h(a.algorithm.explanation),"graph"===n){a.algorithm.graph=p([{id:"graph",input:"graph"},{id:"startVertex",input:"startNode"}])(),a.addStartingNodeInput=function(){u("startVertex","0",{description:"Starting Vertex",invalid:function(e,n){var r=n.graph;return!t.i(d.d)(r).hasNode(e)&&"node doesn't exist ("+e+")"}})},u("graph",t.i(o.a)(e).graph),h(a.algorithm.graph);var g=t.i(o.b)(e);h(x([{id:"graph",input:"graph"},{id:"startVertex",input:"startNode"}])(g.length>0?g:t.i(d.i)(o.c.map(function(e){return e.graphs}))))}return a},c={graph:[{name:"Starting Vertex",method:"addStartingNodeInput",propName:"startVertex"}]},u={code:"Code",explanation:"Explanation"},h=function(e){var n=e.mod,t=e.moduleArgs,i=e.shouldPassSettings,o=void 0!==i&&i,s=e.input,d=e.getSnaps,l=e.resetSnaps;return{getSnap:function(){var e,t=(e=a.a[n]).snap.apply(e,r(d()));return l(),t},getModule:function(e){var i;return(i=a.a[n]).module.apply(i,r(t).concat([o?e:void 0]))},getInputType:function(e){return s.map(function(t){var r=t.id,i=t.input;return{id:r,inputType:i?a.a[n].input(e)[i]:a.a[n].input(e)}})}}},g=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=n.shouldPassSettings;return function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return function(){for(var r=arguments.length,a=Array(r),i=0;i<r;i++)a[i]=arguments[i];var o=[],s=function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];o=n};return s._internals=h({mod:e,moduleArgs:a,shouldPassSettings:t,input:n,getSnaps:function(){return o},resetSnaps:function(){return o=[]}}),s}}},p=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return function(){for(var n=arguments.length,t=Array(n),r=0;r<n;r++)t[r]=arguments[r];var a=[[],[]];return{setColor:function(e,n,t){a[0][e]=n,a[1][e]=t},setGlyphs:function(e){a[2]=e},setOverrideGraph:function(e){a[3]=e},_internals:h({mod:"RefinedGraph",moduleArgs:t,input:e,getSnaps:function(){return a},resetSnaps:function(){return a=[[],[]]}})}}},f=g("Code")(),m=g("Text")(),b=g("Table")(),y=g("NodedTable")(),v=g("Description")(),x=g("ExampleGraphs",{shouldPassSettings:!0});n.d=l},function(e,n,t){"use strict";t.d(n,"b",function(){return u}),t.d(n,"c",function(){return h}),t.d(n,"a",function(){return g}),t.d(n,"d",function(){return f});var r=t(1),a=t(25),i=(t.n(a),t(215)),o=(t.n(i),t(218)),s=(t.n(o),t(221)),d=(t.n(s),t(219)),l=(t.n(d),t(217)),c=(t.n(l),t(220)),u=(t.n(c),function(e){return{listStyle:{backgroundColor:t.i(r.b)(e)("primary2Color")},floatingLabelStyle:{color:t.i(r.b)(e)("textColor")},underlineStyle:{display:"none"},iconStyle:{fill:t.i(r.b)(e)("textColor")}}}),h=function(){return{style:{lineHeight:"36px"}}},g=function(e){return{underlineFocusStyle:{borderColor:t.i(r.b)(e)("primary2Color")},underlineStyle:{borderColor:t.i(r.b)(e)("primary1Color")},floatingLabelStyle:{color:t.i(r.b)(e)("textColor")},floatingLabelFocusStyle:{color:t.i(r.b)(e)("primary2Color")}}},p={dark:"tomorrow_night_eighties","giant-goldfish":"solarized_light","cheer-up":"katzenmilch",sugar:"solarized_light","thought-provoking":"tomorrow_night","fresh-cut":"katzenmilch"},f=function(e){return{mode:"plain_text",theme:p[e]||"monokai",showPrintMargin:!1,showGutter:!0,highlightActiveLine:!0,tabSize:4,editorProps:{$blockScrolling:1/0}}}},function(e,n){e.exports=require("material-ui/TextField")},function(e,n){e.exports={drawerHandleWidth:"40px",footerHeight:"40px",headerHeight:"40px",viewportMargin:"60px",moduleMaxWidth:"300px",minWrapperWidth:"768px",uiFont:"'Raleway', 'Roboto', sans-serif",textFont:"'Slabo 27px', serif",monospaceFont:"'AnkaCoderC75Regular', monospace",errorRed:"#b51020",infoBlue:"darken(#40e0d0, 20%)"}},function(e,n,t){"use strict";t.d(n,"b",function(){return a}),t.d(n,"a",function(){return i});var r={},a=r.Graph={graph:"// these will be consumed by both algorithms and modules",startNode:"fdkljgsalfsjitnmjertiwoptjcvw8p9jwt3 83jp 84t greulg"},i=r.Examples={graph:"dfgrge reg argk nregrenbgn g7w4766 t356 tw5tg rn",startNode:" xhyfgkb7gsfd743gb hrgj fdndf gruhgsldf ghh90g 8h9g7 ho"};n.c=r},function(e,n){e.exports=require("lodash.mapvalues")},function(e,n){e.exports={themes:{"giant-goldfish":{primary1Color:"#F38630",primary2Color:"#FA6900",accent1Color:"#009688",accent2Color:"#A7DBD8",textColor:"#434743",alternativeTextColor:"#fdf0ca",backgroundColor:"#fdf0ca"},sugar:{primary1Color:"#FE4365",primary2Color:"#FE4365",accent1Color:"#4ECDC4",accent2Color:"#649b82",textColor:"#434743",alternativeTextColor:"#fceadd",backgroundColor:"#fceadd"},"cheer-up":{primary1Color:"#00A8C6",primary2Color:"#c8f761",accent1Color:"#C44D58",accent2Color:"#FF6B6B",textColor:"#434743",alternativeTextColor:"#edeff1",backgroundColor:"#edeff1"},"fresh-cut":{primary1Color:"#8FBE00",primary2Color:"#AEE239",accent1Color:"#00A8C6",accent2Color:"#40C0CB",textColor:"#434743",alternativeTextColor:"#F9F2E7",backgroundColor:"#F9F2E7"},"thought-provoking":{primary1Color:"#C02942",primary2Color:"#D95B43",accent1Color:"#c89f1c",accent2Color:"#53777A",textColor:"#E0E4CC",alternativeTextColor:"#E0E4CC",backgroundColor:"#542437"},dark:{primary1Color:"#946e58",primary2Color:"#D95B43",accent1Color:"#542437",accent2Color:"#ECD078",textColor:"#E0E4CC",alternativeTextColor:"#E0E4CC",backgroundColor:"#774F38"}}}},function(e,n){e.exports=require("lodash.isequal")},function(e,n){e.exports=require("lodash.isnil")},function(e,n){e.exports=require("material-ui/IconButton")},function(e,n){e.exports=require("material-ui/List")},function(e,n){e.exports=require("material-ui/MenuItem")},function(e,n){e.exports=require("material-ui/svg-icons/action/delete")},function(e,n){e.exports=require("material-ui/svg-icons/content/create")},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(4),d=t.n(s),l=t(1),c=t(90),u=t.n(c),h=t(38),g=(t.n(h),Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}),p=t.i(l.a)(u.a),f=function(e){return a.a.createElement("div",{className:p("container",e.theme),style:{width:"calc((100% - (("+h.margin+" * 2) * "+(e.cols-1)+")) / "+e.cols+")"}},a.a.createElement(d.a,g({label:"just to remove that warning"},t.i(l.q)(e))),a.a.createElement("div",{className:p("innerContainer")},a.a.createElement("div",g({className:p("primary",e.theme)},t.i(l.q)(e)),e.name),a.a.createElement("div",g({className:p("secondary",e.theme)},t.i(l.q)(e)),e.desc)))};f.defaultProps={cols:1,desc:null},f.propTypes={theme:o.a.string.isRequired,cols:o.a.number,name:o.a.string.isRequired,desc:o.a.string},n.a=f},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(231),d=t.n(s),l=t(1),c=t(91),u=t.n(c),h=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},g=t.i(l.a)(u.a),p=function(e){return a.a.createElement(d.a,h({overlayClassName:g("overlay",e.theme),contentClassName:g("content",e.theme),actionsContainerClassName:g("actions-container",e.theme),titleClassName:g("title",e.theme)},e))};p.propTypes={theme:o.a.string.isRequired},n.a=p},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(232),d=t.n(s),l=t(14),c=t.n(l),u=t(16),h=t.n(u),g=t(248),p=t.n(g),f=t(1),m=t(93),b=t.n(m),y=t.i(f.a)(b.a),v=function(e,n,t,r){return a.a.createElement(h.a,{key:e,className:y("menu-item",t),rightIcon:a.a.createElement(n),onTouchTap:r},e)},x=function(e){return a.a.createElement(d.a,{anchorOrigin:{vertical:"center",horizontal:"middle"},iconButtonElement:a.a.createElement(c.a,{touch:!0},a.a.createElement(p.a,null)),menuStyle:{backgroundColor:t.i(f.b)(e.theme)("accent1Color")}},e.items.map(function(n){return v(n.name,n.icon,e.theme,n.onTouch)}))};o.a.defaultProps={items:[]},x.propTypes={theme:o.a.string.isRequired,items:o.a.arrayOf(o.a.shape({name:o.a.string.isRequired,icon:o.a.any.isRequired,onTouch:o.a.func.isRequired}))},n.a=x},function(e,n,t){"use strict";function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function o(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var s=t(2),d=t.n(s),l=t(3),c=t.n(l),u=t(224),h=t.n(u),g=t(1),p=t(4),f=t.n(p),m=t(246),b=t.n(m),y=t(245),v=t.n(y),x=t(95),w=t.n(x),_=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),T=t.i(g.a)(w.a),k=function(e){function n(e){a(this,n);var r=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return r.theme=function(e){return t.i(g.b)(r.props.theme)(e)},r.toggleActive=function(){r.setState(function(e){return e.active=!e.active,e},function(){return r.props.visualCache()&&r.props.visualCache()("isOpened").set(r.state.active)})},r.state={active:!!e.visualCache()&&e.visualCache()("isOpened").get()},r}return o(n,e),_(n,[{key:"side",value:function(e,n){return"right"===this.props.side?e:n}},{key:"active",value:function(e,n){return this.state.active?n:e}},{key:"render",value:function(){var e;return d.a.createElement("aside",{className:h()((e={},r(e,T("par",this.props.theme),!0),r(e,this.side(T("right"),T("left")),!0),r(e,T("active"),this.state.active),e)),style:this.props.style},d.a.createElement("section",{className:T("container"),style:this.props.contentStyle},this.props.children),d.a.createElement("div",{className:T("handle")},d.a.createElement(f.a,{label:"just to remove that warning",onClick:this.toggleActive}),d.a.createElement(this.side(v.a,b.a),{className:T("handleIcon"),color:this.theme("alternativeTextColor")})))}}]),n}(s.Component);k.defaultProps={children:null,style:{},contentStyle:{},visualCache:function(){return!1}},k.propTypes={theme:c.a.string.isRequired,side:c.a.oneOf(["right","left"]).isRequired,children:c.a.any,style:c.a.object,contentStyle:c.a.object,visualCache:c.a.func},n.a=k},function(e,n,t){"use strict";var r=t(46),a=t(55),i=t(53),o=t(54),s=t(47),d=t(48),l={code:r.a,text:a.a,graph:i.a,table:o.a,description:s.a,examples:d.a};n.a=l},function(e,n,t){"use strict";t.d(n,"b",function(){return r}),t.d(n,"a",function(){return a});var r=function(e,n,t){return{type:"module",invalid:function(){return!1},data:{moduleName:e,targetModule:n,inputIdentifier:t}}},a=function(e){return{type:"init",invalid:arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){return!1},data:{description:e}}}},function(e,n){e.exports=require("brace")},function(e,n){e.exports=require("graphology")},function(e,n){e.exports=require("lodash.pickby")},function(e,n){e.exports=require("material-ui/Checkbox")},function(e,n){e.exports=require("material-ui/SelectField")},function(e,n){e.exports=require("material-ui/Slider")},function(e,n){e.exports=require("material-ui/Subheader")},function(e,n){e.exports=require("material-ui/styles/MuiThemeProvider")},function(e,n){e.exports=require("material-ui/styles/getMuiTheme")},function(e,n){e.exports=require("material-ui/svg-icons/content/add")},function(e,n){e.exports=require("material-ui/svg-icons/content/send")},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t(2),a=t.n(r),i=t(253),o=t.n(i),s=t(257),d=t.n(s),l=t(254),c=(t.n(l),t(59));d()();var u=function(e){o.a.render(a.a.createElement(l.AppContainer,null,a.a.createElement(e,null)),document.getElementById("react-binding"))};u(c.a)},function(e,n){e.exports={sliderWidth:"100px"}},function(e,n){e.exports={margin:"10px",fontSize:"22px"}},function(e,n){e.exports={labelSize:20,curvedEdges:!1}},function(e,n,t){"use strict";function r(e,n){var t={};for(var r in e)n.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}var a=t(2),i=t.n(a),o=t(3),s=t.n(o),d=t(10),l=t.n(d),c=t(1),u=t(22),h=t(227),g=t.n(h),p=t(23),f=t(88),m=t.n(f),b=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},y=t.i(c.a)(m.a),v=function(e){var n=e.animationDirectives,t=e.algorithmStatic,a=e.input,o=r(e,["animationDirectives","algorithmStatic","input"]),s=l()({main:0,right:0,left:0},function(e,r){var s=Object.keys(t).filter(function(e){return t[e].layout.location===r});return s.sort(function(e,n){return t[n].layout.order-t[e].layout.order}),s.map(function(e){return i.a.createElement(p.a[t[e].type],b({},o,{id:e,key:e,input:(a.find(function(n){return n.data.targetModule===e})||a.filter(function(n){return n.data.moduleName===t[e].type})).reduce(function(e,n){return e[n.data.inputIdentifier]=g()(n,["value","update"]),e},{})},t[e].data,n[e]))})});return e.visualCache()("leftDrawer")("isOpened").default(!1),e.visualCache()("rightDrawer")("isOpened").default(!0),i.a.createElement("section",{className:y("top")},i.a.createElement("section",{className:y("main")},s.main),i.a.createElement(u.a,{side:"left",theme:e.theme,visualCache:function(){return e.visualCache()("leftDrawer")}},s.left),i.a.createElement(u.a,{side:"right",theme:e.theme,visualCache:function(){return e.visualCache()("rightDrawer")}},s.right))};v.propTypes={animationDirectives:s.a.object.isRequired,algorithmStatic:s.a.object.isRequired,input:s.a.arrayOf(s.a.object).isRequired,theme:s.a.string.isRequired,visualCache:s.a.func.isRequired},n.a=v},function(e,n,t){"use strict";function r(e,n){var t={};for(var r in e)n.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}var a=t(2),i=t.n(a),o=t(3),s=t.n(o),d=t(32),l=t.n(d),c=t(33),u=t.n(c),h=t(30),g=t.n(h),p=t(233),f=t.n(p),m=t(4),b=t.n(m),y=t(243),v=t.n(y),x=t(239),w=t.n(x),_=t(241),T=t.n(_),k=t(240),E=t.n(k),C=t(249),S=t.n(C),A=t(238),j=t.n(A),N=t(242),I=t.n(N),O=t(35),P=t.n(O),R=t(1),M=t(43),q=t(8),z=t.n(q),L=t(37),D=(t.n(L),t(89)),F=t.n(D),B=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},Y=t.i(R.a)(F.a),V=function(e,n){return i.a.createElement(e,{color:t.i(R.b)(n.theme)("alternativeTextColor"),hoverColor:t.i(R.b)(n.theme)("accent1Color")})},X=function(e){return i.a.createElement("div",{className:Y("container",e.theme)},i.a.createElement("div",{className:Y("upper")},i.a.createElement(l.a,{muiTheme:u()({slider:{handleFillColor:t.i(R.b)(e.theme)("accent1Color"),selectionColor:t.i(R.b)(e.theme)("alternativeTextColor"),rippleColor:t.i(R.b)(e.theme)("accent1Color")}})},i.a.createElement(g.a,{max:100,min:1,step:1,value:e.animationSpeed,defaultValue:e.animationSpeed,onChange:function(n,t){return e.onAnimationChangeSpeed(t)},onDragStop:function(){return e.onAnimationChangeSpeed(null,!0)},style:{flexGrow:1,maxWidth:L.sliderWidth},sliderStyle:{margin:0}})),i.a.createElement("div",{className:Y("buttons")},i.a.createElement(b.a,{icon:V(v.a,e),onTouchTap:e.onAnimationToBegin}),i.a.createElement(b.a,{icon:V(w.a,e),onTouchTap:e.onAnimationStepBackward}),i.a.createElement(M.a,{activeIcon:V(P.a,e),passiveIcon:V(100===e.animationProgress?S.a:e.animationIsPaused?T.a:E.a,e),elevation:z.a.footerHeight,theme:e.theme,demandCondition:0===e.animationProgress,demandings:e.input.map(function(e){var n=e.data.description,t=e.update,a=r(e,["data","update"]);return B({text:n,handler:t},a)}),resolve:e.onAnimationPauseRestart}),i.a.createElement(b.a,{icon:V(j.a,e),onTouchTap:e.onAnimationStepForward}),i.a.createElement(b.a,{icon:V(I.a,e),onTouchTap:e.onAnimationToEnd}))),i.a.createElement(f.a,{value:e.animationProgress,mode:"determinate",color:t.i(R.b)(e.theme)("accent1Color"),style:{height:z.a.footerHeight,position:"absolute",bottom:0,backgroundColor:t.i(R.b)(e.theme)("primary1Color"),zIndex:-1}}))};X.defaultProps={input:[]},X.propTypes={animationSpeed:s.a.number.isRequired,animationProgress:s.a.number.isRequired,animationIsPaused:s.a.bool.isRequired,onAnimationChangeSpeed:s.a.func.isRequired,onAnimationToBegin:s.a.func.isRequired,onAnimationStepForward:s.a.func.isRequired,onAnimationPauseRestart:s.a.func.isRequired,onAnimationStepBackward:s.a.func.isRequired,onAnimationToEnd:s.a.func.isRequired,input:s.a.arrayOf(s.a.shape({data:s.a.shape({description:s.a.string.isRequired}).isRequired,update:s.a.func.isRequired})),theme:s.a.string.isRequired},n.a=X},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(4),d=t.n(s),l=t(1),c=t(247),u=t.n(c),h=t(92),g=t.n(h),p=t.i(l.a)(g.a),f=function(e){return!e.disabled&&a.a.createElement("header",{className:p("container",e.app.theme)},e.back&&a.a.createElement(d.a,{icon:a.a.createElement(u.a,{color:t.i(l.b)(e.app.theme)("alternativeTextColor")}),label:""+e.back.name,onTouchTap:function(){return e.app.goBack()},labelStyle:{color:t.i(l.b)(e.app.theme)("alternativeTextColor")}}),a.a.createElement("nav",{className:p("nav")},e.routes.map(function(n){return a.a.createElement(d.a,{label:n.name,onTouchTap:function(){return e.app.changeView(n)}})})),a.a.createElement("h1",{className:p("header")},e.current.name.toUpperCase()))};f.defaultProps={routes:[],back:null,current:{name:""}},f.propTypes={app:o.a.shape({theme:o.a.string.isRequired,goBack:o.a.func.isRequired}).isRequired,back:o.a.shape({name:o.a.string.isRequired}),current:o.a.shape({name:o.a.string.isRequired}),routes:o.a.array},n.a=f},function(e,n,t){"use strict";function r(e,n){var t={};for(var r in e)n.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}function a(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function o(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var s=t(2),d=t.n(s),l=t(3),c=t.n(l),u=t(4),h=t.n(u),g=t(7),p=t.n(g),f=t(6),m=t(1),b=t(94),y=t.n(b),v=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},x=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),w=t.i(m.a)(y.a),_=function(e){function n(e){a(this,n);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.canBeShown=function(){return t.props.demandCondition&&0!==t.props.demandings.length},t.isOpened=function(){return t.canBeShown()&&t.state.opened},t.passiveHandler=function(){t.canBeShown()?t.setState({opened:!0}):t.props.resolve()},t.activeHandler=function(){var e=t.props.demandings.length;t.props.demandings.forEach(function(n,r){n.handler(t.state.inputs[r],function(){0===--e&&t.setState({opened:!1},function(){return t.props.resolve()})})})},t.inputHandler=function(e,n){return function(e){var r=e.target.value;t.setState(function(e){return e.inputs[n]=r,e})}},t.isButtonDisabled=function(){return t.state.inputs.reduce(function(e,n,r){return e||!t.props.demandings[r].validate(n)},!1)},t.state={opened:!1,inputs:t.props.demandings.map(function(e){return e.value})},t}return o(n,e),x(n,[{key:"componentWillReceiveProps",value:function(e){this.setState({inputs:e.demandings.map(function(e){return e.value})})}},{key:"render",value:function(){var e=this,n=this.props,a=(n.demandCondition,n.demandings),i=(n.resolve,n.formatter,n.activeIcon),o=n.passiveIcon,s=n.theme,l=n.elevation,c=r(n,["demandCondition","demandings","resolve","formatter","activeIcon","passiveIcon","theme","elevation"]),u=a.map(function(n,r){return d.a.createElement(p.a,v({},t.i(f.a)(e.props.theme),{key:n.text,floatingLabelText:n.text,value:e.state.inputs[r],onChange:e.inputHandler(n,r),errorText:n.invalid(e.state.inputs[r]),style:{marginTop:"-14px",width:"125px"}}))});return d.a.createElement("div",{style:{display:"inline-flex",alignItems:"center"}},d.a.createElement("div",{className:"\n\t\t\t\t\t\t"+w("fields-container",s)+"\n\t\t\t\t\t\t"+(this.isOpened()&&w("open",s))+"\n\t\t\t\t\t",style:{bottom:l}},u),d.a.createElement(h.a,v({},c,{disabled:this.isButtonDisabled(),onTouchTap:this.isOpened()?this.activeHandler:this.passiveHandler,icon:this.isOpened()?i:o})))}}]),n}(s.Component);_.defaultProps={formatter:function(e){return e},demandings:[],demandCondition:!1,elevation:"0px"},_.propTypes={demandCondition:c.a.bool,demandings:c.a.arrayOf(c.a.shape({text:c.a.string.isRequired,validate:c.a.func.isRequired,handler:c.a.func.isRequired,value:c.a.string.isRequired})),formatter:c.a.func,activeIcon:c.a.element.isRequired,passiveIcon:c.a.element.isRequired,resolve:c.a.func.isRequired,elevation:c.a.string,theme:c.a.string.isRequired},n.a=_},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function i(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var o=t(2),s=t.n(o),d=t(4),l=t.n(d),c=t(7),u=t.n(c),h=t(35),g=t.n(h),p=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),f=function(e){function n(e){r(this,n);var t=a(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.onInputChange=function(e){return t.setState({value:e.target.value})},t.onButtonClick=function(){return t.props.send(t.state.value)},t.state={value:""},t}return i(n,e),p(n,[{key:"render",value:function(){return s.a.createElement("div",{style:{display:"flex",justifyContent:"flex-end",alignItems:"center"}},s.a.createElement(u.a,{id:"prompt-text",hintText:this.props.hintText,value:this.state.value,onChange:this.onInputChange,underlineFocusStyle:this.props.underlineFocusStyle,underlineStyle:this.props.underlineStyle,underlineShow:this.props.underlineShow}),s.a.createElement(l.a,{icon:s.a.createElement(g.a,null),onTouchTap:this.onButtonClick}))}}]),n}(o.Component);n.a=f},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},d=function(e){return a.a.createElement("div",{style:s({position:"relative",height:"100%"},e.style),className:e.className},e.children)};d.defaultProps={style:{},className:""},d.propTypes={children:o.a.any.isRequired,style:o.a.object,className:o.a.string},n.a=d},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(1),d=t(96),l=t.n(d),c=t.i(s.a)(l.a),u=function(e){var n=Array(e.code.length).fill("");e.highlights.forEach(function(e){return n[e]=c("active")});var r=e.code.map(function(e,t){return a.a.createElement("p",{key:e+t,className:n[t]},e)});return t.i(s.c)("code",e,a.a.createElement("div",{className:c("code",e.theme)},r))};u.defaultProps={highlights:[]},u.propTypes={code:o.a.arrayOf(o.a.string).isRequired,theme:o.a.string.isRequired,highlights:o.a.arrayOf(o.a.number)},n.a=u},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(255),d=t.n(s),l=t(1),c=t(97),u=(t.n(c),function(e){return t.i(l.c)("description",e,e.text&&a.a.createElement("div",{className:c.container},a.a.createElement(d.a,{escapeHtml:!0,source:e.text}))||null)});u.propTypes={text:o.a.string},u.defaultProps={text:""},n.a=u},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function i(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var o=t(2),s=t.n(o),d=t(3),l=t.n(d),c=t(15),u=(t.n(c),t(14)),h=t.n(u),g=t(21),p=t(17),f=t.n(p),m=t(34),b=t.n(m),y=t(18),v=t.n(y),x=t(9),w=t(1),_=t(98),T=t.n(_),k=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),E=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},C=t.i(w.a)(T.a),S=function(e,n,t){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:function(){return{}},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;return s.a.createElement(c.ListItem,E({key:JSON.stringify(e),primaryText:n+" "+t.props.exampleGroup+"s",primaryTogglesNestedList:!0,autoGenerateNestedIndicator:!1,open:t.state["open"+n],onNestedListToggle:function(){return t.setState(function(e){return e["open"+n]=!e["open"+n],e})}},r,{nestedItems:e.map(function(e){return s.a.createElement(c.ListItem,E({key:e.name,primaryText:e.name,onTouchTap:function(){var n=function(){return t.props.input[x.a.graph].update(e.data)};if(t.props.input[x.a.startNode])return t.props.input[x.a.startNode].update("0",n);n()}},a(e)))}).concat(i)}))},A=function(e){function n(e){r(this,n);var t=a(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.state={openExample:!0,openCustom:!1},t}return i(n,e),k(n,[{key:"render",value:function(){var e=this,n=function(n){for(var t=n;e.props.customs.map(function(e){return e.name}).includes(t);)t+="!";return t};return t.i(w.c)("examples",this.props,s.a.createElement("div",{className:C("container",this.props.theme)},s.a.createElement(c.List,null,this.props.examples.length>0?S(this.props.examples,"Example",this):null,S(this.props.customs,"Custom",this,{rightIconButton:s.a.createElement(h.a,{touch:!0,onTouchTap:function(){e.props.app.prompt("Enter Name",function(t){return e.props.addCustom(n(t),e.props.input[x.a.graph].value)})}},s.a.createElement(b.a,null))},function(r){return{rightIconButton:t.i(g.a)({theme:e.props.app.theme,items:[{name:"Rename",icon:v.a,onTouch:function(){return e.props.app.prompt("Enter New Name",function(t){return e.props.renameCustom(r.name,n(t))})}},{name:"Delete",icon:f.a,onTouch:function(){return e.props.deleteCustom(r.name)}}]})}}))))}}]),n}(o.Component);A.propTypes={theme:l.a.string.isRequired,examples:l.a.arrayOf(l.a.shape({name:l.a.string.isRequired,data:l.a.any.isRequired})).isRequired,customs:l.a.arrayOf(l.a.shape({name:l.a.string.isRequired,data:l.a.any.isRequired})).isRequired},n.a=A},function(e,n,t){"use strict";var r=t(223),a=t.n(r),i=t(10),o=t.n(i),s=t(1),d=a.a.scale(),l=function(e){var n={edges:{},nodes:{}},r=function(e,t,r,a){n[e][t]=n[e][t]||{},n[e][t][r]=a},i=function(){n={edges:{},nodes:{}}},l=[],c=function(){for(;0!==l.length;)l.pop()()},u={},h=function(n){return e.props.app.settings("options")("grayscale-visualizations").get()?d(1-a()(n).luminance()).hex():n},g=function(n){return t.i(s.b)(e.props.theme)(n)},p={default:g("primary1Color"),text:g("textColor")},f=g("backgroundColor"),m=a()(p.default).saturate(2),b={},y=function(e){return b[e]?b[e]:b[e]=Array(e).fill(1).map(function(n,t){return m.set("hsl.h","+"+360/(e+1)*(t+1)).hex()})},v=o()(p,h),x=function(){return y.apply(void 0,arguments).map(h)},w=function(e,n,t){r(t,e,"col",n),l.push(function(){return r(t,e,"col",v.default)})},_=function(e,n,t){r(t,e,"lab",n),l.push(function(){return r(t,e,"lab",-1)})},T=function(){var t={},r={};Object.keys(n).forEach(function(a){return Object.keys(n[a]).forEach(function(i){if(e.sigma.graph[a](i)&&(n[a][i].col&&(e.props.app.animationsEnabled?k({scaleCache:t,eachTimeCache:r,firstCol:e.sigma.graph[a](i).color,secCol:n[a][i].col,callback:function(n){e.sigma.graph[a](i).color=n,e.sigma.refresh({skipIndexation:!0})}}):(e.sigma.graph[a](i).color=n[a][i].col,e.sigma.refresh({skipIndexation:!0}))),n[a][i].lab)){var o=e.sigma.graph[a](i);o.glyphs[0].content=n[a][i].lab,-1===n[a][i].lab?o.glyphs[0].draw=!1:o.glyphs[0].draw=!0,e.sigma.refresh({skipIndexation:!0})}})}),i()},k=function(n){var t=n.firstCol,r=n.secCol,i=n.eachTimeCache,o=void 0===i?{}:i,s=n.scaleCache,d=void 0===s?{}:s,l=n.callback;if(a()(r).hex()!==a()(t).hex()){var c=function(){return e.props.animationNextFrameTime},h=function(){return Math.floor(.5*c()/50)},g=function(e){return o[e*c()]||(o[e*c()]=Math.floor(.5*c()/e))},p=function(e){return d[e+".."+t+"."+r]||(d[e+".."+t+"."+r]=a.a.scale([t,r]).mode("lch").domain([0,e-1]))},f=function(e){var n=setTimeout(function(){u[n]=null,e()},g(h()));u[n]={clear:function(){return clearTimeout(n)},fastforward:function(){return l(r)}}};f(function e(n){return function(){n>=h()||(l(p(h())(n).hex()),f(e(n+1)))}}(0))}},E=function(e,n){var t=s.g.revive(e);c(),Object.keys(n).forEach(function(e){_(e,n[e],"nodes")}),t.forEachEdge(function(e,n){w(e,x(t.neededColorVariety())[n],"edges")}),t.forEachNode(function(e,n){w(e,x(t.neededColorVariety())[n],"nodes")}),T()},C=function(){Object.keys(u).forEach(function(e){u[e]&&(u[e].clear(),u[e].fastforward())}),u={}};return{updateAppearence:E,resetAppearence:function(){c(),T()},killAppearenceAnimations:C,defaultColor:v.default,textColor:v.text,backgroundColor:f}};n.a=l},function(e,n){!function(){"use strict";sigma.utils.pkg("sigma.canvas.edges");var e=function(e,n,t,r){if(r){var a=e*n/t;return{y:a||Number.POSITIVE_INFINITY}}var i=e/(n/2),a=e-i*t;return{y:a?1/a:n}};sigma.canvas.edges.autoCurve=function(n){var t,r=n.settings("autoCurveSortByDirection"),a=n.settings("defaultEdgeType"),i=n.graph.edges(),o={key:function(e){var n=e.source+","+e.target;return this[n]?n:!r&&(n=e.target+","+e.source,this[n])?n:(r&&this[e.target+","+e.source]?this[n]={i:1,n:1}:this[n]={i:0,n:0},n)},inc:function(e){this[this.key(e)].n++}};i.forEach(function(e){o.inc(e)}),i.forEach(function(n){t=o.key(n),o[t].n>1||o[t].i>0?(n.cc||("arrow"===n.type||"arrow"===a?(n.cc_prev_type||(n.cc_prev_type=n.type),n.type="curvedArrow"):(n.cc_prev_type||(n.cc_prev_type=n.type),n.type="curve")),n.cc=e(100,o[t].n,o[t].i++,r)):n.cc&&(n.type=n.cc_prev_type,n.cc_prev_type=void 0,n.cc=void 0)})}}()},function(e,n,t){"use strict";var r=t(9),a=t(1),i=function(e){var n=function(n){return e.props.input[r.b.graph].update(n.export())},i=function(n){return function(t){if(t.data.captor.ctrlKey)return n(t,e.graph)}},o={handlerClickNode:i(function(t,a){if(t.data.captor.altKey){if(e.props.input[r.b.startNode]&&t.data.node.id===e.props.input[r.b.startNode].value)return void e.props.app.alert(1,"Cannot remove starting node");a.dropNode(t.data.node.id),e.sigma.graph.dropNode(t.data.node.id),e.layout(),n(a)}}),get bind(){var n=this;return function(){return e.sigma.bind("clickNode",n.handlerClickNode)}},get unbind(){var n=this;return function(){return e.sigma.unbind("clickNode",n.handlerClickNode)}}},s={handlerClickStage:i(function(r,i){if(!r.data.captor.altKey){for(var o=i.order;i.hasNode(o);)if(++o>1e3)throw new Error("Sictin");var s=i.addNode(o);e.sigma.graph.addNode(e.node(s,t.i(a.e)(0,50),t.i(a.e)(0,50))),e.layout(),n(i)}}),get bind(){var n=this;return function(){return e.sigma.bind("clickStage",n.handlerClickStage)}},get unbind(){var n=this;return function(){return e.sigma.unbind("clickStage",n.handlerClickStage)}}},d=null,l={handlerClickNode:i(function(t,r){if(!t.data.captor.altKey){if(null!==d&&r.hasNode(d)){var i=d,o=t.data.node.id;if(!r.hasEdge(i,o)){var s=function(t){var s=r.addEdgeWithKey(a.f.edgeKeyGenerator(i,o),i,o,{weight:t});e.sigma.graph.addEdge(e.edge(s,r,r.getEdgeAttribute(s,"weight"))),e.layout(),n(r)};r.edges().find(function(e){return r.getEdgeAttribute(e,"weight")})?e.props.app.prompt("Enter Weight",function(e){return s(parseInt(e,10))}):s()}return void(d=null)}d=t.data.node.id}}),get bind(){var n=this;return d=null,function(){return e.sigma.bind("clickNode",n.handlerClickNode)}},get unbind(){var n=this;return d=null,function(){return e.sigma.unbind("clickNode",n.handlerClickNode)}}};return{attachEvents:function(){s.bind(),o.bind(),l.bind()},detachEvents:function(){s.unbind(),o.unbind(),l.unbind()}}};n.a=i},function(e,n,t){"use strict";var r=t(12),a=t.n(r),i=function(e){var n=function(n,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};e.sigma.graph.nodes().forEach(function(n,t){n.ananx=100*Math.cos(2*t*Math.PI/e.graph.order),n.anany=100*Math.sin(2*t*Math.PI/e.graph.order)}),sigma.plugins.animate(e.sigma,{x:"ananx",y:"anany"},{easing:"cubicInOut",onComplete:function(){r(),e.graph=n,e.createGraph(),t()}})};return{updateGraphSoft:function(n,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};a()(n.exportNodes(),e.graph.exportNodes())&&!a()(n.exportEdges(),e.graph.exportEdges())&&(e.sigma.graph.edges().forEach(function(n){var t=n.id;return e.sigma.graph.dropEdge(t)}),e.sigma.graph.read({edges:e.readGraph(n).edges})),r(),e.graph=n,e.layout(),t()},updateGraphHard:n}};n.a=i},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function i(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var o=t(207),s=(t.n(o),t(173)),d=(t.n(s),t(209)),l=(t.n(d),t(208)),c=(t.n(l),t(169)),u=(t.n(c),t(168)),h=(t.n(u),t(171)),g=(t.n(h),t(167)),p=(t.n(g),t(172)),f=(t.n(p),t(170)),m=(t.n(f),t(165)),b=(t.n(m),t(166)),y=(t.n(b),t(192)),v=(t.n(y),t(195)),x=(t.n(v),t(194)),w=(t.n(x),t(193)),_=(t.n(w),t(205)),T=(t.n(_),t(206)),k=(t.n(T),t(203)),E=(t.n(k),t(204)),C=(t.n(E),t(202)),S=(t.n(C),t(190)),A=(t.n(S),t(189)),j=(t.n(A),t(191)),N=(t.n(j),t(187)),I=(t.n(N),t(185)),O=(t.n(I),t(184)),P=(t.n(O),t(186)),R=(t.n(P),t(183)),M=(t.n(R),t(181)),q=(t.n(M),t(180)),z=(t.n(q),t(182)),L=(t.n(z),t(188)),D=(t.n(L),t(201)),F=(t.n(D),t(200)),B=(t.n(F),t(197)),Y=(t.n(B),t(196)),V=(t.n(Y),t(199)),X=(t.n(V),t(198)),H=(t.n(X),t(175)),G=(t.n(H),t(174)),U=(t.n(G),t(176)),W=(t.n(U),t(178)),J=(t.n(W),t(177)),K=(t.n(J),t(179)),Q=(t.n(K),t(163)),Z=(t.n(Q),t(164)),$=(t.n(Z),t(2)),ee=t.n($),ne=t(3),te=t.n(ne),re=t(12),ae=t.n(re),ie=t(13),oe=t.n(ie),se=t(9),de=t(1),le=t(8),ce=(t.n(le),t(162)),ue=(t.n(ce),t(50)),he=(t.n(ue),t(161)),ge=(t.n(he),t(49)),pe=t(51),fe=t(52),me=t(99),be=t.n(me),ye=t(39),ve=t.n(ye),xe=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},we=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),_e=t.i(de.a)(be.a),Te=function(e){function n(e){r(this,n);var i=a(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return ke.call(i),i.graphId="graph"+i.props.id,i.graph=n.parseGraph(i.props),Object.assign(i,t.i(ge.a)(i,n),t.i(pe.a)(i,n),t.i(fe.a)(i,n)),i}return i(n,e),we(n,[{key:"componentDidMount",value:function(){var e=this;this.sigma=new sigma({renderer:{container:this.graphId,type:"canvas"},graph:this.readGraph(this.graph)}),sigma.utils.zoomTo(this.sigma.cameras[0],0,0,1.2),this.sigma.renderers[0].glyphs(),this.sigma.renderers[0].bind("render",function(){return e.sigma.renderers[0].glyphs()}),this.attachEvents(),this.createGraph()}},{key:"componentWillReceiveProps",value:function(e){var t=this,r=n.parseGraph(e),a=function(){t.updateAppearence(e.colors,e.customLabels)},i=function(){t.killAppearenceAnimations()};this.killAppearenceAnimations(),ae()(r,this.graph)?ae()(r.export(),this.graph.export())?a():this.updateGraphSoft(r,a,i):(this.resetAppearence(),this.updateGraphHard(r,a,i))}},{key:"componentWillUnmount",value:function(){this.killAppearenceAnimations(),this.detachEvents(),this.sigma.kill()}},{key:"createGraph",value:function(){var e=this.graph;this.sigma.graph.clear(),this.sigma.settings(xe({zoomMin:.3,zoomMax:5.5,minArrowSize:6,maxEdgeSize:5,minNodeSize:15,maxNodeSize:15,defaultLabelSize:ve.a.labelSize,font:le.uiFont,edgeLabelSize:"proportional",defaultLabelColor:this.textColor,defaultEdgeLabelColor:this.textColor,doubleClickEnabled:!1,enableHovering:!1,edgeLabelSizePowRatio:1.1,glyphScale:.7,glyphLineWidth:5,glyphFontScale:1.5,glyphThreshold:6,glyphFillColor:this.backgroundColor,glyphTextColor:this.textColor,animationsTime:this.props.app.animationsEnabled?400:0,autoCurveRatio:10},n.typeOptions[e.type])),this.sigma.graph.read(this.readGraph(e)),this.layout()}},{key:"layout",value:function(){sigma.canvas.edges.autoCurve(this.sigma),sigma.layouts.killForceLink(this.sigma),sigma.layouts.startForceLink(this.sigma,{worker:!0,gravity:1.5,scalingRatio:10,autoStop:!0,background:!0,easing:"cubicInOut",alignNodeSiblings:!0})}},{key:"render",value:function(){return ee.a.createElement("div",{id:this.graphId,className:_e("style",this.props.theme),style:{display:t.i(de.c)("graph",this.props,!0)?"block":"none"}})}}]),n}($.Component);Te.parseGraph=function(e){return t.i(de.d)(JSON.parse(JSON.stringify(e.optGraph||e.input[se.b.graph].value)))},Te.typeOptions={directed:{defaultEdgeType:ve.a.curvedEdges?"curvedArrow":"arrow"},undirected:{defaultEdgeType:ve.a.curvedEdges?"curvedLine":"line"},mixed:{}};var ke=function(){var e=this;this.shouldComponentUpdate=function(){return!1},this.node=function(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return{id:n,label:""+n,size:1,color:e.defaultColor,x:t,y:r,glyphs:[{position:"top-left",strokeColor:function(){return this.color},content:void 0,draw:!1}]}},this.edge=function(n,t,r){return{id:n,source:t.source(n),target:t.target(n),label:!oe()(r)&&""+r,color:e.defaultColor,size:1}},this.readGraph=function(n){return{nodes:n.nodes().map(function(t,r){return e.node(t,100*Math.cos(2*r*Math.PI/n.order),100*Math.sin(2*r*Math.PI/n.order))}),edges:n.edges().map(function(t){return e.edge(t,n,n.getEdgeAttribute(t,"weight"))})}}};Te.defaultProps={optGraph:null,customLabels:{}},Te.propTypes={id:te.a.string.isRequired,optGraph:te.a.object,customLabels:te.a.object,input:te.a.objectOf(te.a.shape({update:te.a.func,value:te.a.any})).isRequired,theme:te.a.string.isRequired,animationNextFrameTime:te.a.number.isRequired},n.a=Te},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(236),d=(t.n(s),t(1)),l=t(100),c=t.n(l),u=t.i(d.a)(c.a),h=function(e){return t.i(d.c)("table",e,e.data.length>0&&a.a.createElement("div",{className:u("container",e.theme)},a.a.createElement(s.Table,null,a.a.createElement(s.TableHeader,{adjustForCheckbox:!1,displaySelectAll:!1},a.a.createElement(s.TableRow,null,e.columns.map(function(e){return a.a.createElement(s.TableHeaderColumn,{key:e,style:{textAlign:"center"}},e)}))),a.a.createElement(s.TableBody,{displayRowCheckbox:!1,style:{maxHeight:e.width+"px"}},e.data.map(function(n,t){return a.a.createElement(s.TableRow,{key:"row"+t+JSON.stringify(n),hoverable:!0},n.map(function(n,t){return a.a.createElement(s.TableRowColumn,{key:"v"+e.columns[t]+n,style:{textAlign:"center"}},n)}))}))))||null)};h.propTypes={width:o.a.number.isRequired,columns:o.a.arrayOf(o.a.string).isRequired,data:o.a.array.isRequired,theme:o.a.string.isRequired},n.a=h},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(1),d=t(101),l=(t.n(d),function(e){return t.i(s.c)("text",e,a.a.createElement("div",{className:d.style},e.text))});l.propTypes={text:o.a.string},l.defaultProps={text:""},n.a=l},function(e,n,t){"use strict";function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function o(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}t.d(n,"b",function(){return v});var s=t(2),d=t.n(s),l=t(27),c=t.n(l),u=t(1),h=t(58),g=t(81),p=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},f=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),m=function(e,n){e.push(JSON.parse(JSON.stringify(n)))},b=function(e,n){return function(){return m(e,n.apply(void 0,arguments))}},y=function(e,n){return c()(e,function(e,t){return void 0!==n[t]})},v=function(e,n){return function(r){var a=[];return Promise.resolve(e(r,b(a,n))).catch(function(e){throw e}).then(function(){if(0===a.length)throw t.i(u.k)("Algorithm must frame at least once")}).then(function(){return a})}},x=function(e){var n=e.logic,l=e.snap,c=e.input,m=e.inputType,b=e.info,x=e.modules;return function(e){var m,w,_=e.revampedAlgInputType;return w=m=function(e){function n(e){a(this,n);var o=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return o.cancellable=function(e){var n=t.i(u.l)(e);return o.cancellables.push(n),n.promise},o.cancelRunning=function(){for(;o.cancellables.length>0;)o.cancellables.pop().cancel()},o.getInput=function(){return y(o.state,c)},o.inputs=function(){return _.map(function(e){var n=e.inputName,t=e.inputType,a=t.type,i=t.invalid;return{type:a,data:t.data,value:o.getInput()[n],validate:function(e){return!i(e,o.getInput())},invalid:function(e){return i(e,o.getInput())},update:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){},a=i(e,o.getInput());return a?t(a):o.inputHandler(r({},n,e),t)}}})},o.state=p({},c),o.state.frames=null,o.state.updating=!0,o.cancellables=[],o}return o(n,e),f(n,[{key:"componentDidMount",value:function(){var e=this;this.cancellable(n.logic(c)).then(function(n){e.setState({frames:n,updating:!1})}).catch(u.m).catch(function(e){throw new Error("Algorithm can't init, "+e)})}},{key:"componentWillUnmount",value:function(){this.cancelRunning()}},{key:"inputHandler",value:function(e,t){var r=this;this.setState({updating:!0});var a=p({},this.state,e);this.cancellable(n.logic(y(a,c))).then(function(n){r.setState(p({},e,{frames:n,updating:!1}),t)}).catch(u.m).catch(function(e){throw new Error("Input is faulty, "+e)})}},{key:"render",value:function(){var e=this;return d.a.createElement(g.a,p({},this.props,{overlay:this.state.frames?d.a.createElement(h.a,p({},this.props,{frames:this.state.frames,algorithmInfo:b,algorithmStatic:"function"==typeof x?x(this.props.app.settings):x,algorithmInput:this.inputs()})):null,disabled:!this.state.updating,message:this.state.frames?"Evaluating":"Loading Algorithm",tooLongTime:3e3,tooLongMessage:"Algorithm logic is taking too long to compute",tooLongEscape:function(){return e.cancelRunning(),e.state.frames?e.setState({updating:!1}):e.props.app.goBack()}}))}}]),n}(s.Component),m.logic=v(n,l),m.selectInput=function(e){return _.filter(function(n){return n.inputType.type===e})},w}({revampedAlgInputType:Object.keys(m).reduce(function(e,n){return e.concat((Array.isArray(m[n])?m[n]:[m[n]]).map(function(e){return{inputName:n,inputType:e}}))},[])})};n.a=x},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}var a=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),i=function(){function e(n,t,a){var i=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;r(this,e),this.getSpeed=function(){return i.speed},this.getProgress=function(){return i.progress},this.getDirectives=function(){return i.directives},this.getIsPaused=function(){return i.isPaused},this.getNextFrameTime=function(){return i.nextFrameTime},this.toBegin=function(){return i.advanceTo(0)},this.toEnd=function(){return i.advanceTo(i.frames.length-1)},this.stepForward=function(){return i.advance(1)},this.stepBackward=function(){return i.advance(-1)},this.pauseRestart=function(){return i.isPaused=!i.isPaused,i.didEnd?(i.didEnd=!1,i.toBegin()):i.changeHandler()},this.changeSpeed=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:50;if(arguments[1])return void i.setting()("speed").set(i.speed);var t=n;n>=100&&(t=100),n<=0&&(t=0),i.speed=t,i.internalSpeed=e.calcInternalSpeed(t),i.changeHandler()},this.mount=function(){var e=function(e){return setTimeout(e,i.nextFrameTime)},n=function n(){i.nextFrameTime=Math.floor(i.frameTime*i.internalSpeed*1e3),i.tick(),i.timer=e(n)};i.timer=e(n)},this.unmount=function(){clearTimeout(i.timer)},Object.assign(this,{frames:n,setting:t,changeHandler:a,frameTime:o}),this._init()}return a(e,[{key:"_init",value:function(){this.setting()("speed").default(50),this.speed=this.setting()("speed").get(),this.progress=0,this.directives=this.frames[0],this.isPaused=!0,this.nextFrameTime=1e3*this.frameTime,this.frameIndex=0,this.internalSpeed=e.calcInternalSpeed(this.speed),this.didEnd=!1}},{key:"refresh",value:function(e){this.frames=e,this._init(),this.changeHandler()}},{key:"tick",value:function(){this.isPaused||this.advance()}},{key:"advance",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return this.advanceTo(this.frameIndex+e)}},{key:"advanceTo",value:function(e){if(this.didEnd=!1,e>this.frames.length-1)return this.didEnd=!0,this.isPaused=!0,void(e===this.frames.length&&this.changeHandler());this.directives=e>0?this.frames[e]:this.frames[0],this.frameIndex=e>0?e:0,this.calculateProgress(),this.changeHandler()}},{key:"calculateProgress",value:function(){this.progress=Math.round(this.frameIndex/(this.frames.length-1)*100)}}]),e}();i.calcInternalSpeed=function(e){var n=e,t=void 0;return n-=50,n/=10,0===n?t=1:n<0?t=-1*n+1:n>0&&(t=1/(n+1)),t},n.a=i},function(e,n,t){"use strict";function r(e,n){var t={};for(var r in e)n.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}function a(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function o(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var s=t(2),d=t.n(s),l=t(3),c=t.n(l),u=t(77),h=t(57),g=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},p=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),f=function(e){function n(e){a(this,n);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.handleAnimatorChange=function(){t.setState({animationDirectives:t.animator.getDirectives(),speed:t.animator.getSpeed(),progress:t.animator.getProgress(),isPaused:t.animator.getIsPaused(),nextFrameTime:t.animator.getNextFrameTime()})},t.animator=new h.a(e.frames,function(){return e.app.settings("options")("animation")},t.handleAnimatorChange),t.state={animationDirectives:t.animator.getDirectives(),speed:t.animator.getSpeed(),progress:t.animator.getProgress(),isPaused:t.animator.getIsPaused(),nextFrameTime:t.animator.getNextFrameTime()},t}return o(n,e),p(n,[{key:"componentDidMount",value:function(){this.animator.mount()}},{key:"componentWillReceiveProps",value:function(e){e.frames!==this.props.frames&&this.animator.refresh(e.frames)}},{key:"componentWillUnmount",value:function(){this.animator.unmount()}},{key:"render",value:function(){var e=this.props,n=(e.frames,r(e,["frames"]));return d.a.createElement(u.a,g({},n,{animationDirectives:this.state.animationDirectives,animationSpeed:this.state.speed,animationProgress:this.state.progress,animationIsPaused:this.state.isPaused,animationNextFrameTime:this.state.nextFrameTime,onAnimationChangeSpeed:this.animator.changeSpeed,onAnimationToBegin:this.animator.toBegin,onAnimationStepForward:this.animator.stepForward,onAnimationPauseRestart:this.animator.pauseRestart,onAnimationStepBackward:this.animator.stepBackward,onAnimationToEnd:this.animator.toEnd}))}}]),n}(s.Component);f.propTypes={frames:c.a.array.isRequired},n.a=f},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function i(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var o=t(2),s=t.n(o),d=t(32),l=t.n(d),c=t(33),u=t.n(c),h=t(86),g=t(23),p=t(82),f=t(78),m=t(75),b=t(11),y=(t.n(b),t(8)),v=(t.n(y),function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}()),x=new h.a,w={view:p.a,name:"Main"},_=function(e){return JSON.stringify(JSON.parse(e.rawSettings)["visual-cache"])},T=function(e){function n(e){r(this,n);var i=a(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return i._topHistory=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return i.history[i.history.length-(1+e)]||null},i._getThemeColors=function(){return{palette:b.themes[i.settings("options")("theme").get()],fontFamily:y.uiFont}},i._getBack=function(){return i._topHistory(1)},i._setView=function(){i.setState({view:i._topHistory()||w,back:i._getBack()})},i.prompt=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){},t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};i.setState({modal:{type:"prompt",message:e,exitStrategy:function(){i.setState({modal:{}})},options:{continuation:n,refuse:t}}})},i.confirm=function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"Yes",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"No",s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"Cancel";i.setState({modal:{type:"confirm",message:e,exitStrategy:function(){i.setState({modal:{}})},options:{affirmative:n,negative:t,cancellor:r,yes:a,no:o,cancel:s}}})},i.alert=function(e,n){i.setState({modal:{type:"alert",message:n,exitStrategy:function(e){return"timeout"===e&&i.setState({modal:{}})},durationModifier:e+1}})},i.updateHeader=function(e,n){i.setState({headerRoutes:e},n)},i.goBack=function(){i.history.pop(),i._setView()},i.changeView=function(e){e.name!==i._topHistory().name&&(i.history.push(e),i._setView())},i.settings=t.i(m.a)(x,function(){i.setState({rawSettings:JSON.stringify(i.settings().get())})}),i.state={view:w,back:null,headerRoutes:[],modal:{},rawSettings:JSON.stringify(i.settings().get())},i.settings("options")("theme").default("giant-goldfish"),i.settings("options")("grayscale-visualizations").default(!1),i.settings("options")("animations-enabled").default(!0),i.settings("options")("custom-code")("timeout").default(5),Object.keys(g.a).forEach(function(e){i.settings("options")("enabled-modules")(e).default(!0)}),i.history=[w],i}return i(n,e),v(n,[{key:"componentDidMount",value:function(){requestAnimationFrame(function(){return setTimeout(function(){document.documentElement.removeAttribute("data-preload")},0)})}},{key:"shouldComponentUpdate",value:function(e,n){return _(this.state)===_(n)}},{key:"render",value:function(){return document.documentElement.setAttribute("data-theme",this.settings("options")("theme").get()),document.documentElement.setAttribute("data-animations-enabled",this.settings("options")("animations-enabled").get()),s.a.createElement(l.a,{muiTheme:u()(this._getThemeColors())},s.a.createElement(f.a,{view:this.state.view,modal:this.state.modal,backData:this.state.back,goBack:this.goBack,headerRoutes:this.state.headerRoutes,theme:this.settings("options")("theme").get(),animationsEnabled:this.settings("options")("animations-enabled").get(),settings:this.settings,rawSettings:this.state.rawSettings,prompt:this.prompt,alert:this.alert,confirm:this.confirm,updateHeader:this.updateHeader,changeView:this.changeView}))}}]),n}(o.Component);n.a=T},function(e,n,t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=function(e){var n=function n(t){if(t.isPrimitive)return t.data;if("function"===t.type)return function(){throw new Error("Functions passed from interpreter to native are masked and will throw when invoked")};var r=t.parent===e.ARRAY,a=r?[]:{};return Object.keys(t.properties).forEach(function(e){var r=t.properties[e],i=n(r);a[e]=i}),a},t=function n(t,i){var o=void 0===t?"undefined":r(t);if("number"===o||"string"===o||"boolean"===o)return e.createPrimitive(t);if("undefined"===o)return e.UNDEFINED;if("function"===o){var s=i||window;return e.createNativeFunction(a(s,t))}if("object"===o){var d=Array.isArray(t)?e.ARRAY:e.OBJECT,l=e.createObject(d);return Object.keys(t).forEach(function(r){var a=t[r],i=n(a,t);e.setProperty(l,r,i)}),l}throw new Error("Native to interpreter does not support type: "+o)},a=function(e,r){return function(){for(var a=arguments.length,i=Array(a),o=0;o<a;o++)i[o]=arguments[o];var s=i.map(function(e){return n(e)}),d=r.apply(e,s);return t(d)}};return{toNative:n,toInterpreter:t}};n.a=a},function(e,n,t){"use strict";t.d(n,"a",function(){return r}),t.d(n,"d",function(){return a}),t.d(n,"c",function(){return i}),t.d(n,"b",function(){return o}),t.d(n,"e",function(){return s});var r="// type your algorithm's logic code...\n//\n// variables you can use will appear as comments on top of\n// this editor as you specify options from the right sidebar.",a="Add your algorithm's description here, you can use markdown",i=["# enter your algorithm's pseudo-code"],o="Untitled Algorithm",s=[{name:"Custom Algorithm DFS Example",data:{code:"// type your algorithm's logic code, variables you can use will appear as comments on top of\n// this editor as you specify options from the right sidebar. Below you see an example algorithm,\n// DFS, with a starting vertex option and 2 tables (called visiterd and recursion) added.\nconst { graph, startVertex: st } = input;\n\nconst vis2array = vis => Object.keys(vis)\n\t.map((k) => ((vis[k] !== true) ? -1 : k))\n\t.filter(v => (v !== -1));\n\nconst getNeighbors = (v) => graph.edges.map(o => {\n    if (o.source === v) {\n        return {\n            u: o.target,\n            edge: o.key\n        };\n    }\n    \n    if (o.undirected && o.target === v) {\n        return {\n            u: o.source,\n            edge: o.key\n        };\n    }\n}).filter(x => x);\n\nconst reclist = [];\nconst posEd = [];\nconst vis = graph.nodes.map(v => v.key).reduce((acc, v) => {\n\tacc[v] = false;\n\treturn acc;\n}, {});\n\n/**\n * snap is a normal function, but functions like this are very helpful, since manually typing\n * all algorithm things when you want to shoot a frame is very not DRY.\n *\n * at the end it calls 'frame' which shoots a frame.\n */\nconst snap = (a, b, c, d) => {\n    // these are kinda constants / or change according to a constant, no need for specific params for them\n\tAlgorithm.visited([Object.keys(vis), Object.keys(vis).map(k => vis[k].toString())]); // These two tables are added from the right sidebar, their names were specified there too\n\tAlgorithm.recursion([reclist]); // This is the other table, we are passing columns to it, you can see the API for detailed info\n\tAlgorithm.graph.setColor(0, vis2array(vis), posEd); // graph property is set, since the type is 'graph'\n\tAlgorithm.graph.setColor(1, reclist, []); // you can see its API for info\n\n\t// these change everytime, use params\n\tAlgorithm.code(a); // pseudo-code, a is the lines to highlight, [0, 1, ...]\n\tAlgorithm.explanation(b); // explanation is also in every algorithm, you must give a quick explanation; b is a string\n\tAlgorithm.graph.setColor(2, c, d);\n\tframe(); // when you are ready to make a frame, call the frame global.\n};\n\nconst dfs = v => {\n\tsnap([0], `Start DFS(${v})`, v); // we are shooting a frame here\n\tif (vis[v]) {\n\t\tsnap([1], `${v} is visited; return`, v); // here too\n\t\treturn;\n\t}\n\tvis[v] = true;\n\tsnap([2], `Mark ${v} visited`, v); // here too too :D\n\tgetNeighbors(v).forEach(({ u, edge }) => {\n\t\tsnap([3, 4], `For neighbour ${u} of ${v} do DFS`, v, edge);\n\t\treclist.push(u);\n\t\tdfs(u);\n\t\treclist.pop();\n\t\tposEd.push(edge);\n\t});\n\tsnap([5], `DFS(${v}) ended!`, v);\n};\nreclist.push(st);\nsnap([], undefined);\nsnap([7], `Starting main DFS from ${st}`, st);\ndfs(st);\nsnap([], `DFS from ${st} ended!`, st);\n\n// ps: the editor you are seeing here is ace, you can find it's default keyboard shortcuts here:\n// https://github.com/ajaxorg/ace/wiki/Default-Keyboard-Shortcuts",name:"Custom Algorithm DFS Example",type:"graph",typeFeatures:{"Starting Vertex":!0},pseudoCode:["DFS(v):","    if v is visited return","    mark v visited","    for every neighbour u of v:","        DFS(u)","    return","DFS(s)"],description:"Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.\n\nA version of depth-first search was investigated in the 19th century by French mathematician Charles Pierre TrÃ©maux as a strategy for solving mazes.",tables:[{id:"recursion",columns:["Recursion"]},{id:"visited",columns:["Nodes","Visited"]}],debugConsole:[]}}]},function(e,n,t){"use strict";var r=t(226),a=t.n(r),i=t(60),o=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments[4];return new a.a(o,function(a,o){var s=new i.a(a);a.setProperty(o,"frame",s.toInterpreter(t),a.READONLY_DESCRIPTOR),a.setProperty(o,"input",s.toInterpreter(n),a.READONLY_DESCRIPTOR),a.setProperty(o,"Algorithm",s.toInterpreter(e),a.READONLY_DESCRIPTOR),Object.keys(r).forEach(function(e){a.setProperty(o,e,s.toInterpreter(r[e]),a.READONLY_DESCRIPTOR)})})};n.a=o},function(e,n,t){"use strict";function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function i(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function o(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var s=t(2),d=t.n(s),l=t(3),c=t.n(l),u=t(5),h=t(80),g=t(85),p=t(10),f=t.n(p),m=t(111),b=t.n(m),y=t(62),v=t(61),x=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},w="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),T=function(e,n){return{value:e,set:n}},k=function(e){function n(e){a(this,n);var t=i(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.debugBindings={log:function(){for(var e=arguments.length,n=Array(e),r=0;r<e;r++)n[r]=arguments[r];t.setState(function(e){return e.debugConsole.push(n.map(function(e){var n=void 0===e?"undefined":w(e);return"function"===n?"function "+e.name:"undefined"===n?"undefined":JSON.stringify(e,function(e,n){return"function"==typeof n?"function "+n.name:n},2)}).join(" ")),e})}},t.onCodeChange=function(e){t.addToState("code",e)},t.onSelectSave=function(e){t.setState(e.data)},t.renameSave=function(e,n){t.saves().set(function(t){return t.find(function(n){return n.name===e.name}).name=n,t})},t.deleteSave=function(e){t.saves().set(function(n){return n.splice(n.findIndex(function(n){return n.name===e.name}),1),n})},t.addSave=function(e){t.saves().set(function(n){var r=n.findIndex(function(n){return n.name===e});return-1!==r?(n[r]={name:e,data:x({},t.state)},n):(n.push({name:e,data:x({},t.state)}),n)})},t.getCodeTranspiled=function(){return'"use strict";;'+b.a+";!(function() {;"+g.a.transform(t.state.code,{presets:["es2015"]}).code+"\n;}());"},t.run=function(){t.addToState("debugConsole",[]);var e=t.createAlgFromInfo();e.dryRun(t.getLogic(e,t.debugBindings)).catch(function(e){if("AlgorithmError"!==e.name)throw e})},t.visualize=function(){var e=function(){var e=t.createAlgFromInfo();e.logic=t.getLogic(e,f()(t.debugBindings,function(){return function(){}})),t.props.app.changeView(e.asView())},n=t.saves().get().findIndex(function(e){return e.name===t.state.name});if(-1===n||t.saves().get()[n].data.code!==t.state.code)return void t.props.app.confirm("Save before visualizing?",function(){t.addSave(t.state.name),e()},e);e()},t.prependCode=function(e){t.setState(function(n){return n.code=e+"\n"+n.code,n})},t.addToState=function(e,n){t.setState(r({},e,n))},t.algName=function(){return T(t.state.name,function(e){return t.addToState("name",e)})},t.algType=function(){return T({current:t.state.type,possible:Object.keys(u.a)},function(e){t.prependCode("// Algorithm Type is "+e+", input is available as `input."+e+"`, controls are available as `Algorithm."+e+"`"+(t.state.name.includes(" ")?"":" and `"+t.state.name+"["+e+"]`")),t.addToState("type",e),t.addToState("typeFeatures",{})})},t.algTypeFeatures=function(){return T((u.a[t.state.type]||[]).map(function(e){return{name:e.name,enabled:t.state.typeFeatures[e.name]||!1}}),function(e,n){t.prependCode("// Feature "+e+" of type "+t.state.type+" is now "+(n?"enabled, available as `input."+u.a[t.state.type].find(function(n){return n.name===e}).propName+"`":"disabled")+" "),t.setState(function(t){return t.typeFeatures[e]=n,t})})},t.algPseudoCode=function(){return T(t.state.pseudoCode.join("\n"),function(e){return t.addToState("pseudoCode",e.split("\n"))})},t.algDescription=function(){return T(t.state.description,function(e){return t.addToState("description",e)})},t.algTables=function(){return T(t.state.tables,function(){return{add:function(e,n,r){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){};t.setState(function(t){var a=t.tables.find(function(n){return n.id===e});return a?(a.columns=n,a.id=r||e,t):(t.tables.push({id:e,columns:n}),t)},a)},remove:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){};t.setState(function(n){var t=n.tables.findIndex(function(n){return n.id===e});return-1!==t&&n.tables.splice(t,1),n},n)}}})},t.state={code:Object.keys(u.b).map(function(e){return"// "+u.b[e]+" is available as `Algorithm."+e+"`"}).join("\n")+"\n\n"+v.a,name:v.b,type:void 0,typeFeatures:{},pseudoCode:v.c,description:v.d,tables:[],debugConsole:[]},t.saves=function(){return t.props.app.settings("custom-code")("saves")},t.saves().default(v.e),t}return o(n,e),_(n,[{key:"createAlgFromInfo",value:function(){var e=this,n=t.i(u.c)(this.state.name,this.state.type);return Object.keys(this.state.typeFeatures).filter(function(n){return e.state.typeFeatures[n]}).map(function(n){return u.a[e.state.type].find(function(e){return e.name===n}).method}).forEach(function(e){n[e]()}),this.state.tables.forEach(function(e){n.addTable(e.id,e.columns)}),n.addDescription(this.state.description),n.addCode(this.state.pseudoCode),n}},{key:"getLogic",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=n.algorithm,a=arguments[1];return function(n,i){return new Promise(function(o,s){var d=void 0;try{d=t.i(y.a)(r,n,i,a,e.getCodeTranspiled())}catch(e){return s(e)}var l=!0,c=setTimeout(function(){l=!1,d=void 0,s(new Error("Algorithm is taking too long to complete, check for infinite loops"))},1e3*e.props.app.settings("options")("custom-code")("timeout").get());!function e(){if(l){var n=!1;try{for(var t=!0,r=1e3;r>0&&t;r--)t=d.step();n=t}catch(e){return s(e)}return n?setImmediate(e):(clearTimeout(c),o())}}()})}}},{key:"checkAlgorithmValidity",value:function(){var e=this,n=this.createAlgFromInfo();return new Promise(function(t){n.dryRun(e.getLogic(n,f()(e.debugBindings,function(){return function(){}}))).then(function(){return t(!1)}).catch(function(e){if("AlgorithmError"===e.name)return void t({alg:!0,err:"Problems with your code, can't visualize!\n"+e.toString()});t({alg:!1,err:e.toString()})})})}},{key:"render",value:function(){return d.a.createElement(h.a,x({},this.props,{onCodeChange:this.onCodeChange,code:this.state.code,savedCodes:this.saves().get(),onSelectSave:this.onSelectSave,renameSave:this.renameSave,deleteSave:this.deleteSave,addSave:this.addSave,visualize:this.visualize,run:this.run,errProms:this.checkAlgorithmValidity(),debugConsole:this.state.debugConsole,algName:this.algName(),algType:this.algType(),algTypeFeatures:this.algTypeFeatures(),algPseudoCode:this.algPseudoCode(),algDescription:this.algDescription(),algTables:this.algTables()}))}}]),n}(s.Component);k.propTypes={app:c.a.any.isRequired},n.a=k},function(e,n,t){"use strict";var r=t(5),a=t(1),i=t.i(r.d)("BFS","graph");i.addStartingNodeInput(),i.addDescription("\nBreadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.\n\nBFS was invented in the late 1950s by E. F. Moore, who used it to find the shortest path out of a maze, and discovered independently by C. Y. Lee as a wire routing algorithm (published 1961).\n"),i.addCode(["BFS(s):","    Q = {s}; // FIFO","    while Q is not empty","        v = Q.front(); Q.pop();","        if v is visited already, continue;","        mark v visited","        for each neighbour u of v:","            if u is visited already, continue;","            else, Q.push(u);"]),i.addTable("queue",["Queue"]),i.addNodedTable("visited","Visited"),i.logic=function(e,n){var r=e.startVertex,o=e.graph,s=t.i(a.d)(o),d=i.algorithm,l=[],c=[],u=[],h=s.nodes().reduce(function(e,n){return e[n]=!1,e},{}),g=function(e,r,i,o){d.visited(h),d.queue([l]),d.graph.setColor(0,t.i(a.n)(h),u),d.graph.setColor(1,l,[]),d.code(e),d.explanation(r),d.graph.setColor(2,i,o),n()};g([],void 0),l.push(r),c.push(void 0),g([0,1],"Run BFS from vertex "+r,r);for(;0!==l.length;){(function(){var e=l.shift(),n=c.shift();if(g([3],"Processing vertex "+e,e),h[e])return g([4],"Vertex "+e+" is visited",e),"continue";h[e]=!0,n&&u.push(s.edge(n,e)),g([5],"Mark vertex "+e+" visited"),s.outNeighbors(e).forEach(function(n){if(h[n])return void g([7],"Vertex "+n+" is visited",e,s.edge(e,n));l.push(n),c.push(e),g([8],"Vertex "+n+" is not visited, push to queue",e,s.edge(e,n))})})()}g([],"BFS("+r+") completed")},n.a=i.create()},function(e,n,t){"use strict";var r=t(5),a=t(1),i=t.i(r.d)("DFS","graph");i.addStartingNodeInput(),i.addDescription("\nDepth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.\n\nA version of depth-first search was investigated in the 19th century by French mathematician Charles Pierre TrÃ©maux as a strategy for solving mazes.\n"),i.addCode(["DFS(v):","    if v is visited return","    mark v visited","    for every neighbour u of v:","        DFS(u)","    return"," ","DFS(s)"]),i.addTable("recursion",["Recursion Stack"]),i.addNodedTable("visited","Visited"),i.logic=function(e,n){var r=e.startVertex,o=e.graph,s=t.i(a.d)(o),d=i.algorithm,l=[],c=[],u=s.nodes().reduce(function(e,n){return e[n]=!1,e},{}),h=function(e,r,i,o){d.visited(u),d.recursion([l]),d.graph.setColor(0,t.i(a.n)(u),c),d.graph.setColor(1,l,[]),d.code(e),d.explanation(r),d.graph.setColor(2,i,o),n()};l.push(r),h([],void 0),h([7],"Starting main DFS from "+r,r),function e(n){if(h([0],"Start DFS("+n+")",n),u[n])return void h([1],n+" is visited; return",n);u[n]=!0,h([2],"Mark "+n+" visited",n),s.outNeighbors(n).forEach(function(t){h([3,4],"For neighbour "+t+" of "+n+" do DFS",n,s.edge(n,t)),l.push(t),e(t),l.pop(),c.push(s.edge(n,t))}),h([5],"DFS("+n+") ended!",n)}(r),h([],"DFS from "+r+" ended!",r)},n.a=i.create()},function(e,n,t){"use strict";var r=t(5),a=t(1),i=t.i(r.d)("Djikstra","graph");i.addStartingNodeInput(),i.addDescription("\nDijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.\n\nThe algorithm exists in many variants; Dijkstra's original variant found the shortest path between two nodes, but a more common variant fixes a single node as the \"source\" node and finds shortest paths from the source to all other nodes in the graph, producing a shortest-path tree.\n\nThe algorithm only works as long as we do not have edges with negative weights. Otherwise, there is noguarantee that when we pick u as the closest vertex, dist[v] for some other vertex v will not becomesmaller than dist[u] at some time in the future.\n"),i.addCode(["Djikstra(s):","    enqueue pair(s, 0) // Min-PriorityQueue","    while pq is not empty","         retrieve node v and distance d -> dequeue","         if v is visited continue","         else mark node visited","         for every neighbor u of v","             enqueue pair(u, d + weight)"]),i.addNodedTable("shortest","Distance"),i.addNodedTable("visited","Visited"),i.logic=function(e,n){var r=e.startVertex,o=e.graph,s=t.i(a.d)(o),d=i.algorithm,l=function(e,n,t){return{id:e,distance:n,parent:t}},c=[],u=s.nodes().reduce(function(e,n){return e[n]=1/0,e},{}),h=s.nodes().reduce(function(e,n){return e[n]=!1,e},{}),g=function(e,r,i,o){d.visited(h),d.graph.setColor(0,t.i(a.n)(h),c),d.graph.setGlyphs(u),d.shortest(u),d.code(e),d.explanation(r),d.graph.setColor(1,i,o),n()},p=new a.o.PriorityQueue(function(e,n){return e.distance>n.distance?-1:e.distance<n.distance?1:0});g([],void 0),g([0],"Starting Djikstra from node "+r,r),p.enqueue(l(r,0)),g([1],"Enqueue the starting node "+r+" with the distance 0",r);for(;!p.isEmpty();){(function(){var e=p.dequeue(),n=e.distance,t=e.id,r=e.parent;if(g([2,3],"Dequeued node "+t+" with distance "+n,t),h[t])return g([4],"Node "+t+" is visited, continue",t),"continue";u[t]=n,h[t]=!0,r&&c.push(s.edge(r,t)),g([5],"Mark "+t+" visited"),s.outNeighbors(t).forEach(function(e){var r=s.getEdgeAttribute(t,e,"weight");g([6,7],"Enqueue neighbor "+e+" with distance "+(r+n)+" (= weight "+r+" + v's distance "+n+")",e,s.edge(t,e)),p.enqueue(l(e,r+n,t))})})()}g([],"Djikstra from "+r+" completed")},n.a=i.create()},function(e,n,t){"use strict";var r=t(5),a=t(1),i=t(12),o=t.n(i),s=t(230),d=t.n(s),l=t(229),c=t.n(l),u=t.i(r.d)("Kruskal","graph");u.addDescription("\nA minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. That is, it is a spanning tree whose sum of edge weights is as small as possible. Directed graph equivalent of a MST is a minimum spanning arborescence.\n\nThe algorithm initializes a forest consisting of trees with single nodes. The edges are sorted in a queue based on their weights. In each round an edge is removed from the queue. If the edge's endpoints belong to different trees then the trees are merged using the edge. The process continues until all the nodes are in the same tree or the edge-queue is empty.\n"),u.addCode(["Kruskal(s):","    map each vertex v -> makeset v","    sort edges by increasing weight -> E","    while E is not empty","         pop e from E","         if both extremities of e are from different sets","             union both sets","             add e to mst"]),u.addText("sum"),u.logic=function(e,n){var r=e.graph,i=t.i(a.d)(r),s=u.algorithm,l=0,h=[],g=i.nodes().reduce(function(e,n){return e[n]=!1,e},{}),p=function(e,r,i,o,d,c,u,p){s.code(e),s.graph.setColor(0,t.i(a.n)(g),h),s.graph.setColor(1,d,u),s.graph.setColor(2,c,p),s.graph.setColor(3,i,o),s.explanation(r),s.sum("MST Cost: "+l),n()};p([],void 0),p([0],"Starting MST-Kruskal");var f=i.nodes().map(function(e){return[e]});p([1],"Make a set for every node, that initially only contains that node",i.nodes());var m=i.edges();m.sort(function(e,n){return i.getEdgeAttribute(n,"weight")-i.getEdgeAttribute(e,"weight")}),p([2],"Sort edges by increasing weight:\n"+m.map(function(e){return i.extremities(e).join("-")}).join(", "),i.nodes()),m.reverse(),m.forEach(function(e){var n=i.extremities(e),t=i.getEdgeAttribute(e,"weight");p([3,4],"Pop edge "+i.extremities(e).join("-")+" with connection cost "+t,n,e);var r=n.map(function(e){return f.find(function(n){return n.includes(e)})});if(!o()(r[0],r[1])){var a=r.map(function(e){for(var n=[],t=0;t<e.length;t++)for(var r=t+1;r<e.length;r++)n.push(i.edge(e[t],e[r]));return n}).filter(function(e){return e});p([5],"Vertex "+n[0]+" and vertex "+n[1]+" are from different sets",null,e,r[0],r[1],a[0],a[1]),f=d()(f,r[0],r[1]),f.push(c()(r[0],r[1])),h.push(e),n.forEach(function(e){return g[e]=!0}),l+=t,p([6,7],"Union both sets")}}),p([],"MST-Kruskal completed, MST is "+l)},n.a=u.create()},function(e,n,t){"use strict";var r=t(5),a=t(1),i=t.i(r.d)("Prim","graph");i.addStartingNodeInput(),i.addDescription("\nA minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. That is, it is a spanning tree whose sum of edge weights is as small as possible. Directed equivalent of a MST is a minimum spanning arborescence.\n\nPrim's algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex.\n\nThe algorithm was developed in 1930 by Czech mathematician VojtÄ›ch JarnÃ­k and later rediscovered and republished by computer scientists Robert C. Prim in 1957 and Edsger W. Dijkstra in 1959.\n"),i.addCode(["Prim(s):","    enqueue pair(s, 0) // Min-PriorityQueue","    while pq is not empty","         retrieve node v and connection cost -> dequeue","         if v is visited continue","         else add cost to sum and mark node visited","         for every neighbor u of v","             enqueue pair(u, weight of edge v -> u)"]),i.addText("sum"),i.addNodedTable("visited","Visited"),i.logic=function(e,n){var r=e.startVertex,o=e.graph,s=t.i(a.d)(o),d=i.algorithm,l=function(e,n,t){return{id:e,weight:n,parent:t}},c=0,u=[],h=s.nodes().reduce(function(e,n){return e[n]=1/0,e},{}),g=s.nodes().reduce(function(e,n){return e[n]=!1,e},{}),p=function(e,r,i,o){d.code(e),d.graph.setColor(0,t.i(a.n)(g),u),d.graph.setColor(1,i,o),d.graph.setGlyphs(h),d.explanation(r),d.sum("MST Cost: "+c),d.visited(g),n()},f=new a.o.PriorityQueue(function(e,n){return e.weight>n.weight?-1:e.weight<n.weight?1:0});p([],void 0),p([0],"Starting MST-Prim from node "+r,r),f.enqueue(l(r,0)),p([1],"Enqueue the starting node "+r+" with connection cost 0",r);for(;!f.isEmpty();){(function(){var e=f.dequeue(),n=e.weight,t=e.id,r=e.parent;if(p([2,3],"Dequeued node "+t+" with connection cost "+n,t),g[t])return p([4],"Node "+t+" is visited, continue",t),"continue";c+=n,h[t]=n,g[t]=!0,r&&u.push(s.edge(r,t)),p([5],"Add cost "+n+" to sum and mark vertex "+t+" visited"),s.outNeighbors(t).forEach(function(e){var n=s.getEdgeAttribute(t,e,"weight");p([6,7],"Enqueue neighbor "+e+" with connection cost "+n,e,s.edge(t,e)),f.enqueue(l(e,n,t))})})()}p([],"MST-Prim from "+r+" completed, MST is "+c)},n.a=i.create()},function(e,n,t){"use strict";var r=t(5),a=t(1),i=t.i(r.d)("SCC","graph");i.addStartingNodeInput(),i.addDescription("\nIn the mathematical theory of directed graphs, a graph is said to be strongly connected or diconnected if every vertex is reachable from every other vertex. The strongly connected components or disconnected components of an arbitrary directed graph form a partition into subgraphs that are themselves strongly connected.\n\nKosaraju's algorithm uses two passes of depth first search. The first, in the original graph, is used to choose the order in which the outer loop of the second depth first search tests vertices for having been visited already and recursively explores them if not. The second depth first search is on the transpose graph of the original graph, and each recursive exploration finds a single new strongly connected component. It is named after S. Rao Kosaraju, who described it (but did not publish his results) in 1978; Micha Sharir later published it in 1981."),i.addCode(["SCC(s):","    computeFinishOrders(v):","        if v visited return","        else mark v visited","        for every neighbor u of v","            if u visited continue","            else computeFinishOrders(u)","        save finish time of v"," ","    for every node v","        if v visited continue","        else computeFinishOrders(v)","    reset visited map"," ","    reverse graph","    let SCCID be 0"," ","    traverseConnectedComponent(v):","        if v visited return","        else mark v visited","        node v belongs to SCC SCCID","        for every neighbor u of v in reversed graph","            if u visited continue","            else traverseConnectedComponent(u)"," ","    while finishTimesList is not empty","        pop v from finishTimesList","        if v visited continue","        else traverseConnectedComponent(v)","        increase SCCID by one"]),i.addTable("f1",["Nodes","Finish Times"]),i.addTable("scc",["SCCs"]),i.logic=function(e,n){var r=e.startVertex,o=e.graph,s=t.i(a.d)(o),d=i.algorithm,l=function(e,n){return{fi:e,se:n}},c=void 0,u=void 0,h=void 0,g=void 0,p=function(){c=s.nodes().reduce(function(e,n){return e[n]=!1,e},{}),h=[],g=[],u=[]};p();var f=[],m=[],b=[],y=function(e,r,i,o){var s=[f.map(function(e){return e.fi.toString()}),f.map(function(e){return e.se.toString()})];d.code(e);var l=m.length;d.graph.setColor(0,t.i(a.n)(c),u),Array(l).fill(1).map(function(e,n){return n+1}).forEach(function(e,n){d.graph.setColor(e,m[n],b[n])}),d.graph.setColor(l+1,h,g),d.graph.setColor(l+2,i,o),d.graph.setGlyphs(s[1].reduce(function(e,n,t){return e[n]=s[0][t],e},{})),d.f1([s[1],s[0]]),d.scc([m.map(function(e){return e.join(", ")})]),d.explanation(r),n()},v=function(){d.graph.setOverrideGraph(s.export()),y.apply(void 0,arguments)};v([],void 0),v([],"Starting SCC from node "+r,r);var x=0,w=function e(n){c[n]||(h.push(n),v([3],"Traverse node "+n,n),c[n]=!0,s.outNeighbors(n).forEach(function(t){c[t]||(v([4,6],"Extend to neighbour "+t+" of "+n,[n,t],s.edge(n,t)),g.push(s.edge(n,t)),e(t),g.pop(),h.pop(),u.push(s.edge(n,t)))}),f.push(l(++x,n)),v([7],"Finish time of node "+n+" is "+x,n))};s.nodes().forEach(function(e){c[e]||(v([1,9,11],"computeFinishOrders("+e+")",e),w(e),h.pop())}),p(),v([12],"Computation of finish orders finished, reset vars");var _=t.i(a.p)(s);(v=function(){d.graph.setOverrideGraph(_.export()),y.apply(void 0,arguments)})([14],"Reverse the graph");for(var T=0,k=[];f.length>0;){var E=f.pop().se;if(!c[E]){v([17,28],"Traversing SCC "+T+" starting with node "+E,E),k[T]=[],function e(n){c[n]||(h.push(n),c[n]=!0,k[T].push(n),v([19],"Node "+n+" belongs to SCC "+T,n),_.outNeighbors(n).forEach(function(t){c[t]||(v([21,22],"Extend to neighbour "+t+" of "+n,n,_.edge(n,t)),g.push(_.edge(n,t)),e(t),g.pop(),h.pop(),u.push(_.edge(n,t)))}))}(E),h.pop();var C=function(e){return k.map(function(e){for(var n=[],t=0;t<e.length;t++)for(var r=0;r<e.length;r++)n.push(_.edge(e[t],e[r]));return n.filter(function(e){return e})}).filter(function(e){return e})[e]}(T);v([29],"Traversal of SCC "+T+" completed, it includes nodes:\n"+k[T],k[T],C),b[T]=C,m[T]=k[T],T++}}(v=function(){d.graph.setOverrideGraph(s.export()),y.apply(void 0,arguments)})([],"SCC from "+r+" completed "+T)},n.a=i.create()},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=function(e){return a.a.createElement("div",{className:"TopologicalDFS"}," ")};n.a=i},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=function(e){return a.a.createElement("div",{className:"TopologicalIndegree"}," ")};n.a=i},function(e,n,t){"use strict";t.d(n,"a",function(){return h});var r=t(66),a=t(64),i=t(65),o=t(69),s=t(68),d=t(67),l=t(70),c=t(71),u={Djikstra:{name:"Djikstra",desc:"Visualise Djikstra's Single Source Shortest Path Algorithm",view:r.a},BFS:{name:"BFS",desc:"Visualise Breadth-First Search Algorithm",view:a.a},DFS:{name:"DFS",desc:"Visualise Depth-First Search Algorithm",view:i.a},SCC:{name:"Strongly Connected Components",desc:"Visualise Kosaraju's Algorithm to find Strongly Connected Components",view:o.a},Prim:{name:"Prim's MST",desc:"Find a Minimum Spanning Tree using Prim's MST Algorithm",view:s.a},Kruskal:{name:"Kruskal's MST",desc:"Find a Minimum Spanning Tree using Kruskal's MST Algorithm",view:d.a},TopologicalDFS:{name:"Topological Sort (DFS)",desc:"Sort topologically using DFS",view:l.a},TopologicalIndegree:{name:"Topological Sort (Indegree Array)",desc:"Sort topologically using Indegree Array",view:c.a}},h=[{title:"Graph Algorithms",algorithms:[u.Djikstra,u.BFS,u.DFS,u.SCC,u.Prim,u.Kruskal,u.TopologicalDFS,u.TopologicalIndegree]}]},function(e,n,t){"use strict";function r(e){if(Array.isArray(e)){for(var n=0,t=Array(e.length);n<e.length;n++)t[n]=e[n];return t}return Array.from(e)}t.d(n,"c",function(){return u}),t.d(n,"b",function(){return p}),t.d(n,"a",function(){return f});var a=t(228),i=t.n(a),o=t(1),s=t(26),d=t.n(s),l=function(e,n){var t=new d.a[e](o.f);return n(t),"undirected"===t.type&&(t.inNeighbors=t.outNeighbors=t.neighbors),t},c=function(e,n){return l(e,function(e){var t=Math.max.apply(Math,r(n.map(function(e){return Math.max.apply(Math,r(e.map(function(e){return Array.isArray(e)?e[0]:e})))})));e.addNodesFrom(Array(t+1).fill(1).map(function(e,n){return n})),n.forEach(function(n,t){return n.forEach(function(n){var r=Array.isArray(n)?n[0]:n,a=Array.isArray(n)?n[1]:null;e.addEdgeWithKey(o.f.edgeKeyGenerator({source:t,target:r}),t,r,Array.isArray(n)&&{weight:a})})})}).export()},u=[{suits:["BFS","DFS"],graphs:[{name:"Undirected Cyclic",graph:c("UndirectedGraph",[[1,2,4],[3],[3],[4],[5]])},{name:"Undirected Acyclic",graph:c("UndirectedGraph",[[1,2,3,4],[5],[6],[7],[8],[9,10,11],[12,13,14],[15,16,17],[18,19,20]])},{name:"Dengesiz Binary Tree",graph:c("DirectedGraph",[[1,2],[3,4],[],[5,6],[],[7,8],[],[9,10]])}]},{suits:["Djikstra","BFS","DFS"],graphs:[{name:"Dengesiz Binary Tree Weighted",graph:c("DirectedGraph",[[[1,18],[2,3]],[[3,10],[4,6]],[],[[5,24],[6,3]],[],[[7,11],[8,15]],[],[[9,8],[10,10]]])},{name:"Directed Cyclic Weighted",graph:c("DirectedGraph",[[[1,5],[3,10]],[[2,1],[3,3]],[[3,2]],[[1,4]]])}]},{suits:["Prim","Djikstra","Kruskal","BFS","DFS"],graphs:[{name:"Undirected Cyclic Weighted",graph:c("UndirectedGraph",[[[1,4],[7,8]],[[2,8],[7,11]],[[3,7],[5,4],[8,2]],[[4,9],[5,14]],[[5,10]],[[6,2]],[[7,1],[8,6]],[[8,7]]])},{name:"Undirected Cyclic Weighted 2",graph:c("UndirectedGraph",[[[1,6],[2,3]],[[3,8],[4,1]],[[4,2]],[[4,10]]])},{name:"Undirected Big Numbers",graph:c("UndirectedGraph",[[[2,8447],[4,1922]],[[1,6144],[2,5366]],[[4,1677]]])}]},{suits:["BFS","DFS","SCC"],graphs:[{name:"Directed Cyclic 4 SCCs",graph:c("DirectedGraph",[[1,9],[2,8],[3,7],[4,5,6,7],[5],[4],[5],[2,4],[0,7],[8]])},{name:"Directed Cyclic 5 SCCs",graph:c("DirectedGraph",[[1,9],[2,8],[3,7,11],[4,5,6,7,14],[5],[4],[5,12],[2,4],[0,7],[8],[2],[10],[13],[6],[15],[16],[14,5]])}]}],h=function(e,n){return n.includes(e)},g=t.i(o.i)(u.map(function(e){return e.graphs})),p=function(e){return t.i(o.i)(u.map(function(n){return h(e,n.suits)?n.graphs:[]}))},f=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(e){if(i()(p(e)))return i()(p(e))}return i()(g)}},function(e,n,t){"use strict";var r=t(10),a=t.n(r),i=t(1),o=t(24),s=t(9),d=function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return{type:e,layout:"string"==typeof n?{location:n,order:0}:n,data:t}},l=function(e,n,t){return{snap:e,module:n,input:t}},c={},u=c.Graph=l(function(e,n,t){return{colors:e,customLabels:n,optGraph:t}},function(e){return d("graph","main",{options:e})},function(e){return a()(s.c.Graph,function(n){return t.i(o.b)("graph",e,n)})}),h=c.Table=l(function(e){return{data:Array(e.reduce(function(e,n){return Math.max(e,n.length)},0)).fill(1).map(function(n,t){return e.reduce(function(e,n){return e.push(n[t]),e},[])})}},function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:150;return d("table","right",{width:n,columns:e})}),g=(c.Text=l(function(e){return{text:e}},function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"right";return d("text",n,{text:e})}),c.Examples=l(function(){return{}},function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(e){return e},r=arguments[3];return d("examples",{location:"left",order:-100},{exampleGroup:e,examples:n,customs:(r("examples")(e).get()||[]).map(function(e){var n=e.data;return{name:e.name,data:t(n)}}),addCustom:function(n,t){return r("examples")(e).set(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return e.push({name:n,data:t}),e})},deleteCustom:function(n){return r("examples")(e).set(function(e){return e.splice(e.map(function(e){return e.name}).indexOf(n),1),e})},renameCustom:function(n,t){return r("examples")(e).set(function(e){return e[e.map(function(e){return e.name}).indexOf(n)].name=t,e})}})},function(e){return a()(s.c.Examples,function(n){return t.i(o.b)("examples",e,n)})}));c.Code=l(function(e){return{highlights:e}},function(e){return d("code",{location:"right",order:100},{code:e})}),c.ExampleGraphs=l(g.snap,function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),r=1;r<n;r++)t[r-1]=arguments[r];return g.module.apply(g,["Graph",e.map(function(e){return{name:e.name,data:e.graph}}),void 0].concat(t))},g.input),c.Description=l(function(){return{}},function(e){return d("description","left",{text:e})}),c.RefinedGraph=l(function(e,n){for(var t=arguments.length,r=Array(t>3?t-3:0),o=3;o<t;o++)r[o-3]=arguments[o];var s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},d=new i.g;return e.forEach(function(e){return d.pushNodes(Array.isArray(e)?e:[e])}),n.forEach(function(e){return d.pushEdges(Array.isArray(e)?e:[e])}),u.snap.apply(u,[d,a()(s,i.j)].concat(r))},function(){return u.module.apply(u,arguments)},function(){return u.input.apply(u,arguments)}),c.NodedTable=l(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return h.snap([Object.keys(e),Object.keys(e).map(function(n){return e[n].toString()})])},function(e){return h.module(["Node",e],200)});n.a=c},function(e,n,t){"use strict";var r=t(13),a=t.n(r),i=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){},t=function(){return JSON.parse(e.getItem("settings")||"{}")},r=function(t,r){e.setItem("settings",JSON.stringify(t)),r&&n()},i=function e(){var n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t(),o=arguments[2],s=o||i,d=function(t){var r=void 0;return r=i[n]?i[n]:i[n]={},e(t,r,s)};return d.set=function(e){var t="function"==typeof e?e:function(){return e};i[n]=t(i[n]),r(s,!0)},d.default=function(e){var t="function"==typeof e?e:function(){return e};a()(i[n])&&(i[n]=t(i[n]),r(s,!1))},d},o=function e(){var n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t(),i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=r;n&&(a()(r[n])?i=!0:o=r[n]);var s=function n(t){return i||a()(n.ctx[t])?e(!1,{},!0):e(!1,n.ctx[t])};return s.get=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0;return i?e:o},i||(s.ctx=o),s};return function e(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];n&&t.push(n);var r=function(n){return e(n,t)};return r.get=function(){var e,n=o(t[0]);return t.slice(1).forEach(function(e){return n=n(e)}),(e=n).get.apply(e,arguments)},r.set=function(){var e,n=i(t[0]);return t.slice(1).forEach(function(e){return n=n(e)}),(e=n).set.apply(e,arguments)},r.default=function(){var e,n=i(t[0]);return t.slice(1).forEach(function(e){return n=n(e)}),(e=n).default.apply(e,arguments)},r}};n.a=i},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(72),d=t(19),l=t(102),c=(t.n(l),function(e){return a.a.createElement("div",{className:l.pageView},s.a.map(function(n){return a.a.createElement("nav",{key:n.title},a.a.createElement("h1",null,n.title),a.a.createElement("div",{className:l.container},n.algorithms.map(function(n){return a.a.createElement(d.a,{name:n.name,key:n.name,desc:n.desc,cols:2,onTouchTap:function(){return e.app.changeView(n)},theme:e.app.theme})})))}))});c.propTypes={app:o.a.shape({theme:o.a.string.isRequired}).isRequired},n.a=c},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(40),d=t(41),l=t(45),c=t(103),u=(t.n(c),Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}),h=["algorithmInput","animationSpeed","animationIsPaused","onAnimationChangeSpeed","onAnimationToBegin","onAnimationToEnd","onAnimationStepBackward","onAnimationPauseRestart","onAnimationStepForward"],g=function(e){return a.a.createElement(l.a,null,a.a.createElement("section",{className:c.section},a.a.createElement(s.a,u({},Object.keys(e).filter(function(e){return!h.includes(e)}).reduce(function(n,t){return n[t]=e[t],n},{}),{input:e.algorithmInput.filter(function(e){return"module"===e.type}),theme:e.app.theme,visualCache:function(){return e.app.settings("visual-cache")("algorithmView")}}))),a.a.createElement("footer",{className:c.footer},a.a.createElement(d.a,u({},e,{input:e.algorithmInput.filter(function(e){return"init"===e.type}),theme:e.app.theme}))))};g.propTypes={app:o.a.any.isRequired,algorithmInput:o.a.arrayOf(o.a.shape({type:o.a.string.isRequired})).isRequired},n.a=g},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(235),d=t.n(s),l=t(4),c=t.n(l),u=t(42),h=t(44),g=t(20),p=t(1),f=t(244),m=t.n(f),b=t(237),y=t.n(b),v=t(6),x=t(104),w=t.n(x),_=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},T=t.i(p.a)(w.a),k=function(e){return Object.keys(e).filter(function(e){return!["view","backData","headerRoutes","modal"].includes(e)}).reduce(function(n,t){return n[t]=e[t],n},{})},E=function(e){return a.a.createElement("div",null,a.a.createElement(g.a,{style:{zIndex:2500},theme:e.theme,open:0!==Object.keys(e.modal).length&&["prompt","confirm"].includes(e.modal.type),title:e.modal.message,actions:function(){switch(e.modal.type){case"prompt":return[a.a.createElement(h.a,_({send:function(){var n;(n=e.modal.options).continuation.apply(n,arguments),e.modal.exitStrategy()}},t.i(v.a)(e.theme)))];case"confirm":var n=function(n,r,i){return a.a.createElement(c.a,{icon:n,label:e.modal.options[r],style:{color:t.i(p.b)(e.theme)("alternativeTextColor")},onTouchTap:function(){e.modal.options[i](),e.modal.exitStrategy()}})};return[a.a.createElement("div",{style:{display:"flex",justifyContent:"space-around"}},n(a.a.createElement(y.a,null),"yes","affirmative"),n(a.a.createElement(m.a,null),"no","negative"),n(a.a.createElement(y.a,null),"cancel","cancellor"))];default:return[]}}(),onRequestClose:function(){switch(e.modal.type){case"prompt":return function(){e.modal.options.refuse(),e.modal.exitStrategy()};case"confirm":return function(){e.modal.options.cancellor(),e.modal.exitStrategy()};default:return e.modal.exitStrategy}}()}),a.a.createElement(d.a,{open:0!==Object.keys(e.modal).length&&["alert"].includes(e.modal.type),message:e.modal.message||"",autoHideDuration:1500*(e.modal.durationModifier||1),onRequestClose:e.modal.exitStrategy,className:T("snackbar",e.theme)}))},C=function(e){return a.a.createElement("div",{className:T("container",e.theme)},E(e),a.a.createElement(u.a,{disabled:!e.backData,current:e.view,back:e.backData,routes:e.headerRoutes,app:k(e)}),a.a.createElement("div",{className:T("main")},a.a.createElement(e.view.view,{app:k(e)})))};C.defaultProps={backData:null},C.propTypes={view:o.a.object.isRequired,theme:o.a.string.isRequired,backData:o.a.any,headerRoutes:o.a.any.isRequired},n.a=C},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function i(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var o=t(2),s=t.n(o),d=t(3),l=t.n(d),c=t(14),u=t.n(c),h=t(4),g=t.n(h),p=t(7),f=t.n(p),m=t(15),b=(t.n(m),t(20)),y=t(1),v=t(6),x=t(18),w=t.n(x),_=t(34),T=t.n(_),k=t(17),E=t.n(k),C=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},S=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),A=function(e){function n(e){r(this,n);var t=a(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.onTableEditTap=function(e){t.openTableDialog(e.id,e)},t.onAddTableTap=function(){t.openTableDialog("Add")},t.onDeleteColumnTap=function(e){t.setState(function(n){return n.dCols.splice(n.dCols.findIndex(function(n){return n===e}),1),n})},t.onAddColumnTap=function(){t.props.prompt("Column Name",function(e){t.setState(function(n){return n.dCols.push(e),n})})},t.saveTable=function(){if(t.state.dTName){var e=function(){return t.dialogClose()};t.state.oldTable?t.props.vsTables.set().add(t.state.oldTable,t.state.dCols,t.state.dTName,e):t.props.vsTables.set().add(t.state.dTName,t.state.dCols,void 0,e)}},t.deleteTable=function(){var e=function(){return t.dialogClose()};t.props.vsTables.set().remove(t.state.oldTable,e)},t.dialogClose=function(){t.setState({dialogOpen:!1,dTName:"",dCols:[]})},t.state={dialogOpen:!1,dialogTitle:"",oldTable:!1,dTName:"",dCols:[]},t}return i(n,e),S(n,[{key:"openTableDialog",value:function(e,n){this.setState({dialogTitle:"Table - "+e,dialogOpen:!0,oldTable:!!n&&n.id,dTName:n?n.id:"",dCols:n?n.columns:[]})}},{key:"render",value:function(){var e=this,n={color:t.i(y.b)(this.props.theme)("alternativeTextColor")};return s.a.createElement("div",null,s.a.createElement(b.a,{theme:this.props.theme,open:this.state.dialogOpen,title:this.state.dialogTitle,onRequestClose:this.dialogClose,actions:[this.state.oldTable?s.a.createElement(g.a,{style:n,label:"Delete",onTouchTap:this.deleteTable}):void 0,s.a.createElement(g.a,{style:n,label:this.state.oldTable?"Save":"Add",onTouchTap:this.saveTable})].filter(function(e){return e})},s.a.createElement("div",null,s.a.createElement(f.a,C({},t.i(v.a)(this.props.theme),{id:"table-name-text-field-custom-code",floatingLabelText:"Table ID",value:this.state.dTName,onChange:function(n,t){return e.setState({dTName:t})}})),s.a.createElement(m.List,null,s.a.createElement(m.ListItem,{style:n,primaryText:"Columns",primaryTogglesNestedList:!0,autoGenerateNestedIndicator:!1,open:!0,disabled:!0,nestedItems:this.state.dCols.map(function(t){return s.a.createElement(m.ListItem,{style:n,key:t,primaryText:t,disabled:!0,rightIconButton:s.a.createElement(u.a,{touch:!0,onTouchTap:function(){return e.onDeleteColumnTap(t)}},s.a.createElement(E.a,n))})}),rightIconButton:s.a.createElement(u.a,{touch:!0,onTouchTap:function(){return e.onAddColumnTap()}},s.a.createElement(T.a,n))})))),s.a.createElement(m.List,null,s.a.createElement(m.ListItem,{primaryText:"Tables",autoGenerateNestedIndicator:!1,open:!0,disabled:!0,nestedItems:this.props.vsTables.value.map(function(n){return s.a.createElement(m.ListItem,{key:n.id,primaryText:n.id,disabled:!0,rightIconButton:s.a.createElement(u.a,{touch:!0,onTouchTap:function(){return e.onTableEditTap(n)}},s.a.createElement(w.a,null))})}),rightIconButton:s.a.createElement(u.a,{touch:!0,onTouchTap:this.onAddTableTap},s.a.createElement(T.a,null))})))}}]),n}(o.Component);A.propTypes={vsTables:l.a.object.isRequired,theme:l.a.string.isRequired,prompt:l.a.func.isRequired},n.a=A},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(22),d=t(15),l=(t.n(d),t(21)),c=t(234),u=t.n(c),h=t(7),g=t.n(h),p=t(29),f=t.n(p),m=t(16),b=t.n(m),y=t(31),v=t.n(y),x=t(28),w=t.n(x),_=t(252),T=t.n(_),k=t(256),E=t.n(k),C=t(17),S=t.n(C),A=t(18),j=t.n(A),N=t(1),I=t(8),O=t.n(I),P=t(6),R=t(25),M=(t.n(R),t(211)),q=(t.n(M),t(212)),z=(t.n(q),t(213)),L=(t.n(z),t(214)),D=(t.n(L),t(216)),F=(t.n(D),t(105)),B=t.n(F),Y=t(79),V=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},X=t.i(N.a)(B.a),H=function(e){var n=O.a.moduleMaxWidth,r=O.a.moduleMaxWidth,i=function(n){return a.a.createElement("div",{style:{width:"100%"}},a.a.createElement("div",{className:X("error",e.app.theme)},n))},o=function(n,r,i){return a.a.createElement(u.a,V({label:n,labelColor:t.i(N.b)(e.app.theme)("alternativeTextColor"),disabled:r},i))},c=function(){return e.app.settings("visual-cache")("customCodeView")};c()("algConfigDrawer")("isOpened").default(!0),c()("tables")("list")("isOpened").default(!0);var h=function(){return a.a.createElement(g.a,V({},t.i(P.a)(e.app.theme),{floatingLabelText:"Algorithm/Code Name",width:r,value:e.algName.value,onChange:function(n){return e.algName.set(n.target.value)}}))},p=function(){return a.a.createElement(f.a,V({floatingLabelText:"Algorithm Type",width:r,value:e.algType.value.current,onChange:function(n,t,r){return e.algType.set(r)}},t.i(P.b)(e.app.theme)),e.algType.value.possible.map(function(e){return a.a.createElement(b.a,{key:e,value:e,primaryText:e})}))},m=function(){return 0!==Object.keys(e.algTypeFeatures).length&&e.algType.value.current?a.a.createElement("div",{style:{width:r}},a.a.createElement(v.a,t.i(P.c)(),"Type Specific Features"),e.algTypeFeatures.value.map(function(n){var t=n.name,r=n.enabled;return a.a.createElement(w.a,{key:t,label:t,checked:r,onCheck:function(n,r){return e.algTypeFeatures.set(t,r)}})})):null},y=function(){return a.a.createElement(T.a,V({},t.i(P.d)(e.app.theme),{name:"text-editor-description",mode:"markdown",onChange:e.algDescription.set,value:e.algDescription.value,showGutter:!1,highlightActiveLine:!1,wrapEnabled:!0,editorProps:{$blockScrolling:1/0,wrap:!0},style:{width:r,height:.25*t.i(N.h)(r)+"px",minHeight:.25*t.i(N.h)(r)+"px",background:t.i(N.b)(e.app.theme)("backgroundColor"),fontFamily:"monospace",fontSize:"11pt"}}))},x=function(){return a.a.createElement(T.a,V({},t.i(P.d)(e.app.theme),{name:"text-editor-pseudo-code",onChange:e.algPseudoCode.set,value:e.algPseudoCode.value,style:{width:r,height:.5*t.i(N.h)(r)+"px",minHeight:.5*t.i(N.h)(r)+"px"}}))},_=function(){return a.a.createElement(E.a,{promise:e.errProms,then:function(e){return e?i(e.err):null},pendingRender:i("Processing")})},k=function(){return a.a.createElement("div",{style:{width:"100%"}},a.a.createElement("div",{className:X("button-container",e.app.theme)},a.a.createElement(E.a,{promise:e.errProms,then:function(n){return o("Run",n&&!n.alg,{onTouchTap:e.run,backgroundColor:t.i(N.b)(e.app.theme)("accent1Color")})},pendingRender:o("Run",!0)}),a.a.createElement(E.a,{promise:e.errProms,then:function(n){return o("Visualize",!!n,{onTouchTap:e.visualize,backgroundColor:t.i(N.b)(e.app.theme)("accent1Color")})},pendingRender:o("Visualize",!0)}),o("Save",!1,{onTouchTap:function(){return e.addSave(e.algName.value)},backgroundColor:t.i(N.b)(e.app.theme)("primary2Color")})))},C=function(){return e.debugConsole.length>0?a.a.createElement("div",{style:{width:"100%"}},a.a.createElement("div",{className:X("debug-console",e.app.theme)},e.debugConsole.map(function(e){return"> "+e}).join("\n"))):null},A=function(){return a.a.createElement(Y.a,{visualCache:function(){return c()("tables")},vsTables:e.algTables,theme:e.app.theme,prompt:e.app.prompt})};return a.a.createElement("div",{className:X("container",e.app.theme)},function(){return a.a.createElement(T.a,V({},t.i(P.d)(e.app.theme),{className:X("ace-editor",e.app.theme),mode:"javascript",name:"text-editor-logic-code",onChange:e.onCodeChange,value:e.code,enableBasicAutocompletion:!0,enableLiveAutocompletion:!0,setOptions:{enableSnippets:!1,showLineNumbers:!0}}))}(),function(){return a.a.createElement(s.a,{side:"left",theme:e.app.theme},a.a.createElement(d.List,null,a.a.createElement(d.ListItem,{primaryText:"Saved Codes",disabled:!0,primaryTogglesNestedList:!0,autoGenerateNestedIndicator:!1,open:!0,nestedItems:e.savedCodes.map(function(n){return a.a.createElement(d.ListItem,{key:n.name,primaryText:n.name,onTouchTap:function(){return e.onSelectSave(n)},rightIconButton:t.i(l.a)({theme:e.app.theme,items:[{name:"Rename",icon:j.a,onTouch:function(){return e.app.prompt("Enter New Name",function(t){return e.renameSave(n,t)})}},{name:"Delete",icon:S.a,onTouch:function(){return e.deleteSave(n)}}]})})})})))}(),function(){return a.a.createElement(s.a,{side:"right",theme:e.app.theme,contentStyle:{width:n},visualCache:function(){return c()("algConfigDrawer")}},h(),p(),m(),y(),x(),A(),_(),k(),C())}())};H.defaultProps={code:"// type your code...",savedCodes:[],debugConsole:[]};var G=o.a.shape({set:o.a.func.isRequired,value:o.a.any.isRequired});H.propTypes={app:o.a.any.isRequired,onCodeChange:o.a.func.isRequired,code:o.a.string,savedCodes:o.a.arrayOf(o.a.shape({name:o.a.string,code:o.a.string})),onSelectSave:o.a.func.isRequired,renameSave:o.a.func.isRequired,deleteSave:o.a.func.isRequired,addSave:o.a.func.isRequired,visualize:o.a.func.isRequired,run:o.a.func.isRequired,debugConsole:o.a.array,errProms:o.a.object.isRequired,algName:G.isRequired,algType:G.isRequired,algTypeFeatures:G.isRequired,algPseudoCode:G.isRequired,algDescription:G.isRequired,algTables:G.isRequired},n.a=H},function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function i(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}var o=t(2),s=t.n(o),d=t(3),l=t.n(d),c=t(4),u=t.n(c),h=t(1),g=t(87),p=(t.n(g),t(106)),f=t.n(p),m=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),b=t.i(h.a)(f.a),y=function(e){return e.disabled?"transparent":e.overlay?"semi-transparent":"opaque"},v=function(e){function n(e){r(this,n);var t=a(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,e));return t.state={showCancel:!1},t.timeout=void 0,t}return i(n,e),m(n,[{key:"componentWillMount",value:function(){this.componentWillReceiveProps(this.props)}},{key:"componentWillReceiveProps",value:function(e){var n=this;"transparent"===y(e)?(clearTimeout(this.timeout),this.timeout=void 0,this.setState({showCancel:!1})):this.timeout=setTimeout(function(){n.setState({showCancel:!0})},e.tooLongTime)}},{key:"componentWillUnmount",value:function(){clearTimeout(this.timeout)}},{key:"render",value:function(){return s.a.createElement("div",{className:b("container",this.props.app.theme)},s.a.createElement("div",{className:[b("screen",this.props.app.theme),b(y(this.props),this.props.app.theme)].join(" ")},s.a.createElement("div",{className:b("loading")},s.a.createElement("span",null,this.props.message)),s.a.createElement("div",{className:b("load-indicator",this.props.app.theme)},s.a.createElement("div",{className:g.ballGridPulse},s.a.createElement("div",null),s.a.createElement("div",null),s.a.createElement("div",null),s.a.createElement("div",null),s.a.createElement("div",null),s.a.createElement("div",null),s.a.createElement("div",null),s.a.createElement("div",null),s.a.createElement("div",null))),this.state.showCancel?s.a.createElement("div",{className:b("too-long")},s.a.createElement("p",null,this.props.tooLongMessage),s.a.createElement(u.a,{label:"Cancel",onTouchTap:this.props.tooLongEscape,backgroundColor:t.i(h.b)(this.props.app.theme)("accent1Color")})):null),this.props.overlay)}}]),n}(o.Component);v.defaultProps={overlay:null,message:"",disabled:!1,tooLongTime:3e3,tooLongEscape:function(){},tooLongMessage:""},v.propTypes={app:l.a.any.isRequired,overlay:l.a.element,message:l.a.string,disabled:l.a.bool,tooLongTime:l.a.number,tooLongEscape:l.a.func,tooLongMessage:l.a.string},n.a=v},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(19),d=t(76),l=t(63),c=t(84),u=t(83),h=t(110),g=t.n(h),p=t(107),f=(t.n(p),function(e){return a.a.createElement("div",{className:p.mainView},a.a.createElement("div",{className:p.container},m.map(function(n){return a.a.createElement(s.a,{name:n.name,key:n.name,desc:n.desc,onTouchTap:function(){return e.app.changeView(n)},theme:e.app.theme})})))}),m=[{view:d.a,name:"Algorithms",desc:"Choose from numerous algorithms to visualize"},{view:l.a,name:"Custom Code",desc:"Visualize your own code with algoriv"},{view:u.a,name:"Options"},{view:t.i(c.a)(g.a),name:"Usage"}];f.propTypes={app:o.a.shape({theme:o.a.any.isRequired,changeView:o.a.func.isRequired}).isRequired},n.a=f},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(29),d=t.n(s),l=t(7),c=t.n(l),u=t(16),h=t.n(u),g=t(28),p=t.n(g),f=t(30),m=t.n(f),b=t(31),y=t.n(b),v=t(4),x=t.n(v),w=t(1),_=t(11),T=(t.n(_),t(6)),k=t(108),E=t.n(k),C=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},S=Object.keys(_.themes),A=t.i(w.a)(E.a),j=function(e){return function(n){var r=n.name,i=n.option,o=n.possib;return a.a.createElement("div",{className:A("control")},a.a.createElement(d.a,C({floatingLabelText:r,fullWidth:!0,value:i().get(),onChange:function(e,n,t){return i().set(t)}},t.i(T.b)(e)),o.map(function(e){return a.a.createElement(h.a,{key:e,value:e,primaryText:e})})))}},N=function(e){return function(n){var r=n.name,i=n.option,o=n.parser,s=void 0===o?function(e){return e}:o;return a.a.createElement("div",{className:A("control")},a.a.createElement(c.a,C({},t.i(T.a)(e),{floatingLabelText:r,fullWidth:!0,value:i().get(),onChange:function(e,n){return i().set(s(n))}})))}},I=function(){return function(e){var n=e.name,t=e.option;return a.a.createElement("div",{className:A("control")},a.a.createElement(p.a,{label:n,checked:t().get(),onCheck:function(e,n){return t().set(n)}}))}},O=function(){return function(e){var n=e.name,r=e.option,i=e.min,o=e.max;return a.a.createElement("div",{className:A("control")},a.a.createElement(y.a,t.i(T.c)(),n),a.a.createElement(m.a,{min:i,max:o,value:r().get(),onChange:function(e,n){return r().set(n)},sliderStyle:{margin:0}}))}},P=function(e){return function(n){var r=n.name,i=n.action;return a.a.createElement("div",{className:A("control")},a.a.createElement(x.a,{label:r,onTouchTap:i,backgroundColor:t.i(w.b)(e)("primary1Color"),hoverColor:t.i(w.b)(e)("accent1Color"),style:{color:t.i(w.b)(e)("alternativeTextColor")},fullWidth:!0}))}},R=function(e){var n=function(){return e.app.settings("options")},t=j(e.app.theme),r=I(e.app.theme),i=O(e.app.theme),o=P(e.app.theme),s=N(e.app.theme);return a.a.createElement("div",{className:A("container")},a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h1",null,"Core Options"),a.a.createElement("span",null,"These options are ","application's"," core settings which affect behaviour unrelated to modules and algorithms.")),t({name:"Theme",option:function(){return n()("theme")},possib:S}),r({name:"Minimal Colored Visualizations",option:function(){return n()("grayscale-visualizations")}}),r({name:"Animations",option:function(){return n()("animations-enabled")}}),i({name:"Animation Speed",option:function(){return n()("animation")("speed")},min:1,max:100}),s({name:"Timeout for Custom Code",option:function(){return n()("custom-code")("timeout")},parser:parseInt})),a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h1",null,"Module Options"),a.a.createElement("span",null,"These options are specific to modules which only affect their behaviour.")),a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h2",null,"Code Module"),a.a.createElement("span",null,"Options for the Code module.")),r({name:"Enabled",option:function(){return n()("enabled-modules")("code")}})),a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h2",null,"Description Module"),a.a.createElement("span",null,"Options for the Description module.")),r({name:"Enabled",option:function(){return n()("enabled-modules")("description")}})),a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h2",null,"Graph Module"),a.a.createElement("span",null,"Options for the Graph module.")),r({name:"Enabled",option:function(){return n()("enabled-modules")("graph")}})),a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h2",null,"Table Module"),a.a.createElement("span",null,"Options for the Table module.")),r({name:"Enabled",option:function(){return n()("enabled-modules")("table")}})),a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h2",null,"Text Module"),a.a.createElement("span",null,"Options for the Text module.")),r({name:"Enabled",option:function(){return n()("enabled-modules")("text")}})),a.a.createElement("div",{className:A("control-group")},a.a.createElement("header",null,a.a.createElement("h2",null,"Examples Module"),a.a.createElement("span",null,"Options for the Examples module.")),r({name:"Enabled",option:function(){return n()("enabled-modules")("examples")}}),o({name:"Purge Custom Inputs",action:function(){return e.app.settings("examples").set({})}}))))};R.propTypes={app:o.a.shape({theme:o.a.any.isRequired,settings:o.a.func.isRequired}).isRequired},n.a=R},function(e,n,t){"use strict";var r=t(2),a=t.n(r),i=t(3),o=t.n(i),s=t(1),d=t(109),l=t.n(d),c=t.i(s.a)(l.a),u=function(e){var n=function(n){return a.a.createElement("div",{className:c("container",n.app.theme),dangerouslySetInnerHTML:{__html:e}})};return n.propTypes={app:o.a.shape({theme:o.a.string.isRequired}).isRequired},n};n.a=u},function(e,n,t){"use strict";var r=t(210);n.a=r},function(e,n,t){"use strict";function r(){return new l(i.a.join(s.getPath("userData"),"./storage.json"))}n.a=r;var a=t(251),i=t.n(a),o=t(225),s=o.remote.app,d=t(250),l=d.LocalStorage},function(e,n){e.exports={"ball-pulse":"node_modules-loaders-css-loaders__ball-pulse--oeElM",ballPulse:"node_modules-loaders-css-loaders__ball-pulse--oeElM",scale:"node_modules-loaders-css-loaders__scale--1r7Rd","ball-pulse-sync":"node_modules-loaders-css-loaders__ball-pulse-sync--2iom1",ballPulseSync:"node_modules-loaders-css-loaders__ball-pulse-sync--2iom1","ball-scale":"node_modules-loaders-css-loaders__ball-scale--1L1x5",ballScale:"node_modules-loaders-css-loaders__ball-scale--1L1x5","ball-scale-random":"node_modules-loaders-css-loaders__ball-scale-random--2PPEI",ballScaleRandom:"node_modules-loaders-css-loaders__ball-scale-random--2PPEI","ball-rotate":"node_modules-loaders-css-loaders__ball-rotate--1j0ze",ballRotate:"node_modules-loaders-css-loaders__ball-rotate--1j0ze",rotate:"node_modules-loaders-css-loaders__rotate--1pRMP","ball-clip-rotate":"node_modules-loaders-css-loaders__ball-clip-rotate--39J_j",ballClipRotate:"node_modules-loaders-css-loaders__ball-clip-rotate--39J_j","ball-clip-rotate-pulse":"node_modules-loaders-css-loaders__ball-clip-rotate-pulse--_p4g6",ballClipRotatePulse:"node_modules-loaders-css-loaders__ball-clip-rotate-pulse--_p4g6","ball-clip-rotate-multiple":"node_modules-loaders-css-loaders__ball-clip-rotate-multiple--2bYP0",ballClipRotateMultiple:"node_modules-loaders-css-loaders__ball-clip-rotate-multiple--2bYP0","ball-scale-ripple":"node_modules-loaders-css-loaders__ball-scale-ripple--_eSan",ballScaleRipple:"node_modules-loaders-css-loaders__ball-scale-ripple--_eSan","ball-scale-ripple-multiple":"node_modules-loaders-css-loaders__ball-scale-ripple-multiple--2kRGV",ballScaleRippleMultiple:"node_modules-loaders-css-loaders__ball-scale-ripple-multiple--2kRGV","ball-beat":"node_modules-loaders-css-loaders__ball-beat--3mkdy",ballBeat:"node_modules-loaders-css-loaders__ball-beat--3mkdy","ball-scale-multiple":"node_modules-loaders-css-loaders__ball-scale-multiple--3gHg3",ballScaleMultiple:"node_modules-loaders-css-loaders__ball-scale-multiple--3gHg3","ball-triangle-path":"node_modules-loaders-css-loaders__ball-triangle-path--1A5an",ballTrianglePath:"node_modules-loaders-css-loaders__ball-triangle-path--1A5an","ball-triangle-path-1":"node_modules-loaders-css-loaders__ball-triangle-path-1--Aadc1",ballTrianglePath1:"node_modules-loaders-css-loaders__ball-triangle-path-1--Aadc1","ball-triangle-path-2":"node_modules-loaders-css-loaders__ball-triangle-path-2--uGiK4",ballTrianglePath2:"node_modules-loaders-css-loaders__ball-triangle-path-2--uGiK4","ball-triangle-path-3":"node_modules-loaders-css-loaders__ball-triangle-path-3--16xe7",ballTrianglePath3:"node_modules-loaders-css-loaders__ball-triangle-path-3--16xe7","ball-pulse-rise":"node_modules-loaders-css-loaders__ball-pulse-rise--1WP08",ballPulseRise:"node_modules-loaders-css-loaders__ball-pulse-rise--1WP08","ball-pulse-rise-even":"node_modules-loaders-css-loaders__ball-pulse-rise-even--1zH8F",ballPulseRiseEven:"node_modules-loaders-css-loaders__ball-pulse-rise-even--1zH8F","ball-pulse-rise-odd":"node_modules-loaders-css-loaders__ball-pulse-rise-odd--2BtpA",ballPulseRiseOdd:"node_modules-loaders-css-loaders__ball-pulse-rise-odd--2BtpA","ball-grid-beat":"node_modules-loaders-css-loaders__ball-grid-beat--1fLQa",ballGridBeat:"node_modules-loaders-css-loaders__ball-grid-beat--1fLQa","ball-grid-pulse":"node_modules-loaders-css-loaders__ball-grid-pulse--20qYD",ballGridPulse:"node_modules-loaders-css-loaders__ball-grid-pulse--20qYD","ball-spin-fade-loader":"node_modules-loaders-css-loaders__ball-spin-fade-loader--2-4DF",ballSpinFadeLoader:"node_modules-loaders-css-loaders__ball-spin-fade-loader--2-4DF","ball-spin-loader":"node_modules-loaders-css-loaders__ball-spin-loader--2ybPw",ballSpinLoader:"node_modules-loaders-css-loaders__ball-spin-loader--2ybPw","ball-zig-zag":"node_modules-loaders-css-loaders__ball-zig-zag--3hEch",ballZigZag:"node_modules-loaders-css-loaders__ball-zig-zag--3hEch","ball-zig":"node_modules-loaders-css-loaders__ball-zig--2YE4w",ballZig:"node_modules-loaders-css-loaders__ball-zig--2YE4w","ball-zag":"node_modules-loaders-css-loaders__ball-zag--2vdW4",ballZag:"node_modules-loaders-css-loaders__ball-zag--2vdW4","ball-zig-zag-deflect":"node_modules-loaders-css-loaders__ball-zig-zag-deflect--1b2lL",ballZigZagDeflect:"node_modules-loaders-css-loaders__ball-zig-zag-deflect--1b2lL","ball-zig-deflect":"node_modules-loaders-css-loaders__ball-zig-deflect--1PwwZ",ballZigDeflect:"node_modules-loaders-css-loaders__ball-zig-deflect--1PwwZ","ball-zag-deflect":"node_modules-loaders-css-loaders__ball-zag-deflect--bbYL0",ballZagDeflect:"node_modules-loaders-css-loaders__ball-zag-deflect--bbYL0","line-scale":"node_modules-loaders-css-loaders__line-scale--1keCl",lineScale:"node_modules-loaders-css-loaders__line-scale--1keCl","line-scale-party":"node_modules-loaders-css-loaders__line-scale-party--pkyJW",lineScaleParty:"node_modules-loaders-css-loaders__line-scale-party--pkyJW","line-scale-pulse-out":"node_modules-loaders-css-loaders__line-scale-pulse-out--1GNfS",lineScalePulseOut:"node_modules-loaders-css-loaders__line-scale-pulse-out--1GNfS","line-scale-pulse-out-rapid":"node_modules-loaders-css-loaders__line-scale-pulse-out-rapid--2NGzn",lineScalePulseOutRapid:"node_modules-loaders-css-loaders__line-scale-pulse-out-rapid--2NGzn","line-spin-fade-loader":"node_modules-loaders-css-loaders__line-spin-fade-loader--2xcE9",lineSpinFadeLoader:"node_modules-loaders-css-loaders__line-spin-fade-loader--2xcE9","triangle-skew-spin":"node_modules-loaders-css-loaders__triangle-skew-spin--35Xpa",triangleSkewSpin:"node_modules-loaders-css-loaders__triangle-skew-spin--35Xpa","square-spin":"node_modules-loaders-css-loaders__square-spin--1D0To",squareSpin:"node_modules-loaders-css-loaders__square-spin--1D0To",pacman:"node_modules-loaders-css-loaders__pacman--1cTlR","pacman-balls":"node_modules-loaders-css-loaders__pacman-balls--1axVq",pacmanBalls:"node_modules-loaders-css-loaders__pacman-balls--1axVq",rotate_pacman_half_up:"node_modules-loaders-css-loaders__rotate_pacman_half_up--1dMLO",rotatePacmanHalfUp:"node_modules-loaders-css-loaders__rotate_pacman_half_up--1dMLO",rotate_pacman_half_down:"node_modules-loaders-css-loaders__rotate_pacman_half_down--31BVH",rotatePacmanHalfDown:"node_modules-loaders-css-loaders__rotate_pacman_half_down--31BVH","cube-transition":"node_modules-loaders-css-loaders__cube-transition--21v7x",cubeTransition:"node_modules-loaders-css-loaders__cube-transition--21v7x","semi-circle-spin":"node_modules-loaders-css-loaders__semi-circle-spin--HTHE4",semiCircleSpin:"node_modules-loaders-css-loaders__semi-circle-spin--HTHE4","spin-rotate":"node_modules-loaders-css-loaders__spin-rotate--2mrPT",spinRotate:"node_modules-loaders-css-loaders__spin-rotate--2mrPT","bar-progress":"node_modules-loaders-css-loaders__bar-progress--2wI6s",barProgress:"node_modules-loaders-css-loaders__bar-progress--2wI6s","bar-swing":"node_modules-loaders-css-loaders__bar-swing--oo6AB",barSwing:"node_modules-loaders-css-loaders__bar-swing--oo6AB","bar-swing-container":"node_modules-loaders-css-loaders__bar-swing-container--2T8Bx",barSwingContainer:"node_modules-loaders-css-loaders__bar-swing-container--2T8Bx"}},function(e,n){e.exports={top:"app-components-AlgorithmInner-style__top--DNYik",main:"app-components-AlgorithmInner-style__main--20W4G"}},function(e,n){e.exports={"container-dark":"app-components-AnimationControls-style__container-dark--3-hkM",containerDark:"app-components-AnimationControls-style__container-dark--3-hkM",upper:"app-components-AnimationControls-style__upper--3M59d",buttons:"app-components-AnimationControls-style__buttons--3cq2X","container-giant-goldfish":"app-components-AnimationControls-style__container-giant-goldfish--Vu2-N",containerGiantGoldfish:"app-components-AnimationControls-style__container-giant-goldfish--Vu2-N","container-sugar":"app-components-AnimationControls-style__container-sugar--3dZOQ",containerSugar:"app-components-AnimationControls-style__container-sugar--3dZOQ","container-thought-provoking":"app-components-AnimationControls-style__container-thought-provoking--K-y2G",containerThoughtProvoking:"app-components-AnimationControls-style__container-thought-provoking--K-y2G","container-cheer-up":"app-components-AnimationControls-style__container-cheer-up--1KXAq",containerCheerUp:"app-components-AnimationControls-style__container-cheer-up--1KXAq","container-fresh-cut":"app-components-AnimationControls-style__container-fresh-cut--qVbtg",containerFreshCut:"app-components-AnimationControls-style__container-fresh-cut--qVbtg"}},function(e,n){e.exports={"container-dark":"app-components-BigButton-style__container-dark--2Kh24",containerDark:"app-components-BigButton-style__container-dark--2Kh24","inner-container":"app-components-BigButton-style__inner-container--29Kfw",innerContainer:"app-components-BigButton-style__inner-container--29Kfw","primary-dark":"app-components-BigButton-style__primary-dark--1NjB1",primaryDark:"app-components-BigButton-style__primary-dark--1NjB1","secondary-dark":"app-components-BigButton-style__secondary-dark--1fAGR",secondaryDark:"app-components-BigButton-style__secondary-dark--1fAGR","container-giant-goldfish":"app-components-BigButton-style__container-giant-goldfish--1tTX2",containerGiantGoldfish:"app-components-BigButton-style__container-giant-goldfish--1tTX2","primary-giant-goldfish":"app-components-BigButton-style__primary-giant-goldfish--1DlmD",primaryGiantGoldfish:"app-components-BigButton-style__primary-giant-goldfish--1DlmD","secondary-giant-goldfish":"app-components-BigButton-style__secondary-giant-goldfish--_EcH3",secondaryGiantGoldfish:"app-components-BigButton-style__secondary-giant-goldfish--_EcH3","container-sugar":"app-components-BigButton-style__container-sugar--1U88t",containerSugar:"app-components-BigButton-style__container-sugar--1U88t","primary-sugar":"app-components-BigButton-style__primary-sugar--2eIcZ",primarySugar:"app-components-BigButton-style__primary-sugar--2eIcZ","secondary-sugar":"app-components-BigButton-style__secondary-sugar--2dZqZ",secondarySugar:"app-components-BigButton-style__secondary-sugar--2dZqZ","container-thought-provoking":"app-components-BigButton-style__container-thought-provoking--2_BF9",containerThoughtProvoking:"app-components-BigButton-style__container-thought-provoking--2_BF9","primary-thought-provoking":"app-components-BigButton-style__primary-thought-provoking--2dh1c",primaryThoughtProvoking:"app-components-BigButton-style__primary-thought-provoking--2dh1c","secondary-thought-provoking":"app-components-BigButton-style__secondary-thought-provoking--39jF9",secondaryThoughtProvoking:"app-components-BigButton-style__secondary-thought-provoking--39jF9","container-cheer-up":"app-components-BigButton-style__container-cheer-up--3iaxv",containerCheerUp:"app-components-BigButton-style__container-cheer-up--3iaxv","primary-cheer-up":"app-components-BigButton-style__primary-cheer-up--abk4g",primaryCheerUp:"app-components-BigButton-style__primary-cheer-up--abk4g","secondary-cheer-up":"app-components-BigButton-style__secondary-cheer-up--2KlEA",secondaryCheerUp:"app-components-BigButton-style__secondary-cheer-up--2KlEA","container-fresh-cut":"app-components-BigButton-style__container-fresh-cut--3z-BH",containerFreshCut:"app-components-BigButton-style__container-fresh-cut--3z-BH","primary-fresh-cut":"app-components-BigButton-style__primary-fresh-cut--29JWg",primaryFreshCut:"app-components-BigButton-style__primary-fresh-cut--29JWg","secondary-fresh-cut":"app-components-BigButton-style__secondary-fresh-cut--1eDby",secondaryFreshCut:"app-components-BigButton-style__secondary-fresh-cut--1eDby"}},function(e,n){e.exports={"actions-container-dark":"app-components-Dialog-style__actions-container-dark--3pU2L",actionsContainerDark:"app-components-Dialog-style__actions-container-dark--3pU2L","content-dark":"app-components-Dialog-style__content-dark--1KRgP",contentDark:"app-components-Dialog-style__content-dark--1KRgP","title-dark":"app-components-Dialog-style__title-dark--2_0yW",titleDark:"app-components-Dialog-style__title-dark--2_0yW","overlay-dark":"app-components-Dialog-style__overlay-dark--11s9M",overlayDark:"app-components-Dialog-style__overlay-dark--11s9M","actions-container-giant-goldfish":"app-components-Dialog-style__actions-container-giant-goldfish--3c6ZN",actionsContainerGiantGoldfish:"app-components-Dialog-style__actions-container-giant-goldfish--3c6ZN","content-giant-goldfish":"app-components-Dialog-style__content-giant-goldfish--2_BcG",contentGiantGoldfish:"app-components-Dialog-style__content-giant-goldfish--2_BcG","title-giant-goldfish":"app-components-Dialog-style__title-giant-goldfish--1UN9Q",titleGiantGoldfish:"app-components-Dialog-style__title-giant-goldfish--1UN9Q","overlay-giant-goldfish":"app-components-Dialog-style__overlay-giant-goldfish--36nab",overlayGiantGoldfish:"app-components-Dialog-style__overlay-giant-goldfish--36nab","actions-container-sugar":"app-components-Dialog-style__actions-container-sugar--1Eqq0",actionsContainerSugar:"app-components-Dialog-style__actions-container-sugar--1Eqq0","content-sugar":"app-components-Dialog-style__content-sugar--1Vwum",contentSugar:"app-components-Dialog-style__content-sugar--1Vwum","title-sugar":"app-components-Dialog-style__title-sugar--sYkZ0",titleSugar:"app-components-Dialog-style__title-sugar--sYkZ0","overlay-sugar":"app-components-Dialog-style__overlay-sugar--1u8nH",overlaySugar:"app-components-Dialog-style__overlay-sugar--1u8nH","actions-container-thought-provoking":"app-components-Dialog-style__actions-container-thought-provoking--3qsZc",actionsContainerThoughtProvoking:"app-components-Dialog-style__actions-container-thought-provoking--3qsZc","content-thought-provoking":"app-components-Dialog-style__content-thought-provoking--1Lcey",contentThoughtProvoking:"app-components-Dialog-style__content-thought-provoking--1Lcey","title-thought-provoking":"app-components-Dialog-style__title-thought-provoking--3cx2F",titleThoughtProvoking:"app-components-Dialog-style__title-thought-provoking--3cx2F","overlay-thought-provoking":"app-components-Dialog-style__overlay-thought-provoking--27U-R",overlayThoughtProvoking:"app-components-Dialog-style__overlay-thought-provoking--27U-R","actions-container-cheer-up":"app-components-Dialog-style__actions-container-cheer-up--2ja9V",actionsContainerCheerUp:"app-components-Dialog-style__actions-container-cheer-up--2ja9V","content-cheer-up":"app-components-Dialog-style__content-cheer-up--3mYwg",contentCheerUp:"app-components-Dialog-style__content-cheer-up--3mYwg","title-cheer-up":"app-components-Dialog-style__title-cheer-up--Ppg4q",titleCheerUp:"app-components-Dialog-style__title-cheer-up--Ppg4q","overlay-cheer-up":"app-components-Dialog-style__overlay-cheer-up--9m1Hr",overlayCheerUp:"app-components-Dialog-style__overlay-cheer-up--9m1Hr","actions-container-fresh-cut":"app-components-Dialog-style__actions-container-fresh-cut--1Fjc4",actionsContainerFreshCut:"app-components-Dialog-style__actions-container-fresh-cut--1Fjc4","content-fresh-cut":"app-components-Dialog-style__content-fresh-cut--3ez0J",contentFreshCut:"app-components-Dialog-style__content-fresh-cut--3ez0J","title-fresh-cut":"app-components-Dialog-style__title-fresh-cut--1g9ZJ",titleFreshCut:"app-components-Dialog-style__title-fresh-cut--1g9ZJ","overlay-fresh-cut":"app-components-Dialog-style__overlay-fresh-cut--1E-oS",overlayFreshCut:"app-components-Dialog-style__overlay-fresh-cut--1E-oS","actions-container":"app-components-Dialog-style__actions-container--mboyn",actionsContainer:"app-components-Dialog-style__actions-container--mboyn",content:"app-components-Dialog-style__content--3sMDq",title:"app-components-Dialog-style__title--xSk4D",overlay:"app-components-Dialog-style__overlay--2-z9Z"}},function(e,n){e.exports={"container-dark":"app-components-Header-style__container-dark--vzFEz",containerDark:"app-components-Header-style__container-dark--vzFEz",nav:"app-components-Header-style__nav--2JA8P",header:"app-components-Header-style__header--33Bx3","container-giant-goldfish":"app-components-Header-style__container-giant-goldfish--3btEW",containerGiantGoldfish:"app-components-Header-style__container-giant-goldfish--3btEW","container-sugar":"app-components-Header-style__container-sugar--sleVD",containerSugar:"app-components-Header-style__container-sugar--sleVD","container-thought-provoking":"app-components-Header-style__container-thought-provoking--3EJMP",containerThoughtProvoking:"app-components-Header-style__container-thought-provoking--3EJMP","container-cheer-up":"app-components-Header-style__container-cheer-up--13qF5",containerCheerUp:"app-components-Header-style__container-cheer-up--13qF5","container-fresh-cut":"app-components-Header-style__container-fresh-cut--m9Lhk",containerFreshCut:"app-components-Header-style__container-fresh-cut--m9Lhk"}},function(e,n){e.exports={"menu-item-dark":"app-components-IconMenu-style__menu-item-dark--3nDjn",menuItemDark:"app-components-IconMenu-style__menu-item-dark--3nDjn","menu-item-giant-goldfish":"app-components-IconMenu-style__menu-item-giant-goldfish--3Kf6s",menuItemGiantGoldfish:"app-components-IconMenu-style__menu-item-giant-goldfish--3Kf6s","menu-item-sugar":"app-components-IconMenu-style__menu-item-sugar--33YdG",menuItemSugar:"app-components-IconMenu-style__menu-item-sugar--33YdG","menu-item-thought-provoking":"app-components-IconMenu-style__menu-item-thought-provoking--3Whcl",menuItemThoughtProvoking:"app-components-IconMenu-style__menu-item-thought-provoking--3Whcl","menu-item-cheer-up":"app-components-IconMenu-style__menu-item-cheer-up--1tln0",menuItemCheerUp:"app-components-IconMenu-style__menu-item-cheer-up--1tln0","menu-item-fresh-cut":"app-components-IconMenu-style__menu-item-fresh-cut--3S_Ex",menuItemFreshCut:"app-components-IconMenu-style__menu-item-fresh-cut--3S_Ex"}},function(e,n){e.exports={"fields-container-dark":"app-components-InformationDemandingButton-style__fields-container-dark--3LdqI",fieldsContainerDark:"app-components-InformationDemandingButton-style__fields-container-dark--3LdqI","fields-container-giant-goldfish":"app-components-InformationDemandingButton-style__fields-container-giant-goldfish--nKAdw",fieldsContainerGiantGoldfish:"app-components-InformationDemandingButton-style__fields-container-giant-goldfish--nKAdw","fields-container-sugar":"app-components-InformationDemandingButton-style__fields-container-sugar--baUdH",fieldsContainerSugar:"app-components-InformationDemandingButton-style__fields-container-sugar--baUdH","fields-container-thought-provoking":"app-components-InformationDemandingButton-style__fields-container-thought-provoking--1fiSr",fieldsContainerThoughtProvoking:"app-components-InformationDemandingButton-style__fields-container-thought-provoking--1fiSr","fields-container-cheer-up":"app-components-InformationDemandingButton-style__fields-container-cheer-up--2YKyh",fieldsContainerCheerUp:"app-components-InformationDemandingButton-style__fields-container-cheer-up--2YKyh","fields-container-fresh-cut":"app-components-InformationDemandingButton-style__fields-container-fresh-cut--To4Ay",fieldsContainerFreshCut:"app-components-InformationDemandingButton-style__fields-container-fresh-cut--To4Ay","fields-container":"app-components-InformationDemandingButton-style__fields-container--1FfYn",fieldsContainer:"app-components-InformationDemandingButton-style__fields-container--1FfYn",open:"app-components-InformationDemandingButton-style__open--3ZJst"}},function(e,n){e.exports={"par-dark":"app-components-SideDrawer-style__par-dark--34AQA",parDark:"app-components-SideDrawer-style__par-dark--34AQA",handle:"app-components-SideDrawer-style__handle--38pQC",container:"app-components-SideDrawer-style__container--2e5Uz",par:"app-components-SideDrawer-style__par--1s8iK","handle-icon":"app-components-SideDrawer-style__handle-icon--2BJwb",handleIcon:"app-components-SideDrawer-style__handle-icon--2BJwb",right:"app-components-SideDrawer-style__right--1aiWG",left:"app-components-SideDrawer-style__left--3Vycx",active:"app-components-SideDrawer-style__active--3djnY","par-giant-goldfish":"app-components-SideDrawer-style__par-giant-goldfish--XAZlq",parGiantGoldfish:"app-components-SideDrawer-style__par-giant-goldfish--XAZlq","par-sugar":"app-components-SideDrawer-style__par-sugar--3pplM",parSugar:"app-components-SideDrawer-style__par-sugar--3pplM","par-thought-provoking":"app-components-SideDrawer-style__par-thought-provoking--301tv",parThoughtProvoking:"app-components-SideDrawer-style__par-thought-provoking--301tv","par-cheer-up":"app-components-SideDrawer-style__par-cheer-up--1_cWj",parCheerUp:"app-components-SideDrawer-style__par-cheer-up--1_cWj","par-fresh-cut":"app-components-SideDrawer-style__par-fresh-cut--2I4UF",parFreshCut:"app-components-SideDrawer-style__par-fresh-cut--2I4UF"}},function(e,n){e.exports={"code-dark":"app-components-modules-code-module-style__code-dark--2wOkZ",codeDark:"app-components-modules-code-module-style__code-dark--2wOkZ",active:"app-components-modules-code-module-style__active--28DRM",code:"app-components-modules-code-module-style__code--2KQjM","code-giant-goldfish":"app-components-modules-code-module-style__code-giant-goldfish--3xli-",codeGiantGoldfish:"app-components-modules-code-module-style__code-giant-goldfish--3xli-","code-sugar":"app-components-modules-code-module-style__code-sugar--31qnx",codeSugar:"app-components-modules-code-module-style__code-sugar--31qnx","code-thought-provoking":"app-components-modules-code-module-style__code-thought-provoking--1mJWL",codeThoughtProvoking:"app-components-modules-code-module-style__code-thought-provoking--1mJWL","code-cheer-up":"app-components-modules-code-module-style__code-cheer-up--3n9i4",codeCheerUp:"app-components-modules-code-module-style__code-cheer-up--3n9i4","code-fresh-cut":"app-components-modules-code-module-style__code-fresh-cut--16TIl",codeFreshCut:"app-components-modules-code-module-style__code-fresh-cut--16TIl"}},function(e,n){e.exports={container:"app-components-modules-description-module-style__container--1mIsd",header:"app-components-modules-description-module-style__header--DlGIJ"}},function(e,n){e.exports={"container-dark":"app-components-modules-examples-module-style__container-dark--39Ocs",containerDark:"app-components-modules-examples-module-style__container-dark--39Ocs","container-giant-goldfish":"app-components-modules-examples-module-style__container-giant-goldfish--2Szbm",containerGiantGoldfish:"app-components-modules-examples-module-style__container-giant-goldfish--2Szbm","container-sugar":"app-components-modules-examples-module-style__container-sugar--F6dJW",containerSugar:"app-components-modules-examples-module-style__container-sugar--F6dJW","container-thought-provoking":"app-components-modules-examples-module-style__container-thought-provoking--T66DE",containerThoughtProvoking:"app-components-modules-examples-module-style__container-thought-provoking--T66DE","container-cheer-up":"app-components-modules-examples-module-style__container-cheer-up--t_BMo",containerCheerUp:"app-components-modules-examples-module-style__container-cheer-up--t_BMo","container-fresh-cut":"app-components-modules-examples-module-style__container-fresh-cut--3_llC",containerFreshCut:"app-components-modules-examples-module-style__container-fresh-cut--3_llC",container:"app-components-modules-examples-module-style__container--2LqRy"}},function(e,n){e.exports={"style-dark":"app-components-modules-graph-module-style__style-dark--Wb1VB",styleDark:"app-components-modules-graph-module-style__style-dark--Wb1VB","style-giant-goldfish":"app-components-modules-graph-module-style__style-giant-goldfish--1yy86",styleGiantGoldfish:"app-components-modules-graph-module-style__style-giant-goldfish--1yy86","style-sugar":"app-components-modules-graph-module-style__style-sugar--3GCTP",styleSugar:"app-components-modules-graph-module-style__style-sugar--3GCTP","style-thought-provoking":"app-components-modules-graph-module-style__style-thought-provoking--3imjn",styleThoughtProvoking:"app-components-modules-graph-module-style__style-thought-provoking--3imjn","style-cheer-up":"app-components-modules-graph-module-style__style-cheer-up--2iOCX",styleCheerUp:"app-components-modules-graph-module-style__style-cheer-up--2iOCX","style-fresh-cut":"app-components-modules-graph-module-style__style-fresh-cut--HwT2r",styleFreshCut:"app-components-modules-graph-module-style__style-fresh-cut--HwT2r",style:"app-components-modules-graph-module-style__style--3q_gd"}},function(e,n){e.exports={"container-dark":"app-components-modules-table-module-style__container-dark--2HqSa",containerDark:"app-components-modules-table-module-style__container-dark--2HqSa","container-giant-goldfish":"app-components-modules-table-module-style__container-giant-goldfish--1rBlo",containerGiantGoldfish:"app-components-modules-table-module-style__container-giant-goldfish--1rBlo","container-sugar":"app-components-modules-table-module-style__container-sugar--wKMfe",containerSugar:"app-components-modules-table-module-style__container-sugar--wKMfe","container-thought-provoking":"app-components-modules-table-module-style__container-thought-provoking--2CHCb",containerThoughtProvoking:"app-components-modules-table-module-style__container-thought-provoking--2CHCb","container-cheer-up":"app-components-modules-table-module-style__container-cheer-up--1GMJV",containerCheerUp:"app-components-modules-table-module-style__container-cheer-up--1GMJV","container-fresh-cut":"app-components-modules-table-module-style__container-fresh-cut--8b2fu",containerFreshCut:"app-components-modules-table-module-style__container-fresh-cut--8b2fu"}},function(e,n){e.exports={style:"app-components-modules-text-module-style__style--22abm"}},function(e,n){e.exports={"page-view":"app-views-AlgorithmPageView-style__page-view--3dTUh",pageView:"app-views-AlgorithmPageView-style__page-view--3dTUh",container:"app-views-AlgorithmPageView-style__container--zmtLh"}},function(e,n){e.exports={section:"app-views-AlgorithmView-style__section--O2RpE",footer:"app-views-AlgorithmView-style__footer--37KDy"}},function(e,n){e.exports={"container-dark":"app-views-AppView-style__container-dark--3Ucyj",containerDark:"app-views-AppView-style__container-dark--3Ucyj","snackbar-dark":"app-views-AppView-style__snackbar-dark--44ZUd",snackbarDark:"app-views-AppView-style__snackbar-dark--44ZUd","container-giant-goldfish":"app-views-AppView-style__container-giant-goldfish--1FudJ",containerGiantGoldfish:"app-views-AppView-style__container-giant-goldfish--1FudJ","snackbar-giant-goldfish":"app-views-AppView-style__snackbar-giant-goldfish--2cM-G",snackbarGiantGoldfish:"app-views-AppView-style__snackbar-giant-goldfish--2cM-G","container-sugar":"app-views-AppView-style__container-sugar--1JWJc",containerSugar:"app-views-AppView-style__container-sugar--1JWJc","snackbar-sugar":"app-views-AppView-style__snackbar-sugar--U7sxo",snackbarSugar:"app-views-AppView-style__snackbar-sugar--U7sxo","container-thought-provoking":"app-views-AppView-style__container-thought-provoking--3BRyE",containerThoughtProvoking:"app-views-AppView-style__container-thought-provoking--3BRyE","snackbar-thought-provoking":"app-views-AppView-style__snackbar-thought-provoking--orklY",snackbarThoughtProvoking:"app-views-AppView-style__snackbar-thought-provoking--orklY","container-cheer-up":"app-views-AppView-style__container-cheer-up--2Awj9",containerCheerUp:"app-views-AppView-style__container-cheer-up--2Awj9","snackbar-cheer-up":"app-views-AppView-style__snackbar-cheer-up--1vAp2",snackbarCheerUp:"app-views-AppView-style__snackbar-cheer-up--1vAp2","container-fresh-cut":"app-views-AppView-style__container-fresh-cut--FgbEe",containerFreshCut:"app-views-AppView-style__container-fresh-cut--FgbEe","snackbar-fresh-cut":"app-views-AppView-style__snackbar-fresh-cut--15_4f",snackbarFreshCut:"app-views-AppView-style__snackbar-fresh-cut--15_4f",container:"app-views-AppView-style__container--1wrNt",main:"app-views-AppView-style__main--204PJ"}},function(e,n){e.exports={"button-container":"app-views-CustomCodeView-style__button-container--rmErH",buttonContainer:"app-views-CustomCodeView-style__button-container--rmErH",error:"app-views-CustomCodeView-style__error--1JdoK","debug-console":"app-views-CustomCodeView-style__debug-console--3xm7v",debugConsole:"app-views-CustomCodeView-style__debug-console--3xm7v",container:"app-views-CustomCodeView-style__container--7vg-A","ace-editor":"app-views-CustomCodeView-style__ace-editor--25nKn",aceEditor:"app-views-CustomCodeView-style__ace-editor--25nKn"}},function(e,n){e.exports={"screen-dark":"app-views-LoadingView-style__screen-dark--Q0nxm",screenDark:"app-views-LoadingView-style__screen-dark--Q0nxm","too-long":"app-views-LoadingView-style__too-long--2TCLl",tooLong:"app-views-LoadingView-style__too-long--2TCLl",opaque:"app-views-LoadingView-style__opaque--1Ioc4","load-indicator-dark":"app-views-LoadingView-style__load-indicator-dark--3HGvp",loadIndicatorDark:"app-views-LoadingView-style__load-indicator-dark--3HGvp","screen-giant-goldfish":"app-views-LoadingView-style__screen-giant-goldfish--2-4xl",screenGiantGoldfish:"app-views-LoadingView-style__screen-giant-goldfish--2-4xl","load-indicator-giant-goldfish":"app-views-LoadingView-style__load-indicator-giant-goldfish--1fuZM",loadIndicatorGiantGoldfish:"app-views-LoadingView-style__load-indicator-giant-goldfish--1fuZM","screen-sugar":"app-views-LoadingView-style__screen-sugar--1ITIZ",screenSugar:"app-views-LoadingView-style__screen-sugar--1ITIZ","load-indicator-sugar":"app-views-LoadingView-style__load-indicator-sugar--izqdO",loadIndicatorSugar:"app-views-LoadingView-style__load-indicator-sugar--izqdO","screen-thought-provoking":"app-views-LoadingView-style__screen-thought-provoking--2CxK9",screenThoughtProvoking:"app-views-LoadingView-style__screen-thought-provoking--2CxK9","load-indicator-thought-provoking":"app-views-LoadingView-style__load-indicator-thought-provoking--11vY7",loadIndicatorThoughtProvoking:"app-views-LoadingView-style__load-indicator-thought-provoking--11vY7","screen-cheer-up":"app-views-LoadingView-style__screen-cheer-up--3P7IW",screenCheerUp:"app-views-LoadingView-style__screen-cheer-up--3P7IW","load-indicator-cheer-up":"app-views-LoadingView-style__load-indicator-cheer-up--1d5Sg",loadIndicatorCheerUp:"app-views-LoadingView-style__load-indicator-cheer-up--1d5Sg","screen-fresh-cut":"app-views-LoadingView-style__screen-fresh-cut--eVt2h",screenFreshCut:"app-views-LoadingView-style__screen-fresh-cut--eVt2h","load-indicator-fresh-cut":"app-views-LoadingView-style__load-indicator-fresh-cut--1Osiz",loadIndicatorFreshCut:"app-views-LoadingView-style__load-indicator-fresh-cut--1Osiz","load-indicator":"app-views-LoadingView-style__load-indicator--34gJm",loadIndicator:"app-views-LoadingView-style__load-indicator--34gJm",container:"app-views-LoadingView-style__container--2POFT",screen:"app-views-LoadingView-style__screen--OTgWQ","semi-transparent":"app-views-LoadingView-style__semi-transparent--2n4E-",semiTransparent:"app-views-LoadingView-style__semi-transparent--2n4E-",transparent:"app-views-LoadingView-style__transparent--YiEue",loading:"app-views-LoadingView-style__loading--20n0t"}},function(e,n){e.exports={"main-view":"app-views-MainView-style__main-view--3gou5",mainView:"app-views-MainView-style__main-view--3gou5",container:"app-views-MainView-style__container--1BJYC"}},function(e,n){e.exports={container:"app-views-OptionsView-style__container--142vA",control:"app-views-OptionsView-style__control--KzVft"}},function(e,n){e.exports={"container-dark":"app-views-PageViewFactory-style__container-dark--19mCD",containerDark:"app-views-PageViewFactory-style__container-dark--19mCD","container-giant-goldfish":"app-views-PageViewFactory-style__container-giant-goldfish--2a8TV",containerGiantGoldfish:"app-views-PageViewFactory-style__container-giant-goldfish--2a8TV","container-sugar":"app-views-PageViewFactory-style__container-sugar--1o4Fp",containerSugar:"app-views-PageViewFactory-style__container-sugar--1o4Fp","container-thought-provoking":"app-views-PageViewFactory-style__container-thought-provoking--MdxKV",containerThoughtProvoking:"app-views-PageViewFactory-style__container-thought-provoking--MdxKV","container-cheer-up":"app-views-PageViewFactory-style__container-cheer-up--14xW1",containerCheerUp:"app-views-PageViewFactory-style__container-cheer-up--14xW1","container-fresh-cut":"app-views-PageViewFactory-style__container-fresh-cut--GcaRm",containerFreshCut:"app-views-PageViewFactory-style__container-fresh-cut--GcaRm",container:"app-views-PageViewFactory-style__container--1vkHR"}},function(e,n){e.exports='<h1 id=usage-manual>Usage Manual</h1> <p>There is a main visualization area, 2 sidebars and some controls in the algorithm views. Clicking on their handles opens sidebars. Animation controls consist of: back-to-beginning, one-step-back, pause/start/restart, one-step-forward, to-end and a speed slider to control animation speed. Necessary input is to be supplied upon clicking on the start button, which prompts for these inputs. Main area and sidebars consist of modules, which can be customized or toggled on/off in settings. The app has multiple themes to choose from.</p> <h2 id=algorithms-view>Algorithms View</h2> <p>In this screen there are predefined algorithms. Each algorithm has its input customized specifically for it.</p> <h2 id=usage-of-modules>Usage of modules</h2> <p>Most modules are static, meaning that they don&#39;t support interactions, they are only visual. Interactive modules are:</p> <ul> <li>Graph module</li> <li>Examples module</li> </ul> <h3 id=graph-module>Graph module</h3> <p>Graph used in the visualization can be changed by ctrl-clicking on the graph. To add an edge ctrl-click on two nodes consequently. To add a node ctrl-click on the stage, to remove one ctrl-alt-click. If the graph is weighted, then a modal asks for weight when you add an edge. If a node/edge cannot be removed/added because of reasons, an info message pops up, informing the user of these reasons. Graph module, by default, features colors and animations to visualize graphs better.</p> <h3 id=examples-module>Examples module</h3> <p>Examples and Custom Input module is found by default on the left sidebar. Users have the ability to select from multiple examples which are fine tuned for the algorithm, or can save their own customized input and use it. Users can later delete or rename these inputs. Custom inputs are persistent and will stay after application exits.</p> <p>Options for this module:</p> <ul> <li>Purge custom inputs: removes all custom inputs</li> </ul> <h2 id=custom-code-view>Custom Code View</h2> <p>Users have the ability to write their own algorithms and have them visualized. Algorithm&#39;s logic must be entered in the text editor that greets the user as they enter the view. On the left sidebar users can save their Algorithm and later open it again. On the right sidebar there is a form for Algorithm info and 2 buttons, Run and Visualize. As users write their logic, app evaluates it and checks for errors. Found errors are displayed in a red box on the right sidebar. Via Run button users can run their code, without visualizing it. Debug Bindings are also enabled in run mode. If the logic takes too long or ends up in an infinite loop, it is terminated after a configurable duration of time.</p> <p>ECMAScript 5 is fully and ECMAScript 6 is partially supported. ECMAScript 6 syntax is <a href=https://babeljs.io/ title=Babel>fully available</a>. Code is <a href=https://github.com/NeilFraser/JS-Interpreter title=JS-Interpreter>interpreted in a sandbox</a> and there are some injected variables to it.</p> <p>Used text editor is Ace Editor, you can find it&#39;s <a href=https://github.com/ajaxorg/ace/wiki/Default-Keyboard-Shortcuts title="Ace Keyboard Shortcuts">default keyboard shotcuts here</a>.</p> <h3 id=injected-variables>Injected Variables</h3> <h4 id=visualization-api>Visualization API</h4> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Parameters</th> </tr> </thead> <tbody> <tr> <td><code>frame</code></td> <td>function</td> <td>used to &#39;snapshot&#39; current state of <code>Algorithm</code> as a step</td> <td><code>none</code></td> </tr> <tr> <td><code>Algorithm</code></td> <td>object</td> <td>Visualization API populated depending on configuration</td> <td>-</td> </tr> <tr> <td><code>Algorithm.code</code></td> <td>function</td> <td>used to highlight lines in pseudo-code</td> <td><code>lines</code>: array of integers</td> </tr> <tr> <td><code>Algorithm.explanation</code></td> <td>function</td> <td>used to inform user about current state of algorithm</td> <td><code>text</code>: string</td> </tr> <tr> <td><code>Algorithm[name]</code> where name is a Table name</td> <td>function</td> <td>used to update Table&#39;s data</td> <td><code>data</code>: array <code>rows</code> of array <code>columns</code></td> </tr> <tr> <td><code>Algorithm[name]</code> where name is a Text name</td> <td>function</td> <td><strong>used to update Text&#39;s text</strong></td> <td><code>text</code>: string</td> </tr> <tr> <td><code>Algorithm[type]</code> where type is Algorithm&#39;s type</td> <td>object</td> <td>Collection of functions for Algorithm&#39;s type</td> <td>-</td> </tr> <tr> <td><code>Algorithm[type = graph]</code></td> <td>object</td> <td>Collection of methods to operate on the graph</td> <td>-</td> </tr> <tr> <td><code>Algorithm[type = graph].setColor</code></td> <td>function</td> <td>set color of nodes and edges based on indexes [0-360)</td> <td><code>colorIndex</code>: number, <code>nodes</code>: array of <a href=https://graphology.github.io/ title=Graphology>node keys</a>, <code>edges</code>: array of <a href=https://graphology.github.io/ title=Graphology>edge keys</a></td> </tr> <tr> <td><code>Algorithm[type = graph].setGlyphs</code></td> <td>function</td> <td>set glyphs of nodes to strings</td> <td><code>glyphs</code>: shape{[key: <a href=https://graphology.github.io/ title=Graphology>node key</a>]: value: string}</td> </tr> <tr> <td><code>Algorithm[type = graph].setOverrideGraph</code></td> <td>function</td> <td>change viewed graph, doesn&#39;t affect the input (useful for reversing etc.)</td> <td><code>graph</code>: <a href=https://graphology.github.io/ title=Graphology>serialized graph</a></td> </tr> </tbody> </table> <h4 id=inputs>Inputs</h4> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>input[type]</code> where type is Algorithm&#39;s type</td> <td>any</td> <td>Algorithm&#39;s main input</td> </tr> <tr> <td><code>input[typeFeature]</code> where typeFeature is specified type feature ids</td> <td>any</td> <td>Toggled additional input for type</td> </tr> <tr> <td><code>input[type = graph]</code></td> <td><a href=https://graphology.github.io/ title=Graphology>serialized graph</a></td> <td>Graph</td> </tr> <tr> <td><code>input[type = graph].startVertex</code></td> <td><a href=https://graphology.github.io/ title=Graphology>node key</a></td> <td>Starting node for the algorithm</td> </tr> </tbody> </table> <h4 id=debug-bindings>Debug Bindings</h4> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Parameters</th> <th>Returns</th> </tr> </thead> <tbody> <tr> <td><code>log</code></td> <td>function</td> <td>logs params to the console on the right sidebar</td> <td>...any</td> <td><code>none</code></td> </tr> </tbody> </table> <h4 id=others>Others</h4> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>Structures</code></td> <td><a href=https://github.com/mauriciosantos/Buckets-JS title=Buckets-JS>Buckets-JS</a></td> <td>Buckets-JS Data Structures library</td> </tr> <tr> <td><code>buckets</code></td> <td><a href=https://github.com/mauriciosantos/Buckets-JS title=Buckets-JS>Buckets-JS</a></td> <td>alias of <code>Structures</code></td> </tr> </tbody> </table> <h2 id=options>Options</h2> <ul> <li>Theme</li> <li>Algorithm speed</li> <li>Minimal Colored Visualizations: whether or not to use color in Visualizations</li> <li>Animations: are animations enabled</li> <li>Timeout for Custom Code</li> </ul> '},function(e,n){e.exports='/* eslint-disable */\n\n/* Polyfill service v3.18.1\n * For detailed credits and licence information see https://github.com/financial-times/polyfill-service.\n *\n * Features requested: default\n *\n * - Object.defineProperty, License: CC0 (required by "default", "Array.from", "Array.isArray", "Array.of", "Array.prototype.fill", "Element.prototype.classList", "Event", "CustomEvent", "Event.focusin", "Event.hashchange", "Function.prototype.bind", "Map", "Object.defineProperties", "Object.create", "Set", "Symbol", "Symbol.iterator", "Symbol.species")\n * - Array.from, License: CC0 (required by "default")\n * - Array.isArray, License: CC0 (required by "default", "Promise")\n * - Array.of, License: MIT (required by "default")\n * - Array.prototype.every, License: CC0 (required by "default")\n * - Array.prototype.fill, License: CC0 (required by "default")\n * - Array.prototype.filter, License: CC0 (required by "default", "Symbol", "Map", "Set")\n * - Array.prototype.forEach, License: CC0 (required by "default", "URL", "Symbol", "Map", "Set")\n * - Array.prototype.indexOf, License: CC0 (required by "default", "Map", "Set")\n * - Array.prototype.lastIndexOf, License: CC0 (required by "default")\n * - Array.prototype.map, License: CC0 (required by "default", "Symbol", "Map", "Set")\n * - Array.prototype.reduce, License: CC0 (required by "default")\n * - Array.prototype.reduceRight, License: CC0 (required by "default")\n * - Array.prototype.some, License: CC0 (required by "default")\n * - Window, License: CC0 (required by "default", "Event", "CustomEvent", "Event.focusin", "Event.hashchange")\n * - Document, License: CC0 (required by "default", "Element.prototype.after", "Element.prototype.append", "Element.prototype.before", "Element.prototype.prepend", "Element.prototype.remove", "Element.prototype.replaceWith", "Element", "Element.prototype.classList", "Element.prototype.cloneNode", "Element.prototype.matches", "Element.prototype.closest", "Event", "CustomEvent", "Event.focusin", "Event.hashchange", "document.querySelector", "~html5-elements", "_mutation")\n * - Element, License: CC0 (required by "default", "Element.prototype.after", "Element.prototype.append", "Element.prototype.before", "Element.prototype.classList", "Element.prototype.cloneNode", "Element.prototype.matches", "Element.prototype.closest", "Element.prototype.prepend", "Element.prototype.remove", "Element.prototype.replaceWith", "Event", "CustomEvent", "Event.focusin", "Event.hashchange", "Node.prototype.contains", "document.querySelector", "_mutation")\n * - Event, License: CC0 (required by "default", "CustomEvent", "Event.focusin", "Event.hashchange", "Promise", "XMLHttpRequest")\n * - CustomEvent, License: CC0 (required by "default", "document.visibilityState")\n * - _DOMTokenList, License: CC0 (required by "DOMTokenList", "default", "Element.prototype.classList")\n * - DOMTokenList, License: CC0 (required by "default")\n * - Date.now, License: CC0 (required by "default", "requestAnimationFrame", "performance.now")\n * - Date.prototype.toISOString, License: CC0 (required by "default")\n * - _mutation, License: CC0 (required by "Element.prototype.after", "default", "Element.prototype.append", "Element.prototype.before", "Element.prototype.prepend", "Element.prototype.remove", "Element.prototype.replaceWith")\n * - Element.prototype.after, License: CC0 (required by "default")\n * - Element.prototype.append, License: CC0 (required by "default")\n * - Element.prototype.before, License: CC0 (required by "default")\n * - Element.prototype.classList, License: CC0 (required by "default")\n * - Element.prototype.cloneNode, License: CC0 (required by "default")\n * - document.querySelector, License: CC0 (required by "default", "Element.prototype.matches", "Element.prototype.closest")\n * - Element.prototype.matches, License: CC0 (required by "default", "Element.prototype.closest")\n * - Element.prototype.closest, License: CC0 (required by "default")\n * - Element.prototype.prepend, License: CC0 (required by "default")\n * - Element.prototype.remove, License: CC0 (required by "default")\n * - Element.prototype.replaceWith, License: CC0 (required by "default")\n * - Event.focusin, License: CC0 (required by "default")\n * - Event.hashchange, License: CC0 (required by "default")\n * - Function.prototype.bind, License: MIT (required by "default", "Object.getOwnPropertyDescriptor")\n * - JSON, License: MIT (required by "default")\n * - Object.defineProperties, License: CC0 (required by "default", "Object.create", "URL", "location.origin")\n * - Object.create, License: CC0 (required by "default", "Symbol", "Map", "Set")\n * - Object.getOwnPropertyNames, License: CC0 (required by "default", "Symbol", "Map", "Set")\n * - Object.getOwnPropertyDescriptor, License: CC0 (required by "default", "Symbol", "Map", "Set")\n * - Object.keys, License: CC0 (required by "default", "Symbol", "Map", "Set")\n * - Symbol, License: MIT (required by "Map", "default", "Set", "Symbol.iterator", "Symbol.species")\n * - Symbol.iterator, License: MIT (required by "Map", "default", "Set")\n * - Symbol.species, License: MIT (required by "Map", "default", "Set")\n * - Number.isNaN, License: MIT (required by "default", "Map", "Set")\n * - Map, License: CC0 (required by "default")\n * - Node.prototype.contains, License: CC0 (required by "default")\n * - Object.assign, License: CC0 (required by "default")\n * - Object.getPrototypeOf, License: CC0 (required by "default")\n * - setImmediate, License: CC0 (required by "Promise", "default")\n * - Promise, License: MIT (required by "default")\n * - Set, License: CC0 (required by "default")\n * - String.prototype.endsWith, License: CC0 (required by "default")\n * - String.prototype.includes, License: CC0 (required by "default")\n * - String.prototype.startsWith, License: CC0 (required by "default")\n * - String.prototype.trim, License: CC0 (required by "default")\n * - URL, License: CC0 (required by "default")\n * - XMLHttpRequest, License: CC0 (required by "default")\n * - atob, License: MIT (required by "default")\n * - document.visibilityState, License: CC0 (required by "default")\n * - location.origin, License: CC0 (required by "default")\n * - performance.now, License: CC0 (required by "requestAnimationFrame", "default")\n * - requestAnimationFrame, License: MIT (required by "default")\n * - ~html5-elements, License: MIT (required by "default") */\n\n\n // Array.from\n// // Wrapped in IIFE to prevent leaking to global scope.\n// (function () {\n// \tfunction parseIterable (arraylike) {\n// \t\tvar done = false;\n// \t\tvar iterableResponse;\n// \t\tvar tempArray = [];\n//\n// \t\t// if the iterable doesn\'t have next;\n// \t\t// it is an iterable if \'next\' is a function but it has not been defined on\n// \t\t// the object itself.\n// \t\tif (typeof arraylike.next === \'function\') {\n// \t\t\twhile (!done) {\n// \t\t\t\titerableResponse = arraylike.next();\n// \t\t\t\tif (\n// \t\t\t\t\titerableResponse.hasOwnProperty(\'value\') &&\n// \t\t\t\t\titerableResponse.hasOwnProperty(\'done\')\n// \t\t\t\t) {\n// \t\t\t\t\tif (iterableResponse.done === true) {\n// \t\t\t\t\t\tdone = true;\n// \t\t\t\t\t\tbreak;\n//\n// \t\t\t\t\t// handle the case where the done value is not Boolean\n// \t\t\t\t\t} else if (iterableResponse.done !== false) {\n// \t\t\t\t\t\tbreak;\n// \t\t\t\t\t}\n//\n// \t\t\t\t\ttempArray.push(iterableResponse.value);\n// \t\t\t\t} else {\n//\n// \t\t\t\t\t// it does not conform to the iterable pattern\n// \t\t\t\t\tbreak;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n//\n// \t\tif (done) {\n// \t\t\treturn tempArray;\n// \t\t} else {\n//\n// \t\t\t// something went wrong return false;\n// \t\t\treturn false;\n// \t\t}\n//\n// \t}\n//\n// \tObject.defineProperty(Array, \'from\', {\n// \t\tconfigurable: true,\n// \t\tvalue: function from(source) {\n// \t\t\t// handle non-objects\n// \t\t\tif (source === undefined || source === null) {\n// \t\t\t\tthrow new TypeError(source + \' is not an object\');\n// \t\t\t}\n//\n// \t\t\t// handle maps that are not functions\n// \t\t\tif (1 in arguments && !(arguments[1] instanceof Function)) {\n// \t\t\t\tthrow new TypeError(arguments[1] + \' is not a function\');\n// \t\t\t}\n//\n// \t\t\tvar arraylike = typeof source === \'string\' ? source.split(\'\') : Object(source);\n// \t\t\tvar map = arguments[1];\n// \t\t\tvar scope = arguments[2];\n// \t\t\tvar array = [];\n// \t\t\tvar index = -1;\n// \t\t\tvar length = Math.min(Math.max(Number(arraylike.length) || 0, 0), 9007199254740991);\n// \t\t\tvar value;\n//\n// \t\t\t// variables for rebuilding array from iterator\n// \t\t\tvar arrayFromIterable;\n//\n// \t\t\t// if it is an iterable treat like one\n// \t\t\tarrayFromIterable = parseIterable(arraylike);\n//\n// \t\t\t//if it is a Map or a Set then handle them appropriately\n// \t\t\tif (\n// \t\t\t\ttypeof arraylike.entries === \'function\' &&\n// \t\t\t\ttypeof arraylike.values === \'function\'\n// \t\t\t) {\n// \t\t\t\tif (arraylike.constructor.name === \'Set\' && \'values\' in Set.prototype) {\n// \t\t\t\t\tarrayFromIterable = parseIterable(arraylike.values());\n// \t\t\t\t}\n// \t\t\t\tif (arraylike.constructor.name === \'Map\' && \'entries\' in Map.prototype) {\n// \t\t\t\t\tarrayFromIterable = parseIterable(arraylike.entries());\n// \t\t\t\t}\n// \t\t\t}\n//\n// \t\t\tif (arrayFromIterable) {\n// \t\t\t\tarraylike = arrayFromIterable;\n// \t\t\t\tlength = arrayFromIterable.length;\n// \t\t\t}\n//\n// \t\t\twhile (++index < length) {\n// \t\t\t\t\tvalue = arraylike[index];\n//\n// \t\t\t\t\tarray[index] = map ? map.call(scope, value, index) : value;\n// \t\t\t}\n//\n// \t\t\tarray.length = length;\n//\n// \t\t\treturn array;\n// \t\t},\n// \t\twritable: true\n// \t});\n// }());\n\n// Array.of\n/*! https://mths.be/array-of v0.1.0 by @mathias */\n(function () {\n\t\'use strict\';\n\tvar defineProperty = (function () {\n\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\ttry {\n\t\t\tvar object = {};\n\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t} catch (error) { /**/ }\n\t\treturn result;\n\t}());\n\tvar isConstructor = function isConstructor(Constructor) {\n\t\ttry {\n\t\t\treturn !!new Constructor();\n\t\t} catch (_) {\n\t\t\treturn false;\n\t\t}\n\t};\n\tvar of = function of() {\n\t\tvar items = arguments;\n\t\tvar length = items.length;\n\t\tvar Me = this;\n\t\tvar result = isConstructor(Me) ? new Me(length) : new Array(length);\n\t\tvar index = 0;\n\t\tvar value;\n\t\twhile (index < length) {\n\t\t\tvalue = items[index];\n\t\t\tif (defineProperty) {\n\t\t\t\tdefineProperty(result, index, {\n\t\t\t\t\t\'value\': value,\n\t\t\t\t\t\'writable\': true,\n\t\t\t\t\t\'enumerable\': true,\n\t\t\t\t\t\'configurable\': true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresult[index] = value;\n\t\t\t}\n\t\t\tindex += 1;\n\t\t}\n\t\tresult.length = length;\n\t\treturn result;\n\t};\n\tif (defineProperty) {\n\t\tdefineProperty(Array, \'of\', {\n\t\t\t\'value\': of,\n\t\t\t\'configurable\': true,\n\t\t\t\'writable\': true\n\t\t});\n\t} else {\n\t\tArray.of = of;\n\t}\n}());\n\n// Array.prototype.fill\nObject.defineProperty(Array.prototype, \'fill\', {\n\tconfigurable: true,\n\tvalue: function fill(value) {\n\t\tif (this === undefined || this === null) {\n\t\t\tthrow new TypeError(this + \' is not an object\');\n\t\t}\n\n\t\tvar arrayLike = Object(this);\n\n\t\tvar length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;\n\n\t\tvar relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n\n\t\trelativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);\n\n\t\tvar relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;\n\n\t\trelativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);\n\n\t\twhile (relativeStart < relativeEnd) {\n\t\t\tarrayLike[relativeStart] = value;\n\n\t\t\t++relativeStart;\n\t\t}\n\n\t\treturn arrayLike;\n\t},\n\twritable: true\n});\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.find\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, \'find\', {\n    value: function(predicate) {\n     // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError(\'"this" is null or not defined\');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, "length")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== \'function\') {\n        throw new TypeError(\'predicate must be a function\');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, Â« kValue, k, O Â»)).\n        // d. If testResult is true, return kValue.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return undefined.\n      return undefined;\n    }\n  });\n}\n\n// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\nif (!Array.prototype.findIndex) {\n  Object.defineProperty(Array.prototype, \'findIndex\', {\n    value: function(predicate) {\n     // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError(\'"this" is null or not defined\');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, "length")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== \'function\') {\n        throw new TypeError(\'predicate must be a function\');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, Â« kValue, k, O Â»)).\n        // d. If testResult is true, return k.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return k;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return -1.\n      return -1;\n    }\n  });\n}\n\n// Object.defineProperties\nObject.defineProperties = function defineProperties(object, descriptors) {\n\tfor (var property in descriptors) {\n\t\tObject.defineProperty(object, property, descriptors[property]);\n\t}\n\n\treturn object;\n};\n\n// Object.create DOESNT WORK\n// (function(){\n// \tfunction isPrimitive(o) {\n// \t\treturn o == null || (typeof o !== \'object\' && typeof o !== \'function\');\n//   };\n//\n// \tObject.create = function create(prototype, properties) {\n// \t/* jshint evil: true */\n//     if (prototype !== null && isPrimitive(prototype)) {\n//       throw new TypeError(\'Object prototype may only be an Object or null\');\n//     }\n//\n// \tvar\n// \tobject = new Function(\'e\', \'function Object() {}Object.prototype=e;return new Object\')(prototype);\n//\n// \tobject.constructor.prototype = prototype;\n//\n// \tif (1 in arguments) {\n// \t\tObject.defineProperties(object, properties);\n// \t}\n//\n// \treturn object;\n// };\n// }());\n\n// Number.isNaN\nNumber.isNaN = Number.isNaN || function(value) {\n    return typeof value === "number" && isNaN(value);\n};\n\n// // Map\n// (function(global) {\n//\n//\n// \t// Deleted map items mess with iterator pointers, so rather than removing them mark them as deleted. Can\'t use undefined or null since those both valid keys so use a private symbol.\n// \tvar undefMarker = Symbol(\'undef\');\n//\n// \t// NaN cannot be found in an array using indexOf, so we encode NaNs using a private symbol.\n// \tvar NaNMarker = Symbol(\'NaN\');\n//\n// \tfunction encodeKey(key) {\n// \t\treturn Number.isNaN(key) ? NaNMarker : key;\n// \t}\n// \tfunction decodeKey(encodedKey) {\n// \t\treturn (encodedKey === NaNMarker) ? NaN : encodedKey;\n// \t}\n//\n// \tfunction makeIterator(mapInst, getter) {\n// \t\tvar nextIdx = 0;\n// \t\tvar done = false;\n// \t\treturn {\n// \t\t\tnext: function() {\n// \t\t\t\tif (nextIdx === mapInst._keys.length) done = true;\n// \t\t\t\tif (!done) {\n// \t\t\t\t\twhile (mapInst._keys[nextIdx] === undefMarker) nextIdx++;\n// \t\t\t\t\treturn {value: getter.call(mapInst, nextIdx++), done: false};\n// \t\t\t\t} else {\n// \t\t\t\t\treturn {value: void 0, done:true};\n// \t\t\t\t}\n// \t\t\t}\n// \t\t};\n// \t}\n//\n// \tfunction calcSize(mapInst) {\n// \t\tvar size = 0;\n// \t\tfor (var i=0, s=mapInst._keys.length; i<s; i++) {\n// \t\t\tif (mapInst._keys[i] !== undefMarker) size++;\n// \t\t}\n// \t\treturn size;\n// \t}\n//\n// \tvar ACCESSOR_SUPPORT = true;\n//\n// \tfunction hasProtoMethod(instance, method){\n// \t\treturn typeof instance[method] === \'function\';\n// \t}\n//\n// \tvar Map = function(data) {\n// \t\tthis._keys = [];\n// \t\tthis._values = [];\n// \t\t// If `data` is iterable (indicated by presence of a forEach method), pre-populate the map\n// \t\tif (data && hasProtoMethod(data, \'forEach\')){\n// \t\t\t// Fastpath: If `data` is a Map, shortcircuit all following the checks\n// \t\t\tif (data instanceof Map ||\n// \t\t\t\t// If `data` is not an instance of Map, it could be because you have a Map from an iframe or a worker or something.\n// \t\t\t\t// Check if  `data` has all the `Map` methods and if so, assume data is another Map\n// \t\t\t\thasProtoMethod(data, \'clear\') &&\n// \t\t\t\thasProtoMethod(data, \'delete\') &&\n// \t\t\t\thasProtoMethod(data, \'entries\') &&\n// \t\t\t\thasProtoMethod(data, \'forEach\') &&\n// \t\t\t\thasProtoMethod(data, \'get\') &&\n// \t\t\t\thasProtoMethod(data, \'has\') &&\n// \t\t\t\thasProtoMethod(data, \'keys\') &&\n// \t\t\t\thasProtoMethod(data, \'set\') &&\n// \t\t\t\thasProtoMethod(data, \'values\')){\n// \t\t\t\tdata.forEach(function (value, key) {\n// \t\t\t\t\tthis.set.apply(this, [key, value]);\n// \t\t\t\t}, this);\n// \t\t\t} else {\n// \t\t\t\tdata.forEach(function (item) {\n// \t\t\t\t\tthis.set.apply(this, item);\n// \t\t\t\t}, this);\n// \t\t\t}\n// \t\t}\n//\n// \t\tif (!ACCESSOR_SUPPORT) this.size = calcSize(this);\n// \t};\n// \tMap.prototype = {};\n//\n// \t// Some old engines do not support ES5 getters/setters.  Since Map only requires these for the size property, we can fall back to setting the size property statically each time the size of the map changes.\n// \ttry {\n// \t\tObject.defineProperty(Map.prototype, \'size\', {\n// \t\t\tget: function() {\n// \t\t\t\treturn calcSize(this);\n// \t\t\t}\n// \t\t});\n// \t} catch(e) {\n// \t\tACCESSOR_SUPPORT = false;\n// \t}\n//\n// \tMap.prototype[\'get\'] = function(key) {\n// \t\tvar idx = this._keys.indexOf(encodeKey(key));\n// \t\treturn (idx !== -1) ? this._values[idx] : undefined;\n// \t};\n// \tMap.prototype[\'set\'] = function(key, value) {\n// \t\tvar idx = this._keys.indexOf(encodeKey(key));\n// \t\tif (idx !== -1) {\n// \t\t\tthis._values[idx] = value;\n// \t\t} else {\n// \t\t\tthis._keys.push(encodeKey(key));\n// \t\t\tthis._values.push(value);\n// \t\t\tif (!ACCESSOR_SUPPORT) this.size = calcSize(this);\n// \t\t}\n// \t\treturn this;\n// \t};\n// \tMap.prototype[\'has\'] = function(key) {\n// \t\treturn (this._keys.indexOf(encodeKey(key)) !== -1);\n// \t};\n// \tMap.prototype[\'delete\'] = function(key) {\n// \t\tvar idx = this._keys.indexOf(encodeKey(key));\n// \t\tif (idx === -1) return false;\n// \t\tthis._keys[idx] = undefMarker;\n// \t\tthis._values[idx] = undefMarker;\n// \t\tif (!ACCESSOR_SUPPORT) this.size = calcSize(this);\n// \t\treturn true;\n// \t};\n// \tMap.prototype[\'clear\'] = function() {\n// \t\tthis._keys = this._values = [];\n// \t\tif (!ACCESSOR_SUPPORT) this.size = 0;\n// \t};\n// \tMap.prototype[\'values\'] = function() {\n// \t\treturn makeIterator(this, function(i) { return this._values[i]; });\n// \t};\n// \tMap.prototype[\'keys\'] = function() {\n// \t\treturn makeIterator(this, function(i) { return decodeKey(this._keys[i]); });\n// \t};\n// \tMap.prototype[\'entries\'] =\n// \tMap.prototype[Symbol.iterator] = function() {\n// \t\treturn makeIterator(this, function(i) { return [decodeKey(this._keys[i]), this._values[i]]; });\n// \t};\n// \tMap.prototype[\'forEach\'] = function(callbackFn, thisArg) {\n// \t\tthisArg = thisArg || global;\n// \t\tvar iterator = this.entries();\n// \t\tvar result = iterator.next();\n// \t\twhile (result.done === false) {\n// \t\t\tcallbackFn.call(thisArg, result.value[1], result.value[0], this);\n// \t\t\tresult = iterator.next();\n// \t\t}\n// \t};\n// \tMap.prototype[\'constructor\'] =\n// \tMap.prototype[Symbol.species] = Map;\n//\n// \tMap.length = 0;\n//\n// \t// Export the object\n// \tglobal.Map = Map;\n//\n// }(this));\n//\n// Object.assign\nObject.assign = function assign(target, source) { // eslint-disable-line no-unused-vars\n\tfor (var index = 1, key, src; index < arguments.length; ++index) {\n\t\tsrc = arguments[index];\n\n\t\tfor (key in src) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(src, key)) {\n\t\t\t\ttarget[key] = src[key];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target;\n};\n\n// // Set\n// (function(global) {\n//\n//\n// \t// Deleted map items mess with iterator pointers, so rather than removing them mark them as deleted. Can\'t use undefined or null since those both valid keys so use a private symbol.\n// \tvar undefMarker = Symbol(\'undef\');\n//\n// \t// NaN cannot be found in an array using indexOf, so we encode NaNs using a private symbol.\n// \tvar NaNMarker = Symbol(\'NaN\');\n//\n// \tfunction encodeVal(data) {\n// \t\treturn Number.isNaN(data) ? NaNMarker : data;\n// \t}\n// \tfunction decodeVal(encodedData) {\n// \t\treturn (encodedData === NaNMarker) ? NaN : encodedData;\n// \t}\n//\n// \tfunction makeIterator(setInst, getter) {\n// \t\tvar nextIdx = 0;\n// \t\treturn {\n// \t\t\tnext: function() {\n// \t\t\t\twhile (setInst._values[nextIdx] === undefMarker) nextIdx++;\n// \t\t\t\tif (nextIdx === setInst._values.length) {\n// \t\t\t\t\treturn {value: void 0, done: true};\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\treturn {value: getter.call(setInst, nextIdx++), done: false};\n// \t\t\t\t}\n// \t\t\t}\n// \t\t};\n// \t}\n//\n// \tfunction calcSize(setInst) {\n// \t\tvar size = 0;\n// \t\tfor (var i=0, s=setInst._values.length; i<s; i++) {\n// \t\t\tif (setInst._values[i] !== undefMarker) size++;\n// \t\t}\n// \t\treturn size;\n// \t}\n//\n// \tvar ACCESSOR_SUPPORT = true;\n//\n// \tvar Set = function(data) {\n// \t\tthis._values = [];\n//\n// \t\t// If `data` is iterable (indicated by presence of a forEach method), pre-populate the set\n// \t\tdata && (typeof data.forEach === \'function\') && data.forEach(function (item) {\n// \t\t\tthis.add.call(this, item);\n// \t\t}, this);\n//\n// \t\tif (!ACCESSOR_SUPPORT) this.size = calcSize(this);\n// \t};\n//\n// \t// Some old engines do not support ES5 getters/setters.  Since Set only requires these for the size property, we can fall back to setting the size property statically each time the size of the set changes.\n// \ttry {\n// \t\tObject.defineProperty(Set.prototype, \'size\', {\n// \t\t\tget: function() {\n// \t\t\t\treturn calcSize(this);\n// \t\t\t}\n// \t\t});\n// \t} catch(e) {\n// \t\tACCESSOR_SUPPORT = false;\n// \t}\n//\n// \tSet.prototype[\'add\'] = function(value) {\n// \t\tvalue = encodeVal(value);\n// \t\tif (this._values.indexOf(value) === -1) {\n// \t\t\tthis._values.push(value);\n// \t\t\tif (!ACCESSOR_SUPPORT) this.size = calcSize(this);\n// \t\t}\n// \t\treturn this;\n// \t};\n// \tSet.prototype[\'has\'] = function(value) {\n// \t\treturn (this._values.indexOf(encodeVal(value)) !== -1);\n// \t};\n// \tSet.prototype[\'delete\'] = function(value) {\n// \t\tvar idx = this._values.indexOf(encodeVal(value));\n// \t\tif (idx === -1) return false;\n// \t\tthis._values[idx] = undefMarker;\n// \t\tif (!ACCESSOR_SUPPORT) this.size = calcSize(this);\n// \t\treturn true;\n// \t};\n// \tSet.prototype[\'clear\'] = function() {\n// \t\tthis._values = [];\n// \t\tif (!ACCESSOR_SUPPORT) this.size = 0;\n// \t};\n// \tSet.prototype[\'values\'] =\n// \tSet.prototype[\'keys\'] = function() {\n// \t\treturn makeIterator(this, function(i) { return decodeVal(this._values[i]); });\n// \t};\n// \tSet.prototype[\'entries\'] =\n// \tSet.prototype[Symbol.iterator] = function() {\n// \t\treturn makeIterator(this, function(i) { return [decodeVal(this._values[i]), decodeVal(this._values[i])]; });\n// \t};\n// \tSet.prototype[\'forEach\'] = function(callbackFn, thisArg) {\n// \t\tthisArg = thisArg || global;\n// \t\tvar iterator = this.entries();\n// \t\tvar result = iterator.next();\n// \t\twhile (result.done === false) {\n// \t\t\tcallbackFn.call(thisArg, result.value[1], result.value[0], this);\n// \t\t\tresult = iterator.next();\n// \t\t}\n// \t};\n// \tSet.prototype[\'constructor\'] =\n// \tSet.prototype[Symbol.species] = Set;\n//\n// \tSet.length = 0;\n//\n// \t// Export the object\n// \tglobal.Set = Set;\n//\n// }(this));\n//\n// String.prototype.endsWith\nString.prototype.endsWith = function (string) {\n\tvar index = arguments.length < 2 ? this.length : arguments[1];\n\tvar foundIndex = this.lastIndexOf(string);\n\treturn foundIndex !== -1 && foundIndex === index - string.length;\n};\n\n// String.prototype.includes\nString.prototype.includes = function (string, index) {\n\tif (typeof string === \'object\' && string instanceof RegExp) throw new TypeError("First argument to String.prototype.includes must not be a regular expression");\n\treturn this.indexOf(string, index) !== -1;\n};\n\n// String.prototype.startsWith\nString.prototype.startsWith = function (string) {\n\tvar index = arguments.length < 2 ? 0 : arguments[1];\n\n\treturn this.slice(index).indexOf(string) === 0;\n};\n\n\n/*! buckets - version: 1.98.2 - (c) 2013 - 2016 Mauricio Santos - https://github.com/mauriciosantos/Buckets-JS*/\n!function(a,b){"function"==typeof define&&define.amd?define([],b):"object"==typeof exports?module.exports=b():a.buckets=b()}(this,function(){"use strict";var a={};return a.defaultCompare=function(a,b){return a<b?-1:a===b?0:1},a.defaultEquals=function(a,b){return a===b},a.defaultToString=function(b){return null===b?"BUCKETS_NULL":a.isUndefined(b)?"BUCKETS_UNDEFINED":a.isString(b)?b:b.toString()},a.isFunction=function(a){return"function"==typeof a},a.isUndefined=function(a){return void 0===a},a.isString=function(a){return"[object String]"===Object.prototype.toString.call(a)},a.reverseCompareFunction=function(b){return a.isFunction(b)?function(a,c){return b(a,c)*-1}:function(a,b){return a<b?1:a===b?0:-1}},a.compareToEquals=function(a){return function(b,c){return 0===a(b,c)}},a.arrays={},a.arrays.indexOf=function(b,c,d){var e,f=d||a.defaultEquals,g=b.length;for(e=0;e<g;e+=1)if(f(b[e],c))return e;return-1},a.arrays.lastIndexOf=function(b,c,d){var e,f=d||a.defaultEquals,g=b.length;for(e=g-1;e>=0;e-=1)if(f(b[e],c))return e;return-1},a.arrays.contains=function(b,c,d){return a.arrays.indexOf(b,c,d)>=0},a.arrays.remove=function(b,c,d){var e=a.arrays.indexOf(b,c,d);return!(e<0)&&(b.splice(e,1),!0)},a.arrays.frequency=function(b,c,d){var e,f=d||a.defaultEquals,g=b.length,h=0;for(e=0;e<g;e+=1)f(b[e],c)&&(h+=1);return h},a.arrays.equals=function(b,c,d){var e,f=d||a.defaultEquals,g=b.length;if(b.length!==c.length)return!1;for(e=0;e<g;e+=1)if(!f(b[e],c[e]))return!1;return!0},a.arrays.copy=function(a){return a.concat()},a.arrays.swap=function(a,b,c){var d;return!(b<0||b>=a.length||c<0||c>=a.length)&&(d=a[b],a[b]=a[c],a[c]=d,!0)},a.arrays.forEach=function(a,b){var c,d=a.length;for(c=0;c<d;c+=1)if(b(a[c])===!1)return},a.Bag=function(b){var c={},d=b||a.defaultToString,e=new a.Dictionary(d),f=0;return c.add=function(b,d){var g;return(isNaN(d)||a.isUndefined(d))&&(d=1),!(a.isUndefined(b)||d<=0)&&(c.contains(b)?e.get(b).copies+=d:(g={value:b,copies:d},e.set(b,g)),f+=d,!0)},c.count=function(a){return c.contains(a)?e.get(a).copies:0},c.contains=function(a){return e.containsKey(a)},c.remove=function(b,d){var g;return(isNaN(d)||a.isUndefined(d))&&(d=1),!(a.isUndefined(b)||d<=0)&&(!!c.contains(b)&&(g=e.get(b),f-=d>g.copies?g.copies:d,g.copies-=d,g.copies<=0&&e.remove(b),!0))},c.toArray=function(){var a,b,c,d,f,g=[],h=e.values(),i=h.length;for(d=0;d<i;d+=1)for(a=h[d],b=a.value,c=a.copies,f=0;f<c;f+=1)g.push(b);return g},c.toSet=function(){var b,c=new a.Set(d),f=e.values(),g=f.length;for(b=0;b<g;b+=1)c.add(f[b].value);return c},c.forEach=function(a){e.forEach(function(b,c){var d,e=c.value,f=c.copies;for(d=0;d<f;d+=1)if(a(e)===!1)return!1;return!0})},c.size=function(){return f},c.isEmpty=function(){return 0===f},c.clear=function(){f=0,e.clear()},c.equals=function(b){var d;return!a.isUndefined(b)&&"function"==typeof b.toSet&&(c.size()===b.size()&&(d=!0,b.forEach(function(a){return d=c.count(a)===b.count(a)}),d))},c},a.BSTree=function(b){function c(a,b){for(var c,d=a;void 0!==d&&0!==c;)c=g(b,d.element),c<0?d=d.leftCh:c>0&&(d=d.rightCh);return d}function d(a){for(var b=a;void 0!==b.leftCh;)b=b.leftCh;return b}var e,f={},g=b||a.defaultCompare,h=0;return f.add=function(b){function c(a){for(var b,c,d=e;void 0!==d;){if(c=g(a.element,d.element),0===c)return;c<0?(b=d,d=d.leftCh):(b=d,d=d.rightCh)}return a.parent=b,void 0===b?e=a:g(a.element,b.element)<0?b.leftCh=a:b.rightCh=a,a}if(a.isUndefined(b))return!1;var d={element:b,leftCh:void 0,rightCh:void 0,parent:void 0};return void 0!==c(d)&&(h+=1,!0)},f.clear=function(){e=void 0,h=0},f.isEmpty=function(){return 0===h},f.size=function(){return h},f.contains=function(b){return!a.isUndefined(b)&&void 0!==c(e,b)},f.remove=function(a){function b(a,b){void 0===a.parent?e=b:a===a.parent.leftCh?a.parent.leftCh=b:a.parent.rightCh=b,void 0!==b&&(b.parent=a.parent)}function f(a){if(void 0===a.leftCh)b(a,a.rightCh);else if(void 0===a.rightCh)b(a,a.leftCh);else{var c=d(a.rightCh);c.parent!==a&&(b(c,c.rightCh),c.rightCh=a.rightCh,c.rightCh.parent=c),b(a,c),c.leftCh=a.leftCh,c.leftCh.parent=c}}var g;return g=c(e,a),void 0!==g&&(f(g),h-=1,!0)},f.inorderTraversal=function(a){function b(a,c,d){void 0===a||d.stop||(b(a.leftCh,c,d),d.stop||(d.stop=c(a.element)===!1,d.stop||b(a.rightCh,c,d)))}b(e,a,{stop:!1})},f.preorderTraversal=function(a){function b(a,c,d){void 0===a||d.stop||(d.stop=c(a.element)===!1,d.stop||(b(a.leftCh,c,d),d.stop||b(a.rightCh,c,d)))}b(e,a,{stop:!1})},f.postorderTraversal=function(a){function b(a,c,d){void 0===a||d.stop||(b(a.leftCh,c,d),d.stop||(b(a.rightCh,c,d),d.stop||(d.stop=c(a.element)===!1)))}b(e,a,{stop:!1})},f.levelTraversal=function(b){function c(b,c){var d=a.Queue();for(void 0!==b&&d.enqueue(b);!d.isEmpty();){if(b=d.dequeue(),c(b.element)===!1)return;void 0!==b.leftCh&&d.enqueue(b.leftCh),void 0!==b.rightCh&&d.enqueue(b.rightCh)}}c(e,b)},f.minimum=function(){if(!f.isEmpty())return d(e).element},f.maximum=function(){function a(a){for(;void 0!==a.rightCh;)a=a.rightCh;return a}if(!f.isEmpty())return a(e).element},f.forEach=function(a){f.inorderTraversal(a)},f.toArray=function(){var a=[];return f.inorderTraversal(function(b){a.push(b)}),a},f.height=function(){function a(b){return void 0===b?-1:Math.max(a(b.leftCh),a(b.rightCh))+1}function b(b){return void 0===b?-1:Math.max(a(b.leftCh),a(b.rightCh))+1}return b(e)},f.equals=function(b){var c;return!a.isUndefined(b)&&"function"==typeof b.levelTraversal&&(f.size()===b.size()&&(c=!0,b.forEach(function(a){return c=f.contains(a)}),c))},f},a.Dictionary=function(b){var c={},d={},e=0,f=b||a.defaultToString,g="/$ ";return c.get=function(b){var c=d[g+f(b)];if(!a.isUndefined(c))return c.value},c.set=function(b,c){var h,i,j;if(!a.isUndefined(b)&&!a.isUndefined(c))return i=g+f(b),j=d[i],a.isUndefined(j)?(e+=1,h=void 0):h=j.value,d[i]={key:b,value:c},h},c.remove=function(b){var c=g+f(b),h=d[c];if(!a.isUndefined(h))return delete d[c],e-=1,h.value},c.keys=function(){var a,b=[];for(a in d)Object.prototype.hasOwnProperty.call(d,a)&&b.push(d[a].key);return b},c.values=function(){var a,b=[];for(a in d)Object.prototype.hasOwnProperty.call(d,a)&&b.push(d[a].value);return b},c.forEach=function(a){var b,c,e;for(b in d)if(Object.prototype.hasOwnProperty.call(d,b)&&(c=d[b],e=a(c.key,c.value),e===!1))return},c.containsKey=function(b){return!a.isUndefined(c.get(b))},c.clear=function(){d={},e=0},c.size=function(){return e},c.isEmpty=function(){return e<=0},c.equals=function(b,d){var e,f;return!a.isUndefined(b)&&"function"==typeof b.keys&&(c.size()===b.size()&&(e=d||a.defaultEquals,f=!0,b.forEach(function(a,b){return f=e(c.get(a),b)}),f))},c},a.Heap=function(b){function c(b){function c(a){return Math.floor((a-1)/2)}var d;for(d=c(b);b>0&&g(f[d],f[b])>0;)a.arrays.swap(f,d,b),b=d,d=c(b)}function d(b){function c(a){return 2*a+1}function d(a){return 2*a+2}function e(a,b){return b>=f.length?a>=f.length?-1:a:g(f[a],f[b])<=0?a:b}var h;for(h=e(c(b),d(b));h>=0&&g(f[b],f[h])>0;)a.arrays.swap(f,h,b),b=h,h=e(c(b),d(b))}var e={},f=[],g=b||a.defaultCompare;return e.peek=function(){if(f.length>0)return f[0]},e.add=function(b){if(!a.isUndefined(b))return f.push(b),c(f.length-1),!0},e.removeRoot=function(){var a;if(f.length>0)return a=f[0],f[0]=f[f.length-1],f.splice(f.length-1,1),f.length>0&&d(0),a},e.contains=function(b){var c=a.compareToEquals(g);return a.arrays.contains(f,b,c)},e.size=function(){return f.length},e.isEmpty=function(){return f.length<=0},e.clear=function(){f.length=0},e.forEach=function(b){a.arrays.forEach(f,b)},e.toArray=function(){return a.arrays.copy(f)},e.equals=function(b){var c,d,f;return!a.isUndefined(b)&&"function"==typeof b.removeRoot&&(e.size()===b.size()&&(c=e.toArray(),d=b.toArray(),f=a.compareToEquals(g),c.sort(g),d.sort(g),a.arrays.equals(c,d,f)))},e},a.LinkedList=function(){function b(a){var b,e;if(!(a<0||a>=f)){if(a===f-1)return d;for(b=c,e=0;e<a;e+=1)b=b.next;return b}}var c,d,e={},f=0;return e.add=function(e,g){var h,i;return a.isUndefined(g)&&(g=f),!(g<0||g>f||a.isUndefined(e))&&(h={element:e,next:void 0},0===f?(c=h,d=h):g===f?(d.next=h,d=h):0===g?(h.next=c,c=h):(i=b(g-1),h.next=i.next,i.next=h),f+=1,!0)},e.first=function(){if(void 0!==c)return c.element},e.last=function(){if(void 0!==d)return d.element},e.elementAtIndex=function(a){var c=b(a);if(void 0!==c)return c.element},e.indexOf=function(b,d){var e=d||a.defaultEquals,f=c,g=0;if(a.isUndefined(b))return-1;for(;void 0!==f;){if(e(f.element,b))return g;g+=1,f=f.next}return-1},e.contains=function(a,b){return e.indexOf(a,b)>=0},e.remove=function(b,e){var g,h=e||a.defaultEquals,i=c;if(f<1||a.isUndefined(b))return!1;for(;void 0!==i;){if(h(i.element,b))return i===c?(c=c.next,i===d&&(d=void 0)):i===d?(d=g,g.next=i.next,i.next=void 0):(g.next=i.next,i.next=void 0),f-=1,!0;g=i,i=i.next}return!1},e.clear=function(){c=void 0,d=void 0,f=0},e.equals=function(b,d){var f=d||a.defaultEquals,g=!0,h=c;return!a.isUndefined(b)&&"function"==typeof b.elementAtIndex&&(e.size()===b.size()&&(b.forEach(function(a){return g=f(a,h.element),h=h.next,g}),g))},e.removeElementAtIndex=function(a){var e,g;if(!(a<0||a>=f))return 1===f?(e=c.element,c=void 0,d=void 0):(g=b(a-1),void 0===g?(e=c.element,c=c.next):g.next===d&&(e=d.element,d=g),void 0!==g&&(e=g.next.element,g.next=g.next.next)),f-=1,e},e.forEach=function(a){for(var b=c;void 0!==b&&a(b.element)!==!1;)b=b.next},e.reverse=function(){for(var a,b,e=c;void 0!==e;)b=e.next,e.next=a,a=e,e=b;b=c,c=d,d=b},e.toArray=function(){var a=[];return e.forEach(function(b){a.push(b)}),a},e.size=function(){return f},e.isEmpty=function(){return f<=0},e},a.MultiDictionary=function(b,c){var d={},e=new a.Dictionary(b),f=c||a.defaultEquals;return d.get=function(b){var c=e.get(b);return a.isUndefined(c)?[]:a.arrays.copy(c)},d.set=function(b,c){var g;return!a.isUndefined(b)&&!a.isUndefined(c)&&(d.containsKey(b)?(g=e.get(b),!a.arrays.contains(g,c,f)&&(g.push(c),!0)):(e.set(b,[c]),!0))},d.remove=function(b,c){var d,g;return a.isUndefined(c)?(d=e.remove(b),!a.isUndefined(d)):(g=e.get(b),!!a.arrays.remove(g,c,f)&&(0===g.length&&e.remove(b),!0))},d.keys=function(){return e.keys()},d.values=function(){var a,b,c,d=e.values(),f=[];for(a=0;a<d.length;a+=1)for(c=d[a],b=0;b<c.length;b+=1)f.push(c[b]);return f},d.containsKey=function(a){return e.containsKey(a)},d.clear=function(){return e.clear()},d.size=function(){return e.size()},d.isEmpty=function(){return e.isEmpty()},d.forEach=function(a){return e.forEach(a)},d.equals=function(b){var c,e=!0;return!a.isUndefined(b)&&"function"==typeof b.values&&(d.size()===b.size()&&(b.forEach(function(b,g){return c=d.get(b)||[],c.length!==g.length?e=!1:a.arrays.forEach(c,function(b){return e=a.arrays.contains(g,b,f)}),e}),e))},d},a.PriorityQueue=function(b){var c={},d=a.reverseCompareFunction(b),e=new a.Heap(d);return c.enqueue=function(a){return e.add(a)},c.add=function(a){return e.add(a)},c.dequeue=function(){var a;if(0!==e.size())return a=e.peek(),e.removeRoot(),a},c.peek=function(){return e.peek()},c.contains=function(a){return e.contains(a)},c.isEmpty=function(){return e.isEmpty()},c.size=function(){return e.size()},c.clear=function(){e.clear()},c.forEach=function(a){e.forEach(a)},c.toArray=function(){return e.toArray()},c.equals=function(b){var e,f,g;return!a.isUndefined(b)&&"function"==typeof b.dequeue&&(c.size()===b.size()&&(e=c.toArray(),f=b.toArray(),g=a.compareToEquals(d),e.sort(d),f.sort(d),a.arrays.equals(e,f,g)))},c},a.Queue=function(){var b={},c=new a.LinkedList;return b.enqueue=function(a){return c.add(a)},b.add=function(a){return c.add(a)},b.dequeue=function(){var a;if(0!==c.size())return a=c.first(),c.removeElementAtIndex(0),a},b.peek=function(){if(0!==c.size())return c.first()},b.size=function(){return c.size()},b.contains=function(a,b){return c.contains(a,b)},b.isEmpty=function(){return c.size()<=0},b.clear=function(){c.clear()},b.forEach=function(a){c.forEach(a)},b.toArray=function(){return c.toArray()},b.equals=function(c,d){var e,f,g;return!a.isUndefined(c)&&"function"==typeof c.dequeue&&(b.size()===c.size()&&(e=d||a.defaultEquals,f=!0,c.forEach(function(a){return g=b.dequeue(),b.enqueue(g),f=e(g,a)}),f))},b},a.Set=function(b){var c={},d=new a.Dictionary(b);return c.contains=function(a){return d.containsKey(a)},c.add=function(b){return!c.contains(b)&&!a.isUndefined(b)&&(d.set(b,b),!0)},c.intersection=function(a){c.forEach(function(b){a.contains(b)||c.remove(b)})},c.union=function(a){a.forEach(function(a){c.add(a)})},c.difference=function(a){a.forEach(function(a){c.remove(a)})},c.isSubsetOf=function(a){var b=!0;return!(c.size()>a.size())&&(c.forEach(function(c){if(!a.contains(c))return b=!1,!1}),b)},c.remove=function(a){return!!c.contains(a)&&(d.remove(a),!0)},c.forEach=function(a){d.forEach(function(b,c){return a(c)})},c.toArray=function(){return d.values()},c.isEmpty=function(){return d.isEmpty()},c.size=function(){return d.size()},c.clear=function(){d.clear()},c.equals=function(b){var d;return!a.isUndefined(b)&&"function"==typeof b.isSubsetOf&&(c.size()===b.size()&&(d=!0,b.forEach(function(a){return d=c.contains(a)}),d))},c},a.Stack=function(){var b={},c=new a.LinkedList;return b.push=function(a){return c.add(a,0)},b.add=function(a){return c.add(a,0)},b.pop=function(){return c.removeElementAtIndex(0)},b.peek=function(){return c.first()},b.size=function(){return c.size()},b.contains=function(a,b){return c.contains(a,b)},b.isEmpty=function(){return c.isEmpty()},b.clear=function(){c.clear()},b.forEach=function(a){c.forEach(a)},b.toArray=function(){return c.toArray()},b.equals=function(d,e){var f,g,h;return!a.isUndefined(d)&&"function"==typeof d.peek&&(b.size()===d.size()&&(f=e||a.defaultEquals,g=!0,d.forEach(function(a){return h=b.pop(),c.add(h),g=f(h,a)}),g))},b},a});\n//# sourceMappingURL=buckets.min.js.map\n;var Structures = buckets;\n'},function(e,n){e.exports='/**\n * @license\n * Copyright (c) [2014] [Linkurious]\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (undefined) {\n  "use strict";\n  function Supervisor(t, e) {\n    _root.URL = _root.URL || _root.webkitURL, e = e || {}, this.sigInst = t, this.graph = this.sigInst.graph, this.ppn = 10, this.ppe = 3, this.config = {}, this.worker = null, this.shouldUseWorker = null, this.workerUrl = null, this.runOnBackground = null, this.easing = null, this.randomize = null, this.configure(e), this.started = !1, this.running = !1, this.initWorker();\n  }if ("undefined" == typeof sigma) throw new Error("sigma is not declared");sigma.utils.pkg("sigma.layouts");var _root = this,\n      webWorkers = "Worker" in _root,\n      eventEmitter = {};sigma.classes.dispatcher.extend(eventEmitter), Supervisor.prototype.makeBlob = function (t) {\n    var e;try {\n      e = new Blob([t], { type: "application/javascript" });\n    } catch (r) {\n      _root.BlobBuilder = _root.BlobBuilder || _root.WebKitBlobBuilder || _root.MozBlobBuilder, e = new BlobBuilder(), e.append(t), e = e.getBlob();\n    }return e;\n  }, Supervisor.prototype.graphToByteArrays = function () {\n    var t,\n        e,\n        r,\n        s = this.graph.nodes(),\n        n = this.graph.edges(),\n        i = s.length * this.ppn,\n        o = n.length * this.ppe,\n        a = {};for (this.nodesByteArray = new Float32Array(i), this.edgesByteArray = new Float32Array(o), t = e = 0, r = s.length; r > t; t++) {\n      a[s[t].id] = e, this.nodesByteArray[e] = this.randomize(s[t].x), this.nodesByteArray[e + 1] = this.randomize(s[t].y), this.nodesByteArray[e + 2] = 0, this.nodesByteArray[e + 3] = 0, this.nodesByteArray[e + 4] = 0, this.nodesByteArray[e + 5] = 0, this.nodesByteArray[e + 6] = 1 + this.graph.degree(s[t].id), this.nodesByteArray[e + 7] = 1, this.nodesByteArray[e + 8] = s[t].size, this.nodesByteArray[e + 9] = s[t].fixed || 0, e += this.ppn;\n    }for (t = e = 0, r = n.length; r > t; t++) {\n      this.edgesByteArray[e] = a[n[t].source], this.edgesByteArray[e + 1] = a[n[t].target], this.edgesByteArray[e + 2] = n[t].weight || 0, e += this.ppe;\n    }\n  }, Supervisor.prototype.applyLayoutChanges = function (t) {\n    for (var e = this.graph.nodes(), r = 0, s = 0, n = this.nodesByteArray.length; n > s; s += this.ppn) {\n      e[r].fixed || (t ? (e[r].fa2_x = this.nodesByteArray[s], e[r].fa2_y = this.nodesByteArray[s + 1]) : (e[r].x = this.nodesByteArray[s], e[r].y = this.nodesByteArray[s + 1])), r++;\n    }\n  }, Supervisor.prototype.sendByteArrayToWorker = function (t) {\n    var e = { action: t || "loop", nodes: this.nodesByteArray.buffer },\n        r = [this.nodesByteArray.buffer];"start" === t && (e.config = this.config || {}, e.edges = this.edgesByteArray.buffer, r.push(this.edgesByteArray.buffer)), this.shouldUseWorker ? this.worker.postMessage(e, r) : _root.postMessage(e, "*");\n  }, Supervisor.prototype.start = function () {\n    this.running || (this.running = !0, this.started ? this.sendByteArrayToWorker() : (this.sendByteArrayToWorker("start"), this.started = !0, eventEmitter.dispatchEvent("start")));\n  }, Supervisor.prototype.stop = function () {\n    this.running && (this.running = !1, eventEmitter.dispatchEvent("stop"));\n  }, Supervisor.prototype.initWorker = function () {\n    var _this = this,\n        workerFn = sigma.layouts.getForceLinkWorker();if (this.shouldUseWorker) {\n      if (this.workerUrl) this.worker = new Worker(this.workerUrl);else {\n        var blob = this.makeBlob(workerFn);this.worker = new Worker(URL.createObjectURL(blob));\n      }this.worker.postMessage = this.worker.webkitPostMessage || this.worker.postMessage;\n    } else eval(workerFn);this.msgName = this.worker ? "message" : "newCoords", this.listener = function (t) {\n      _this.nodesByteArray = new Float32Array(t.data.nodes), _this.running && (_this.applyLayoutChanges(_this.runOnBackground), _this.sendByteArrayToWorker(), _this.runOnBackground || _this.sigInst.refresh({ skipIndexation: !0 })), t.data.converged && (_this.running = !1), _this.running || (_this.killWorker(), _this.runOnBackground && _this.easing ? (_this.applyLayoutChanges(!0), eventEmitter.dispatchEvent("interpolate"), _this.graph.nodes().filter(function (t) {\n        return t.fixed;\n      }).forEach(function (t) {\n        t.fa2_x = t.x, t.fa2_y = t.y;\n      }), sigma.plugins.animate(_this.sigInst, { x: "fa2_x", y: "fa2_y" }, { easing: _this.easing, onComplete: function onComplete() {\n          _this.sigInst.refresh(), eventEmitter.dispatchEvent("stop");\n        } })) : (_this.applyLayoutChanges(!1), _this.sigInst.refresh(), eventEmitter.dispatchEvent("stop")));\n    }, (this.worker || document).addEventListener(this.msgName, this.listener), this.graphToByteArrays(), _this.sigInst.bind("kill", function () {\n      sigma.layouts.killForceLink();\n    });\n  }, Supervisor.prototype.killWorker = function () {\n    this.worker ? this.worker.terminate() : (_root.postMessage({ action: "kill" }, "*"), document.removeEventListener(this.msgName, this.listener));\n  }, Supervisor.prototype.configure = function (t) {\n    switch (this.config = t, this.shouldUseWorker = t.worker === !1 ? !1 : webWorkers, this.workerUrl = t.workerUrl, this.runOnBackground = t.background ? !0 : !1, this.easing = t.easing, t.randomize) {case "globally":\n        this.randomize = function (e) {\n          return Math.random() * (t.randomizeFactor || 1);\n        };break;case "locally":\n        this.randomize = function (e) {\n          return e + Math.random() * (t.randomizeFactor || 1);\n        };break;default:\n        this.randomize = function (t) {\n          return t;\n        };}if (this.started) {\n      var e = { action: "config", config: this.config };this.shouldUseWorker ? this.worker.postMessage(e) : _root.postMessage(e, "*");\n    }\n  };var supervisor = null;sigma.layouts.startForceLink = function (t, e) {\n    return supervisor ? supervisor.running || (supervisor.killWorker(), supervisor.initWorker(), supervisor.started = !1) : supervisor = new Supervisor(t, e), e && supervisor.configure(e), supervisor.start(), eventEmitter;\n  }, sigma.layouts.stopForceLink = function () {\n    return supervisor ? (supervisor.stop(), supervisor) : void 0;\n  }, sigma.layouts.killForceLink = function () {\n    supervisor && (supervisor.stop(), supervisor.killWorker(), supervisor = null, eventEmitter = {}, sigma.classes.dispatcher.extend(eventEmitter));\n  }, sigma.layouts.configForceLink = function (t, e) {\n    return supervisor ? supervisor.running || (supervisor.killWorker(), supervisor.initWorker(), supervisor.started = !1) : supervisor = new Supervisor(t, e), supervisor.configure(e), eventEmitter;\n  }, sigma.layouts.isForceLinkRunning = function () {\n    return !!supervisor && supervisor.running;\n  };\n}).call(this), function (undefined) {\n  "use strict";\n  function no_crush(t) {\n    var e,\n        r,\n        s,\n        n = ["x", "y", "dx", "dy", "old_dx", "old_dy", "mass", "convergence", "size", "fixed"],\n        i = ["source", "target", "weight"],\n        o = ["node", "centerX", "centerY", "size", "nextSibling", "firstChild", "mass", "massCenterX", "massCenterY"];for (r = 0, s = o.length; s > r; r++) {\n      e = new RegExp("rp\\\\(([^,]*), \'" + o[r] + "\'\\\\)", "g"), t = t.replace(e, 0 === r ? "$1" : "$1 + " + r);\n    }for (r = 0, s = n.length; s > r; r++) {\n      e = new RegExp("np\\\\(([^,]*), \'" + n[r] + "\'\\\\)", "g"), t = t.replace(e, 0 === r ? "$1" : "$1 + " + r);\n    }for (r = 0, s = i.length; s > r; r++) {\n      e = new RegExp("ep\\\\(([^,]*), \'" + i[r] + "\'\\\\)", "g"), t = t.replace(e, 0 === r ? "$1" : "$1 + " + r);\n    }return t;\n  }function getWorkerFn() {\n    var t = crush ? crush(Worker.toString()) : Worker.toString();return ";(" + t + ").call(this);";\n  }if ("undefined" == typeof sigma) throw new Error("sigma is not declared");sigma.utils.pkg("sigma.layouts");var _root = this,\n      inWebWorker = !("document" in _root),\n      Worker = function Worker(t) {\n    function e() {\n      var t,\n          e,\n          r = {},\n          s = arguments.length;for (t = s - 1; t >= 0; t--) {\n        for (e in arguments[t]) {\n          r[e] = arguments[t][e];\n        }\n      }return r;\n    }function r(t) {\n      var e;for (e in t) {\n        "hasOwnProperty" in t && !t.hasOwnProperty(e) || delete t[e];\n      }return t;\n    }function s(t, e, r, s) {\n      return Math.sqrt((r - t) * (r - t) + (s - e) * (s - e));\n    }function n(t, e, r, s, n) {\n      return (n - s) * (t - e) / (r - e) + s;\n    }function i(t) {\n      return Math.acos(t.x / Math.sqrt(t.x * t.x + t.y * t.y));\n    }function o(t, e, r, s) {\n      return { xi: -(s - e), yi: r - t, xi_prime: s - e, yi_prime: -(r - t) };\n    }function a(t, e) {\n      return { x: (t.xi_prime - t.xi) / e, y: (t.yi_prime - t.yi) / e };\n    }function h(t, e, r, s, n) {\n      return { x: t + (r - t) * n, y: e + (s - e) * n };\n    }function g(t, e, r) {\n      r = r || {};l = t, c = e, v.nodesLength = l.length, v.edgesLength = c.length, u(r);\n    }function u(t) {\n      v.settings = e(t, v.settings);\n    }function p() {\n      var t,\n          e,\n          r,\n          g,\n          u,\n          p,\n          d,\n          y,\n          k,\n          m,\n          b,\n          w,\n          M,\n          B,\n          _,\n          A,\n          x,\n          L = v.settings.minNodeDistance;for (r = 0; r < v.nodesLength; r += v.ppn) {\n        l[r + 4] = l[r + 2], l[r + 5] = l[r + 3], l[r + 2] = 0, l[r + 3] = 0;\n      }if (v.settings.outboundAttractionDistribution) {\n        for (k = 0, r = 0; r < v.nodesLength; r += v.ppn) {\n          k += l[r + 6];\n        }k /= v.nodesLength;\n      }if (v.settings.barnesHutOptimize) {\n        var S,\n            W,\n            E = 1 / 0,\n            F = -(1 / 0),\n            I = 1 / 0,\n            z = -(1 / 0);for (f = [], r = 0; r < v.nodesLength; r += v.ppn) {\n          E = Math.min(E, l[r]), F = Math.max(F, l[r]), I = Math.min(I, l[r + 1]), z = Math.max(z, l[r + 1]);\n        }for (f[0] = -1, f[1] = (E + F) / 2, f[2] = (I + z) / 2, f[3] = Math.max(F - E, z - I), f[4] = -1, f[5] = -1, f[6] = 0, f[7] = 0, f[8] = 0, t = 1, r = 0; r < v.nodesLength; r += v.ppn) {\n          for (e = 0;;) {\n            if (f[e + 5] >= 0) S = l[r] < f[e + 1] ? l[r + 1] < f[e + 2] ? f[e + 5] : f[e + 5] + v.ppr : l[r + 1] < f[e + 2] ? f[e + 5] + 2 * v.ppr : f[e + 5] + 3 * v.ppr, f[e + 7] = (f[e + 7] * f[e + 6] + l[r] * l[r + 6]) / (f[e + 6] + l[r + 6]), f[e + 8] = (f[e + 8] * f[e + 6] + l[r + 1] * l[r + 6]) / (f[e + 6] + l[r + 6]), f[e + 6] += l[r + 6], e = S;else {\n              if (f[e] < 0) {\n                f[e] = r;break;\n              }if (f[e + 5] = t * v.ppr, d = f[e + 3] / 2, y = f[e + 5], f[y] = -1, f[y + 1] = f[e + 1] - d, f[y + 2] = f[e + 2] - d, f[y + 3] = d, f[y + 4] = y + v.ppr, f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, y += v.ppr, f[y] = -1, f[y + 1] = f[e + 1] - d, f[y + 2] = f[e + 2] + d, f[y + 3] = d, f[y + 4] = y + v.ppr, f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, y += v.ppr, f[y] = -1, f[y + 1] = f[e + 1] + d, f[y + 2] = f[e + 2] - d, f[y + 3] = d, f[y + 4] = y + v.ppr, f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, y += v.ppr, f[y] = -1, f[y + 1] = f[e + 1] + d, f[y + 2] = f[e + 2] + d, f[y + 3] = d, f[y + 4] = f[e + 4], f[y + 5] = -1, f[y + 6] = 0, f[y + 7] = 0, f[y + 8] = 0, t += 4, S = l[f[e]] < f[e + 1] ? l[f[e] + 1] < f[e + 2] ? f[e + 5] : f[e + 5] + v.ppr : l[f[e] + 1] < f[e + 2] ? f[e + 5] + 2 * v.ppr : f[e + 5] + 3 * v.ppr, f[e + 6] = l[f[e] + 6], f[e + 7] = l[f[e]], f[e + 8] = l[f[e] + 1], f[S] = f[e], f[e] = -1, W = l[r] < f[e + 1] ? l[r + 1] < f[e + 2] ? f[e + 5] : f[e + 5] + v.ppr : l[r + 1] < f[e + 2] ? f[e + 5] + 2 * v.ppr : f[e + 5] + 3 * v.ppr, S !== W) {\n                f[W] = r;break;\n              }e = S;\n            }\n          }\n        }\n      }if (v.settings.barnesHutOptimize) for (m = v.settings.scalingRatio, r = 0; r < v.nodesLength; r += v.ppn) {\n        for (e = 0;;) {\n          if (f[e + 5] >= 0) {\n            if (A = Math.sqrt((l[r] - f[e + 7]) * (l[r] - f[e + 7]) + (l[r + 1] - f[e + 8]) * (l[r + 1] - f[e + 8])), 2 * f[e + 3] / A < v.settings.barnesHutTheta) {\n              if (b = l[r] - f[e + 7], w = l[r + 1] - f[e + 8], v.settings.adjustSizes ? A > 0 ? (x = m * l[r + 6] * f[e + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x) : 0 > A && (x = -m * l[r + 6] * f[e + 6] / A, l[r + 2] += b * x, l[r + 3] += w * x) : A > 0 && (x = m * l[r + 6] * f[e + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x), f[e + 4] < 0) break;e = f[e + 4];continue;\n            }e = f[e + 5];\n          } else {\n            if (f[e] >= 0 && f[e] !== r && (b = l[r] - l[f[e]], w = l[r + 1] - l[f[e] + 1], A = Math.sqrt(b * b + w * w), v.settings.adjustSizes ? A > 0 ? (x = m * l[r + 6] * l[f[e] + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x) : 0 > A && (x = -m * l[r + 6] * l[f[e] + 6] / A, l[r + 2] += b * x, l[r + 3] += w * x) : A > 0 && (x = m * l[r + 6] * l[f[e] + 6] / A / A, l[r + 2] += b * x, l[r + 3] += w * x)), f[e + 4] < 0) break;e = f[e + 4];\n          }\n        }\n      } else for (m = v.settings.scalingRatio, g = 0; g < v.nodesLength; g += v.ppn) {\n        for (u = 0; g > u; u += v.ppn) {\n          b = l[g] - l[u], w = l[g + 1] - l[u + 1], v.settings.adjustSizes ? (A = Math.sqrt(b * b + w * w) - l[g + 8] - l[u + 8], A > 0 ? (x = m * l[g + 6] * l[u + 6] / A / A, l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] += b * x, l[u + 3] += w * x) : 0 > A && (x = 100 * m * l[g + 6] * l[u + 6], l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] -= b * x, l[u + 3] -= w * x)) : (A = Math.sqrt(b * b + w * w), A > 0 && (x = m * l[g + 6] * l[u + 6] / A / A, l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] -= b * x, l[u + 3] -= w * x));\n        }\n      }for (y = v.settings.gravity / v.settings.scalingRatio, m = v.settings.scalingRatio, r = 0; r < v.nodesLength; r += v.ppn) {\n        x = 0, b = l[r], w = l[r + 1], A = Math.sqrt(b * b + w * w), v.settings.strongGravityMode ? A > 0 && (x = m * l[r + 6] * y) : A > 0 && (x = m * l[r + 6] * y / A), l[r + 2] -= b * x, l[r + 3] -= w * x;\n      }for (m = 1 * (v.settings.outboundAttractionDistribution ? k : 1), p = 0; p < v.edgesLength; p += v.ppe) {\n        g = c[p], u = c[p + 1], d = c[p + 2], _ = Math.pow(d, v.settings.edgeWeightInfluence), b = l[g] - l[u], w = l[g + 1] - l[u + 1], v.settings.adjustSizes ? (A = Math.sqrt(b * b + w * w - l[g + 8] - l[u + 8]) - L, v.settings.linLogMode ? v.settings.outboundAttractionDistribution ? A > 0 && (x = -m * _ * Math.log(1 + A) / A / l[g + 6]) : A > 0 && (x = -m * _ * Math.log(1 + A) / A) : v.settings.outboundAttractionDistribution ? A > 0 && (x = -m * _ / l[g + 6]) : A > 0 && (x = -m * _)) : (A = Math.sqrt(b * b + w * w) - L, v.settings.linLogMode ? v.settings.outboundAttractionDistribution ? A > 0 && (x = -m * _ * Math.log(1 + A) / A / l[g + 6]) : A > 0 && (x = -m * _ * Math.log(1 + A) / A) : v.settings.outboundAttractionDistribution ? (A = 1, x = -m * _ / l[g + 6]) : (A = 1, x = -m * _)), A > 0 && (l[g + 2] += b * x, l[g + 3] += w * x, l[u + 2] -= b * x, l[u + 3] -= w * x);\n      }var q,\n          O,\n          D,\n          R,\n          U = 0;if (v.settings.adjustSizes) for (r = 0; r < v.nodesLength; r += v.ppn) {\n        l[r + 9] || (q = Math.sqrt(l[r + 2] * l[r + 2] + l[r + 3] * l[r + 3]), q > v.maxForce && (l[r + 2] = l[r + 2] * v.maxForce / q, l[r + 3] = l[r + 3] * v.maxForce / q), O = l[r + 6] * Math.sqrt((l[r + 4] - l[r + 2]) * (l[r + 4] - l[r + 2]) + (l[r + 5] - l[r + 3]) * (l[r + 5] - l[r + 3])), D = Math.sqrt((l[r + 4] + l[r + 2]) * (l[r + 4] + l[r + 2]) + (l[r + 5] + l[r + 3]) * (l[r + 5] + l[r + 3])) / 2, R = .1 * Math.log(1 + D) / (1 + Math.sqrt(O)), M = l[r], B = l[r + 1], l[r] = l[r] + l[r + 2] * (R / v.settings.slowDown), l[r + 1] = l[r + 1] + l[r + 3] * (R / v.settings.slowDown), b = l[r], w = l[r + 1], A = Math.sqrt((b - M) * (b - M) + (w - B) * (w - B)), U += A);\n      } else for (r = 0; r < v.nodesLength; r += v.ppn) {\n        l[r + 9] || (O = l[r + 6] * Math.sqrt((l[r + 4] - l[r + 2]) * (l[r + 4] - l[r + 2]) + (l[r + 5] - l[r + 3]) * (l[r + 5] - l[r + 3])), D = Math.sqrt((l[r + 4] + l[r + 2]) * (l[r + 4] + l[r + 2]) + (l[r + 5] + l[r + 3]) * (l[r + 5] + l[r + 3])) / 2, R = l[r + 7] * Math.log(1 + D) / (1 + Math.sqrt(O)), l[r + 7] = Math.min(1, Math.sqrt(R * (l[r + 2] * l[r + 2] + l[r + 3] * l[r + 3]) / (1 + Math.sqrt(O)))), M = l[r], B = l[r + 1], l[r] = l[r] + l[r + 2] * (R / v.settings.slowDown), l[r + 1] = l[r + 1] + l[r + 3] * (R / v.settings.slowDown), b = l[r], w = l[r + 1], A = Math.sqrt((b - M) * (b - M) + (w - B) * (w - B)), U += A);\n      }if (v.iterations++, v.settings.autoStop && (v.converged = v.iterations > v.settings.maxIterations || U / v.nodesLength < v.settings.avgDistanceThreshold, v.converged && v.settings.alignNodeSiblings)) {\n        var j,\n            P,\n            C = {},\n            T = {};for (p = 0; p < v.edgesLength; p += v.ppe) {\n          g = c[p], u = c[p + 1], g !== u && (C[g] = C[g] || {}, C[u] = C[u] || {}, C[g][u] = !0, C[u][g] = !0);\n        }Object.keys(C).forEach(function (t) {\n          t = ~~t, P = Object.keys(C[t]), 2 == P.length && (j = P[0] + ";" + P[1], j in T ? T[j].push(t) : (j = P[1] + ";" + P[0], T[j] || (T[j] = [~~P[1], ~~P[0]]), T[j].push(t)));\n        });var N,\n            $,\n            H,\n            G,\n            X,\n            Y,\n            K,\n            J,\n            Q,\n            V,\n            Z,\n            tt,\n            et,\n            rt,\n            st,\n            nt = v.settings.nodeSiblingsAngleMin;Object.keys(T).forEach(function (t) {\n          if ($ = T[t].shift(), H = T[t].shift(), N = T[t].filter(function (t) {\n            return !l[t + 9];\n          }), 1 != N.length) {\n            if (Y = l[$], K = l[$ + 1], J = l[H], Q = l[H + 1], G = Object.keys(C[$]).length, X = Object.keys(C[H]).length, V = n(G / (G + X), 0, 1, .25, .75), tt = h(Y, K, J, Q, V), et = o(Y, K, J, Q), Z = s(Y, K, J, Q), rt = a(et, Z), st = i(rt), 2 * nt > Math.PI) throw new Error("ForceLink.Worker - Invalid parameter: angleMin must be smaller than 2 PI.");nt > 0 && (nt > st || st > Math.PI - nt && st <= Math.PI ? rt = { x: 2 * Math.cos(Math.PI - nt), y: 2 * Math.sin(Math.PI - nt) } : (st > 2 * Math.PI - nt || st >= Math.PI && st < Math.PI + nt) && (rt = { x: 2 * Math.cos(nt), y: 2 * Math.sin(nt) }));var e = 0,\n                r = 1,\n                g = 1;N.length % 2 == 1 && (g = 0, e = 1);for (var u = 0; u < N.length; u++) {\n              l[N[u]] = tt.x + r * rt.x * g * (e || u >= 2 ? v.settings.nodeSiblingsScale : 2 * v.settings.nodeSiblingsScale / 3), l[N[u] + 1] = tt.y + r * rt.y * g * (e || u >= 2 ? v.settings.nodeSiblingsScale : 2 * v.settings.nodeSiblingsScale / 3), r = -r, g += (u + e) % 2;\n            }\n          }\n        });\n      }\n    }function d(t) {\n      for (var e = 0; t > e; e++) {\n        p();\n      }y();\n    }var l,\n        c,\n        f,\n        y,\n        v = { ppn: 10, ppe: 3, ppr: 9, maxForce: 10, iterations: 0, converged: !1, settings: { linLogMode: !1, outboundAttractionDistribution: !1, adjustSizes: !1, edgeWeightInfluence: 0, scalingRatio: 1, strongGravityMode: !1, gravity: 1, slowDown: 1, barnesHutOptimize: !1, barnesHutTheta: .5, startingIterations: 1, iterationsPerRender: 1, maxIterations: 1e3, avgDistanceThreshold: .01, autoStop: !1, alignNodeSiblings: !1, nodeSiblingsScale: 1, nodeSiblingsAngleMin: 0, minNodeDistance: 0 } };y = "undefined" != typeof window && window.document ? function () {\n      if (!v.autoStop || v.converged) {\n        var t;document.createEvent ? (t = document.createEvent("Event"), t.initEvent("newCoords", !0, !1)) : (t = document.createEventObject(), t.eventType = "newCoords"), t.eventName = "newCoords", t.data = { nodes: l.buffer, converged: v.converged }, requestAnimationFrame(function () {\n          document.dispatchEvent(t);\n        });\n      }\n    } : function () {\n      (!v.autoStop || v.converged) && self.postMessage({ nodes: l.buffer, converged: v.converged }, [l.buffer]);\n    };var k = function k(t) {\n      switch (t.data.action) {case "start":\n          g(new Float32Array(t.data.nodes), new Float32Array(t.data.edges), t.data.config), d(v.settings.startingIterations);break;case "loop":\n          l = new Float32Array(t.data.nodes), d(v.settings.iterationsPerRender);break;case "config":\n          u(t.data.config);break;case "kill":\n          r(v), l = null, c = null, f = null, self.removeEventListener("message", k);}\n    };self.addEventListener("message", k);\n  },\n      crush = null;if (inWebWorker) eval(getWorkerFn());else {\n    if ("undefined" == typeof sigma) throw new Error("sigma is not declared");sigma.layouts.getForceLinkWorker = getWorkerFn;\n  }\n}.call(this);'},function(e,n){e.exports='/**\n * @license\n * Copyright (c) [2014] [Linkurious]\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (a) {\n  "use strict";\n  if ("undefined" == typeof sigma) throw "sigma.renderers.glyphs: sigma not in scope.";sigma.utils.pkg("sigma.settings");var b = { glyphScale: .5, glyphFillColor: "white", glyphTextColor: "black", glyphStrokeColor: "black", glyphLineWidth: 2, glyphFont: "Arial", glyphFontStyle: "normal", glyphFontScale: 1, glyphTextThreshold: 7, glyphStrokeIfText: !1, glyphThreshold: 1, drawGlyphs: !0 };sigma.settings = sigma.utils.extend(sigma.settings || {}, b);\n}).call(this), function (a) {\n  "use strict";\n  function b(a) {\n    return a * Math.PI / 180;\n  }function c(a, b) {\n    return "function" == typeof a ? a.call(b) : a;\n  }function d(a) {\n    function d(a, b) {\n      if (a.draw && a.x && a.y && a.radius > a.threshold) {\n        var c = a.x,\n            d = a.y;switch (a.position) {case "top-right":\n            c += a.nodeSize * A, d += a.nodeSize * B;break;case "top-left":\n            c += a.nodeSize * y, d += a.nodeSize * z;break;case "bottom-left":\n            c += a.nodeSize * w, d += a.nodeSize * x;break;case "bottom-right":\n            c += a.nodeSize * u, d += a.nodeSize * v;}if (b.fillStyle = a.fillColor, a.strokeColor !== b.strokeStyle && (b.strokeStyle = a.strokeColor), b.beginPath(), b.arc(c, d, a.radius, 2 * Math.PI, !1), b.closePath(), (!a.strokeIfText || a.radius > a.textThreshold) && b.stroke(), b.fill(), a.radius > a.textThreshold) {\n          var e = Math.round(a.fontScale * a.radius),\n              f = a.fontStyle + " " + e + "px " + a.font;f !== b.font && (b.font = f), b.fillStyle = a.textColor, b.fillText(a.content, c, d);\n        }\n      }\n    }a = a || {};var e = a.font || this.settings("glyphFont"),\n        f = a.fontStyle || this.settings("glyphFontStyle"),\n        g = a.fontScale || this.settings("glyphFontScale"),\n        h = a.strokeColor || this.settings("glyphStrokeColor"),\n        i = a.lineWidth || this.settings("glyphLineWidth"),\n        j = a.fillColor || this.settings("glyphFillColor"),\n        k = a.scale || this.settings("glyphScale"),\n        l = a.textColor || this.settings("glyphTextColor"),\n        m = a.textThreshold || this.settings("glyphTextThreshold"),\n        n = "strokeIfText" in a ? a.strokeIfText : this.settings("glyphStrokeIfText"),\n        o = a.threshold || this.settings("glyphThreshold"),\n        p = "draw" in a ? a.draw : this.settings("drawGlyphs");if (p) {\n      this.domElements.glyphs || (this.initDOM("canvas", "glyphs"), this.domElements.glyphs.width = this.container.offsetWidth, this.domElements.glyphs.height = this.container.offsetHeight, this.container.insertBefore(this.domElements.glyphs, this.domElements.mouse)), this.drawingContext = this.domElements.glyphs.getContext("2d"), this.drawingContext.textAlign = "center", this.drawingContext.textBaseline = "middle", this.drawingContext.lineWidth = i, this.drawingContext.strokeStyle = h;var q,\n          r = this,\n          s = this.nodesOnScreen || [],\n          t = this.options.prefix || "",\n          u = Math.cos(b(45)),\n          v = Math.sin(b(45)),\n          w = Math.cos(b(135)),\n          x = Math.sin(b(135)),\n          y = Math.cos(b(225)),\n          z = Math.sin(b(225)),\n          A = Math.cos(b(315)),\n          B = Math.sin(b(315));s.forEach(function (a) {\n        a.glyphs && a.glyphs.forEach(function (b) {\n          q = !a.hidden, q && "draw" in b && (q = b.draw), d({ x: a[t + "x"], y: a[t + "y"], nodeSize: a[t + "size"] || 0, position: b.position, radius: b.size || a[t + "size"] * k, content: (b.content || "").toString() || "", lineWidth: b.lineWidth || i, fillColor: c(b.fillColor, a) || j, textColor: c(b.textColor, a) || l, strokeColor: c(b.strokeColor, a) || h, strokeIfText: "strokeIfText" in b ? b.strokeIfText : n, fontStyle: b.fontStyle || f, font: b.font || e, fontScale: b.fontScale || g, threshold: b.threshold || o, textThreshold: b.textThreshold || m, draw: q }, r.drawingContext);\n        });\n      });\n    }\n  }if ("undefined" == typeof sigma) throw "sigma is not declared";sigma.renderers.canvas.prototype.glyphs = d;\n}.call(this);\n//# sourceMappingURL=sigma.renderers.glyphs.min.js.map'},function(e,n){e.exports='(function(){"use strict";function a(a){if(d[a])return d[a];var b=[0,0,0];return a.match(/^#/)?(a=(a||"").replace(/^#/,""),b=3===a.length?[parseInt(a.charAt(0)+a.charAt(0),16),parseInt(a.charAt(1)+a.charAt(1),16),parseInt(a.charAt(2)+a.charAt(2),16)]:[parseInt(a.charAt(0)+a.charAt(1),16),parseInt(a.charAt(2)+a.charAt(3),16),parseInt(a.charAt(4)+a.charAt(5),16)]):a.match(/^ *rgba? *\\(/)&&(a=a.match(/^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/),b=[+a[1],+a[2],+a[3]]),d[a]={r:b[0],g:b[1],b:b[2]},d[a]}function b(b,c,d){b=a(b),c=a(c);var e={r:b.r*(1-d)+c.r*d,g:b.g*(1-d)+c.g*d,b:b.b*(1-d)+c.b*d};return"rgb("+[0|e.r,0|e.g,0|e.b].join(",")+")"}if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.plugins");var c=0,d={};sigma.plugins.animate=function(a,d,e){function f(){var c=(sigma.utils.dateNow()-m)/k;if(c>=1){g.forEach(function(a){for(var b in d)b in d&&(a[b]=a[d[b]])});var e,n;for(e in a.cameras)n=a.cameras[e],n.edgequadtree._enabled=!0;a.refresh(),"function"==typeof i.onComplete&&i.onComplete()}else c=l(c),g.forEach(function(a){for(var e in d)e in d&&(e.match(/color$/)?a[e]=b(h[a.id][e],a[d[e]],c):a[e]=a[d[e]]*c+h[a.id][e]*(1-c))}),a.refresh(),a.animations[j]=requestAnimationFrame(f)}var g,h,i=e||{},j=++c,k=i.duration||a.settings("animationsTime"),l="string"==typeof i.easing?sigma.utils.easings[i.easing]:"function"==typeof i.easing?i.easing:sigma.utils.easings.quadraticInOut,m=sigma.utils.dateNow();g=i.nodes&&i.nodes.length?"object"==typeof i.nodes[0]?i.nodes:a.graph.nodes(i.nodes):a.graph.nodes(),h=g.reduce(function(a,b){var c;a[b.id]={};for(c in d)c in b&&(a[b.id][c]=b[c]);return a},{}),a.animations=a.animations||Object.create({}),sigma.plugins.kill(a);var n,o;for(n in a.cameras)o=a.cameras[n],o.edgequadtree._enabled=!1;f()},sigma.plugins.kill=function(a){for(var b in a.animations||{})cancelAnimationFrame(a.animations[b]);var b,c;for(b in a.cameras)c=a.cameras[b],c.edgequadtree._enabled=!0}}).call(window);'},function(e,n){e.exports='(function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.settings");var b={defaultEdgeLabelColor:"#000",defaultEdgeLabelActiveColor:"#000",defaultEdgeLabelSize:10,edgeLabelSize:"fixed",edgeLabelSizePowRatio:1,edgeLabelThreshold:1};sigma.settings=sigma.utils.extend(sigma.settings||{},b),sigma.settings.drawEdgeLabels=!0}).call(this),function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.canvas.edges.labels"),sigma.canvas.edges.labels.curve=function(a,b,c,d,e){if("string"==typeof a.label){var f=e("prefix")||"",g=a[f+"size"]||1;if(!(g<e("edgeLabelThreshold"))){var h,i,j,k=b[f+"size"],l=b[f+"x"],m=b[f+"y"],n=c[f+"x"],o=c[f+"y"],p=n-l,q=o-m,r=l<n?1:-1,s={},t=.5;b.id===c.id?(s=sigma.utils.getSelfLoopControlPoints(l,m,k),i=sigma.utils.getPointOnBezierCurve(t,l,m,n,o,s.x1,s.y1,s.x2,s.y2),j=Math.atan2(1,1)):(s=sigma.utils.getQuadraticControlPoint(l,m,n,o),i=sigma.utils.getPointOnQuadraticCurve(t,l,m,n,o,s.x,s.y),j=Math.atan2(q*r,p*r)),h="fixed"===e("edgeLabelSize")?e("defaultEdgeLabelSize"):e("defaultEdgeLabelSize")*g*Math.pow(g,-1/e("edgeLabelSizePowRatio")),d.save(),a.active?(d.font=[e("activeFontStyle"),h+"px",e("activeFont")||e("font")].join(" "),d.fillStyle="edge"===e("edgeActiveColor")?a.active_color||e("defaultEdgeActiveColor"):e("defaultEdgeLabelActiveColor")):(d.font=[e("fontStyle"),h+"px",e("font")].join(" "),d.fillStyle="edge"===e("edgeLabelColor")?a.color||e("defaultEdgeColor"):e("defaultEdgeLabelColor")),d.textAlign="center",d.textBaseline="alphabetic",d.translate(i.x,i.y),d.rotate(j),d.fillText(a.label,0,-g/2-3),d.restore()}}}}.call(this),function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.canvas.edges.labels"),sigma.canvas.edges.labels.curvedArrow=function(a,b,c,d,e){sigma.canvas.edges.labels.curve(a,b,c,d,e)}}.call(this),function(a){"use strict";if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.canvas.edges.labels"),sigma.canvas.edges.labels.def=function(a,b,c,d,e){if("string"==typeof a.label&&b!=c){var f=e("prefix")||"",g=a[f+"size"]||1;if(!(g<e("edgeLabelThreshold"))){if(0===e("edgeLabelSizePowRatio"))throw\'"edgeLabelSizePowRatio" must not be 0.\';var h,i=(b[f+"x"]+c[f+"x"])/2,j=(b[f+"y"]+c[f+"y"])/2,k=c[f+"x"]-b[f+"x"],l=c[f+"y"]-b[f+"y"],m=b[f+"x"]<c[f+"x"]?1:-1,n=Math.atan2(l*m,k*m);h="fixed"===e("edgeLabelSize")?e("defaultEdgeLabelSize"):e("defaultEdgeLabelSize")*g*Math.pow(g,-1/e("edgeLabelSizePowRatio")),d.save(),a.active?(d.font=[e("activeFontStyle"),h+"px",e("activeFont")||e("font")].join(" "),d.fillStyle="edge"===e("edgeActiveColor")?a.active_color||e("defaultEdgeActiveColor"):e("defaultEdgeLabelActiveColor")):(d.font=[e("fontStyle"),h+"px",e("font")].join(" "),d.fillStyle="edge"===e("edgeLabelColor")?a.color||e("defaultEdgeColor"):e("defaultEdgeLabelColor")),d.textAlign="center",d.textBaseline="alphabetic",d.translate(i,j),d.rotate(n),d.fillText(a.label,0,-g/2-3),d.restore()}}}}.call(this);'},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.mouse = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // MOUSE MANAGEMENT:\n        // *****************\n        // The mouse position when the user starts dragging:\n        _startMouseX,\n        _startMouseY,\n\n        _isMouseDown,\n        _isMoving,\n        _hasDragged,\n        _downStartTime,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);\n    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);\n    _target.addEventListener('mousewheel', _wheelHandler, false);\n    _target.addEventListener('mousemove', _moveHandler, false);\n    _target.addEventListener('mousedown', _downHandler, false);\n    _target.addEventListener('click', _clickHandler, false);\n    _target.addEventListener('mouseout', _outHandler, false);\n    document.addEventListener('mouseup', _upHandler, false);\n\n\n\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'click');\n      _target.removeEventListener('DOMMouseScroll', _wheelHandler);\n      _target.removeEventListener('mousewheel', _wheelHandler);\n      _target.removeEventListener('mousemove', _moveHandler);\n      _target.removeEventListener('mousedown', _downHandler);\n      _target.removeEventListener('click', _clickHandler);\n      _target.removeEventListener('mouseout', _outHandler);\n      document.removeEventListener('mouseup', _upHandler);\n    };\n\n\n\n\n    // MOUSE EVENTS:\n    // *************\n\n    /**\n     * The handler listening to the 'move' mouse event. It will effectively\n     * drag the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _moveHandler(e) {\n      var x,\n          y,\n          pos;\n\n      // Dispatch event:\n      if (_settings('mouseEnabled')) {\n        _self.dispatchEvent('mousemove',\n          sigma.utils.mouseCoords(e));\n\n        if (_isMouseDown) {\n          _isMoving = true;\n          _hasDragged = true;\n\n          if (_movingTimeoutId)\n            clearTimeout(_movingTimeoutId);\n\n          _movingTimeoutId = setTimeout(function() {\n            _isMoving = false;\n          }, _settings('dragTimeout'));\n\n          sigma.misc.animation.killAll(_camera);\n\n          _camera.isMoving = true;\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - _startMouseX,\n            sigma.utils.getY(e) - _startMouseY,\n            true\n          );\n\n          x = _startCameraX - pos.x;\n          y = _startCameraY - pos.y;\n\n          if (x !== _camera.x || y !== _camera.y) {\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _camera.goTo({\n              x: x,\n              y: y\n            });\n          }\n\n          if (e.preventDefault)\n            e.preventDefault();\n          else\n            e.returnValue = false;\n\n          e.stopPropagation();\n          return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'up' mouse event. It will stop dragging the\n     * graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _upHandler(e) {\n      if (_settings('mouseEnabled') && _isMouseDown) {\n        _isMouseDown = false;\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _camera.isMoving = false;\n\n        var x = sigma.utils.getX(e),\n            y = sigma.utils.getY(e);\n\n        if (_isMoving) {\n          sigma.misc.animation.killAll(_camera);\n          sigma.misc.animation.camera(\n            _camera,\n            {\n              x: _camera.x +\n                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),\n              y: _camera.y +\n                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)\n            },\n            {\n              easing: 'quadraticOut',\n              duration: _settings('mouseInertiaDuration')\n            }\n          );\n        } else if (\n          _startMouseX !== x ||\n          _startMouseY !== y\n        )\n          _camera.goTo({\n            x: _camera.x,\n            y: _camera.y\n          });\n\n        _self.dispatchEvent('mouseup',\n          sigma.utils.mouseCoords(e));\n\n        // Update _isMoving flag:\n        _isMoving = false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'down' mouse event. It will start observing\n     * the mouse position for dragging the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _downHandler(e) {\n      if (_settings('mouseEnabled')) {\n        _startCameraX = _camera.x;\n        _startCameraY = _camera.y;\n\n        _lastCameraX = _camera.x;\n        _lastCameraY = _camera.y;\n\n        _startMouseX = sigma.utils.getX(e);\n        _startMouseY = sigma.utils.getY(e);\n\n        _hasDragged = false;\n        _downStartTime = (new Date()).getTime();\n\n        switch (e.which) {\n          case 2:\n            // Middle mouse button pressed\n            // Do nothing.\n            break;\n          case 3:\n            // Right mouse button pressed\n            _self.dispatchEvent('rightclick',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n            break;\n          // case 1:\n          default:\n            // Left mouse button pressed\n            _isMouseDown = true;\n\n            _self.dispatchEvent('mousedown',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'out' mouse event. It will just redispatch\n     * the event.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _outHandler(e) {\n      if (_settings('mouseEnabled'))\n        _self.dispatchEvent('mouseout');\n    }\n\n    /**\n     * The handler listening to the 'click' mouse event. It will redispatch the\n     * click event, but with normalized X and Y coordinates.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _clickHandler(e) {\n      if (_settings('mouseEnabled')) {\n        var event = sigma.utils.mouseCoords(e);\n        event.isDragging =\n          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;\n        _self.dispatchEvent('click', event);\n      }\n\n      if (e.preventDefault)\n        e.preventDefault();\n      else\n        e.returnValue = false;\n\n      e.stopPropagation();\n      return false;\n    }\n\n    /**\n     * The handler listening to the double click custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _doubleClickHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (_settings('mouseEnabled')) {\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        _self.dispatchEvent('doubleclick',\n            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration')\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'wheel' mouse event. It will basically zoom\n     * in or not into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _wheelHandler(e) {\n      var pos,\n          ratio,\n          animation,\n          wheelDelta = sigma.utils.getDelta(e);\n\n      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {\n        ratio = wheelDelta > 0 ?\n          1 / _settings('zoomingRatio') :\n          _settings('zoomingRatio');\n\n        pos = _camera.cameraPosition(\n          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n          true\n        );\n\n        animation = {\n          duration: _settings('mouseZoomDuration')\n        };\n\n        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.touch = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        _startCameraRatio,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // TOUCH MANAGEMENT:\n        // *****************\n        // Touches that are down:\n        _downTouches = [],\n\n        _startTouchX0,\n        _startTouchY0,\n        _startTouchX1,\n        _startTouchY1,\n        _startTouchAngle,\n        _startTouchDistance,\n\n        _touchMode,\n\n        _isMoving,\n        _doubleTap,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);\n    _target.addEventListener('touchstart', _handleStart, false);\n    _target.addEventListener('touchend', _handleLeave, false);\n    _target.addEventListener('touchcancel', _handleLeave, false);\n    _target.addEventListener('touchleave', _handleLeave, false);\n    _target.addEventListener('touchmove', _handleMove, false);\n\n    function position(e) {\n      var offset = sigma.utils.getOffset(_target);\n\n      return {\n        x: e.pageX - offset.left,\n        y: e.pageY - offset.top\n      };\n    }\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'touchstart');\n      _target.addEventListener('touchstart', _handleStart);\n      _target.addEventListener('touchend', _handleLeave);\n      _target.addEventListener('touchcancel', _handleLeave);\n      _target.addEventListener('touchleave', _handleLeave);\n      _target.addEventListener('touchmove', _handleMove);\n    };\n\n    // TOUCH EVENTS:\n    // *************\n    /**\n     * The handler listening to the 'touchstart' event. It will set the touch\n     * mode (\"_touchMode\") and start observing the user touch moves.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleStart(e) {\n      if (_settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            pos0,\n            pos1;\n\n        _downTouches = e.touches;\n\n        switch (_downTouches.length) {\n          case 1:\n            _camera.isMoving = true;\n            _touchMode = 1;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            pos0 = position(_downTouches[0]);\n            _startTouchX0 = pos0.x;\n            _startTouchY0 = pos0.y;\n\n            break;\n          case 2:\n            _camera.isMoving = true;\n            _touchMode = 2;\n\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _startCameraAngle = _camera.angle;\n            _startCameraRatio = _camera.ratio;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _startTouchX0 = x0;\n            _startTouchY0 = y0;\n            _startTouchX1 = x1;\n            _startTouchY1 = y1;\n\n            _startTouchAngle = Math.atan2(\n              _startTouchY1 - _startTouchY0,\n              _startTouchX1 - _startTouchX0\n            );\n            _startTouchDistance = Math.sqrt(\n              (_startTouchY1 - _startTouchY0) *\n                (_startTouchY1 - _startTouchY0) +\n              (_startTouchX1 - _startTouchX0) *\n                (_startTouchX1 - _startTouchX0)\n            );\n\n            e.preventDefault();\n            return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'\n     * event. It will update the touch mode if there are still at least one\n     * finger, and stop dragging else.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleLeave(e) {\n      if (_settings('touchEnabled')) {\n        _downTouches = e.touches;\n        var inertiaRatio = _settings('touchInertiaRatio');\n\n        if (_movingTimeoutId) {\n          _isMoving = false;\n          clearTimeout(_movingTimeoutId);\n        }\n\n        switch (_touchMode) {\n          case 2:\n            if (e.touches.length === 1) {\n              _handleStart(e);\n\n              e.preventDefault();\n              break;\n            }\n            /* falls through */\n          case 1:\n            _camera.isMoving = false;\n            _self.dispatchEvent('stopDrag');\n\n            if (_isMoving) {\n              _doubleTap = false;\n              sigma.misc.animation.camera(\n                _camera,\n                {\n                  x: _camera.x +\n                    inertiaRatio * (_camera.x - _lastCameraX),\n                  y: _camera.y +\n                    inertiaRatio * (_camera.y - _lastCameraY)\n                },\n                {\n                  easing: 'quadraticOut',\n                  duration: _settings('touchInertiaDuration')\n                }\n              );\n            }\n\n            _isMoving = false;\n            _touchMode = 0;\n            break;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchmove' event. It will effectively drag\n     * the graph, and eventually zooms and turn it if the user is using two\n     * fingers.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleMove(e) {\n      if (!_doubleTap && _settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            cos,\n            sin,\n            end,\n            pos0,\n            pos1,\n            diff,\n            start,\n            dAngle,\n            dRatio,\n            newStageX,\n            newStageY,\n            newStageRatio,\n            newStageAngle;\n\n        _downTouches = e.touches;\n        _isMoving = true;\n\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _movingTimeoutId = setTimeout(function() {\n          _isMoving = false;\n        }, _settings('dragTimeout'));\n\n        switch (_touchMode) {\n          case 1:\n            pos0 = position(_downTouches[0]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n\n            diff = _camera.cameraPosition(\n              x0 - _startTouchX0,\n              y0 - _startTouchY0,\n              true\n            );\n\n            newStageX = _startCameraX - diff.x;\n            newStageY = _startCameraY - diff.y;\n\n            if (newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY\n              });\n\n              _self.dispatchEvent('mousemove',\n                sigma.utils.mouseCoords(e, pos0.x, pos0.y));\n\n              _self.dispatchEvent('drag');\n            }\n            break;\n          case 2:\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            start = _camera.cameraPosition(\n              (_startTouchX0 + _startTouchX1) / 2 -\n                sigma.utils.getCenter(e).x,\n              (_startTouchY0 + _startTouchY1) / 2 -\n                sigma.utils.getCenter(e).y,\n              true\n            );\n            end = _camera.cameraPosition(\n              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,\n              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,\n              true\n            );\n\n            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;\n            dRatio = Math.sqrt(\n              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)\n            ) / _startTouchDistance;\n\n            // Translation:\n            x0 = start.x;\n            y0 = start.y;\n\n            // Homothetic transformation:\n            newStageRatio = _startCameraRatio / dRatio;\n            x0 = x0 * dRatio;\n            y0 = y0 * dRatio;\n\n            // Rotation:\n            newStageAngle = _startCameraAngle - dAngle;\n            cos = Math.cos(-dAngle);\n            sin = Math.sin(-dAngle);\n            x1 = x0 * cos + y0 * sin;\n            y1 = y0 * cos - x0 * sin;\n            x0 = x1;\n            y0 = y1;\n\n            // Finalize:\n            newStageX = x0 - end.x + _startCameraX;\n            newStageY = y0 - end.y + _startCameraY;\n\n            if (\n              newStageRatio !== _camera.ratio ||\n              newStageAngle !== _camera.angle ||\n              newStageX !== _camera.x ||\n              newStageY !== _camera.y\n            ) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n              _lastCameraAngle = _camera.angle;\n              _lastCameraRatio = _camera.ratio;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY,\n                angle: newStageAngle,\n                ratio: newStageRatio\n              });\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n        }\n\n        e.preventDefault();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the double tap custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A touch event.\n     */\n    function _doubleTapHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {\n        _doubleTap = true;\n\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        pos = position(e.touches[0]);\n        _self.dispatchEvent('doubleclick',\n          sigma.utils.mouseCoords(e, pos.x, pos.y));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            pos.x - sigma.utils.getCenter(e).x,\n            pos.y - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration'),\n            onComplete: function() {\n              _doubleTap = false;\n            }\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.classes');\n\n  /**\n   * The camera constructor. It just initializes its attributes and methods.\n   *\n   * @param  {string}       id       The id.\n   * @param  {sigma.classes.graph}  graph    The graph.\n   * @param  {configurable} settings The settings function.\n   * @param  {?object}      options  Eventually some overriding options.\n   * @return {camera}                Returns the fresh new camera instance.\n   */\n  sigma.classes.camera = function(id, graph, settings, options) {\n    sigma.classes.dispatcher.extend(this);\n\n    Object.defineProperty(this, 'graph', {\n      value: graph\n    });\n    Object.defineProperty(this, 'id', {\n      value: id\n    });\n    Object.defineProperty(this, 'readPrefix', {\n      value: 'read_cam' + id + ':'\n    });\n    Object.defineProperty(this, 'prefix', {\n      value: 'cam' + id + ':'\n    });\n\n    this.x = 0;\n    this.y = 0;\n    this.ratio = 1;\n    this.angle = 0;\n    this.isAnimated = false;\n    this.settings = (typeof options === 'object' && options) ?\n      settings.embedObject(options) :\n      settings;\n  };\n\n  /**\n   * Updates the camera position.\n   *\n   * @param  {object} coordinates The new coordinates object.\n   * @return {camera}             Returns the camera.\n   */\n  sigma.classes.camera.prototype.goTo = function(coordinates) {\n    if (!this.settings('enableCamera'))\n      return this;\n\n    var i,\n        l,\n        c = coordinates || {},\n        keys = ['x', 'y', 'ratio', 'angle'];\n\n    for (i = 0, l = keys.length; i < l; i++)\n      if (c[keys[i]] !== undefined) {\n        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))\n          this[keys[i]] = c[keys[i]];\n        else\n          throw 'Value for \"' + keys[i] + '\" is not a number.';\n      }\n\n    this.dispatchEvent('coordinatesUpdated');\n    return this;\n  };\n\n  /**\n   * This method takes a graph and computes for each node and edges its\n   * coordinates relatively to the center of the camera. Basically, it will\n   * compute the coordinates that will be used by the graphic renderers.\n   *\n   * Since it should be possible to use different cameras and different\n   * renderers, it is possible to specify a prefix to put before the new\n   * coordinates (to get something like \"node.camera1_x\")\n   *\n   * @param  {?string} read    The prefix of the coordinates to read.\n   * @param  {?string} write   The prefix of the coordinates to write.\n   * @param  {?object} options Eventually an object of options. Those can be:\n   *                           - A restricted nodes array.\n   *                           - A restricted edges array.\n   *                           - A width.\n   *                           - A height.\n   * @return {camera}        Returns the camera.\n   */\n  sigma.classes.camera.prototype.applyView = function(read, write, options) {\n    options = options || {};\n    write = write !== undefined ? write : this.prefix;\n    read = read !== undefined ? read : this.readPrefix;\n\n    var nodes = options.nodes || this.graph.nodes(),\n        edges = options.edges || this.graph.edges();\n\n    var i,\n        l,\n        node,\n        relCos = Math.cos(this.angle) / this.ratio,\n        relSin = Math.sin(this.angle) / this.ratio,\n        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),\n        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),\n        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,\n        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      node[write + 'x'] =\n        (node[read + 'x'] || 0) * relCos +\n        (node[read + 'y'] || 0) * relSin +\n        xOffset;\n      node[write + 'y'] =\n        (node[read + 'y'] || 0) * relCos -\n        (node[read + 'x'] || 0) * relSin +\n        yOffset;\n      node[write + 'size'] =\n        (node[read + 'size'] || 0) /\n        nodeRatio;\n    }\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      edges[i][write + 'size'] =\n        (edges[i][read + 'size'] || 0) /\n        edgeRatio;\n    }\n\n    return this;\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * camera to the frame of the graph.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    camera.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    camera.\n   * @return {object}   The point coordinates in the frame of the graph.\n   */\n  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: (x * cos + y * sin) / this.ratio + X,\n      y: (y * cos - x * sin) / this.ratio + Y\n    };\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * graph to the frame of the camera.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    graph.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    graph.\n   * @return {object}   The point coordinates in the frame of the camera.\n   */\n  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,\n      y: ((y - Y) * cos + (x - X) * sin) * this.ratio\n    };\n  };\n\n  /**\n   * This method returns the transformation matrix of the camera. This is\n   * especially useful to apply the camera view directly in shaders, in case of\n   * WebGL rendering.\n   *\n   * @return {array} The transformation matrix.\n   */\n  sigma.classes.camera.prototype.getMatrix = function() {\n    var scale = sigma.utils.matrices.scale(1 / this.ratio),\n        rotation = sigma.utils.matrices.rotation(this.angle),\n        translation = sigma.utils.matrices.translation(-this.x, -this.y),\n        matrix = sigma.utils.matrices.multiply(\n          translation,\n          sigma.utils.matrices.multiply(\n            rotation,\n            scale\n          )\n        );\n\n    return matrix;\n  };\n\n  /**\n   * Taking a width and a height as parameters, this method returns the\n   * coordinates of the rectangle representing the camera on screen, in the\n   * graph's referentiel.\n   *\n   * To keep displaying labels of nodes going out of the screen, the method\n   * keeps a margin around the screen in the returned rectangle.\n   *\n   * @param  {number} width  The width of the screen.\n   * @param  {number} height The height of the screen.\n   * @return {object}        The rectangle as x1, y1, x2 and y2, representing\n   *                         two opposite points.\n   */\n  sigma.classes.camera.prototype.getRectangle = function(width, height) {\n    var widthVect = this.cameraPosition(width, 0, true),\n        heightVect = this.cameraPosition(0, height, true),\n        centerVect = this.cameraPosition(width / 2, height / 2, true),\n        marginX = this.cameraPosition(width / 4, 0, true).x,\n        marginY = this.cameraPosition(0, height / 4, true).y;\n\n    return {\n      x1: this.x - centerVect.x - marginX,\n      y1: this.y - centerVect.y - marginY,\n      x2: this.x - centerVect.x + marginX + widthVect.x,\n      y2: this.y - centerVect.y - marginY + widthVect.y,\n      height: Math.sqrt(\n        Math.pow(heightVect.x, 2) +\n        Math.pow(heightVect.y + 2 * marginY, 2)\n      )\n    };\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  /**\n   * This utils aims to facilitate the manipulation of each instance setting.\n   * Using a function instead of an object brings two main advantages: First,\n   * it will be easier in the future to catch settings updates through a\n   * function than an object. Second, giving it a full object will \"merge\" it\n   * to the settings object properly, keeping us to have to always add a loop.\n   *\n   * @return {configurable} The \"settings\" function.\n   */\n  var configurable = function() {\n    var i,\n        l,\n        data = {},\n        datas = Array.prototype.slice.call(arguments, 0);\n\n    /**\n     * The method to use to set or get any property of this instance.\n     *\n     * @param  {string|object}    a1 If it is a string and if a2 is undefined,\n     *                               then it will return the corresponding\n     *                               property. If it is a string and if a2 is\n     *                               set, then it will set a2 as the property\n     *                               corresponding to a1, and return this. If\n     *                               it is an object, then each pair string +\n     *                               object(or any other type) will be set as a\n     *                               property.\n     * @param  {*?}               a2 The new property corresponding to a1 if a1\n     *                               is a string.\n     * @return {*|configurable}      Returns itself or the corresponding\n     *                               property.\n     *\n     * Polymorphism:\n     * *************\n     * Here are some basic use examples:\n     *\n     *  > settings = new configurable();\n     *  > settings('mySetting', 42);\n     *  > settings('mySetting'); // Logs: 42\n     *  > settings('mySetting', 123);\n     *  > settings('mySetting'); // Logs: 123\n     *  > settings({mySetting: 456});\n     *  > settings('mySetting'); // Logs: 456\n     *\n     * Also, it is possible to use the function as a fallback:\n     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'\n     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456\n     */\n    var settings = function(a1, a2) {\n      var o,\n          i,\n          l,\n          k;\n\n      if (arguments.length === 1 && typeof a1 === 'string') {\n        if (data[a1] !== undefined)\n          return data[a1];\n        for (i = 0, l = datas.length; i < l; i++)\n          if (datas[i][a1] !== undefined)\n            return datas[i][a1];\n        return undefined;\n      } else if (typeof a1 === 'object' && typeof a2 === 'string') {\n        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);\n      } else {\n        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};\n\n        if (typeof a1 === 'string')\n          o[a1] = a2;\n\n        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)\n          data[k[i]] = o[k[i]];\n\n        return this;\n      }\n    };\n\n    /**\n     * This method returns a new configurable function, with new objects\n     *\n     * @param  {object*}  Any number of objects to search in.\n     * @return {function} Returns the function. Check its documentation to know\n     *                    more about how it works.\n     */\n    settings.embedObjects = function() {\n      var args = datas.concat(\n        data\n      ).concat(\n        Array.prototype.splice.call(arguments, 0)\n      );\n\n      return configurable.apply({}, args);\n    };\n\n    // Initialize\n    for (i = 0, l = arguments.length; i < l; i++)\n      settings(arguments[i]);\n\n    return settings;\n  };\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.configurable = configurable;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = configurable;\n    exports.configurable = configurable;\n  } else\n    this.configurable = configurable;\n}).call(this);\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  /**\n   * Dispatcher constructor.\n   *\n   * @return {dispatcher} The new dispatcher instance.\n   */\n  var dispatcher = function() {\n    Object.defineProperty(this, '_handlers', {\n      value: {}\n    });\n  };\n\n\n\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string}           events  The name of the event (or the events\n   *                                    separated by spaces).\n   * @param  {function(Object)} handler The handler to bind.\n   * @return {dispatcher}               Returns the instance itself.\n   */\n  dispatcher.prototype.bind = function(events, handler) {\n    var i,\n        l,\n        event,\n        eArray;\n\n    if (\n      arguments.length === 1 &&\n      typeof arguments[0] === 'object'\n    )\n      for (events in arguments[0])\n        this.bind(events, arguments[0][events]);\n    else if (\n      arguments.length === 2 &&\n      typeof arguments[1] === 'function'\n    ) {\n      eArray = typeof events === 'string' ? events.split(' ') : events;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i];\n\n        // Check that event is not '':\n        if (!event)\n          continue;\n\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        this._handlers[event].push({\n          handler: handler\n        });\n      }\n    } else\n      throw 'bind: Wrong arguments.';\n\n    return this;\n  };\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {dispatcher}                Returns the instance itself.\n   */\n  dispatcher.prototype.unbind = function(events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    if (!arguments.length) {\n      for (k in this._handlers)\n        delete this._handlers[k];\n      return this;\n    }\n\n    if (handler) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n        if (this._handlers[event]) {\n          a = [];\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)\n            if (this._handlers[event][j].handler !== handler)\n              a.push(this._handlers[event][j]);\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0)\n          delete this._handlers[event];\n      }\n    } else\n      for (i = 0, n = eArray.length; i !== n; i += 1)\n        delete this._handlers[eArray[i]];\n\n    return this;\n  };\n\n  /**\n   * Executes each handler bound to the event\n   *\n   * @param  {string}     events The name of the event (or the events separated\n   *                             by spaces).\n   * @param  {?object}    data   The content of the event (optional).\n   * @return {dispatcher}        Returns the instance itself.\n   */\n  dispatcher.prototype.dispatchEvent = function(events, data) {\n    var i,\n        n,\n        j,\n        m,\n        a,\n        event,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n\n      if (this._handlers[eventName]) {\n        event = self.getEvent(eventName, data);\n        a = [];\n\n        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {\n          this._handlers[eventName][j].handler(event);\n          if (!this._handlers[eventName][j].one)\n            a.push(this._handlers[eventName][j]);\n        }\n\n        this._handlers[eventName] = a;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Return an event object.\n   *\n   * @param  {string}  events The name of the event.\n   * @param  {?object} data   The content of the event (optional).\n   * @return {object}         Returns the instance itself.\n   */\n  dispatcher.prototype.getEvent = function(event, data) {\n    return {\n      type: event,\n      data: data || {},\n      target: this\n    };\n  };\n\n  /**\n   * A useful function to deal with inheritance. It will make the target\n   * inherit the prototype of the class dispatcher as well as its constructor.\n   *\n   * @param {object} target The target.\n   */\n  dispatcher.extend = function(target, args) {\n    var k;\n\n    for (k in dispatcher.prototype)\n      if (dispatcher.prototype.hasOwnProperty(k))\n        target[k] = dispatcher.prototype[k];\n\n    dispatcher.apply(target, args);\n  };\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.dispatcher = dispatcher;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = dispatcher;\n    exports.dispatcher = dispatcher;\n  } else\n    this.dispatcher = dispatcher;\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module for edges\n   * ===============================\n   *\n   * Author: SÃ©bastien Heymann,\n   *   from the quad of Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge with x1, y1, x2, y2 and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph edge with at least two points\n     *                  (x1, y1), (x2, y2) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    lineToSquare: function(e) {\n      if (e.y1 < e.y2) {\n        // (e.x1, e.y1) on top\n        if (e.x1 < e.x2) {\n          // (e.x1, e.y1) on left\n          return {\n            x1: e.x1 - e.size,\n            y1: e.y1 - e.size,\n            x2: e.x2 + e.size,\n            y2: e.y1 - e.size,\n            height: e.y2 - e.y1 + e.size * 2\n          };\n        }\n        // (e.x1, e.y1) on right\n        return {\n          x1: e.x2 - e.size,\n          y1: e.y1 - e.size,\n          x2: e.x1 + e.size,\n          y2: e.y1 - e.size,\n          height: e.y2 - e.y1 + e.size * 2\n        };\n      }\n\n      // (e.x2, e.y2) on top\n      if (e.x1 < e.x2) {\n        // (e.x1, e.y1) on left\n        return {\n          x1: e.x1 - e.size,\n          y1: e.y2 - e.size,\n          x2: e.x2 + e.size,\n          y2: e.y2 - e.size,\n          height: e.y1 - e.y2 + e.size * 2\n        };\n      }\n      // (e.x2, e.y2) on right\n      return {\n        x1: e.x2 - e.size,\n        y1: e.y2 - e.size,\n        x2: e.x1 + e.size,\n        y2: e.y2 - e.size,\n        height: e.y1 - e.y2 + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,\n     * control point and size into an axis-aligned square.\n     *\n     * @param  {object} e  A graph edge with at least two points\n     *                     (x1, y1), (x2, y2) and a size.\n     * @param  {object} cp A control point (x,y).\n     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.\n     */\n    quadraticCurveToSquare: function(e, cp) {\n      var pt = sigma.utils.getPointOnQuadraticCurve(\n        0.5,\n        e.x1,\n        e.y1,\n        e.x2,\n        e.y2,\n        cp.x,\n        cp.y\n      );\n\n      // Bounding box of the two points and the point at the middle of the\n      // curve:\n      var minX = Math.min(e.x1, e.x2, pt.x),\n          maxX = Math.max(e.x1, e.x2, pt.x),\n          minY = Math.min(e.y1, e.y2, pt.y),\n          maxY = Math.max(e.y1, e.y2, pt.y);\n\n      return {\n        x1: minX - e.size,\n        y1: minY - e.size,\n        x2: maxX + e.size,\n        y2: minY - e.size,\n        height: maxY - minY + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph self loop into an axis-aligned square.\n     *\n     * @param  {object} n A graph node with a point (x, y) and a size.\n     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.\n     */\n    selfLoopToSquare: function(n) {\n      // Fitting to the curve is too costly, we compute a larger bounding box\n      // using the control points:\n      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);\n\n      // Bounding box of the point and the two control points:\n      var minX = Math.min(n.x, cp.x1, cp.x2),\n          maxX = Math.max(n.x, cp.x1, cp.x2),\n          minY = Math.min(n.y, cp.y1, cp.y2),\n          maxY = Math.max(n.y, cp.y1, cp.y2);\n\n      return {\n        x1: minX - n.size,\n        y1: minY - n.size,\n        x2: maxX + n.size,\n        y2: minY - n.size,\n        height: maxY - minY + n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 40,\n      maxLevel: maxLevel || 8,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The edgequad API as exposed to sigma.\n   */\n\n  /**\n   * The edgequad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree     Property holding the quadtree object.\n   * property {object} _geom     Exposition of the _geom namespace for testing.\n   * property {object} _cache    Cache for the area method.\n   * property {boolean} _enabled Can index and retreive elements.\n   */\n  var edgequad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n    this._enabled = true;\n  };\n\n  /**\n   * Index a graph by inserting its edges into the quadtree.\n   *\n   * @param  {object} graph   A graph instance.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for edge geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  edgequad.prototype.index = function(graph, params) {\n    if (!this._enabled)\n      return this._tree;\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.edgequad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '',\n        cp,\n        source,\n        target,\n        n,\n        e;\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    var edges = graph.edges();\n\n    // Inserting graph edges into the tree\n    for (var i = 0, l = edges.length; i < l; i++) {\n      source = graph.nodes(edges[i].source);\n      target = graph.nodes(edges[i].target);\n      e = {\n        x1: source[prefix + 'x'],\n        y1: source[prefix + 'y'],\n        x2: target[prefix + 'x'],\n        y2: target[prefix + 'y'],\n        size: edges[i][prefix + 'size'] || 0\n      };\n\n      // Inserting edge\n      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {\n        if (source.id === target.id) {\n          n = {\n            x: source[prefix + 'x'],\n            y: source[prefix + 'y'],\n            size: source[prefix + 'size'] || 0\n          };\n          _quadInsert(\n            edges[i],\n            _geom.selfLoopToSquare(n),\n            this._tree);\n        }\n        else {\n          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);\n          _quadInsert(\n            edges[i],\n            _geom.quadraticCurveToSquare(e, cp),\n            this._tree);\n        }\n      }\n      else {\n        _quadInsert(\n          edges[i],\n          _geom.lineToSquare(e),\n          this._tree);\n      }\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph edges held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.point = function(x, y) {\n    if (!this._enabled)\n      return [];\n\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph edges within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.area = function(rect) {\n    if (!this._enabled)\n      return [];\n\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving edges\n    var edges = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var edgesArray = [];\n    for (var i in edges)\n      edgesArray.push(edges[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = edgesArray;\n\n    return edgesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.edgequad = edgequad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = edgequad;\n    exports.edgequad = edgequad;\n  } else\n    this.edgequad = edgequad;\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  var _methods = Object.create(null),\n      _indexes = Object.create(null),\n      _initBindings = Object.create(null),\n      _methodBindings = Object.create(null),\n      _methodBeforeBindings = Object.create(null),\n      _defaultSettings = {\n        immutable: true,\n        clone: true\n      },\n      _defaultSettingsFunction = function(key) {\n        return _defaultSettings[key];\n      };\n\n  /**\n   * The graph constructor. It initializes the data and the indexes, and binds\n   * the custom indexes and methods to its own scope.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {boolean} clone     Indicates if the data have to be cloned in methods\n   *                       to add nodes or edges.\n   *   {boolean} immutable Indicates if nodes \"id\" values and edges \"id\",\n   *                       \"source\" and \"target\" values must be set as\n   *                       immutable.\n   *\n   * @param  {?configurable} settings Eventually a settings function.\n   * @return {graph}                  The new graph instance.\n   */\n  var graph = function(settings) {\n    var k,\n        fn,\n        data;\n\n    /**\n     * DATA:\n     * *****\n     * Every data that is callable from graph methods are stored in this \"data\"\n     * object. This object will be served as context for all these methods,\n     * and it is possible to add other type of data in it.\n     */\n    data = {\n      /**\n       * SETTINGS FUNCTION:\n       * ******************\n       */\n      settings: settings || _defaultSettingsFunction,\n\n      /**\n       * MAIN DATA:\n       * **********\n       */\n      nodesArray: [],\n      edgesArray: [],\n\n      /**\n       * GLOBAL INDEXES:\n       * ***************\n       * These indexes just index data by ids.\n       */\n      nodesIndex: Object.create(null),\n      edgesIndex: Object.create(null),\n\n      /**\n       * LOCAL INDEXES:\n       * **************\n       * These indexes refer from node to nodes. Each key is an id, and each\n       * value is the array of the ids of related nodes.\n       */\n      inNeighborsIndex: Object.create(null),\n      outNeighborsIndex: Object.create(null),\n      allNeighborsIndex: Object.create(null),\n\n      inNeighborsCount: Object.create(null),\n      outNeighborsCount: Object.create(null),\n      allNeighborsCount: Object.create(null)\n    };\n\n    // Execute bindings:\n    for (k in _initBindings)\n      _initBindings[k].call(data);\n\n    // Add methods to both the scope and the data objects:\n    for (k in _methods) {\n      fn = __bindGraphMethod(k, data, _methods[k]);\n      this[k] = fn;\n      data[k] = fn;\n    }\n  };\n\n\n\n\n  /**\n   * A custom tool to bind methods such that function that are bound to it will\n   * be executed anytime the method is called.\n   *\n   * @param  {string}   methodName The name of the method to bind.\n   * @param  {object}   scope      The scope where the method must be executed.\n   * @param  {function} fn         The method itself.\n   * @return {function}            The new method.\n   */\n  function __bindGraphMethod(methodName, scope, fn) {\n    var result = function() {\n      var k,\n          res;\n\n      // Execute \"before\" bound functions:\n      for (k in _methodBeforeBindings[methodName])\n        _methodBeforeBindings[methodName][k].apply(scope, arguments);\n\n      // Apply the method:\n      res = fn.apply(scope, arguments);\n\n      // Execute bound functions:\n      for (k in _methodBindings[methodName])\n        _methodBindings[methodName][k].apply(scope, arguments);\n\n      // Return res:\n      return res;\n    };\n\n    return result;\n  }\n\n  /**\n   * This custom tool function removes every pair key/value from an hash. The\n   * goal is to avoid creating a new object while some other references are\n   * still hanging in some scopes...\n   *\n   * @param  {object} obj The object to empty.\n   * @return {object}     The empty object.\n   */\n  function __emptyObject(obj) {\n    var k;\n\n    for (k in obj)\n      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))\n        delete obj[k];\n\n    return obj;\n  }\n\n\n\n\n  /**\n   * This global method adds a method that will be bound to the futurly created\n   * graph instances.\n   *\n   * Since these methods will be bound to their scope when the instances are\n   * created, it does not use the prototype. Because of that, methods have to\n   * be added before instances are created to make them available.\n   *\n   * Here is an example:\n   *\n   *  > graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesArray.length;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *\n   * @param  {string}   methodName The name of the method.\n   * @param  {function} fn         The method itself.\n   * @return {object}              The global graph constructor.\n   */\n  graph.addMethod = function(methodName, fn) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length !== 2\n    )\n      throw 'addMethod: Wrong arguments.';\n\n    if (_methods[methodName] || graph[methodName])\n      throw 'The method \"' + methodName + '\" already exists.';\n\n    _methods[methodName] = fn;\n    _methodBindings[methodName] = Object.create(null);\n    _methodBeforeBindings[methodName] = Object.create(null);\n\n    return this;\n  };\n\n  /**\n   * This global method returns true if the method has already been added, and\n   * false else.\n   *\n   * Here are some examples:\n   *\n   *  > graph.hasMethod('addNode'); // returns true\n   *  > graph.hasMethod('hasMethod'); // returns true\n   *  > graph.hasMethod('unexistingMethod'); // returns false\n   *\n   * @param  {string}  methodName The name of the method.\n   * @return {boolean}            The result.\n   */\n  graph.hasMethod = function(methodName) {\n    return !!(_methods[methodName] || graph[methodName]);\n  };\n\n  /**\n   * This global methods attaches a function to a method. Anytime the specified\n   * method is called, the attached function is called right after, with the\n   * same arguments and in the same scope. The attached function is called\n   * right before if the last argument is true, unless the method is the graph\n   * constructor.\n   *\n   * To attach a function to the graph constructor, use 'constructor' as the\n   * method name (first argument).\n   *\n   * The main idea is to have a clean way to keep custom indexes up to date,\n   * for instance:\n   *\n   *  > var timesAddNodeCalled = 0;\n   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {\n   *  >   timesAddNodeCalled++;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(timesAddNodeCalled); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(timesAddNodeCalled); // outputs 2\n   *\n   * The idea for calling a function before is to provide pre-processors, for\n   * instance:\n   *\n   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };\n   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {\n   *  >   n.color = colorPalette[n.category];\n   *  > }, true);\n   *  >\n   *  > var myGraph = new graph();\n   *  > myGraph.addNode({ id: 'n0', category: 'Person' });\n   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'\n   *\n   * @param  {string}   methodName The name of the related method or\n   *                               \"constructor\".\n   * @param  {string}   key        The key to identify the function to attach.\n   * @param  {function} fn         The function to bind.\n   * @param  {boolean}  before     If true the function is called right before.\n   * @return {object}              The global graph constructor.\n   */\n  graph.attach = function(methodName, key, fn, before) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof key !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length < 3 ||\n      arguments.length > 4\n    )\n      throw 'attach: Wrong arguments.';\n\n    var bindings;\n\n    if (methodName === 'constructor')\n      bindings = _initBindings;\n    else {\n      if (before) {\n        if (!_methodBeforeBindings[methodName])\n        throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBeforeBindings[methodName];\n      }\n      else {\n        if (!_methodBindings[methodName])\n          throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBindings[methodName];\n      }\n    }\n\n    if (bindings[key])\n      throw 'A function \"' + key + '\" is already attached ' +\n            'to the method \"' + methodName + '\".';\n\n    bindings[key] = fn;\n\n    return this;\n  };\n\n  /**\n   * Alias of attach(methodName, key, fn, true).\n   */\n  graph.attachBefore = function(methodName, key, fn) {\n    return this.attach(methodName, key, fn, true);\n  };\n\n  /**\n   * This methods is just an helper to deal with custom indexes. It takes as\n   * arguments the name of the index and an object containing all the different\n   * functions to bind to the methods.\n   *\n   * Here is a basic example, that creates an index to keep the number of nodes\n   * in the current graph. It also adds a method to provide a getter on that\n   * new index:\n   *\n   *  > sigma.classes.graph.addIndex('nodesCount', {\n   *  >   constructor: function() {\n   *  >     this.nodesCount = 0;\n   *  >   },\n   *  >   addNode: function() {\n   *  >     this.nodesCount++;\n   *  >   },\n   *  >   dropNode: function() {\n   *  >     this.nodesCount--;\n   *  >   }\n   *  > });\n   *  >\n   *  > sigma.classes.graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesCount;\n   *  > });\n   *  >\n   *  > var myGraph = new sigma.classes.graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(myGraph.getNodesCount()); // outputs 2\n   *\n   * @param  {string} name     The name of the index.\n   * @param  {object} bindings The object containing the functions to bind.\n   * @return {object}          The global graph constructor.\n   */\n  graph.addIndex = function(name, bindings) {\n    if (\n      typeof name !== 'string' ||\n      Object(bindings) !== bindings ||\n      arguments.length !== 2\n    )\n      throw 'addIndex: Wrong arguments.';\n\n    if (_indexes[name])\n      throw 'The index \"' + name + '\" already exists.';\n\n    var k;\n\n    // Store the bindings:\n    _indexes[name] = bindings;\n\n    // Attach the bindings:\n    for (k in bindings)\n      if (typeof bindings[k] !== 'function')\n        throw 'The bindings must be functions.';\n      else\n        graph.attach(k, name, bindings[k]);\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method adds a node to the graph. The node must be an object, with a\n   * string under the key \"id\". Except for this, it is possible to add any\n   * other attribute, that will be preserved all along the manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the node will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id will be defined as immutable.\n   *\n   * @param  {object} node The node to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addNode', function(node) {\n    // Check that the node is an object and has an id:\n    if (Object(node) !== node || arguments.length !== 1)\n      throw 'addNode: Wrong arguments.';\n\n    if (typeof node.id !== 'string' && typeof node.id !== 'number')\n      throw 'The node must have a string or number id.';\n\n    if (this.nodesIndex[node.id])\n      throw 'The node \"' + node.id + '\" already exists.';\n\n    var k,\n        id = node.id,\n        validNode = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in node)\n        if (k !== 'id')\n          validNode[k] = node[k];\n    } else\n      validNode = node;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable'))\n      Object.defineProperty(validNode, 'id', {\n        value: id,\n        enumerable: true\n      });\n    else\n      validNode.id = id;\n\n    // Add empty containers for edges indexes:\n    this.inNeighborsIndex[id] = Object.create(null);\n    this.outNeighborsIndex[id] = Object.create(null);\n    this.allNeighborsIndex[id] = Object.create(null);\n\n    this.inNeighborsCount[id] = 0;\n    this.outNeighborsCount[id] = 0;\n    this.allNeighborsCount[id] = 0;\n\n    // Add the node to indexes:\n    this.nodesArray.push(validNode);\n    this.nodesIndex[validNode.id] = validNode;\n\n    // Return the current instance:\n    return this;\n  });\n\n  /**\n   * This method adds an edge to the graph. The edge must be an object, with a\n   * string under the key \"id\", and strings under the keys \"source\" and\n   * \"target\" that design existing nodes. Except for this, it is possible to\n   * add any other attribute, that will be preserved all along the\n   * manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the edge will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id, source and target will be defined as immutable.\n   *\n   * @param  {object} edge The edge to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addEdge', function(edge) {\n    // Check that the edge is an object and has an id:\n    if (Object(edge) !== edge || arguments.length !== 1)\n      throw 'addEdge: Wrong arguments.';\n\n    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')\n      throw 'The edge must have a string or number id.';\n\n    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||\n        !this.nodesIndex[edge.source])\n      throw 'The edge source must have an existing node id.';\n\n    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||\n        !this.nodesIndex[edge.target])\n      throw 'The edge target must have an existing node id.';\n\n    if (this.edgesIndex[edge.id])\n      throw 'The edge \"' + edge.id + '\" already exists.';\n\n    var k,\n        validEdge = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in edge)\n        if (k !== 'id' && k !== 'source' && k !== 'target')\n          validEdge[k] = edge[k];\n    } else\n      validEdge = edge;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable')) {\n      Object.defineProperty(validEdge, 'id', {\n        value: edge.id,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'source', {\n        value: edge.source,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'target', {\n        value: edge.target,\n        enumerable: true\n      });\n    } else {\n      validEdge.id = edge.id;\n      validEdge.source = edge.source;\n      validEdge.target = edge.target;\n    }\n\n    // Add the edge to indexes:\n    this.edgesArray.push(validEdge);\n    this.edgesIndex[validEdge.id] = validEdge;\n\n    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])\n      this.inNeighborsIndex[validEdge.target][validEdge.source] =\n        Object.create(null);\n    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n      validEdge;\n\n    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])\n      this.outNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])\n      this.allNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (validEdge.target !== validEdge.source) {\n      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])\n        this.allNeighborsIndex[validEdge.target][validEdge.source] =\n          Object.create(null);\n      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n        validEdge;\n    }\n\n    // Keep counts up to date:\n    this.inNeighborsCount[validEdge.target]++;\n    this.outNeighborsCount[validEdge.source]++;\n    this.allNeighborsCount[validEdge.target]++;\n    this.allNeighborsCount[validEdge.source]++;\n\n    return this;\n  });\n\n  /**\n   * This method drops a node from the graph. It also removes each edge that is\n   * bound to it, through the dropEdge method. An error is thrown if the node\n   * does not exist.\n   *\n   * @param  {string} id The node id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropNode', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropNode: Wrong arguments.';\n\n    if (!this.nodesIndex[id])\n      throw 'The node \"' + id + '\" does not exist.';\n\n    var i, k, l;\n\n    // Remove the node from indexes:\n    delete this.nodesIndex[id];\n    for (i = 0, l = this.nodesArray.length; i < l; i++)\n      if (this.nodesArray[i].id === id) {\n        this.nodesArray.splice(i, 1);\n        break;\n      }\n\n    // Remove related edges:\n    for (i = this.edgesArray.length - 1; i >= 0; i--)\n      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)\n        this.dropEdge(this.edgesArray[i].id);\n\n    // Remove related edge indexes:\n    delete this.inNeighborsIndex[id];\n    delete this.outNeighborsIndex[id];\n    delete this.allNeighborsIndex[id];\n\n    delete this.inNeighborsCount[id];\n    delete this.outNeighborsCount[id];\n    delete this.allNeighborsCount[id];\n\n    for (k in this.nodesIndex) {\n      delete this.inNeighborsIndex[k][id];\n      delete this.outNeighborsIndex[k][id];\n      delete this.allNeighborsIndex[k][id];\n    }\n\n    return this;\n  });\n\n  /**\n   * This method drops an edge from the graph. An error is thrown if the edge\n   * does not exist.\n   *\n   * @param  {string} id The edge id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropEdge', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropEdge: Wrong arguments.';\n\n    if (!this.edgesIndex[id])\n      throw 'The edge \"' + id + '\" does not exist.';\n\n    var i, l, edge;\n\n    // Remove the edge from indexes:\n    edge = this.edgesIndex[id];\n    delete this.edgesIndex[id];\n    for (i = 0, l = this.edgesArray.length; i < l; i++)\n      if (this.edgesArray[i].id === id) {\n        this.edgesArray.splice(i, 1);\n        break;\n      }\n\n    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];\n    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)\n      delete this.inNeighborsIndex[edge.target][edge.source];\n\n    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)\n      delete this.outNeighborsIndex[edge.source][edge.target];\n\n    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)\n      delete this.allNeighborsIndex[edge.source][edge.target];\n\n    if (edge.target !== edge.source) {\n      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];\n      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)\n        delete this.allNeighborsIndex[edge.target][edge.source];\n    }\n\n    this.inNeighborsCount[edge.target]--;\n    this.outNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.target]--;\n\n    return this;\n  });\n\n  /**\n   * This method destroys the current instance. It basically empties each index\n   * and methods attached to the graph.\n   */\n  graph.addMethod('kill', function() {\n    // Delete arrays:\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n    delete this.nodesArray;\n    delete this.edgesArray;\n\n    // Delete indexes:\n    delete this.nodesIndex;\n    delete this.edgesIndex;\n    delete this.inNeighborsIndex;\n    delete this.outNeighborsIndex;\n    delete this.allNeighborsIndex;\n    delete this.inNeighborsCount;\n    delete this.outNeighborsCount;\n    delete this.allNeighborsCount;\n  });\n\n  /**\n   * This method empties the nodes and edges arrays, as well as the different\n   * indexes.\n   *\n   * @return {object} The graph instance.\n   */\n  graph.addMethod('clear', function() {\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n\n    // Due to GC issues, I prefer not to create new object. These objects are\n    // only available from the methods and attached functions, but still, it is\n    // better to prevent ghost references to unrelevant data...\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.edgesIndex);\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.inNeighborsIndex);\n    __emptyObject(this.outNeighborsIndex);\n    __emptyObject(this.allNeighborsIndex);\n    __emptyObject(this.inNeighborsCount);\n    __emptyObject(this.outNeighborsCount);\n    __emptyObject(this.allNeighborsCount);\n\n    return this;\n  });\n\n  /**\n   * This method reads an object and adds the nodes and edges, through the\n   * proper methods \"addNode\" and \"addEdge\".\n   *\n   * Here is an example:\n   *\n   *  > var myGraph = new graph();\n   *  > myGraph.read({\n   *  >   nodes: [\n   *  >     { id: 'n0' },\n   *  >     { id: 'n1' }\n   *  >   ],\n   *  >   edges: [\n   *  >     {\n   *  >       id: 'e0',\n   *  >       source: 'n0',\n   *  >       target: 'n1'\n   *  >     }\n   *  >   ]\n   *  > });\n   *  >\n   *  > console.log(\n   *  >   myGraph.nodes().length,\n   *  >   myGraph.edges().length\n   *  > ); // outputs 2 1\n   *\n   * @param  {object} g The graph object.\n   * @return {object}   The graph instance.\n   */\n  graph.addMethod('read', function(g) {\n    var i,\n        a,\n        l;\n\n    a = g.nodes || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addNode(a[i]);\n\n    a = g.edges || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addEdge(a[i]);\n\n    return this;\n  });\n\n  /**\n   * This methods returns one or several nodes, depending on how it is called.\n   *\n   * To get the array of nodes, call \"nodes\" without argument. To get a\n   * specific node, call it with the id of the node. The get multiple node,\n   * call it with an array of ids, and it will return the array of nodes, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related node or array of nodes.\n   */\n  graph.addMethod('nodes', function(v) {\n    // Clone the array of nodes and return it:\n    if (!arguments.length)\n      return this.nodesArray.slice(0);\n\n    // Return the related node:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.nodesIndex[v];\n\n    // Return an array of the related node:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.nodesIndex[v[i]]);\n        else\n          throw 'nodes: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'nodes: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns the degree of one or several nodes, depending on how\n   * it is called. It is also possible to get incoming or outcoming degrees\n   * instead by specifying 'in' or 'out' as a second argument.\n   *\n   * @param  {string|array} v     One id, an array of ids.\n   * @param  {?string}      which Which degree is required. Values are 'in',\n   *                              'out', and by default the normal degree.\n   * @return {number|array}       The related degree or array of degrees.\n   */\n  graph.addMethod('degree', function(v, which) {\n    // Check which degree is required:\n    which = {\n      'in': this.inNeighborsCount,\n      'out': this.outNeighborsCount\n    }[which || ''] || this.allNeighborsCount;\n\n    // Return the related node:\n    if (typeof v === 'string' || typeof v === 'number')\n      return which[v];\n\n    // Return an array of the related node:\n    if (Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(which[v[i]]);\n        else\n          throw 'degree: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'degree: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns one or several edges, depending on how it is called.\n   *\n   * To get the array of edges, call \"edges\" without argument. To get a\n   * specific edge, call it with the id of the edge. The get multiple edge,\n   * call it with an array of ids, and it will return the array of edges, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related edge or array of edges.\n   */\n  graph.addMethod('edges', function(v) {\n    // Clone the array of edges and return it:\n    if (!arguments.length)\n      return this.edgesArray.slice(0);\n\n    // Return the related edge:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.edgesIndex[v];\n\n    // Return an array of the related edge:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.edgesIndex[v[i]]);\n        else\n          throw 'edges: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'edges: Wrong arguments.';\n  });\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof sigma !== 'undefined') {\n    sigma.classes = sigma.classes || Object.create(null);\n    sigma.classes.graph = graph;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = graph;\n    exports.graph = graph;\n  } else\n    this.graph = graph;\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module\n   * =====================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 20,\n      maxLevel: maxLevel || 4,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The quad API as exposed to sigma.\n   */\n\n  /**\n   * The quad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree  Property holding the quadtree object.\n   * property {object} _geom  Exposition of the _geom namespace for testing.\n   * property {object} _cache Cache for the area method.\n   */\n  var quad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n  };\n\n  /**\n   * Index a graph by inserting its nodes into the quadtree.\n   *\n   * @param  {array}  nodes   An array of nodes to index.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for node geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  quad.prototype.index = function(nodes, params) {\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.quad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '';\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    // Inserting graph nodes into the tree\n    for (var i = 0, l = nodes.length; i < l; i++) {\n\n      // Inserting node\n      _quadInsert(\n        nodes[i],\n        _geom.pointToSquare({\n          x: nodes[i][prefix + 'x'],\n          y: nodes[i][prefix + 'y'],\n          size: nodes[i][prefix + 'size']\n        }),\n        this._tree\n      );\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph nodes held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.point = function(x, y) {\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph nodes within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.area = function(rect) {\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving nodes\n    var nodes = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var nodesArray = [];\n    for (var i in nodes)\n      nodesArray.push(nodes[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = nodesArray;\n\n    return nodesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.quad = quad;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = quad;\n    exports.quad = quad;\n  } else\n    this.quad = quad;\n}).call(this);\n"},function(e,n){e.exports="/**\n * conrad.js is a tiny JavaScript jobs scheduler,\n *\n * Version: 0.1.0\n * Sources: http://github.com/jacomyal/conrad.js\n * Doc:     http://github.com/jacomyal/conrad.js#readme\n *\n * License:\n * --------\n * Copyright Â© 2013 Alexis Jacomy, Sciences-Po mÃ©dialab\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n(function(global) {\n  'use strict';\n\n  // Check that conrad.js has not been loaded yet:\n  if (global.conrad)\n    throw new Error('conrad already exists');\n\n\n  /**\n   * PRIVATE VARIABLES:\n   * ******************\n   */\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Number}\n   */\n  var _lastFrameTime;\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Boolean}\n   */\n  var _isRunning = false;\n\n  /**\n   * The hash of registered jobs. Each job must at least have a unique ID\n   * under the key \"id\" and a function under the key \"job\". This hash\n   * contains each running job and each waiting job.\n   *\n   * @type {Object}\n   */\n  var _jobs = {};\n\n  /**\n   * The hash of currently running jobs.\n   *\n   * @type {Object}\n   */\n  var _runningJobs = {};\n\n  /**\n   * The array of currently running jobs, sorted by priority.\n   *\n   * @type {Array}\n   */\n  var _sortedByPriorityJobs = [];\n\n  /**\n   * The array of currently waiting jobs.\n   *\n   * @type {Object}\n   */\n  var _waitingJobs = {};\n\n  /**\n   * The array of finished jobs. They are stored in an array, since two jobs\n   * with the same \"id\" can happen at two different times.\n   *\n   * @type {Array}\n   */\n  var _doneJobs = [];\n\n  /**\n   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called\n   * with several jobs, conrad must be started only at the end. This flag keeps\n   * me from duplicating the code that effectively adds a job.\n   *\n   * @type {Boolean}\n   */\n  var _noStart = false;\n\n  /**\n   * An hash containing some global settings about how conrad.js should\n   * behave.\n   *\n   * @type {Object}\n   */\n  var _parameters = {\n    frameDuration: 20,\n    history: true\n  };\n\n  /**\n   * This object contains every handlers bound to conrad events. It does not\n   * requirea any DOM implementation, since the events are all JavaScript.\n   *\n   * @type {Object}\n   */\n  var _handlers = Object.create(null);\n\n\n  /**\n   * PRIVATE FUNCTIONS:\n   * ******************\n   */\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string|array|object} events  The name of the event (or the events\n   *                                       separated by spaces).\n   * @param  {function(Object)}    handler The handler to bind.\n   * @return {Object}                      Returns conrad.\n   */\n  function _bind(events, handler) {\n    var i,\n        i_end,\n        event,\n        eArray;\n\n    if (!arguments.length)\n      return;\n    else if (\n      arguments.length === 1 &&\n      Object(arguments[0]) === arguments[0]\n    )\n      for (events in arguments[0])\n        _bind(events, arguments[0][events]);\n    else if (arguments.length > 1) {\n      eArray =\n        Array.isArray(events) ?\n          events :\n          events.split(/ /);\n\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n\n        if (!_handlers[event])\n          _handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        _handlers[event].push({\n          handler: handler\n        });\n      }\n    }\n  }\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(Object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {Object}            Returns conrad.\n   */\n  function _unbind(events, handler) {\n    var i,\n        i_end,\n        j,\n        j_end,\n        a,\n        event,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    if (!arguments.length)\n      _handlers = Object.create(null);\n    else if (handler) {\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n        if (_handlers[event]) {\n          a = [];\n          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)\n            if (_handlers[event][j].handler !== handler)\n              a.push(_handlers[event][j]);\n\n          _handlers[event] = a;\n        }\n\n        if (_handlers[event] && _handlers[event].length === 0)\n          delete _handlers[event];\n      }\n    } else\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)\n        delete _handlers[eArray[i]];\n  }\n\n  /**\n   * Executes each handler bound to the event.\n   *\n   * @param  {string}  events The name of the event (or the events separated\n   *                          by spaces).\n   * @param  {?Object} data   The content of the event (optional).\n   * @return {Object}         Returns conrad.\n   */\n  function _dispatch(events, data) {\n    var i,\n        j,\n        i_end,\n        j_end,\n        event,\n        eventName,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      eventName = eArray[i];\n\n      if (_handlers[eventName]) {\n        event = {\n          type: eventName,\n          data: data || {}\n        };\n\n        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)\n          try {\n            _handlers[eventName][j].handler(event);\n          } catch (e) {}\n      }\n    }\n  }\n\n  /**\n   * Executes the most prioritary job once, and deals with filling the stats\n   * (done, time, averageTime, currentTime, etc...).\n   *\n   * @return {?Object} Returns the job object if it has to be killed, null else.\n   */\n  function _executeFirstJob() {\n    var i,\n        l,\n        test,\n        kill,\n        pushed = false,\n        time = __dateNow(),\n        job = _sortedByPriorityJobs.shift();\n\n    // Execute the job and look at the result:\n    test = job.job();\n\n    // Deal with stats:\n    time = __dateNow() - time;\n    job.done++;\n    job.time += time;\n    job.currentTime += time;\n    job.weightTime = job.currentTime / (job.weight || 1);\n    job.averageTime = job.time / job.done;\n\n    // Check if the job has to be killed:\n    kill = job.count ? (job.count <= job.done) : !test;\n\n    // Reset priorities:\n    if (!kill) {\n      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)\n        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {\n          _sortedByPriorityJobs.splice(i, 0, job);\n          pushed = true;\n          break;\n        }\n\n      if (!pushed)\n        _sortedByPriorityJobs.push(job);\n    }\n\n    return kill ? job : null;\n  }\n\n  /**\n   * Activates a job, by adding it to the _runningJobs object and the\n   * _sortedByPriorityJobs array. It also initializes its currentTime value.\n   *\n   * @param  {Object} job The job to activate.\n   */\n  function _activateJob(job) {\n    var l = _sortedByPriorityJobs.length;\n\n    // Add the job to the running jobs:\n    _runningJobs[job.id] = job;\n    job.status = 'running';\n\n    // Add the job to the priorities:\n    if (l) {\n      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;\n      job.currentTime = job.weightTime * (job.weight || 1);\n    }\n\n    // Initialize the job and dispatch:\n    job.startTime = __dateNow();\n    _dispatch('jobStarted', __clone(job));\n\n    _sortedByPriorityJobs.push(job);\n  }\n\n  /**\n   * The main loop of conrad.js:\n   *  . It executes job such that they all occupate the same processing time.\n   *  . It stops jobs that do not need to be executed anymore.\n   *  . It triggers callbacks when it is relevant.\n   *  . It starts waiting jobs when they need to be started.\n   *  . It injects frames to keep a constant frapes per second ratio.\n   *  . It stops itself when there are no more jobs to execute.\n   */\n  function _loop() {\n    var k,\n        o,\n        l,\n        job,\n        time,\n        deadJob;\n\n    // Deal with the newly added jobs (the _jobs object):\n    for (k in _jobs) {\n      job = _jobs[k];\n\n      if (job.after)\n        _waitingJobs[k] = job;\n      else\n        _activateJob(job);\n\n      delete _jobs[k];\n    }\n\n    // Set the _isRunning flag to false if there are no running job:\n    _isRunning = !!_sortedByPriorityJobs.length;\n\n    // Deal with the running jobs (the _runningJobs object):\n    while (\n      _sortedByPriorityJobs.length &&\n      __dateNow() - _lastFrameTime < _parameters.frameDuration\n    ) {\n      deadJob = _executeFirstJob();\n\n      // Deal with the case where the job has ended:\n      if (deadJob) {\n        _killJob(deadJob.id);\n\n        // Check for waiting jobs:\n        for (k in _waitingJobs)\n          if (_waitingJobs[k].after === deadJob.id) {\n            _activateJob(_waitingJobs[k]);\n            delete _waitingJobs[k];\n          }\n      }\n    }\n\n    // Check if conrad still has jobs to deal with, and kill it if not:\n    if (_isRunning) {\n      // Update the _lastFrameTime:\n      _lastFrameTime = __dateNow();\n\n      _dispatch('enterFrame');\n      setTimeout(_loop, 0);\n    } else\n      _dispatch('stop');\n  }\n\n  /**\n   * Adds one or more jobs, and starts the loop if no job was running before. A\n   * job is at least a unique string \"id\" and a function, and there are some\n   * parameters that you can specify for each job to modify the way conrad will\n   * execute it. If a job is added with the \"id\" of another job that is waiting\n   * or still running, an error will be thrown.\n   *\n   * When a job is added, it is referenced in the _jobs object, by its id.\n   * Then, if it has to be executed right now, it will be also referenced in\n   * the _runningJobs object. If it has to wait, then it will be added into the\n   * _waitingJobs object, until it can start.\n   *\n   * Keep reading this documentation to see how to call this method.\n   *\n   * @return {Object} Returns conrad.\n   *\n   * Adding one job:\n   * ***************\n   * Basically, a job is defined by its string id and a function (the job). It\n   * is also possible to add some parameters:\n   *\n   *  > conrad.addJob('myJobId', myJobFunction);\n   *  > conrad.addJob('myJobId', {\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   id: 'myJobId',\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *\n   * Adding several jobs:\n   * ********************\n   * When adding several jobs at the same time, it is possible to specify\n   * parameters for each one individually or for all:\n   *\n   *  > conrad.addJob([\n   *  >   {\n   *  >     id: 'myJobId1',\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   {\n   *  >     id: 'myJobId2',\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > ], {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: {,\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   myJobId2: {,\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: myJobFunction1,\n   *  >   myJobId2: myJobFunction2\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *\n   *  Recognized parameters:\n   *  **********************\n   *  Here is the exhaustive list of every accepted parameters:\n   *\n   *    {?Function} end      A callback to execute when the job is ended. It is\n   *                         not executed if the job is killed instead of ended\n   *                         \"naturally\".\n   *    {?Integer}  count    The number of time the job has to be executed.\n   *    {?Number}   weight   If specified, the job will be executed as it was\n   *                         added \"weight\" times.\n   *    {?String}   after    The id of another job (eventually not added yet).\n   *                         If specified, this job will start only when the\n   *                         specified \"after\" job is ended.\n   */\n  function _addJob(v1, v2) {\n    var i,\n        l,\n        o;\n\n    // Array of jobs:\n    if (Array.isArray(v1)) {\n      // Keep conrad to start until the last job is added:\n      _noStart = true;\n\n      for (i = 0, l = v1.length; i < l; i++)\n        _addJob(v1[i].id, __extend(v1[i], v2));\n\n      _noStart = false;\n      if (!_isRunning) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n    } else if (typeof v1 === 'object') {\n      // One job (object):\n      if (typeof v1.id === 'string')\n        _addJob(v1.id, v1);\n\n      // Hash of jobs:\n      else {\n        // Keep conrad to start until the last job is added:\n        _noStart = true;\n\n        for (i in v1)\n          if (typeof v1[i] === 'function')\n            _addJob(i, __extend({\n              job: v1[i]\n            }, v2));\n          else\n            _addJob(i, __extend(v1[i], v2));\n\n        _noStart = false;\n        if (!_isRunning) {\n          // Update the _lastFrameTime:\n          _lastFrameTime = __dateNow();\n\n          _dispatch('start');\n          _loop();\n        }\n      }\n\n    // One job (string, *):\n    } else if (typeof v1 === 'string') {\n      if (_hasJob(v1))\n        throw new Error(\n          '[conrad.addJob] Job with id \"' + v1 + '\" already exists.'\n        );\n\n      // One job (string, function):\n      if (typeof v2 === 'function') {\n        o = {\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0,\n          job: v2\n        };\n\n      // One job (string, object):\n      } else if (typeof v2 === 'object') {\n        o = __extend(\n          {\n            id: v1,\n            done: 0,\n            time: 0,\n            status: 'waiting',\n            currentTime: 0,\n            averageTime: 0,\n            weightTime: 0\n          },\n          v2\n        );\n\n      // If none of those cases, throw an error:\n      } else\n        throw new Error('[conrad.addJob] Wrong arguments.');\n\n      // Effectively add the job:\n      _jobs[v1] = o;\n      _dispatch('jobAdded', __clone(o));\n\n      // Check if the loop has to be started:\n      if (!_isRunning && !_noStart) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.addJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills one or more jobs, indicated by their ids. It is only possible to\n   * kill running jobs or waiting jobs. If you try to kill a job that does not\n   * exist or that is already killed, a warning will be thrown.\n   *\n   * @param  {Array|String} v1 A string job id or an array of job ids.\n   * @return {Object}       Returns conrad.\n   */\n  function _killJob(v1) {\n    var i,\n        l,\n        k,\n        a,\n        job,\n        found = false;\n\n    // Array of job ids:\n    if (Array.isArray(v1))\n      for (i = 0, l = v1.length; i < l; i++)\n        _killJob(v1[i]);\n\n    // One job's id:\n    else if (typeof v1 === 'string') {\n      a = [_runningJobs, _waitingJobs, _jobs];\n\n      // Remove the job from the hashes:\n      for (i = 0, l = a.length; i < l; i++)\n        if (v1 in a[i]) {\n          job = a[i][v1];\n\n          if (_parameters.history) {\n            job.status = 'done';\n            _doneJobs.push(job);\n          }\n\n          _dispatch('jobEnded', __clone(job));\n          delete a[i][v1];\n\n          if (typeof job.end === 'function')\n            job.end();\n\n          found = true;\n        }\n\n      // Remove the priorities array:\n      a = _sortedByPriorityJobs;\n      for (i = 0, l = a.length; i < l; i++)\n        if (a[i].id === v1) {\n          a.splice(i, 1);\n          break;\n        }\n\n      if (!found)\n        throw new Error('[conrad.killJob] Job \"' + v1 + '\" not found.');\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.killJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills every running, waiting, and just added jobs.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _killAll() {\n    var k,\n        jobs = __extend(_jobs, _runningJobs, _waitingJobs);\n\n    // Take every jobs and push them into the _doneJobs object:\n    if (_parameters.history)\n      for (k in jobs) {\n        jobs[k].status = 'done';\n        _doneJobs.push(jobs[k]);\n\n        if (typeof jobs[k].end === 'function')\n          jobs[k].end();\n      }\n\n    // Reinitialize the different jobs lists:\n    _jobs = {};\n    _waitingJobs = {};\n    _runningJobs = {};\n    _sortedByPriorityJobs = [];\n\n    // In case some jobs are added right after the kill:\n    _isRunning = false;\n\n    return this;\n  }\n\n  /**\n   * Returns true if a job with the specified id is currently running or\n   * waiting, and false else.\n   *\n   * @param  {String}  id The id of the job.\n   * @return {?Object} Returns the job object if it exists.\n   */\n  function _hasJob(id) {\n    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];\n    return job ? __extend(job) : null;\n  }\n\n  /**\n   * This method will set the setting specified by \"v1\" to the value specified\n   * by \"v2\" if both are given, and else return the current value of the\n   * settings \"v1\".\n   *\n   * @param  {String}   v1 The name of the property.\n   * @param  {?*}       v2 Eventually, a value to set to the specified\n   *                       property.\n   * @return {Object|*} Returns the specified settings value if \"v2\" is not\n   *                    given, and conrad else.\n   */\n  function _settings(v1, v2) {\n    var o;\n\n    if (typeof a1 === 'string' && arguments.length === 1)\n      return _parameters[a1];\n    else {\n      o = (typeof a1 === 'object' && arguments.length === 1) ?\n        a1 || {} :\n        {};\n      if (typeof a1 === 'string')\n        o[a1] = a2;\n\n      for (var k in o)\n        if (o[k] !== undefined)\n          _parameters[k] = o[k];\n        else\n          delete _parameters[k];\n\n      return this;\n    }\n  }\n\n  /**\n   * Returns true if conrad is currently running, and false else.\n   *\n   * @return {Boolean} Returns _isRunning.\n   */\n  function _getIsRunning() {\n    return _isRunning;\n  }\n\n  /**\n   * Unreference every job that is stored in the _doneJobs object. It will\n   * not be possible anymore to get stats about these jobs, but it will release\n   * the memory.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _clearHistory() {\n    _doneJobs = [];\n    return this;\n  }\n\n  /**\n   * Returns a snapshot of every data about jobs that wait to be started, are\n   * currently running or are done.\n   *\n   * It is possible to get only running, waiting or done jobs by giving\n   * \"running\", \"waiting\" or \"done\" as fist argument.\n   *\n   * It is also possible to get every job with a specified id by giving it as\n   * first argument. Also, using a RegExp instead of an id will return every\n   * jobs whose ids match the RegExp. And these two last use cases work as well\n   * by giving before \"running\", \"waiting\" or \"done\".\n   *\n   * @return {Array} The array of the matching jobs.\n   *\n   * Some call examples:\n   * *******************\n   *  > conrad.getStats('running')\n   *  > conrad.getStats('waiting')\n   *  > conrad.getStats('done')\n   *  > conrad.getStats('myJob')\n   *  > conrad.getStats(/test/)\n   *  > conrad.getStats('running', 'myRunningJob')\n   *  > conrad.getStats('running', /test/)\n   */\n  function _getStats(v1, v2) {\n    var a,\n        k,\n        i,\n        l,\n        stats,\n        pattern,\n        isPatternString;\n\n    if (!arguments.length) {\n      stats = [];\n\n      for (k in _jobs)\n        stats.push(_jobs[k]);\n\n      for (k in _waitingJobs)\n        stats.push(_waitingJobs[k]);\n\n      for (k in _runningJobs)\n        stats.push(_runningJobs[k]);\n\n      stats = stats.concat(_doneJobs);\n    }\n\n    if (typeof v1 === 'string')\n      switch (v1) {\n        case 'waiting':\n          stats = __objectValues(_waitingJobs);\n          break;\n        case 'running':\n          stats = __objectValues(_runningJobs);\n          break;\n        case 'done':\n          stats = _doneJobs;\n          break;\n        default:\n          pattern = v1;\n      }\n\n    if (v1 instanceof RegExp)\n      pattern = v1;\n\n    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))\n      pattern = v2;\n\n    // Filter jobs if a pattern is given:\n    if (pattern) {\n      isPatternString = typeof pattern === 'string';\n\n      if (stats instanceof Array) {\n        a = stats;\n      } else if (typeof stats === 'object') {\n        a = [];\n\n        for (k in stats)\n          a = a.concat(stats[k]);\n      } else {\n        a = [];\n\n        for (k in _jobs)\n          a.push(_jobs[k]);\n\n        for (k in _waitingJobs)\n          a.push(_waitingJobs[k]);\n\n        for (k in _runningJobs)\n          a.push(_runningJobs[k]);\n\n        a = a.concat(_doneJobs);\n      }\n\n      stats = [];\n      for (i = 0, l = a.length; i < l; i++)\n        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))\n          stats.push(a[i]);\n    }\n\n    return __clone(stats);\n  }\n\n\n  /**\n   * TOOLS FUNCTIONS:\n   * ****************\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when two objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > __extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {Object+} Any number of objects.\n   * @return {Object}  The merged object.\n   */\n  function __extend() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  }\n\n  /**\n   * This function simply clones an object. This object must contain only\n   * objects, arrays and immutable values. Since it is not public, it does not\n   * deal with cyclic references, DOM elements and instantiated objects - so\n   * use it carefully.\n   *\n   * @param  {Object} The object to clone.\n   * @return {Object} The clone.\n   */\n  function __clone(item) {\n    var result, i, k, l;\n\n    if (!item)\n      return item;\n\n    if (Array.isArray(item)) {\n      result = [];\n      for (i = 0, l = item.length; i < l; i++)\n        result.push(__clone(item[i]));\n    } else if (typeof item === 'object') {\n      result = {};\n      for (i in item)\n        result[i] = __clone(item[i]);\n    } else\n      result = item;\n\n    return result;\n  }\n\n  /**\n   * Returns an array containing the values of an object.\n   *\n   * @param  {Object} The object.\n   * @return {Array}  The array of values.\n   */\n  function __objectValues(o) {\n    var k,\n        a = [];\n\n    for (k in o)\n      a.push(o[k]);\n\n    return a;\n  }\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  function __dateNow() {\n    return Date.now ? Date.now() : new Date().getTime();\n  }\n\n  /**\n   * Polyfill for the Array.isArray function:\n   */\n  if (!Array.isArray)\n    Array.isArray = function(v) {\n      return Object.prototype.toString.call(v) === '[object Array]';\n    };\n\n\n  /**\n   * EXPORT PUBLIC API:\n   * ******************\n   */\n  var conrad = {\n    hasJob: _hasJob,\n    addJob: _addJob,\n    killJob: _killJob,\n    killAll: _killAll,\n    settings: _settings,\n    getStats: _getStats,\n    isRunning: _getIsRunning,\n    clearHistory: _clearHistory,\n\n    // Events management:\n    bind: _bind,\n    unbind: _unbind,\n\n    // Version:\n    version: '0.1.0'\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = conrad;\n    exports.conrad = conrad;\n  }\n  global.conrad = conrad;\n})(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n\n  /**\n   * This middleware will just copy the graphic properties.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   */\n  sigma.middlewares.copy = function(readPrefix, writePrefix) {\n    var i,\n        l,\n        a;\n\n    if (writePrefix + '' === readPrefix + '')\n      return;\n\n    a = this.graph.nodes();\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];\n      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n\n    a = this.graph.edges();\n    for (i = 0, l = a.length; i < l; i++)\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n  sigma.utils.pkg('sigma.utils');\n\n  /**\n   * This middleware will rescale the graph such that it takes an optimal space\n   * on the renderer.\n   *\n   * As each middleware, this function is executed in the scope of the sigma\n   * instance.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   * @param {object}  options     The parameters.\n   */\n  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {\n    var i,\n        l,\n        a,\n        b,\n        c,\n        d,\n        scale,\n        margin,\n        n = this.graph.nodes(),\n        e = this.graph.edges(),\n        settings = this.settings.embedObjects(options || {}),\n        bounds = settings('bounds') || sigma.utils.getBoundaries(\n          this.graph,\n          readPrefix,\n          true\n        ),\n        minX = bounds.minX,\n        minY = bounds.minY,\n        maxX = bounds.maxX,\n        maxY = bounds.maxY,\n        sizeMax = bounds.sizeMax,\n        weightMax = bounds.weightMax,\n        w = settings('width') || 1,\n        h = settings('height') || 1,\n        rescaleSettings = settings('autoRescale'),\n        validSettings = {\n          nodePosition: 1,\n          nodeSize: 1,\n          edgeSize: 1\n        };\n\n    /**\n     * What elements should we rescale?\n     */\n    if (!(rescaleSettings instanceof Array))\n      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];\n\n    for (i = 0, l = rescaleSettings.length; i < l; i++)\n      if (!validSettings[rescaleSettings[i]])\n        throw new Error(\n          'The rescale setting \"' + rescaleSettings[i] + '\" is not recognized.'\n        );\n\n    var np = ~rescaleSettings.indexOf('nodePosition'),\n        ns = ~rescaleSettings.indexOf('nodeSize'),\n        es = ~rescaleSettings.indexOf('edgeSize');\n\n    /**\n     * First, we compute the scaling ratio, without considering the sizes\n     * of the nodes : Each node will have its center in the canvas, but might\n     * be partially out of it.\n     */\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    /**\n     * Then, we correct that scaling ratio considering a margin, which is\n     * basically the size of the biggest node.\n     * This has to be done as a correction since to compare the size of the\n     * biggest node to the X and Y values, we have to first get an\n     * approximation of the scaling ratio.\n     **/\n    margin =\n      (\n        settings('rescaleIgnoreSize') ?\n          0 :\n          (settings('maxNodeSize') || sizeMax) / scale\n      ) +\n      (settings('sideMargin') || 0);\n    maxX += margin;\n    minX -= margin;\n    maxY += margin;\n    minY -= margin;\n\n    // Fix the scaling with the new extrema:\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    // Size homothetic parameters:\n    if (!settings('maxNodeSize') && !settings('minNodeSize')) {\n      a = 1;\n      b = 0;\n    } else if (settings('maxNodeSize') === settings('minNodeSize')) {\n      a = 0;\n      b = +settings('maxNodeSize');\n    } else {\n      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;\n      b = +settings('minNodeSize');\n    }\n\n    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {\n      c = 1;\n      d = 0;\n    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {\n      c = 0;\n      d = +settings('minEdgeSize');\n    } else {\n      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;\n      d = +settings('minEdgeSize');\n    }\n\n    // Rescale the nodes and edges:\n    for (i = 0, l = e.length; i < l; i++)\n      e[i][writePrefix + 'size'] =\n        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      n[i][writePrefix + 'size'] =\n        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);\n      n[i][writePrefix + 'x'] =\n        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);\n      n[i][writePrefix + 'y'] =\n        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);\n    }\n  };\n\n  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {\n    var i,\n        l,\n        e = graph.edges(),\n        n = graph.nodes(),\n        weightMax = -Infinity,\n        sizeMax = -Infinity,\n        minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    if (doEdges)\n      for (i = 0, l = e.length; i < l; i++)\n        weightMax = Math.max(e[i][prefix + 'size'], weightMax);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);\n      maxX = Math.max(n[i][prefix + 'x'], maxX);\n      minX = Math.min(n[i][prefix + 'x'], minX);\n      maxY = Math.max(n[i][prefix + 'y'], maxY);\n      minY = Math.min(n[i][prefix + 'y'], minY);\n    }\n\n    weightMax = weightMax || 1;\n    sizeMax = sizeMax || 1;\n\n    return {\n      weightMax: weightMax,\n      sizeMax: sizeMax,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc.animation.running');\n\n  /**\n   * Generates a unique ID for the animation.\n   *\n   * @return {string} Returns the new ID.\n   */\n  var _getID = (function() {\n    var id = 0;\n    return function() {\n      return '' + (++id);\n    };\n  })();\n\n  /**\n   * This function animates a camera. It has to be called with the camera to\n   * animate, the values of the coordinates to reach and eventually some\n   * options. It returns a number id, that you can use to kill the animation,\n   * with the method sigma.misc.animation.kill(id).\n   *\n   * The available options are:\n   *\n   *   {?number}            duration   The duration of the animation.\n   *   {?function}          onNewFrame A callback to execute when the animation\n   *                                   enter a new frame.\n   *   {?function}          onComplete A callback to execute when the animation\n   *                                   is completed or killed.\n   *   {?(string|function)} easing     The name of a function from the package\n   *                                   sigma.utils.easings, or a custom easing\n   *                                   function.\n   *\n   * @param  {camera}  camera  The camera to animate.\n   * @param  {object}  target  The coordinates to reach.\n   * @param  {?object} options Eventually an object to specify some options to\n   *                           the function. The available options are\n   *                           presented in the description of the function.\n   * @return {number}          The animation id, to make it easy to kill\n   *                           through the method \"sigma.misc.animation.kill\".\n   */\n  sigma.misc.animation.camera = function(camera, val, options) {\n    if (\n      !(camera instanceof sigma.classes.camera) ||\n      typeof val !== 'object' ||\n      !val\n    )\n      throw 'animation.camera: Wrong arguments.';\n\n    if (\n      typeof val.x !== 'number' &&\n      typeof val.y !== 'number' &&\n      typeof val.ratio !== 'number' &&\n      typeof val.angle !== 'number'\n    )\n      throw 'There must be at least one valid coordinate in the given val.';\n\n    var fn,\n        id,\n        anim,\n        easing,\n        duration,\n        initialVal,\n        o = options || {},\n        start = sigma.utils.dateNow();\n\n    // Store initial values:\n    initialVal = {\n      x: camera.x,\n      y: camera.y,\n      ratio: camera.ratio,\n      angle: camera.angle\n    };\n\n    duration = o.duration;\n    easing = typeof o.easing !== 'function' ?\n      sigma.utils.easings[o.easing || 'quadraticInOut'] :\n      o.easing;\n\n    fn = function() {\n      var coef,\n          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;\n\n      // If the animation is over:\n      if (t >= 1) {\n        camera.isAnimated = false;\n        camera.goTo({\n          x: val.x !== undefined ? val.x : initialVal.x,\n          y: val.y !== undefined ? val.y : initialVal.y,\n          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,\n          angle: val.angle !== undefined ? val.angle : initialVal.angle\n        });\n\n        cancelAnimationFrame(id);\n        delete sigma.misc.animation.running[id];\n\n        // Check callbacks:\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n\n      // Else, let's keep going:\n      } else {\n        coef = easing(t);\n        camera.isAnimated = true;\n        camera.goTo({\n          x: val.x !== undefined ?\n            initialVal.x + (val.x - initialVal.x) * coef :\n            initialVal.x,\n          y: val.y !== undefined ?\n            initialVal.y + (val.y - initialVal.y) * coef :\n            initialVal.y,\n          ratio: val.ratio !== undefined ?\n            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :\n            initialVal.ratio,\n          angle: val.angle !== undefined ?\n            initialVal.angle + (val.angle - initialVal.angle) * coef :\n            initialVal.angle\n        });\n\n        // Check callbacks:\n        if (typeof o.onNewFrame === 'function')\n          o.onNewFrame();\n\n        anim.frameId = requestAnimationFrame(fn);\n      }\n    };\n\n    id = _getID();\n    anim = {\n      frameId: requestAnimationFrame(fn),\n      target: camera,\n      type: 'camera',\n      options: o,\n      fn: fn\n    };\n    sigma.misc.animation.running[id] = anim;\n\n    return id;\n  };\n\n  /**\n   * Kills a running animation. It triggers the eventual onComplete callback.\n   *\n   * @param  {number} id  The id of the animation to kill.\n   * @return {object}     Returns the sigma.misc.animation package.\n   */\n  sigma.misc.animation.kill = function(id) {\n    if (arguments.length !== 1 || typeof id !== 'number')\n      throw 'animation.kill: Wrong arguments.';\n\n    var o = sigma.misc.animation.running[id];\n\n    if (o) {\n      cancelAnimationFrame(id);\n      delete sigma.misc.animation.running[o.frameId];\n\n      if (o.type === 'camera')\n        o.target.isAnimated = false;\n\n      // Check callbacks:\n      if (typeof (o.options || {}).onComplete === 'function')\n        o.options.onComplete();\n    }\n\n    return this;\n  };\n\n  /**\n   * Kills every running animations, or only the one with the specified type,\n   * if a string parameter is given.\n   *\n   * @param  {?(string|object)} filter A string to filter the animations to kill\n   *                                   on their type (example: \"camera\"), or an\n   *                                   object to filter on their target.\n   * @return {number}                  Returns the number of animations killed\n   *                                   that way.\n   */\n  sigma.misc.animation.killAll = function(filter) {\n    var o,\n        id,\n        count = 0,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      ) {\n        o = sigma.misc.animation.running[id];\n        cancelAnimationFrame(o.frameId);\n        delete sigma.misc.animation.running[id];\n\n        if (o.type === 'camera')\n          o.target.isAnimated = false;\n\n        // Increment counter:\n        count++;\n\n        // Check callbacks:\n        if (typeof (o.options || {}).onComplete === 'function')\n          o.options.onComplete();\n      }\n\n    return count;\n  };\n\n  /**\n   * Returns \"true\" if any animation that is currently still running matches\n   * the filter given to the function.\n   *\n   * @param  {string|object} filter A string to filter the animations to kill\n   *                                on their type (example: \"camera\"), or an\n   *                                object to filter on their target.\n   * @return {boolean}              Returns true if any running animation\n   *                                matches.\n   */\n  sigma.misc.animation.has = function(filter) {\n    var id,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      )\n        return true;\n\n    return false;\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any DOM renderer (for instance svg)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindDOMEvents = function(container) {\n    var self = this,\n        graph = this.graph;\n\n    // DOMElement abstraction\n    function Element(domElement) {\n\n      // Helpers\n      this.attr = function(attrName) {\n        return domElement.getAttributeNS(null, attrName);\n      };\n\n      // Properties\n      this.tag = domElement.tagName;\n      this.class = this.attr('class');\n      this.id = this.attr('id');\n\n      // Methods\n      this.isNode = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');\n      };\n\n      this.isEdge = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');\n      };\n\n      this.isHover = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');\n      };\n    }\n\n    // Click\n    function click(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('click', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('clickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('clickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // Double click\n    function doubleClick(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('doubleClick', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('doubleClickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('doubleClickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // On over\n    function onOver(e) {\n      var target = e.toElement || e.target;\n\n      if (!self.settings('eventsEnabled') || !target)\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('overNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('overEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // On out\n    function onOut(e) {\n      var target = e.fromElement || e.originalTarget;\n\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('outNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('outEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // Registering Events:\n\n    // Click\n    container.addEventListener('click', click, false);\n    sigma.utils.doubleClick(container, 'click', doubleClick);\n\n    // Touch counterparts\n    container.addEventListener('touchstart', click, false);\n    sigma.utils.doubleClick(container, 'touchstart', doubleClick);\n\n    // Mouseover\n    container.addEventListener('mouseover', onOver, true);\n\n    // Mouseout\n    container.addEventListener('mouseout', onOut, true);\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindEvents = function(prefix) {\n    var i,\n        l,\n        mX,\n        mY,\n        captor,\n        self = this;\n\n    function getNodes(e) {\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          n,\n          x,\n          y,\n          s,\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          nodes = self.camera.quadtree.point(\n            point.x,\n            point.y\n          );\n\n      if (nodes.length)\n        for (i = 0, l = nodes.length; i < l; i++) {\n          n = nodes[i];\n          x = n[prefix + 'x'];\n          y = n[prefix + 'y'];\n          s = n[prefix + 'size'];\n\n          if (\n            !n.hidden &&\n            modifiedX > x - s &&\n            modifiedX < x + s &&\n            modifiedY > y - s &&\n            modifiedY < y + s &&\n            Math.sqrt(\n              Math.pow(modifiedX - x, 2) +\n              Math.pow(modifiedY - y, 2)\n            ) < s\n          ) {\n            // Insert the node:\n            inserted = false;\n\n            for (j = 0; j < selected.length; j++)\n              if (n.size > selected[j].size) {\n                selected.splice(j, 0, n);\n                inserted = true;\n                break;\n              }\n\n            if (!inserted)\n              selected.push(n);\n          }\n        }\n\n      return selected;\n    }\n\n\n    function getEdges(e) {\n      if (!self.settings('enableEdgeHovering')) {\n        // No event if the setting is off:\n        return [];\n      }\n\n      var isCanvas = (\n        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);\n\n      if (!isCanvas) {\n        // A quick hardcoded rule to prevent people from using this feature\n        // with the WebGL renderer (which is not good enough at the moment):\n        throw new Error(\n          'The edge events feature is not compatible with the WebGL renderer'\n        );\n      }\n\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          a,\n          edge,\n          s,\n          maxEpsilon = self.settings('edgeHoverPrecision'),\n          source,\n          target,\n          cp,\n          nodeIndex = {},\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          edges = [];\n\n      if (isCanvas) {\n        var nodesOnScreen = self.camera.quadtree.area(\n          self.camera.getRectangle(self.width, self.height)\n        );\n        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)\n          nodeIndex[a[i].id] = a[i];\n      }\n\n      if (self.camera.edgequadtree !== undefined) {\n        edges = self.camera.edgequadtree.point(\n          point.x,\n          point.y\n        );\n      }\n\n      function insertEdge(selected, edge) {\n        inserted = false;\n\n        for (j = 0; j < selected.length; j++)\n          if (edge.size > selected[j].size) {\n            selected.splice(j, 0, edge);\n            inserted = true;\n            break;\n          }\n\n        if (!inserted)\n          selected.push(edge);\n      }\n\n      if (edges.length)\n        for (i = 0, l = edges.length; i < l; i++) {\n          edge = edges[i];\n          source = self.graph.nodes(edge.source);\n          target = self.graph.nodes(edge.target);\n          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:\n          s = edge[prefix + 'size'] ||\n              edge['read_' + prefix + 'size'];\n\n          // First, let's identify which edges are drawn. To do this, we keep\n          // every edges that have at least one extremity displayed according to\n          // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n          // edges.\n          // Then, let's check if the mouse is on the edge (we suppose that it\n          // is a line segment).\n\n          if (\n            !edge.hidden &&\n            !source.hidden && !target.hidden &&\n            (!isCanvas ||\n              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&\n            sigma.utils.getDistance(\n              source[prefix + 'x'],\n              source[prefix + 'y'],\n              modifiedX,\n              modifiedY) > source[prefix + 'size'] &&\n            sigma.utils.getDistance(\n              target[prefix + 'x'],\n              target[prefix + 'y'],\n              modifiedX,\n              modifiedY) > target[prefix + 'size']\n          ) {\n            if (edge.type == 'curve' || edge.type == 'curvedArrow') {\n              if (source.id === target.id) {\n                cp = sigma.utils.getSelfLoopControlPoints(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  source[prefix + 'size']\n                );\n                if (\n                  sigma.utils.isPointOnBezierCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x1,\n                  cp.y1,\n                  cp.x2,\n                  cp.y2,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n              else {\n                cp = sigma.utils.getQuadraticControlPoint(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y']);\n                if (\n                  sigma.utils.isPointOnQuadraticCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x,\n                  cp.y,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n            } else if (\n                sigma.utils.isPointOnSegment(\n                modifiedX,\n                modifiedY,\n                source[prefix + 'x'],\n                source[prefix + 'y'],\n                target[prefix + 'x'],\n                target[prefix + 'y'],\n                Math.max(s, maxEpsilon)\n              )) {\n              insertEdge(selected, edge);\n            }\n          }\n        }\n\n      return selected;\n    }\n\n\n    function bindCaptor(captor) {\n      var nodes,\n          edges,\n          overNodes = {},\n          overEdges = {};\n\n      function onClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('click', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('clickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('clickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('clickStage', {captor: e.data});\n      }\n\n      function onDoubleClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('doubleClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('doubleClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('doubleClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('doubleClickStage', {captor: e.data});\n      }\n\n      function onRightClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('rightClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('rightClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('rightClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('rightClickStage', {captor: e.data});\n      }\n\n      function onOut(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        var k,\n            i,\n            l,\n            le,\n            outNodes = [],\n            outEdges = [];\n\n        for (k in overNodes)\n          outNodes.push(overNodes[k]);\n\n        overNodes = {};\n        // Dispatch both single and multi events:\n        for (i = 0, l = outNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: outNodes[i],\n            captor: e.data\n          });\n        if (outNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: outNodes,\n            captor: e.data\n          });\n\n        overEdges = {};\n        // Dispatch both single and multi events:\n        for (i = 0, le = outEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: outEdges[i],\n            captor: e.data\n          });\n        if (outEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: outEdges,\n            captor: e.data\n          });\n      }\n\n      function onMove(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        var i,\n            k,\n            node,\n            edge,\n            newOutNodes = [],\n            newOverNodes = [],\n            currentOverNodes = {},\n            l = nodes.length,\n            newOutEdges = [],\n            newOverEdges = [],\n            currentOverEdges = {},\n            le = edges.length;\n\n        // Check newly overred nodes:\n        for (i = 0; i < l; i++) {\n          node = nodes[i];\n          currentOverNodes[node.id] = node;\n          if (!overNodes[node.id]) {\n            newOverNodes.push(node);\n            overNodes[node.id] = node;\n          }\n        }\n\n        // Check no more overred nodes:\n        for (k in overNodes)\n          if (!currentOverNodes[k]) {\n            newOutNodes.push(overNodes[k]);\n            delete overNodes[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, l = newOverNodes.length; i < l; i++)\n          self.dispatchEvent('overNode', {\n            node: newOverNodes[i],\n            captor: e.data\n          });\n        for (i = 0, l = newOutNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: newOutNodes[i],\n            captor: e.data\n          });\n        if (newOverNodes.length)\n          self.dispatchEvent('overNodes', {\n            nodes: newOverNodes,\n            captor: e.data\n          });\n        if (newOutNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: newOutNodes,\n            captor: e.data\n          });\n\n        // Check newly overred edges:\n        for (i = 0; i < le; i++) {\n          edge = edges[i];\n          currentOverEdges[edge.id] = edge;\n          if (!overEdges[edge.id]) {\n            newOverEdges.push(edge);\n            overEdges[edge.id] = edge;\n          }\n        }\n\n        // Check no more overred edges:\n        for (k in overEdges)\n          if (!currentOverEdges[k]) {\n            newOutEdges.push(overEdges[k]);\n            delete overEdges[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, le = newOverEdges.length; i < le; i++)\n          self.dispatchEvent('overEdge', {\n            edge: newOverEdges[i],\n            captor: e.data\n          });\n        for (i = 0, le = newOutEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: newOutEdges[i],\n            captor: e.data\n          });\n        if (newOverEdges.length)\n          self.dispatchEvent('overEdges', {\n            edges: newOverEdges,\n            captor: e.data\n          });\n        if (newOutEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: newOutEdges,\n            captor: e.data\n          });\n      }\n\n      // Bind events:\n      captor.bind('click', onClick);\n      captor.bind('mousedown', onMove);\n      captor.bind('mouseup', onMove);\n      captor.bind('mousemove', onMove);\n      captor.bind('mouseout', onOut);\n      captor.bind('doubleclick', onDoubleClick);\n      captor.bind('rightclick', onRightClick);\n      self.bind('render', onMove);\n    }\n\n    for (i = 0, l = this.captors.length; i < l; i++)\n      bindCaptor(this.captors[i]);\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This method listens to \"overNode\", \"outNode\", \"overEdge\" and \"outEdge\"\n   * events from a renderer and renders the nodes differently on the top layer.\n   * The goal is to make any node label readable with the mouse, and to\n   * highlight hovered nodes and edges.\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.drawHovers = function(prefix) {\n    var self = this,\n        hoveredNodes = {},\n        hoveredEdges = {};\n\n    this.bind('overNode', function(event) {\n      var node = event.data.node;\n      if (!node.hidden) {\n        hoveredNodes[node.id] = node;\n        draw();\n      }\n    });\n\n    this.bind('outNode', function(event) {\n      delete hoveredNodes[event.data.node.id];\n      draw();\n    });\n\n    this.bind('overEdge', function(event) {\n      var edge = event.data.edge;\n      if (!edge.hidden) {\n        hoveredEdges[edge.id] = edge;\n        draw();\n      }\n    });\n\n    this.bind('outEdge', function(event) {\n      delete hoveredEdges[event.data.edge.id];\n      draw();\n    });\n\n    this.bind('render', function(event) {\n      draw();\n    });\n\n    function draw() {\n\n      var k,\n          source,\n          target,\n          hoveredNode,\n          hoveredEdge,\n          c = self.contexts.hover.canvas,\n          defaultNodeType = self.settings('defaultNodeType'),\n          defaultEdgeType = self.settings('defaultEdgeType'),\n          nodeRenderers = sigma.canvas.hovers,\n          edgeRenderers = sigma.canvas.edgehovers,\n          extremitiesRenderers = sigma.canvas.extremities,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Clear self.contexts.hover:\n      self.contexts.hover.clearRect(0, 0, c.width, c.height);\n\n      // Node render: single hover\n      if (\n        embedSettings('enableHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredNodes).length\n      ) {\n        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];\n        (\n          nodeRenderers[hoveredNode.type] ||\n          nodeRenderers[defaultNodeType] ||\n          nodeRenderers.def\n        )(\n          hoveredNode,\n          self.contexts.hover,\n          embedSettings\n        );\n      }\n\n      // Node render: multiple hover\n      if (\n        embedSettings('enableHovering') &&\n        !embedSettings('singleHover')\n      )\n        for (k in hoveredNodes)\n          (\n            nodeRenderers[hoveredNodes[k].type] ||\n            nodeRenderers[defaultNodeType] ||\n            nodeRenderers.def\n          )(\n            hoveredNodes[k],\n            self.contexts.hover,\n            embedSettings\n          );\n\n      // Edge render: single hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredEdges).length\n      ) {\n        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];\n        source = self.graph.nodes(hoveredEdge.source);\n        target = self.graph.nodes(hoveredEdge.target);\n\n        if (! hoveredEdge.hidden) {\n          (\n            edgeRenderers[hoveredEdge.type] ||\n            edgeRenderers[defaultEdgeType] ||\n            edgeRenderers.def\n          ) (\n            hoveredEdge,\n            source,\n            target,\n            self.contexts.hover,\n            embedSettings\n          );\n\n          if (embedSettings('edgeHoverExtremities')) {\n            (\n              extremitiesRenderers[hoveredEdge.type] ||\n              extremitiesRenderers.def\n            )(\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n          } else {\n            // Avoid edges rendered over nodes:\n            (\n              sigma.canvas.nodes[source.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              source,\n              self.contexts.hover,\n              embedSettings\n            );\n            (\n              sigma.canvas.nodes[target.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n          }\n        }\n      }\n\n      // Edge render: multiple hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        !embedSettings('singleHover')\n      ) {\n        for (k in hoveredEdges) {\n          hoveredEdge = hoveredEdges[k];\n          source = self.graph.nodes(hoveredEdge.source);\n          target = self.graph.nodes(hoveredEdge.target);\n\n          if (!hoveredEdge.hidden) {\n            (\n              edgeRenderers[hoveredEdge.type] ||\n              edgeRenderers[defaultEdgeType] ||\n              edgeRenderers.def\n            ) (\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n            if (embedSettings('edgeHoverExtremities')) {\n              (\n                extremitiesRenderers[hoveredEdge.type] ||\n                extremitiesRenderers.def\n              )(\n                hoveredEdge,\n                source,\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            } else {\n              // Avoid edges rendered over nodes:\n              (\n                sigma.canvas.nodes[source.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                source,\n                self.contexts.hover,\n                embedSettings\n              );\n              (\n                sigma.canvas.nodes[target.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            }\n          }\n        }\n      }\n    }\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.arrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    size = (edge.hover) ?\n      settings('edgeHoverSizeRatio') * size : size;\n    var aSize = size * 2.5,\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curve =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        d,\n        aSize,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aSize = size * 2.5;\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aSize = size * 2.5;\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.def =\n    function(edge, source, target, context, settings) {\n      var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curve = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves with arrow heading.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * The default edge renderer. It renders the edge as a simple line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.def = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.extremities');\n\n  /**\n   * The default renderer for hovered edge extremities. It renders the edge\n   * extremities as hovered.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.extremities.def =\n    function(edge, source, target, context, settings) {\n    // Source Node:\n    (\n      sigma.canvas.hovers[source.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      source, context, settings\n    );\n\n    // Target Node:\n    (\n      sigma.canvas.hovers[target.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      target, context, settings\n    );\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.hovers');\n\n  /**\n   * This hover renderer will basically display the label with a background.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.hovers.def = function(node, context, settings) {\n    var x,\n        y,\n        w,\n        h,\n        e,\n        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'],\n        fontSize = (settings('labelSize') === 'fixed') ?\n          settings('defaultLabelSize') :\n          settings('labelSizeRatio') * size;\n\n    // Label background:\n    context.font = (fontStyle ? fontStyle + ' ' : '') +\n      fontSize + 'px ' + (settings('hoverFont') || settings('font'));\n\n    context.beginPath();\n    context.fillStyle = settings('labelHoverBGColor') === 'node' ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultHoverLabelBGColor');\n\n    if (node.label && settings('labelHoverShadow')) {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 8;\n      context.shadowColor = settings('labelHoverShadowColor');\n    }\n\n    if (node.label && typeof node.label === 'string') {\n      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n      w = Math.round(\n        context.measureText(node.label).width + fontSize / 2 + size + 7\n      );\n      h = Math.round(fontSize + 4);\n      e = Math.round(fontSize / 2 + 2);\n\n      context.moveTo(x, y + e);\n      context.arcTo(x, y, x + e, y, e);\n      context.lineTo(x + w, y);\n      context.lineTo(x + w, y + h);\n      context.lineTo(x + e, y + h);\n      context.arcTo(x, y + h, x, y + h - e, e);\n      context.lineTo(x, y + e);\n\n      context.closePath();\n      context.fill();\n\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 0;\n    }\n\n    // Node border:\n    if (settings('borderSize') > 0) {\n      context.beginPath();\n      context.fillStyle = settings('nodeBorderColor') === 'node' ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultNodeBorderColor');\n      context.arc(\n        node[prefix + 'x'],\n        node[prefix + 'y'],\n        size + settings('borderSize'),\n        0,\n        Math.PI * 2,\n        true\n      );\n      context.closePath();\n      context.fill();\n    }\n\n    // Node:\n    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;\n    nodeRenderer(node, context, settings);\n\n    // Display the label:\n    if (node.label && typeof node.label === 'string') {\n      context.fillStyle = (settings('labelHoverColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelHoverColor');\n\n      context.fillText(\n        node.label,\n        Math.round(node[prefix + 'x'] + size + 3),\n        Math.round(node[prefix + 'y'] + fontSize / 3)\n      );\n    }\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.labels');\n\n  /**\n   * This label renderer will just display the label on the right of the node.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.labels.def = function(node, context, settings) {\n    var fontSize,\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'];\n\n    if (size < settings('labelThreshold'))\n      return;\n\n    if (!node.label || typeof node.label !== 'string')\n      return;\n\n    fontSize = (settings('labelSize') === 'fixed') ?\n      settings('defaultLabelSize') :\n      settings('labelSizeRatio') * size;\n\n    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +\n      fontSize + 'px ' + settings('font');\n    context.fillStyle = (settings('labelColor') === 'node') ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultLabelColor');\n\n    context.fillText(\n      node.label,\n      Math.round(node[prefix + 'x'] + size + 3),\n      Math.round(node[prefix + 'y'] + fontSize / 3)\n    );\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.nodes.def = function(node, context, settings) {\n    var prefix = settings('prefix') || '';\n\n    context.fillStyle = node.color || settings('defaultNodeColor');\n    context.beginPath();\n    context.arc(\n      node[prefix + 'x'],\n      node[prefix + 'y'],\n      node[prefix + 'size'],\n      0,\n      Math.PI * 2,\n      true\n    );\n\n    context.closePath();\n    context.fill();\n  };\n})();\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.canvas = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.canvas: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Node indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + this.conradId + ':';\n\n    // Initialize the DOM elements:\n    if (\n      !this.settings('batchEdgesDrawing')\n    ) {\n      this.initDOM('canvas', 'scene');\n      this.contexts.edges = this.contexts.scene;\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    } else {\n      this.initDOM('canvas', 'edges');\n      this.initDOM('canvas', 'scene');\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.options.prefix);\n    sigma.misc.drawHovers.call(this, this.options.prefix);\n\n    this.resize(false);\n  };\n\n\n\n\n  /**\n   * This method renders the graph on the canvases.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.canvas}         Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        l,\n        o,\n        id,\n        end,\n        job,\n        start,\n        edges,\n        renderers,\n        rendererType,\n        batchSize,\n        tempGCO,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix\n        });\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Clear canvases:\n    this.clear();\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    // Find which nodes are on screen:\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Draw edges:\n    // - If settings('batchEdgesDrawing') is true, the edges are displayed per\n    //   batches. If not, they are drawn in one frame.\n    if (drawEdges) {\n      // First, let's identify which edges to draw. To do this, we just keep\n      // every edges that have at least one extremity displayed according to\n      // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n      // edges.\n      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n        o = a[i];\n        if (\n          (index[o.source] || index[o.target]) &&\n          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n        )\n          this.edgesOnScreen.push(o);\n      }\n\n      // If the \"batchEdgesDrawing\" settings is true, edges are batched:\n      if (this.settings(options, 'batchEdgesDrawing')) {\n        id = 'edges_' + this.conradId;\n        batchSize = embedSettings('canvasEdgesBatchSize');\n\n        edges = this.edgesOnScreen;\n        l = edges.length;\n\n        start = 0;\n        end = Math.min(edges.length, start + batchSize);\n\n        job = function() {\n          tempGCO = this.contexts.edges.globalCompositeOperation;\n          this.contexts.edges.globalCompositeOperation = 'destination-over';\n\n          renderers = sigma.canvas.edges;\n          for (i = start; i < end; i++) {\n            o = edges[i];\n            (renderers[\n              o.type || this.settings(options, 'defaultEdgeType')\n            ] || renderers.def)(\n              o,\n              graph.nodes(o.source),\n              graph.nodes(o.target),\n              this.contexts.edges,\n              embedSettings\n            );\n          }\n\n          // Draw edge labels:\n          if (drawEdgeLabels) {\n            renderers = sigma.canvas.edges.labels;\n            for (i = start; i < end; i++) {\n              o = edges[i];\n              if (!o.hidden)\n                (renderers[\n                  o.type || this.settings(options, 'defaultEdgeType')\n                ] || renderers.def)(\n                  o,\n                  graph.nodes(o.source),\n                  graph.nodes(o.target),\n                  this.contexts.labels,\n                  embedSettings\n                );\n            }\n          }\n\n          // Restore original globalCompositeOperation:\n          this.contexts.edges.globalCompositeOperation = tempGCO;\n\n          // Catch job's end:\n          if (end === edges.length) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          start = end + 1;\n          end = Math.min(edges.length, start + batchSize);\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this));\n\n      // If not, they are drawn in one frame:\n      } else {\n        renderers = sigma.canvas.edges;\n        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n          o = a[i];\n          (renderers[\n            o.type || this.settings(options, 'defaultEdgeType')\n          ] || renderers.def)(\n            o,\n            graph.nodes(o.source),\n            graph.nodes(o.target),\n            this.contexts.edges,\n            embedSettings\n          );\n        }\n\n        // Draw edge labels:\n        // - No batching\n        if (drawEdgeLabels) {\n          renderers = sigma.canvas.edges.labels;\n          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)\n            if (!a[i].hidden)\n              (renderers[\n                a[i].type || this.settings(options, 'defaultEdgeType')\n              ] || renderers.def)(\n                a[i],\n                graph.nodes(a[i].source),\n                graph.nodes(a[i].target),\n                this.contexts.labels,\n                embedSettings\n              );\n        }\n      }\n    }\n\n    // Draw nodes:\n    // - No batching\n    if (drawNodes) {\n      renderers = sigma.canvas.nodes;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.nodes,\n            embedSettings\n          );\n    }\n\n    // Draw labels:\n    // - No batching\n    if (drawLabels) {\n      renderers = sigma.canvas.labels;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.labels,\n            embedSettings\n          );\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {\n    var dom = document.createElement(tag);\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas')\n      this.contexts[id] = dom.getContext('2d');\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.canvas}        Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n          if (pixelRatio !== 1)\n            this.contexts[k].scale(pixelRatio, pixelRatio);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.canvas} Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.clear = function() {\n    for (var k in this.contexts) {\n      this.contexts[k].clearRect(0, 0, this.width, this.height);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.canvas.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./canvas\" folder.\n   */\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.canvas.edges');\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n"},function(e,n){e.exports=";(function(global) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  // Check if WebGL is enabled:\n  var canvas,\n      webgl = !!global.WebGLRenderingContext;\n  if (webgl) {\n    canvas = document.createElement('canvas');\n    try {\n      webgl = !!(\n        canvas.getContext('webgl') ||\n        canvas.getContext('experimental-webgl')\n      );\n    } catch (e) {\n      webgl = false;\n    }\n  }\n\n  // Copy the good renderer:\n  sigma.renderers.def = webgl ?\n    sigma.renderers.webgl :\n    sigma.renderers.canvas;\n})(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the svg sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.svg}             The renderer instance.\n   */\n  sigma.renderers.svg = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.svg: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.domElements = {\n      graph: null,\n      groups: {},\n      nodes: {},\n      edges: {},\n      labels: {},\n      hovers: {}\n    };\n    this.measurementCanvas = null;\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Is the renderer meant to be freestyle?\n    this.settings('freeStyle', !!this.options.freeStyle);\n\n    // SVG xmlns\n    this.settings('xmlns', 'http://www.w3.org/2000/svg');\n\n    // Indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + sigma.utils.id() + ':';\n\n    // Initialize the DOM elements\n    this.initDOM('svg');\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.graph,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Bind resize:\n    window.addEventListener('resize', function() {\n      self.resize();\n    });\n\n    // Deal with sigma events:\n    // TODO: keep an option to override the DOM events?\n    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);\n    this.bindHovers(this.options.prefix);\n\n    // Resize\n    this.resize(false);\n  };\n\n  /**\n   * This method renders the graph on the svg scene.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.svg}            Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        e,\n        l,\n        o,\n        source,\n        target,\n        start,\n        edges,\n        renderers,\n        subrenderers,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix,\n          forceLabels: this.options.forceLabels\n        });\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Hiding everything\n    // TODO: find a more sensible way to perform this operation\n    this.hideDOMElements(this.domElements.nodes);\n    this.hideDOMElements(this.domElements.edges);\n    this.hideDOMElements(this.domElements.labels);\n\n    // Find which nodes are on screen\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    // Node index\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Find which edges are on screen\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      o = a[i];\n      if (\n        (index[o.source] || index[o.target]) &&\n        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n      )\n        this.edgesOnScreen.push(o);\n    }\n\n    // Display nodes\n    //---------------\n    renderers = sigma.svg.nodes;\n    subrenderers = sigma.svg.labels;\n\n    //-- First we create the nodes which are not already created\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {\n\n          // Node\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.nodes[a[i].id] = e;\n          this.domElements.groups.nodes.appendChild(e);\n\n          // Label\n          e = (subrenderers[a[i].type] || subrenderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.labels[a[i].id] = e;\n          this.domElements.groups.labels.appendChild(e);\n        }\n      }\n\n    //-- Second we update the nodes\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n\n        if (a[i].hidden)\n          continue;\n\n        // Node\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.nodes[a[i].id],\n          embedSettings\n        );\n\n        // Label\n        (subrenderers[a[i].type] || subrenderers.def).update(\n          a[i],\n          this.domElements.labels[a[i].id],\n          embedSettings\n        );\n      }\n\n    // Display edges\n    //---------------\n    renderers = sigma.svg.edges;\n\n    //-- First we create the edges which are not already created\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!this.domElements.edges[a[i].id]) {\n          source = nodes(a[i].source);\n          target = nodes(a[i].target);\n\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            source,\n            target,\n            embedSettings\n          );\n\n          this.domElements.edges[a[i].id] = e;\n          this.domElements.groups.edges.appendChild(e);\n        }\n       }\n\n    //-- Second we update the edges\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        source = nodes(a[i].source);\n        target = nodes(a[i].target);\n\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.edges[a[i].id],\n          source,\n          target,\n          embedSettings\n        );\n       }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.svg.prototype.initDOM = function(tag) {\n    var dom = document.createElementNS(this.settings('xmlns'), tag),\n        c = this.settings('classPrefix'),\n        g,\n        l,\n        i;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', c + '-svg');\n\n    // Setting SVG namespace\n    dom.setAttribute('xmlns', this.settings('xmlns'));\n    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    dom.setAttribute('version', '1.1');\n\n    // Creating the measurement canvas\n    var canvas = document.createElement('canvas');\n    canvas.setAttribute('class', c + '-measurement-canvas');\n\n    // Appending elements\n    this.domElements.graph = this.container.appendChild(dom);\n\n    // Creating groups\n    var groups = ['edges', 'nodes', 'labels', 'hovers'];\n    for (i = 0, l = groups.length; i < l; i++) {\n      g = document.createElementNS(this.settings('xmlns'), 'g');\n\n      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);\n      g.setAttributeNS(null, 'class', c + '-group');\n\n      this.domElements.groups[groups[i]] =\n        this.domElements.graph.appendChild(g);\n    }\n\n    // Appending measurement canvas\n    this.container.appendChild(canvas);\n    this.measurementCanvas = canvas.getContext('2d');\n  };\n\n  /**\n   * This method hides a batch of SVG DOM elements.\n   *\n   * @param  {array}                  elements  An array of elements to hide.\n   * @param  {object}                 renderer  The renderer to use.\n   * @return {sigma.renderers.svg}              Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {\n    var o,\n        i;\n\n    for (i in elements) {\n      o = elements[i];\n      sigma.svg.utils.hide(o);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method binds the hover events to the renderer.\n   *\n   * @param  {string} prefix The renderer prefix.\n   */\n  // TODO: add option about whether to display hovers or not\n  sigma.renderers.svg.prototype.bindHovers = function(prefix) {\n    var renderers = sigma.svg.hovers,\n        self = this,\n        hoveredNode;\n\n    function overNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      var hover = (renderers[node.type] || renderers.def).create(\n        node,\n        self.domElements.nodes[node.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[node.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n      hoveredNode = node;\n    }\n\n    function outNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      // Deleting element\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[node.id]\n      );\n      hoveredNode = null;\n      delete self.domElements.hovers[node.id];\n\n      // Reinstate\n      self.domElements.groups.nodes.appendChild(\n        self.domElements.nodes[node.id]\n      );\n    }\n\n    // OPTIMIZE: perform a real update rather than a deletion\n    function update() {\n      if (!hoveredNode)\n        return;\n\n      var embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Deleting element before update\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[hoveredNode.id]\n      );\n      delete self.domElements.hovers[hoveredNode.id];\n\n      var hover = (renderers[hoveredNode.type] || renderers.def).create(\n        hoveredNode,\n        self.domElements.nodes[hoveredNode.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[hoveredNode.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n    }\n\n    // Binding events\n    this.bind('overNode', overNode);\n    this.bind('outNode', outNode);\n\n    // Update on render\n    this.bind('render', update);\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.svg}           Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.resize = function(w, h) {\n    var oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = 1;\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      this.domElements.graph.style.width = w + 'px';\n      this.domElements.graph.style.height = h + 'px';\n\n      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {\n        this.domElements.graph.setAttribute('width', (w * pixelRatio));\n        this.domElements.graph.setAttribute('height', (h * pixelRatio));\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./svg\" folder.\n   */\n  sigma.utils.pkg('sigma.svg.nodes');\n  sigma.utils.pkg('sigma.svg.edges');\n  sigma.utils.pkg('sigma.svg.labels');\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.webgl = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.webgl: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        _self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Find the prefix:\n    this.options.prefix = this.camera.readPrefix;\n\n    // Initialize programs hash\n    Object.defineProperty(this, 'nodePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'nodeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeIndicesArrays', {\n      value: {}\n    });\n\n    // Initialize the DOM elements:\n    if (this.settings(options, 'batchEdgesDrawing')) {\n      this.initDOM('canvas', 'edges', true);\n      this.initDOM('canvas', 'nodes', true);\n    } else {\n      this.initDOM('canvas', 'scene', true);\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.edges = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'labels');\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.camera.prefix);\n    sigma.misc.drawHovers.call(this, this.camera.prefix);\n\n    this.resize();\n  };\n\n\n\n\n  /**\n   * This method will generate the nodes and edges float arrays. This step is\n   * separated from the \"render\" method, because to keep WebGL efficient, since\n   * all the camera and middlewares are modelised as matrices and they do not\n   * require the float arrays to be regenerated.\n   *\n   * Basically, when the user moves the camera or applies some specific linear\n   * transformations, this process step will be skipped, and the \"render\"\n   * method will efficiently refresh the rendering.\n   *\n   * And when the user modifies the graph colors or positions (applying a new\n   * layout or filtering the colors, for instance), this \"process\" step will be\n   * required to regenerate the float arrays.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.process = function() {\n    var a,\n        i,\n        l,\n        k,\n        type,\n        renderer,\n        graph = this.graph,\n        options = sigma.utils.extend(options, this.options),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        defaultNodeType = this.settings(options, 'defaultNodeType');\n\n    // Empty float arrays:\n    for (k in this.nodeFloatArrays)\n      delete this.nodeFloatArrays[k];\n\n    for (k in this.edgeFloatArrays)\n      delete this.edgeFloatArrays[k];\n\n    for (k in this.edgeIndicesArrays)\n      delete this.edgeIndicesArrays[k];\n\n    // Sort edges and nodes per types:\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultEdgeType;\n      k = (type && sigma.webgl.edges[type]) ? type : 'def';\n\n      if (!this.edgeFloatArrays[k])\n        this.edgeFloatArrays[k] = {\n          edges: []\n        };\n\n      this.edgeFloatArrays[k].edges.push(a[i]);\n    }\n\n    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultNodeType;\n      k = (type && sigma.webgl.nodes[type]) ? type : 'def';\n\n      if (!this.nodeFloatArrays[k])\n        this.nodeFloatArrays[k] = {\n          nodes: []\n        };\n\n      this.nodeFloatArrays[k].nodes.push(a[i]);\n    }\n\n    // Push edges:\n    for (k in this.edgeFloatArrays) {\n      renderer = sigma.webgl.edges[k];\n      a = this.edgeFloatArrays[k].edges;\n\n      // Creating the necessary arrays\n      this.edgeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden &&\n          !graph.nodes(a[i].source).hidden &&\n          !graph.nodes(a[i].target).hidden\n        )\n          renderer.addEdge(\n            a[i],\n            graph.nodes(a[i].source),\n            graph.nodes(a[i].target),\n            this.edgeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n\n      if (typeof renderer.computeIndices === 'function')\n        this.edgeIndicesArrays[k] = renderer.computeIndices(\n          this.edgeFloatArrays[k].array\n        );\n    }\n\n    // Push nodes:\n    for (k in this.nodeFloatArrays) {\n      renderer = sigma.webgl.nodes[k];\n      a = this.nodeFloatArrays[k].nodes;\n\n      // Creating the necessary arrays\n      this.nodeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!this.nodeFloatArrays[k].array)\n          this.nodeFloatArrays[k].array = new Float32Array(\n            a.length * renderer.POINTS * renderer.ATTRIBUTES\n          );\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden\n        )\n          renderer.addNode(\n            a[i],\n            this.nodeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n    }\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method renders the graph. It basically calls each program (and\n   * generate them if they do not exist yet) to render nodes and edges, batched\n   * per renderer.\n   *\n   * As in the canvas renderer, it is possible to display edges, nodes and / or\n   * labels in batches, to make the whole thing way more scalable.\n   *\n   * @param  {?object}               params Eventually an object of options.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.render = function(params) {\n    var a,\n        i,\n        l,\n        k,\n        o,\n        program,\n        renderer,\n        self = this,\n        graph = this.graph,\n        nodesGl = this.contexts.nodes,\n        edgesGl = this.contexts.edges,\n        matrix = this.camera.getMatrix(),\n        options = sigma.utils.extend(params, this.options),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes');\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Clear canvases:\n    this.clear();\n\n    // Translate matrix to [width/2, height/2]:\n    matrix = sigma.utils.matrices.multiply(\n      matrix,\n      sigma.utils.matrices.translation(this.width / 2, this.height / 2)\n    );\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    if (drawEdges) {\n      if (this.settings(options, 'batchEdgesDrawing'))\n        (function() {\n          var a,\n              k,\n              i,\n              id,\n              job,\n              arr,\n              end,\n              start,\n              indices,\n              renderer,\n              batchSize,\n              currentProgram;\n\n          id = 'edges_' + this.conradId;\n          batchSize = this.settings(options, 'webglEdgesBatchSize');\n          a = Object.keys(this.edgeFloatArrays);\n\n          if (!a.length)\n            return;\n          i = 0;\n          renderer = sigma.webgl.edges[a[i]];\n          arr = this.edgeFloatArrays[a[i]].array;\n          indices = this.edgeIndicesArrays[a[i]];\n          start = 0;\n          end = Math.min(\n            start + batchSize * renderer.POINTS,\n            arr.length / renderer.ATTRIBUTES\n          );\n\n          job = function() {\n            // Check program:\n            if (!this.edgePrograms[a[i]])\n              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);\n\n            if (start < end) {\n              edgesGl.useProgram(this.edgePrograms[a[i]]);\n              renderer.render(\n                edgesGl,\n                this.edgePrograms[a[i]],\n                arr,\n                {\n                  settings: this.settings,\n                  matrix: matrix,\n                  width: this.width,\n                  height: this.height,\n                  ratio: this.camera.ratio,\n                  scalingRatio: this.settings(\n                    options,\n                    'webglOversamplingRatio'\n                  ),\n                  start: start,\n                  count: end - start,\n                  indicesData: indices\n                }\n              );\n            }\n\n            // Catch job's end:\n            if (\n              end >= arr.length / renderer.ATTRIBUTES &&\n              i === a.length - 1\n            ) {\n              delete this.jobs[id];\n              return false;\n            }\n\n            if (end >= arr.length / renderer.ATTRIBUTES) {\n              i++;\n              arr = this.edgeFloatArrays[a[i]].array;\n              renderer = sigma.webgl.edges[a[i]];\n              start = 0;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            } else {\n              start = end;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            }\n\n            return true;\n          };\n\n          this.jobs[id] = job;\n          conrad.addJob(id, job.bind(this));\n        }).call(this);\n      else {\n        for (k in this.edgeFloatArrays) {\n          renderer = sigma.webgl.edges[k];\n\n          // Check program:\n          if (!this.edgePrograms[k])\n            this.edgePrograms[k] = renderer.initProgram(edgesGl);\n\n          // Render\n          if (this.edgeFloatArrays[k]) {\n            edgesGl.useProgram(this.edgePrograms[k]);\n            renderer.render(\n              edgesGl,\n              this.edgePrograms[k],\n              this.edgeFloatArrays[k].array,\n              {\n                settings: this.settings,\n                matrix: matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n                indicesData: this.edgeIndicesArrays[k]\n              }\n            );\n          }\n        }\n      }\n    }\n\n    if (drawNodes) {\n      // Enable blending:\n      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);\n      nodesGl.enable(nodesGl.BLEND);\n\n      for (k in this.nodeFloatArrays) {\n        renderer = sigma.webgl.nodes[k];\n\n        // Check program:\n        if (!this.nodePrograms[k])\n          this.nodePrograms[k] = renderer.initProgram(nodesGl);\n\n        // Render\n        if (this.nodeFloatArrays[k]) {\n          nodesGl.useProgram(this.nodePrograms[k]);\n          renderer.render(\n            nodesGl,\n            this.nodePrograms[k],\n            this.nodeFloatArrays[k].array,\n            {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio')\n            }\n          );\n        }\n      }\n    }\n\n    if (drawLabels) {\n      a = this.camera.quadtree.area(\n        this.camera.getRectangle(this.width, this.height)\n      );\n\n      // Apply camera view to these nodes:\n      this.camera.applyView(\n        undefined,\n        undefined,\n        {\n          nodes: a,\n          edges: [],\n          width: this.width,\n          height: this.height\n        }\n      );\n\n      o = function(key) {\n        return self.settings({\n          prefix: self.camera.prefix\n        }, key);\n      };\n\n      for (i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (\n            sigma.canvas.labels[\n              a[i].type ||\n              this.settings(options, 'defaultNodeType')\n            ] || sigma.canvas.labels.def\n          )(a[i], this.contexts.labels, o);\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string}   tag   The label tag.\n   * @param  {string}   id    The id of the element (to store it in\n   *                          \"domElements\").\n   * @param  {?boolean} webgl Will init the WebGL context if true.\n   */\n  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {\n    var gl,\n        dom = document.createElement(tag),\n        self = this;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas') {\n      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {\n        preserveDrawingBuffer: true\n      });\n\n      // Adding webgl context loss listeners\n      if (webgl) {\n        dom.addEventListener('webglcontextlost', function(e) {\n          e.preventDefault();\n        }, false);\n\n        dom.addEventListener('webglcontextrestored', function(e) {\n          self.render();\n        }, false);\n      }\n    }\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}               width  The new width of the container.\n   * @param  {?number}               height The new height of the container.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          // If simple 2D canvas:\n          if (this.contexts[k] && this.contexts[k].scale) {\n            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n            if (pixelRatio !== 1)\n              this.contexts[k].scale(pixelRatio, pixelRatio);\n          } else {\n            this.domElements[k].setAttribute(\n              'width',\n              (w * this.settings('webglOversamplingRatio')) + 'px'\n            );\n            this.domElements[k].setAttribute(\n              'height',\n              (h * this.settings('webglOversamplingRatio')) + 'px'\n            );\n          }\n        }\n      }\n    }\n\n    // Scale:\n    for (k in this.contexts)\n      if (this.contexts[k] && this.contexts[k].viewport)\n        this.contexts[k].viewport(\n          0,\n          0,\n          this.width * this.settings('webglOversamplingRatio'),\n          this.height * this.settings('webglOversamplingRatio')\n        );\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.clear = function() {\n    this.contexts.labels.clearRect(0, 0, this.width, this.height);\n    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.webgl.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The object \"sigma.webgl.nodes\" contains the different WebGL node\n   * renderers. The default one draw nodes as discs. Here are the attributes\n   * any node renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw a node.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addNode     A function that adds a node to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       node\n   *                        > {number}       index   The node index in the\n   *                                                 nodes array.\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the nodes\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n\n\n\n  /**\n   * The object \"sigma.webgl.edges\" contains the different WebGL edge\n   * renderers. The default one draw edges as direct lines. Here are the\n   * attributes any edge renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw an edge.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addEdge     A function that adds an edge to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       edge\n   *                        > {object}       source\n   *                        > {object}       target\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the edges\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.edges');\n\n\n\n\n  /**\n   * The object \"sigma.canvas.labels\" contains the different\n   * label renderers for the WebGL renderer. Since displaying texts in WebGL is\n   * definitely painful and since there a way less labels to display than nodes\n   * or edges, the default renderer simply renders them in a canvas.\n   *\n   * A labels renderer is a simple function, taking as arguments the related\n   * node, the renderer and a settings function.\n   */\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The curve edge renderer. It renders the node as a bezier curve.\n   */\n  sigma.svg.edges.curve = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var path = document.createElementNS(settings('xmlns'), 'path');\n\n      // Attributes\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n\n      // Control point\n      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +\n        (target[prefix + 'y'] - source[prefix + 'y']) / 4,\n          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +\n        (source[prefix + 'x'] - target[prefix + 'x']) / 4;\n\n      // Path\n      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +\n              'Q' + cx + ',' + cy + ' ' +\n              target[prefix + 'x'] + ',' + target[prefix + 'y'];\n\n      // Updating attributes\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none');\n\n      // Showing\n      path.style.display = '';\n\n      return this;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The default edge renderer. It renders the node as a simple line.\n   */\n  sigma.svg.edges.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var line = document.createElementNS(settings('xmlns'), 'line');\n\n      // Attributes\n      line.setAttributeNS(null, 'data-edge-id', edge.id);\n      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      line.setAttributeNS(null, 'stroke', color);\n\n      return line;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, line, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n      line.setAttributeNS(null, 'x1', source[prefix + 'x']);\n      line.setAttributeNS(null, 'y1', source[prefix + 'y']);\n      line.setAttributeNS(null, 'x2', target[prefix + 'x']);\n      line.setAttributeNS(null, 'y2', target[prefix + 'y']);\n\n      // Showing\n      line.style.display = '';\n\n      return this;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.hovers');\n\n  /**\n   * The default hover renderer.\n   */\n  sigma.svg.hovers.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}           node               The node object.\n     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by\n     *                            the svg to perform some measurements and\n     *                            passed by the renderer.\n     * @param  {DOMElement}       nodeCircle         The node DOM Element.\n     * @param  {configurable}     settings           The settings function.\n     */\n    create: function(node, nodeCircle, measurementCanvas, settings) {\n\n      // Defining visual properties\n      var x,\n          y,\n          w,\n          h,\n          e,\n          d,\n          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          fontSize = (settings('labelSize') === 'fixed') ?\n            settings('defaultLabelSize') :\n            settings('labelSizeRatio') * size,\n          fontColor = (settings('labelHoverColor') === 'node') ?\n                        (node.color || settings('defaultNodeColor')) :\n                        settings('defaultLabelHoverColor');\n\n      // Creating elements\n      var group = document.createElementNS(settings('xmlns'), 'g'),\n          rectangle = document.createElementNS(settings('xmlns'), 'rect'),\n          circle = document.createElementNS(settings('xmlns'), 'circle'),\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      // Defining properties\n      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');\n      group.setAttributeNS(null, 'data-node-id', node.id);\n\n      if (typeof node.label === 'string') {\n\n        // Text\n        text.innerHTML = node.label;\n        text.textContent = node.label;\n        text.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-label');\n        text.setAttributeNS(null, 'font-size', fontSize);\n        text.setAttributeNS(null, 'font-family', settings('font'));\n        text.setAttributeNS(null, 'fill', fontColor);\n        text.setAttributeNS(null, 'x',\n          Math.round(node[prefix + 'x'] + size + 3));\n        text.setAttributeNS(null, 'y',\n          Math.round(node[prefix + 'y'] + fontSize / 3));\n\n        // Measures\n        // OPTIMIZE: Find a better way than a measurement canvas\n        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n        w = Math.round(\n          measurementCanvas.measureText(node.label).width +\n            fontSize / 2 + size + 9\n        );\n        h = Math.round(fontSize + 4);\n        e = Math.round(fontSize / 2 + 2);\n\n        // Circle\n        circle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        circle.setAttributeNS(null, 'fill', '#fff');\n        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n        circle.setAttributeNS(null, 'r', e);\n\n        // Rectangle\n        rectangle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        rectangle.setAttributeNS(null, 'fill', '#fff');\n        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);\n        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);\n        rectangle.setAttributeNS(null, 'width', w);\n        rectangle.setAttributeNS(null, 'height', h);\n      }\n\n      // Appending childs\n      group.appendChild(circle);\n      group.appendChild(rectangle);\n      group.appendChild(text);\n      group.appendChild(nodeCircle);\n\n      return group;\n    }\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.labels');\n\n  /**\n   * The default label renderer. It renders the label as a simple text.\n   */\n  sigma.svg.labels.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node       The node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      var fontColor = (settings('labelColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelColor');\n\n      text.setAttributeNS(null, 'data-label-target', node.id);\n      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');\n      text.setAttributeNS(null, 'font-size', fontSize);\n      text.setAttributeNS(null, 'font-family', settings('font'));\n      text.setAttributeNS(null, 'fill', fontColor);\n\n      text.innerHTML = node.label;\n      text.textContent = node.label;\n\n      return text;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               text     The label DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, text, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'];\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      // Case when we don't want to display the label\n      if (!settings('forceLabels') && size < settings('labelThreshold'))\n        return;\n\n      if (typeof node.label !== 'string')\n        return;\n\n      // Updating\n      text.setAttributeNS(null, 'x',\n        Math.round(node[prefix + 'x'] + size + 3));\n      text.setAttributeNS(null, 'y',\n        Math.round(node[prefix + 'y'] + fontSize / 3));\n\n      // Showing\n      text.style.display = '';\n\n      return this;\n    }\n  };\n}).call(this);\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   */\n  sigma.svg.nodes.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {configurable}             settings The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          circle = document.createElementNS(settings('xmlns'), 'circle');\n\n      // Defining the node's circle\n      circle.setAttributeNS(null, 'data-node-id', node.id);\n      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');\n      circle.setAttributeNS(\n        null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Returning the DOM Element\n      return circle;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               circle   The node DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, circle, settings) {\n      var prefix = settings('prefix') || '';\n\n      // Applying changes\n      // TODO: optimize - check if necessary\n      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n      circle.setAttributeNS(null, 'r', node[prefix + 'size']);\n\n      // Updating only if not freestyle\n      if (!settings('freeStyle'))\n        circle.setAttributeNS(\n          null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Showing\n      circle.style.display = '';\n\n      return this;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.utils');\n\n  /**\n   * Some useful functions used by sigma's SVG renderer.\n   */\n  sigma.svg.utils = {\n\n    /**\n     * SVG Element show.\n     *\n     * @param  {DOMElement}               element   The DOM element to show.\n     */\n    show: function(element) {\n      element.style.display = '';\n      return this;\n    },\n\n    /**\n     * SVG Element hide.\n     *\n     * @param  {DOMElement}               element   The DOM element to hide.\n     */\n    hide: function(element) {\n      element.style.display = 'none';\n      return this;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing\n   * mode.\n   *\n   * It is expensive, since drawing a single edge requires 9 points, each\n   * having a lot of attributes.\n   */\n  sigma.webgl.edges.arrow = {\n    POINTS: 9,\n    ATTRIBUTES: 11,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          targetSize = target[prefix + 'size'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      // Arrow head:\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = -1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation1 =\n            gl.getAttribLocation(program, 'a_pos1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_pos2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          targetSizeLocation =\n            gl.getAttribLocation(program, 'a_tSize'),\n          delayLocation =\n            gl.getAttribLocation(program, 'a_delay'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          headLocation =\n            gl.getAttribLocation(program, 'a_head'),\n          headPositionLocation =\n            gl.getAttribLocation(program, 'a_headPosition'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          nodeRatioLocation =\n            gl.getUniformLocation(program, 'u_nodeRatio'),\n          arrowHeadLocation =\n            gl.getUniformLocation(program, 'u_arrowHead'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(\n        nodeRatioLocation,\n        Math.pow(params.ratio, params.settings('nodesPowRatio')) /\n        params.ratio\n      );\n      gl.uniform1f(arrowHeadLocation, 5.0);\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(targetSizeLocation);\n      gl.enableVertexAttribArray(delayLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.enableVertexAttribArray(headLocation);\n      gl.enableVertexAttribArray(headPositionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(targetSizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(delayLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        28\n      );\n      gl.vertexAttribPointer(headLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        32\n      );\n      gl.vertexAttribPointer(headPositionLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        36\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        40\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_pos1;',\n          'attribute vec2 a_pos2;',\n          'attribute float a_thickness;',\n          'attribute float a_tSize;',\n          'attribute float a_delay;',\n          'attribute float a_minus;',\n          'attribute float a_head;',\n          'attribute float a_headPosition;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_nodeRatio;',\n          'uniform float u_arrowHead;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 pos = normalize(a_pos2 - a_pos1);',\n\n            'mat2 matrix = (1.0 - a_head) *',\n              '(',\n                'a_minus * u_matrixHalfPiMinus +',\n                '(1.0 - a_minus) * u_matrixHalfPi',\n              ') + a_head * (',\n                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',\n                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',\n              ');',\n\n            'pos = a_pos1 + (',\n              // Deal with body:\n              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',\n              // Deal with head:\n              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',\n              // Deal with delay:\n              'a_delay * pos * (',\n                'a_tSize / u_nodeRatio +',\n                'u_arrowHead * a_thickness * u_ratio',\n              ')',\n            ');',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(pos, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.\n   *\n   * It is expensive, since drawing a single edge requires 6 points, each\n   * having 7 attributes (source position, target position, thickness, color\n   * and a flag indicating which vertice of the rectangle it is).\n   */\n  sigma.webgl.edges.def = {\n    POINTS: 6,\n    ATTRIBUTES: 7,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation1 =\n            gl.getAttribLocation(program, 'a_position1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_position2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(minusLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position1;',\n          'attribute vec2 a_position2;',\n          'attribute float a_thickness;',\n          'attribute float a_minus;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 position = a_thickness * u_ratio *',\n              'normalize(a_position2 - a_position1);',\n\n            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',\n              '(1.0 - a_minus) * u_matrixHalfPi;',\n\n            'position = matrix * position + a_position1;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines with the gl.LINES display\n   * mode. Since this mode does not support well thickness, edges are all drawn\n   * with the same thickness (3px), independantly of the edge attributes or the\n   * zooming ratio.\n   */\n  sigma.webgl.edges.fast = {\n    POINTS: 2,\n    ATTRIBUTES: 3,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n\n      gl.lineWidth(3);\n      gl.drawArrays(\n        gl.LINES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes as discs, shaped in triangles with\n   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,\n   * it will store three times the center of node, with the color and the size,\n   * and an angle indicating which \"corner\" of the triangle to draw.\n   *\n   * The fragment shader does not deal with anti-aliasing, so make sure that\n   * you deal with it somewhere else in the code (by default, the WebGL\n   * renderer will oversample the rendering through the webglOversamplingRatio\n   * value).\n   */\n  sigma.webgl.nodes.def = {\n    POINTS: 3,\n    ATTRIBUTES: 5,\n    addNode: function(node, data, i, prefix, settings) {\n      var color = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 0;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 2 * Math.PI / 3;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 4 * Math.PI / 3;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          angleLocation =\n            gl.getAttribLocation(program, 'a_angle'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(angleLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n      gl.vertexAttribPointer(\n        angleLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n          'attribute float a_angle;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main() {',\n            // Multiply the point size twice:\n            'radius = a_size * u_ratio;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',\n            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n            'center = position * u_scale;',\n            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',\n\n            'position = position +',\n              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',\n            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n\n            'radius = radius * u_scale;',\n\n            'gl_Position = vec4(position, 0, 1);',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main(void) {',\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n\n            'vec2 m = gl_FragCoord.xy - center;',\n            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            // Here is how we draw a disc instead of a square:\n            'if (diff > 0.0)',\n              'gl_FragColor = color;',\n            'else',\n              'gl_FragColor = color0;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes in the fastest way: Nodes are basic\n   * squares, drawn through the gl.POINTS drawing method. The size of the nodes\n   * are represented with the \"gl_PointSize\" value in the vertex shader.\n   *\n   * It is the fastest node renderer here since the buffer just takes one line\n   * to draw each node (with attributes \"x\", \"y\", \"size\" and \"color\").\n   *\n   * Nevertheless, this method has some problems, especially due to some issues\n   * with the gl.POINTS:\n   *  - First, if the center of a node is outside the scene, the point will not\n   *    be drawn, even if it should be partly on screen.\n   *  - I tried applying a fragment shader similar to the one in the default\n   *    node renderer to display them as discs, but it did not work fine on\n   *    some computers settings, filling the discs with weird gradients not\n   *    depending on the actual color.\n   */\n  sigma.webgl.nodes.fast = {\n    POINTS: 1,\n    ATTRIBUTES: 4,\n    addNode: function(node, data, i, prefix, settings) {\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n\n      gl.drawArrays(\n        gl.POINTS,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Multiply the point size twice:\n            //  - x SCALING_RATIO to correct the canvas scaling\n            //  - x 2 to correct the formulae\n            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'float border = 0.01;',\n            'float radius = 0.5;',\n\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',\n            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            'float t = 0.0;',\n            'if (dist > border)',\n              't = 1.0;',\n            'else if (dist > 0.0)',\n              't = dist / border;',\n\n            'gl_FragColor = mix(color0, color, t);',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  var __instances = {};\n\n  /**\n   * This is the sigma instances constructor. One instance of sigma represent\n   * one graph. It is possible to represent this grapÄ¥ with several renderers\n   * at the same time. By default, the default renderer (WebGL + Canvas\n   * polyfill) will be used as the only renderer, with the container specified\n   * in the configuration.\n   *\n   * @param  {?*}    conf The configuration of the instance. There are a lot of\n   *                      different recognized forms to instantiate sigma, check\n   *                      example files, documentation in this file and unit\n   *                      tests to know more.\n   * @return {sigma}      The fresh new sigma instance.\n   *\n   * Instanciating sigma:\n   * ********************\n   * If no parameter is given to the constructor, the instance will be created\n   * without any renderer or camera. It will just instantiate the graph, and\n   * other modules will have to be instantiated through the public methods,\n   * like \"addRenderer\" etc:\n   *\n   *  > s0 = new sigma();\n   *  > s0.addRenderer({\n   *  >   type: 'canvas',\n   *  >   container: 'my-container-id'\n   *  > });\n   *\n   * In most of the cases, sigma will simply be used with the default renderer.\n   * Then, since the only required parameter is the DOM container, there are\n   * some simpler way to call the constructor. The four following calls do the\n   * exact same things:\n   *\n   *  > s1 = new sigma('my-container-id');\n   *  > s2 = new sigma(document.getElementById('my-container-id'));\n   *  > s3 = new sigma({\n   *  >   container: document.getElementById('my-container-id')\n   *  > });\n   *  > s4 = new sigma({\n   *  >   renderers: [{\n   *  >     container: document.getElementById('my-container-id')\n   *  >   }]\n   *  > });\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters, when calling the\n   * constructor with to top level configuration object (fourth case in the\n   * previous examples):\n   *\n   *   {?string} id        The id of the instance. It will be generated\n   *                       automatically if not specified.\n   *   {?array}  renderers An array containing objects describing renderers.\n   *   {?object} graph     An object containing an array of nodes and an array\n   *                       of edges, to avoid having to add them by hand later.\n   *   {?object} settings  An object containing instance specific settings that\n   *                       will override the default ones defined in the object\n   *                       sigma.settings.\n   */\n  var sigma = function(conf) {\n    // Local variables:\n    // ****************\n    var i,\n        l,\n        a,\n        c,\n        o,\n        id;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Private attributes:\n    // *******************\n    var _self = this,\n        _conf = conf || {};\n\n    // Little shortcut:\n    // ****************\n    // The configuration is supposed to have a list of the configuration\n    // objects for each renderer.\n    //  - If there are no configuration at all, then nothing is done.\n    //  - If there are no renderer list, the given configuration object will be\n    //    considered as describing the first and only renderer.\n    //  - If there are no renderer list nor \"container\" object, it will be\n    //    considered as the container itself (a DOM element).\n    //  - If the argument passed to sigma() is a string, it will be considered\n    //    as the ID of the DOM container.\n    if (\n      typeof _conf === 'string' ||\n      _conf instanceof HTMLElement\n    )\n      _conf = {\n        renderers: [_conf]\n      };\n    else if (Object.prototype.toString.call(_conf) === '[object Array]')\n      _conf = {\n        renderers: _conf\n      };\n\n    // Also check \"renderer\" and \"container\" keys:\n    o = _conf.renderers || _conf.renderer || _conf.container;\n    if (!_conf.renderers || _conf.renderers.length === 0)\n      if (\n        typeof o === 'string' ||\n        o instanceof HTMLElement ||\n        (typeof o === 'object' && 'container' in o)\n      )\n        _conf.renderers = [o];\n\n    // Recense the instance:\n    if (_conf.id) {\n      if (__instances[_conf.id])\n        throw 'sigma: Instance \"' + _conf.id + '\" already exists.';\n      Object.defineProperty(this, 'id', {\n        value: _conf.id\n      });\n    } else {\n      id = 0;\n      while (__instances[id])\n        id++;\n      Object.defineProperty(this, 'id', {\n        value: '' + id\n      });\n    }\n    __instances[this.id] = this;\n\n    // Initialize settings function:\n    this.settings = new sigma.classes.configurable(\n      sigma.settings,\n      _conf.settings || {}\n    );\n\n    // Initialize locked attributes:\n    Object.defineProperty(this, 'graph', {\n      value: new sigma.classes.graph(this.settings),\n      configurable: true\n    });\n    Object.defineProperty(this, 'middlewares', {\n      value: [],\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameras', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderers', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderersPerCamera', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameraFrames', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'camera', {\n      get: function() {\n        return this.cameras[0];\n      }\n    });\n    Object.defineProperty(this, 'events', {\n      value: [\n        'click',\n        'rightClick',\n        'clickStage',\n        'doubleClickStage',\n        'rightClickStage',\n        'clickNode',\n        'clickNodes',\n        'doubleClickNode',\n        'doubleClickNodes',\n        'rightClickNode',\n        'rightClickNodes',\n        'overNode',\n        'overNodes',\n        'outNode',\n        'outNodes',\n        'downNode',\n        'downNodes',\n        'upNode',\n        'upNodes'\n      ],\n      configurable: true\n    });\n\n    // Add a custom handler, to redispatch events from renderers:\n    this._handler = (function(e) {\n      var k,\n          data = {};\n\n      for (k in e.data)\n        data[k] = e.data[k];\n\n      data.renderer = e.target;\n      this.dispatchEvent(e.type, data);\n    }).bind(this);\n\n    // Initialize renderers:\n    a = _conf.renderers || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addRenderer(a[i]);\n\n    // Initialize middlewares:\n    a = _conf.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.middlewares.push(\n        typeof a[i] === 'string' ?\n          sigma.middlewares[a[i]] :\n          a[i]\n      );\n\n    // Check if there is already a graph to fill in:\n    if (typeof _conf.graph === 'object' && _conf.graph) {\n      this.graph.read(_conf.graph);\n\n      // If a graph is given to the to the instance, the \"refresh\" method is\n      // directly called:\n      this.refresh();\n    }\n\n    // Deal with resize:\n    window.addEventListener('resize', function() {\n      if (_self.settings)\n        _self.refresh();\n    });\n  };\n\n\n\n\n  /**\n   * This methods will instantiate and reference a new camera. If no id is\n   * specified, then an automatic id will be generated.\n   *\n   * @param  {?string}              id Eventually the camera id.\n   * @return {sigma.classes.camera}    The fresh new camera instance.\n   */\n  sigma.prototype.addCamera = function(id) {\n    var self = this,\n        camera;\n\n    if (!arguments.length) {\n      id = 0;\n      while (this.cameras['' + id])\n        id++;\n      id = '' + id;\n    }\n\n    if (this.cameras[id])\n      throw 'sigma.addCamera: The camera \"' + id + '\" already exists.';\n\n    camera = new sigma.classes.camera(id, this.graph, this.settings);\n    this.cameras[id] = camera;\n\n    // Add a quadtree to the camera:\n    camera.quadtree = new sigma.classes.quad();\n\n    // Add an edgequadtree to the camera:\n    if (sigma.classes.edgequad !== undefined) {\n      camera.edgequadtree = new sigma.classes.edgequad();\n    }\n\n    camera.bind('coordinatesUpdated', function(e) {\n      self.renderCamera(camera, camera.isAnimated);\n    });\n\n    this.renderersPerCamera[id] = [];\n\n    return camera;\n  };\n\n  /**\n   * This method kills a camera, and every renderer attached to it.\n   *\n   * @param  {string|camera} v The camera to kill or its ID.\n   * @return {sigma}           Returns the instance.\n   */\n  sigma.prototype.killCamera = function(v) {\n    v = typeof v === 'string' ? this.cameras[v] : v;\n\n    if (!v)\n      throw 'sigma.killCamera: The camera is undefined.';\n\n    var i,\n        l,\n        a = this.renderersPerCamera[v.id];\n\n    for (l = a.length, i = l - 1; i >= 0; i--)\n      this.killRenderer(a[i]);\n\n    delete this.renderersPerCamera[v.id];\n    delete this.cameraFrames[v.id];\n    delete this.cameras[v.id];\n\n    if (v.kill)\n      v.kill();\n\n    return this;\n  };\n\n  /**\n   * This methods will instantiate and reference a new renderer. The \"type\"\n   * argument can be the constructor or its name in the \"sigma.renderers\"\n   * package. If no type is specified, then \"sigma.renderers.def\" will be used.\n   * If no id is specified, then an automatic id will be generated.\n   *\n   * @param  {?object}  options Eventually some options to give to the renderer\n   *                            constructor.\n   * @return {renderer}         The fresh new renderer instance.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?string}            id     Eventually the renderer id.\n   *   {?(function|string)} type   Eventually the renderer constructor or its\n   *                               name in the \"sigma.renderers\" package.\n   *   {?(camera|string)}   camera Eventually the renderer camera or its\n   *                               id.\n   */\n  sigma.prototype.addRenderer = function(options) {\n    var id,\n        fn,\n        camera,\n        renderer,\n        o = options || {};\n\n    // Polymorphism:\n    if (typeof o === 'string')\n      o = {\n        container: document.getElementById(o)\n      };\n    else if (o instanceof HTMLElement)\n      o = {\n        container: o\n      };\n\n    // If the container still is a string, we get it by id\n    if (typeof o.container === 'string')\n      o.container = document.getElementById(o.container);\n\n    // Reference the new renderer:\n    if (!('id' in o)) {\n      id = 0;\n      while (this.renderers['' + id])\n        id++;\n      id = '' + id;\n    } else\n      id = o.id;\n\n    if (this.renderers[id])\n      throw 'sigma.addRenderer: The renderer \"' + id + '\" already exists.';\n\n    // Find the good constructor:\n    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];\n    fn = fn || sigma.renderers.def;\n\n    // Find the good camera:\n    camera = 'camera' in o ?\n      (\n        o.camera instanceof sigma.classes.camera ?\n          o.camera :\n          this.cameras[o.camera] || this.addCamera(o.camera)\n      ) :\n      this.addCamera();\n\n    if (this.cameras[camera.id] !== camera)\n      throw 'sigma.addRenderer: The camera is not properly referenced.';\n\n    // Instantiate:\n    renderer = new fn(this.graph, camera, this.settings, o);\n    this.renderers[id] = renderer;\n    Object.defineProperty(renderer, 'id', {\n      value: id\n    });\n\n    // Bind events:\n    if (renderer.bind)\n      renderer.bind(\n        [\n          'click',\n          'rightClick',\n          'clickStage',\n          'doubleClickStage',\n          'rightClickStage',\n          'clickNode',\n          'clickNodes',\n          'clickEdge',\n          'clickEdges',\n          'doubleClickNode',\n          'doubleClickNodes',\n          'doubleClickEdge',\n          'doubleClickEdges',\n          'rightClickNode',\n          'rightClickNodes',\n          'rightClickEdge',\n          'rightClickEdges',\n          'overNode',\n          'overNodes',\n          'overEdge',\n          'overEdges',\n          'outNode',\n          'outNodes',\n          'outEdge',\n          'outEdges',\n          'downNode',\n          'downNodes',\n          'downEdge',\n          'downEdges',\n          'upNode',\n          'upNodes',\n          'upEdge',\n          'upEdges'\n        ],\n        this._handler\n      );\n\n    // Reference the renderer by its camera:\n    this.renderersPerCamera[camera.id].push(renderer);\n\n    return renderer;\n  };\n\n  /**\n   * This method kills a renderer.\n   *\n   * @param  {string|renderer} v The renderer to kill or its ID.\n   * @return {sigma}             Returns the instance.\n   */\n  sigma.prototype.killRenderer = function(v) {\n    v = typeof v === 'string' ? this.renderers[v] : v;\n\n    if (!v)\n      throw 'sigma.killRenderer: The renderer is undefined.';\n\n    var a = this.renderersPerCamera[v.camera.id],\n        i = a.indexOf(v);\n\n    if (i >= 0)\n      a.splice(i, 1);\n\n    if (v.kill)\n      v.kill();\n\n    delete this.renderers[v.id];\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method calls the \"render\" method of each renderer, with the same\n   * arguments than the \"render\" method, but will also check if the renderer\n   * has a \"process\" method, and call it if it exists.\n   *\n   * It is useful for quadtrees or WebGL processing, for instance.\n   *\n   * @param  {?object}  options Eventually some options to give to the refresh\n   *                            method.\n   * @return {sigma}            Returns the instance itself.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?boolean} skipIndexation A flag specifying wether or not the refresh\n   *                             function should reindex the graph in the\n   *                             quadtrees or not (default: false).\n   */\n  sigma.prototype.refresh = function(options) {\n    var i,\n        l,\n        k,\n        a,\n        c,\n        bounds,\n        prefix = 0;\n\n    options = options || {};\n\n    // Call each middleware:\n    a = this.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      a[i].call(\n        this,\n        (i === 0) ? '' : 'tmp' + prefix + ':',\n        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')\n      );\n\n    // Then, for each camera, call the \"rescale\" middleware, unless the\n    // settings specify not to:\n    for (k in this.cameras) {\n      c = this.cameras[k];\n      if (\n        c.settings('autoRescale') &&\n        this.renderersPerCamera[c.id] &&\n        this.renderersPerCamera[c.id].length\n      )\n        sigma.middlewares.rescale.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix,\n          {\n            width: this.renderersPerCamera[c.id][0].width,\n            height: this.renderersPerCamera[c.id][0].height\n          }\n        );\n      else\n        sigma.middlewares.copy.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix\n        );\n\n      if (!options.skipIndexation) {\n        // Find graph boundaries:\n        bounds = sigma.utils.getBoundaries(\n          this.graph,\n          c.readPrefix\n        );\n\n        // Refresh quadtree:\n        c.quadtree.index(this.graph.nodes(), {\n          prefix: c.readPrefix,\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        });\n\n        // Refresh edgequadtree:\n        if (\n          c.edgequadtree !== undefined &&\n          c.settings('drawEdges') &&\n          c.settings('enableEdgeHovering')\n        ) {\n          c.edgequadtree.index(this.graph, {\n            prefix: c.readPrefix,\n            bounds: {\n              x: bounds.minX,\n              y: bounds.minY,\n              width: bounds.maxX - bounds.minX,\n              height: bounds.maxY - bounds.minY\n            }\n          });\n        }\n      }\n    }\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.renderers[a[i]].process) {\n        if (this.settings('skipErrors'))\n          try {\n            this.renderers[a[i]].process();\n          } catch (e) {\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".process()\"'\n            );\n          }\n        else\n          this.renderers[a[i]].process();\n      }\n\n    this.render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer.\n   *\n   * @return {sigma} Returns the instance itself.\n   */\n  sigma.prototype.render = function() {\n    var i,\n        l,\n        a,\n        prefix = 0;\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.settings('skipErrors'))\n        try {\n          this.renderers[a[i]].render();\n        } catch (e) {\n          if (this.settings('verbose'))\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".render()\"'\n            );\n        }\n      else\n        this.renderers[a[i]].render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer that is bound to\n   * the specified camera. To improve the performances, if this method is\n   * called too often, the number of effective renderings is limitated to one\n   * per frame, unless you are using the \"force\" flag.\n   *\n   * @param  {sigma.classes.camera} camera The camera to render.\n   * @param  {?boolean}             force  If true, will render the camera\n   *                                       directly.\n   * @return {sigma}                       Returns the instance itself.\n   */\n  sigma.prototype.renderCamera = function(camera, force) {\n    var i,\n        l,\n        a,\n        self = this;\n\n    if (force) {\n      a = this.renderersPerCamera[camera.id];\n      for (i = 0, l = a.length; i < l; i++)\n        if (this.settings('skipErrors'))\n          try {\n            a[i].render();\n          } catch (e) {\n            if (this.settings('verbose'))\n              console.log(\n                'Warning: The renderer \"' + a[i].id + '\" crashed on \".render()\"'\n              );\n          }\n        else\n          a[i].render();\n    } else {\n      if (!this.cameraFrames[camera.id]) {\n        a = this.renderersPerCamera[camera.id];\n        for (i = 0, l = a.length; i < l; i++)\n          if (this.settings('skipErrors'))\n            try {\n              a[i].render();\n            } catch (e) {\n              if (this.settings('verbose'))\n                console.log(\n                  'Warning: The renderer \"' +\n                    a[i].id +\n                    '\" crashed on \".render()\"'\n                );\n            }\n          else\n            a[i].render();\n\n        this.cameraFrames[camera.id] = requestAnimationFrame(function() {\n          delete self.cameraFrames[camera.id];\n        });\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"kill\" method of each module and destroys any\n   * reference from the instance.\n   */\n  sigma.prototype.kill = function() {\n    var k;\n\n    // Dispatching event\n    this.dispatchEvent('kill');\n\n    // Kill graph:\n    this.graph.kill();\n\n    // Kill middlewares:\n    delete this.middlewares;\n\n    // Kill each renderer:\n    for (k in this.renderers)\n      this.killRenderer(this.renderers[k]);\n\n    // Kill each camera:\n    for (k in this.cameras)\n      this.killCamera(this.cameras[k]);\n\n    delete this.renderers;\n    delete this.cameras;\n\n    // Kill everything else:\n    for (k in this)\n      if (this.hasOwnProperty(k))\n        delete this[k];\n\n    delete __instances[this.id];\n  };\n\n\n\n\n  /**\n   * Returns a clone of the instances object or a specific running instance.\n   *\n   * @param  {?string} id Eventually an instance ID.\n   * @return {object}     The related instance or a clone of the instances\n   *                      object.\n   */\n  sigma.instances = function(id) {\n    return arguments.length ?\n      __instances[id] :\n      sigma.utils.extend({}, __instances);\n  };\n\n\n\n  /**\n   * The current version of sigma:\n   */\n  sigma.version = '1.2.0';\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined')\n    throw 'An object called sigma is already in the global scope.';\n\n  this.sigma = sigma;\n\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Packages initialization:\n  sigma.utils.pkg('sigma.settings');\n\n  var settings = {\n    /**\n     * GRAPH SETTINGS:\n     * ***************\n     */\n    // {boolean} Indicates if the data have to be cloned in methods to add\n    //           nodes or edges.\n    clone: true,\n    // {boolean} Indicates if nodes \"id\" values and edges \"id\", \"source\" and\n    //           \"target\" values must be set as immutable.\n    immutable: true,\n    // {boolean} Indicates if sigma can log its errors and warnings.\n    verbose: false,\n\n\n    /**\n     * RENDERERS SETTINGS:\n     * *******************\n     */\n    // {string}\n    classPrefix: 'sigma',\n    // {string}\n    defaultNodeType: 'def',\n    // {string}\n    defaultEdgeType: 'def',\n    // {string}\n    defaultLabelColor: '#000',\n    // {string}\n    defaultEdgeColor: '#000',\n    // {string}\n    defaultNodeColor: '#000',\n    // {string}\n    defaultLabelSize: 14,\n    // {string} Indicates how to choose the edges color. Available values:\n    //          \"source\", \"target\", \"default\"\n    edgeColor: 'source',\n    // {number} Defines the minimal edge's arrow display size.\n    minArrowSize: 0,\n    // {string}\n    font: 'arial',\n    // {string} Example: 'bold'\n    fontStyle: '',\n    // {string} Indicates how to choose the labels color. Available values:\n    //          \"node\", \"default\"\n    labelColor: 'default',\n    // {string} Indicates how to choose the labels size. Available values:\n    //          \"fixed\", \"proportional\"\n    labelSize: 'fixed',\n    // {string} The ratio between the font size of the label and the node size.\n    labelSizeRatio: 1,\n    // {number} The minimum size a node must have to see its label displayed.\n    labelThreshold: 8,\n    // {number} The oversampling factor used in WebGL renderer.\n    webglOversamplingRatio: 2,\n    // {number} The size of the border of hovered nodes.\n    borderSize: 0,\n    // {number} The default hovered node border's color.\n    defaultNodeBorderColor: '#000',\n    // {number} The hovered node's label font. If not specified, will heritate\n    //          the \"font\" value.\n    hoverFont: '',\n    // {boolean} If true, then only one node can be hovered at a time.\n    singleHover: true,\n    // {string} Example: 'bold'\n    hoverFontStyle: '',\n    // {string} Indicates how to choose the hovered nodes shadow color.\n    //          Available values: \"node\", \"default\"\n    labelHoverShadow: 'default',\n    // {string}\n    labelHoverShadowColor: '#000',\n    // {string} Indicates how to choose the hovered nodes color.\n    //          Available values: \"node\", \"default\"\n    nodeHoverColor: 'node',\n    // {string}\n    defaultNodeHoverColor: '#000',\n    // {string} Indicates how to choose the hovered nodes background color.\n    //          Available values: \"node\", \"default\"\n    labelHoverBGColor: 'default',\n    // {string}\n    defaultHoverLabelBGColor: '#fff',\n    // {string} Indicates how to choose the hovered labels color.\n    //          Available values: \"node\", \"default\"\n    labelHoverColor: 'default',\n    // {string}\n    defaultLabelHoverColor: '#000',\n    // {string} Indicates how to choose the edges hover color. Available values:\n    //          \"edge\", \"default\"\n    edgeHoverColor: 'edge',\n    // {number} The size multiplicator of hovered edges.\n    edgeHoverSizeRatio: 1,\n    // {string}\n    defaultEdgeHoverColor: '#000',\n    // {boolean} Indicates if the edge extremities must be hovered when the\n    //           edge is hovered.\n    edgeHoverExtremities: false,\n    // {booleans} The different drawing modes:\n    //           false: Layered not displayed.\n    //           true: Layered displayed.\n    drawEdges: true,\n    drawNodes: true,\n    drawLabels: true,\n    drawEdgeLabels: false,\n    // {boolean} Indicates if the edges must be drawn in several frames or in\n    //           one frame, as the nodes and labels are drawn.\n    batchEdgesDrawing: false,\n    // {boolean} Indicates if the edges must be hidden during dragging and\n    //           animations.\n    hideEdgesOnMove: false,\n    // {numbers} The different batch sizes, when elements are displayed in\n    //           several frames.\n    canvasEdgesBatchSize: 500,\n    webglEdgesBatchSize: 1000,\n\n\n\n\n    /**\n     * RESCALE SETTINGS:\n     * *****************\n     */\n    // {string} Indicates of to scale the graph relatively to its container.\n    //          Available values: \"inside\", \"outside\"\n    scalingMode: 'inside',\n    // {number} The margin to keep around the graph.\n    sideMargin: 0,\n    // {number} Determine the size of the smallest and the biggest node / edges\n    //          on the screen. This mapping makes easier to display the graph,\n    //          avoiding too big nodes that take half of the screen, or too\n    //          small ones that are not readable. If the two parameters are\n    //          equals, then the minimal display size will be 0. And if they\n    //          are both equal to 0, then there is no mapping, and the radius\n    //          of the nodes will be their size.\n    minEdgeSize: 0.5,\n    maxEdgeSize: 1,\n    minNodeSize: 1,\n    maxNodeSize: 8,\n\n\n\n\n    /**\n     * CAPTORS SETTINGS:\n     * *****************\n     */\n    // {boolean}\n    touchEnabled: true,\n    // {boolean}\n    mouseEnabled: true,\n    // {boolean}\n    mouseWheelEnabled: true,\n    // {boolean}\n    doubleClickEnabled: true,\n    // {boolean} Defines whether the custom events such as \"clickNode\" can be\n    //           used.\n    eventsEnabled: true,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms with the mouse-wheel.\n    zoomingRatio: 1.7,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms by double clicking.\n    doubleClickZoomingRatio: 2.2,\n    // {number} The minimum zooming level.\n    zoomMin: 0.0625,\n    // {number} The maximum zooming level.\n    zoomMax: 2,\n    // {number} The duration of animations following a mouse scrolling.\n    mouseZoomDuration: 200,\n    // {number} The duration of animations following a mouse double click.\n    doubleClickZoomDuration: 200,\n    // {number} The duration of animations following a mouse dropping.\n    mouseInertiaDuration: 200,\n    // {number} The inertia power (mouse captor).\n    mouseInertiaRatio: 3,\n    // {number} The duration of animations following a touch dropping.\n    touchInertiaDuration: 200,\n    // {number} The inertia power (touch captor).\n    touchInertiaRatio: 3,\n    // {number} The maximum time between two clicks to make it a double click.\n    doubleClickTimeout: 300,\n    // {number} The maximum time between two taps to make it a double tap.\n    doubleTapTimeout: 300,\n    // {number} The maximum time of dragging to trigger intertia.\n    dragTimeout: 200,\n\n\n\n\n    /**\n     * GLOBAL SETTINGS:\n     * ****************\n     */\n    // {boolean} Determines whether the instance has to refresh itself\n    //           automatically when a \"resize\" event is dispatched from the\n    //           window object.\n    autoResize: true,\n    // {boolean} Determines whether the \"rescale\" middleware has to be called\n    //           automatically for each camera on refresh.\n    autoRescale: true,\n    // {boolean} If set to false, the camera method \"goTo\" will basically do\n    //           nothing.\n    enableCamera: true,\n    // {boolean} If set to false, the nodes cannot be hovered.\n    enableHovering: true,\n    // {boolean} If set to true, the edges can be hovered.\n    enableEdgeHovering: false,\n    // {number} The size of the area around the edges to activate hovering.\n    edgeHoverPrecision: 5,\n    // {boolean} If set to true, the rescale middleware will ignore node sizes\n    //           to determine the graphs boundings.\n    rescaleIgnoreSize: false,\n    // {boolean} Determines if the core has to try to catch errors on\n    //           rendering.\n    skipErrors: false,\n\n\n\n\n    /**\n     * CAMERA SETTINGS:\n     * ****************\n     */\n    // {number} The power degrees applied to the nodes/edges size relatively to\n    //          the zooming level. Basically:\n    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R\n    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T\n    nodesPowRatio: 0.5,\n    edgesPowRatio: 0.5,\n\n\n\n\n    /**\n     * ANIMATIONS SETTINGS:\n     * ********************\n     */\n    // {number} The default animation time.\n    animationsTime: 200\n  };\n\n  // Export the previously designed settings:\n  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);\n}).call(this);\n"},function(e,n){e.exports=";(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  var _root = this;\n\n  // Initialize packages:\n  sigma.utils = sigma.utils || {};\n\n  /**\n   * MISC UTILS:\n   */\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when several objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > sigma.utils.extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {object+} Any number of objects.\n   * @return {object}  The merged object.\n   */\n  sigma.utils.extend = function() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  };\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  sigma.utils.dateNow = function() {\n    return Date.now ? Date.now() : new Date().getTime();\n  };\n\n  /**\n   * Takes a package name as parameter and checks at each lebel if it exists,\n   * and if it does not, creates it.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.pkg('a.b.c');\n   *  > a.b.c;\n   *  > // Object {};\n   *  >\n   *  > sigma.utils.pkg('a.b.d');\n   *  > a.b;\n   *  > // Object { c: {}, d: {} };\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.pkg = function(pkgName) {\n    return (pkgName || '').split('.').reduce(function(context, objName) {\n      return (objName in context) ?\n        context[objName] :\n        (context[objName] = {});\n    }, _root);\n  };\n\n  /**\n   * Returns a unique incremental number ID.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.id();\n   *  > // 1;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 2;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 3;\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.id = (function() {\n    var i = 0;\n    return function() {\n      return ++i;\n    };\n  })();\n\n  /**\n   * This function takes an hexa color (for instance \"#ffcc00\" or \"#fc0\") or a\n   * rgb / rgba color (like \"rgb(255,255,12)\" or \"rgba(255,255,12,1)\") and\n   * returns an integer equal to \"r * 255 * 255 + g * 255 + b\", to gain some\n   * memory in the data given to WebGL shaders.\n   *\n   * Note that the function actually caches its results for better performance.\n   *\n   * @param  {string} val The hexa or rgba color.\n   * @return {number}     The number value.\n   */\n  var floatColorCache = {};\n\n  sigma.utils.floatColor = function(val) {\n\n    // Is the color already computed?\n    if (floatColorCache[val])\n      return floatColorCache[val];\n\n    var original = val,\n        r = 0,\n        g = 0,\n        b = 0;\n\n    if (val[0] === '#') {\n      val = val.slice(1);\n\n      if (val.length === 3) {\n        r = parseInt(val.charAt(0) + val.charAt(0), 16);\n        g = parseInt(val.charAt(1) + val.charAt(1), 16);\n        b = parseInt(val.charAt(2) + val.charAt(2), 16);\n      }\n      else {\n        r = parseInt(val.charAt(0) + val.charAt(1), 16);\n        g = parseInt(val.charAt(2) + val.charAt(3), 16);\n        b = parseInt(val.charAt(4) + val.charAt(5), 16);\n      }\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      r = +val[1];\n      g = +val[2];\n      b = +val[3];\n    }\n\n    var color = (\n      r * 256 * 256 +\n      g * 256 +\n      b\n    );\n\n    // Caching the color\n    floatColorCache[original] = color;\n\n    return color;\n  };\n\n    /**\n   * Perform a zoom into a camera, with or without animation, to the\n   * coordinates indicated using a specified ratio.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the animation\n   * object:\n   *\n   *   {?number} duration     An amount of time that means the duration of the\n   *                          animation. If this parameter doesn't exist the\n   *                          zoom will be performed without animation.\n   *   {?function} onComplete A function to perform it after the animation. It\n   *                          will be performed even if there is no duration.\n   *\n   * @param {camera}     The camera where perform the zoom.\n   * @param {x}          The X coordiantion where the zoom goes.\n   * @param {y}          The Y coordiantion where the zoom goes.\n   * @param {ratio}      The ratio to apply it to the current camera ratio.\n   * @param {?animation} A dictionary with options for a possible animation.\n   */\n  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {\n    var settings = camera.settings,\n        count,\n        newRatio,\n        animationSettings,\n        coordinates;\n\n    // Create the newRatio dealing with min / max:\n    newRatio = Math.max(\n      settings('zoomMin'),\n      Math.min(\n        settings('zoomMax'),\n        camera.ratio * ratio\n      )\n    );\n\n    // Check that the new ratio is different from the initial one:\n    if (newRatio !== camera.ratio) {\n      // Create the coordinates variable:\n      ratio = newRatio / camera.ratio;\n      coordinates = {\n        x: x * (1 - ratio) + camera.x,\n        y: y * (1 - ratio) + camera.y,\n        ratio: newRatio\n      };\n\n      if (animation && animation.duration) {\n        // Complete the animation setings:\n        count = sigma.misc.animation.killAll(camera);\n        animation = sigma.utils.extend(\n          animation,\n          {\n            easing: count ? 'quadraticOut' : 'quadraticInOut'\n          }\n        );\n\n        sigma.misc.animation.camera(camera, coordinates, animation);\n      } else {\n        camera.goTo(coordinates);\n        if (animation && animation.onComplete)\n          animation.onComplete();\n      }\n    }\n  };\n\n  /**\n   * Return the control point coordinates for a quadratic bezier curve.\n   *\n   * @param  {number} x1  The X coordinate of the start point.\n   * @param  {number} y1  The Y coordinate of the start point.\n   * @param  {number} x2  The X coordinate of the end point.\n   * @param  {number} y2  The Y coordinate of the end point.\n   * @return {x,y}        The control point coordinates.\n   */\n  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {\n    return {\n      x: (x1 + x2) / 2 + (y2 - y1) / 4,\n      y: (y1 + y2) / 2 + (x1 - x2) / 4\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the quadratic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the ending point.\n    * @param  {number} y2 The Y coordinate of the ending point.\n    * @param  {number} xi The X coordinate of the control point.\n    * @param  {number} yi The Y coordinate of the control point.\n    * @return {object}    {x,y}.\n  */\n  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {\n    // http://stackoverflow.com/a/5634528\n    return {\n      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,\n      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the cubic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the end point.\n    * @param  {number} y2 The Y coordinate of the end point.\n    * @param  {number} cx The X coordinate of the first control point.\n    * @param  {number} cy The Y coordinate of the first control point.\n    * @param  {number} dx The X coordinate of the second control point.\n    * @param  {number} dy The Y coordinate of the second control point.\n    * @return {object}    {x,y} The point at t.\n  */\n  sigma.utils.getPointOnBezierCurve =\n    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {\n    // http://stackoverflow.com/a/15397596\n    // Blending functions:\n    var B0_t = Math.pow(1 - t, 3),\n        B1_t = 3 * t * Math.pow(1 - t, 2),\n        B2_t = 3 * Math.pow(t, 2) * (1 - t),\n        B3_t = Math.pow(t, 3);\n\n    return {\n      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),\n      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)\n    };\n  };\n\n  /**\n   * Return the coordinates of the two control points for a self loop (i.e.\n   * where the start point is also the end point) computed as a cubic bezier\n   * curve.\n   *\n   * @param  {number} x    The X coordinate of the node.\n   * @param  {number} y    The Y coordinate of the node.\n   * @param  {number} size The node size.\n   * @return {x1,y1,x2,y2} The coordinates of the two control points.\n   */\n  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {\n    return {\n      x1: x - size * 7,\n      y1: y,\n      x2: x,\n      y2: y + size * 7\n    };\n  };\n\n  /**\n   * Return the euclidian distance between two points of a plane\n   * with an orthonormal basis.\n   *\n   * @param  {number} x1  The X coordinate of the first point.\n   * @param  {number} y1  The Y coordinate of the first point.\n   * @param  {number} x2  The X coordinate of the second point.\n   * @param  {number} y2  The Y coordinate of the second point.\n   * @return {number}     The euclidian distance.\n   */\n  sigma.utils.getDistance = function(x0, y0, x1, y1) {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  };\n\n  /**\n   * Return the coordinates of the intersection points of two circles.\n   *\n   * @param  {number} x0  The X coordinate of center location of the first\n   *                      circle.\n   * @param  {number} y0  The Y coordinate of center location of the first\n   *                      circle.\n   * @param  {number} r0  The radius of the first circle.\n   * @param  {number} x1  The X coordinate of center location of the second\n   *                      circle.\n   * @param  {number} y1  The Y coordinate of center location of the second\n   *                      circle.\n   * @param  {number} r1  The radius of the second circle.\n   * @return {xi,yi}      The coordinates of the intersection points.\n   */\n  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {\n    // http://stackoverflow.com/a/12219802\n    var a, dx, dy, d, h, rx, ry, x2, y2;\n\n    // dx and dy are the vertical and horizontal distances between the circle\n    // centers:\n    dx = x1 - x0;\n    dy = y1 - y0;\n\n    // Determine the straight-line distance between the centers:\n    d = Math.sqrt((dy * dy) + (dx * dx));\n\n    // Check for solvability:\n    if (d > (r0 + r1)) {\n        // No solution. circles do not intersect.\n        return false;\n    }\n    if (d < Math.abs(r0 - r1)) {\n        // No solution. one circle is contained in the other.\n        return false;\n    }\n\n    //'point 2' is the point where the line through the circle intersection\n    // points crosses the line between the circle centers.\n\n    // Determine the distance from point 0 to point 2:\n    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);\n\n    // Determine the coordinates of point 2:\n    x2 = x0 + (dx * a / d);\n    y2 = y0 + (dy * a / d);\n\n    // Determine the distance from point 2 to either of the intersection\n    // points:\n    h = Math.sqrt((r0 * r0) - (a * a));\n\n    // Determine the offsets of the intersection points from point 2:\n    rx = -dy * (h / d);\n    ry = dx * (h / d);\n\n    // Determine the absolute intersection points:\n    var xi = x2 + rx;\n    var xi_prime = x2 - rx;\n    var yi = y2 + ry;\n    var yi_prime = y2 - ry;\n\n    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};\n  };\n\n  /**\n    * Check if a point is on a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if point is \"close to\" the line\n    *                          segment, false otherwise.\n  */\n  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {\n    // http://stackoverflow.com/a/328122\n    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),\n        d = sigma.utils.getDistance(x1, y1, x2, y2),\n        nCrossProduct = crossProduct / d; // normalized cross product\n\n    return (nCrossProduct < epsilon &&\n     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&\n     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));\n  };\n\n  /**\n    * Check if a point is on a quadratic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx     The X coordinate of the curve control point.\n    * @param  {number} cpy     The Y coordinate of the curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnQuadraticCurve =\n    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);\n    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n    * Check if a point is on a cubic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx1    The X coordinate of the 1st curve control point.\n    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.\n    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.\n    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnBezierCurve =\n    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);\n    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnBezierCurve(\n          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnBezierCurve(\n        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n   * ************\n   * EVENTS UTILS:\n   * ************\n   */\n  /**\n   * Here are some useful functions to unify extraction of the information we\n   * need with mouse events and touch events, from different browsers:\n   */\n\n  /**\n   * Extract the local X position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local X value of the mouse.\n   */\n  sigma.utils.getX = function(e) {\n    return (\n      (e.offsetX !== undefined && e.offsetX) ||\n      (e.layerX !== undefined && e.layerX) ||\n      (e.clientX !== undefined && e.clientX)\n    );\n  };\n\n  /**\n   * Extract the local Y position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local Y value of the mouse.\n   */\n  sigma.utils.getY = function(e) {\n    return (\n      (e.offsetY !== undefined && e.offsetY) ||\n      (e.layerY !== undefined && e.layerY) ||\n      (e.clientY !== undefined && e.clientY)\n    );\n  };\n\n  /**\n   * The pixel ratio of the screen. Taking zoom into account\n   *\n   * @return {number}        Pixel ratio of the screen\n   */\n  sigma.utils.getPixelRatio = function() {\n    var ratio = 1;\n    if (window.screen.deviceXDPI !== undefined &&\n         window.screen.logicalXDPI !== undefined &&\n         window.screen.deviceXDPI > window.screen.logicalXDPI) {\n        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;\n    }\n    else if (window.devicePixelRatio !== undefined) {\n        ratio = window.devicePixelRatio;\n    }\n    return ratio;\n  };\n\n  /**\n   * Extract the width from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The width of the event's target.\n   */\n  sigma.utils.getWidth = function(e) {\n    var w = (!e.target.ownerSVGElement) ?\n              e.target.width :\n              e.target.ownerSVGElement.width;\n\n    return (\n      (typeof w === 'number' && w) ||\n      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the center from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {object}   The center of the event's target.\n   */\n  sigma.utils.getCenter = function(e) {\n    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :\n        sigma.utils.getPixelRatio();\n    return {\n      x: sigma.utils.getWidth(e) / (2 * ratio),\n      y: sigma.utils.getHeight(e) / (2 * ratio)\n    };\n  };\n\n  /**\n   * Convert mouse coords to sigma coords\n   *\n   * @param  {event}   e A mouse or touch event.\n   * @param  {number?} x The x coord to convert\n   * @param  {number?} x The y coord to convert\n   *\n   * @return {object}    The standardized event\n   */\n  sigma.utils.mouseCoords = function(e, x, y) {\n    x = x || sigma.utils.getX(e);\n    y = y || sigma.utils.getY(e);\n    return {\n        x: x - sigma.utils.getCenter(e).x,\n        y: y - sigma.utils.getCenter(e).y,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey\n    };\n  };\n\n  /**\n   * Extract the height from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The height of the event's target.\n   */\n  sigma.utils.getHeight = function(e) {\n    var h = (!e.target.ownerSVGElement) ?\n              e.target.height :\n              e.target.ownerSVGElement.height;\n\n    return (\n      (typeof h === 'number' && h) ||\n      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the wheel delta from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The wheel delta of the mouse.\n   */\n  sigma.utils.getDelta = function(e) {\n    return (\n      (e.wheelDelta !== undefined && e.wheelDelta) ||\n      (e.detail !== undefined && -e.detail)\n    );\n  };\n\n  /**\n   * Returns the offset of a DOM element.\n   *\n   * @param  {DOMElement} dom The element to retrieve the position.\n   * @return {object}         The offset of the DOM element (top, left).\n   */\n  sigma.utils.getOffset = function(dom) {\n    var left = 0,\n        top = 0;\n\n    while (dom) {\n      top = top + parseInt(dom.offsetTop);\n      left = left + parseInt(dom.offsetLeft);\n      dom = dom.offsetParent;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n\n  /**\n   * Simulates a \"double click\" event.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   * @param  {function}    callback The callback to execute.\n   */\n  sigma.utils.doubleClick = function(target, type, callback) {\n    var clicks = 0,\n        self = this,\n        handlers;\n\n    target._doubleClickHandler = target._doubleClickHandler || {};\n    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];\n    handlers = target._doubleClickHandler[type];\n\n    handlers.push(function(e) {\n      clicks++;\n\n      if (clicks === 2) {\n        clicks = 0;\n        return callback(e);\n      } else if (clicks === 1) {\n        setTimeout(function() {\n          clicks = 0;\n        }, sigma.settings.doubleClickTimeout);\n      }\n    });\n\n    target.addEventListener(type, handlers[handlers.length - 1], false);\n  };\n\n  /**\n   * Unbind simulated \"double click\" events.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   */\n  sigma.utils.unbindDoubleClick = function(target, type) {\n    var handler,\n        handlers = (target._doubleClickHandler || {})[type] || [];\n\n    while ((handler = handlers.pop())) {\n      target.removeEventListener(type, handler);\n    }\n\n    delete (target._doubleClickHandler || {})[type];\n  };\n\n\n\n\n  /**\n   * Here are just some of the most basic easing functions, used for the\n   * animated camera \"goTo\" calls.\n   *\n   * If you need some more easings functions, don't hesitate to add them to\n   * sigma.utils.easings. But I will not add some more here or merge PRs\n   * containing, because I do not want sigma sources full of overkill and never\n   * used stuff...\n   */\n  sigma.utils.easings = sigma.utils.easings || {};\n  sigma.utils.easings.linearNone = function(k) {\n    return k;\n  };\n  sigma.utils.easings.quadraticIn = function(k) {\n    return k * k;\n  };\n  sigma.utils.easings.quadraticOut = function(k) {\n    return k * (2 - k);\n  };\n  sigma.utils.easings.quadraticInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k;\n    return - 0.5 * (--k * (k - 2) - 1);\n  };\n  sigma.utils.easings.cubicIn = function(k) {\n    return k * k * k;\n  };\n  sigma.utils.easings.cubicOut = function(k) {\n    return --k * k * k + 1;\n  };\n  sigma.utils.easings.cubicInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n  };\n\n\n\n\n  /**\n   * ************\n   * WEBGL UTILS:\n   * ************\n   */\n  /**\n   * Loads a WebGL shader and returns it.\n   *\n   * @param  {WebGLContext}           gl           The WebGLContext to use.\n   * @param  {string}                 shaderSource The shader source.\n   * @param  {number}                 shaderType   The type of shader.\n   * @param  {function(string): void} error        Callback for errors.\n   * @return {WebGLShader}                         The created shader.\n   */\n  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {\n    var compiled,\n        shader = gl.createShader(shaderType);\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    // If something went wrong:\n    if (!compiled) {\n      if (error) {\n        error(\n          'Error compiling shader \"' + shader + '\":' +\n          gl.getShaderInfoLog(shader)\n        );\n      }\n\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  };\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.\n   * @param  {Array.<string>}         attribs   The attribs names.\n   * @param  {Array.<number>}         locations The locations for the attribs.\n   * @param  {function(string): void} error     Callback for errors.\n   * @return {WebGLProgram}                     The created program.\n   */\n  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {\n    var i,\n        linked,\n        program = gl.createProgram();\n\n    for (i = 0; i < shaders.length; ++i)\n      gl.attachShader(program, shaders[i]);\n\n    if (attribs)\n      for (i = 0; i < attribs.length; ++i)\n        gl.bindAttribLocation(\n          program,\n          locations ? locations[i] : i,\n          opt_attribs[i]\n        );\n\n    gl.linkProgram(program);\n\n    // Check the link status\n    linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n      if (error)\n        error('Error in program linking: ' + gl.getProgramInfoLog(program));\n\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    return program;\n  };\n\n\n\n\n  /**\n   * *********\n   * MATRICES:\n   * *********\n   * The following utils are just here to help generating the transformation\n   * matrices for the WebGL renderers.\n   */\n  sigma.utils.pkg('sigma.utils.matrices');\n\n  /**\n   * The returns a 3x3 translation matrix.\n   *\n   * @param  {number} dx The X translation.\n   * @param  {number} dy The Y translation.\n   * @return {array}     Returns the matrix.\n   */\n  sigma.utils.matrices.translation = function(dx, dy) {\n    return [\n      1, 0, 0,\n      0, 1, 0,\n      dx, dy, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 rotation matrix.\n   *\n   * @param  {number}  angle The rotation angle.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.rotation = function(angle, m2) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    return m2 ? [\n      cos, -sin,\n      sin, cos\n    ] : [\n      cos, -sin, 0,\n      sin, cos, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {number}  ratio The scaling ratio.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.scale = function(ratio, m2) {\n    return m2 ? [\n      ratio, 0,\n      0, ratio\n    ] : [\n      ratio, 0, 0,\n      0, ratio, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {array}   a  The first matrix.\n   * @param  {array}   b  The second matrix.\n   * @param  {boolean} m2 If true, the function will assume both matrices are\n   *                      2x2.\n   * @return {array}      Returns the matrix.\n   */\n  sigma.utils.matrices.multiply = function(a, b, m2) {\n    var l = m2 ? 2 : 3,\n        a00 = a[0 * l + 0],\n        a01 = a[0 * l + 1],\n        a02 = a[0 * l + 2],\n        a10 = a[1 * l + 0],\n        a11 = a[1 * l + 1],\n        a12 = a[1 * l + 2],\n        a20 = a[2 * l + 0],\n        a21 = a[2 * l + 1],\n        a22 = a[2 * l + 2],\n        b00 = b[0 * l + 0],\n        b01 = b[0 * l + 1],\n        b02 = b[0 * l + 2],\n        b10 = b[1 * l + 0],\n        b11 = b[1 * l + 1],\n        b12 = b[1 * l + 2],\n        b20 = b[2 * l + 0],\n        b21 = b[2 * l + 1],\n        b22 = b[2 * l + 2];\n\n    return m2 ? [\n      a00 * b00 + a01 * b10,\n      a00 * b01 + a01 * b11,\n      a10 * b00 + a11 * b10,\n      a10 * b01 + a11 * b11\n    ] : [\n      a00 * b00 + a01 * b10 + a02 * b20,\n      a00 * b01 + a01 * b11 + a02 * b21,\n      a00 * b02 + a01 * b12 + a02 * b22,\n      a10 * b00 + a11 * b10 + a12 * b20,\n      a10 * b01 + a11 * b11 + a12 * b21,\n      a10 * b02 + a11 * b12 + a12 * b22,\n      a20 * b00 + a21 * b10 + a22 * b20,\n      a20 * b01 + a21 * b11 + a22 * b21,\n      a20 * b02 + a21 * b12 + a22 * b22\n    ];\n  };\n}).call(this);\n"},function(e,n,t){t(0)(t(112))},function(e,n,t){t(0)(t(113))},function(e,n,t){t(0)(t(114))},function(e,n,t){t(0)(t(115))},function(e,n,t){t(0)(t(116))},function(e,n,t){t(0)(t(117))},function(e,n,t){t(0)(t(118))},function(e,n,t){t(0)(t(119))},function(e,n,t){t(0)(t(120))},function(e,n,t){t(0)(t(121))},function(e,n,t){t(0)(t(122))},function(e,n,t){t(0)(t(123))},function(e,n,t){t(0)(t(124))},function(e,n,t){t(0)(t(125))},function(e,n,t){t(0)(t(126))},function(e,n,t){t(0)(t(127))},function(e,n,t){t(0)(t(128))},function(e,n,t){t(0)(t(129))},function(e,n,t){t(0)(t(130))},function(e,n,t){t(0)(t(131))},function(e,n,t){t(0)(t(132))},function(e,n,t){t(0)(t(133))},function(e,n,t){t(0)(t(134))},function(e,n,t){t(0)(t(135))},function(e,n,t){t(0)(t(136))},function(e,n,t){t(0)(t(137))},function(e,n,t){t(0)(t(138))},function(e,n,t){t(0)(t(139))},function(e,n,t){t(0)(t(140))},function(e,n,t){t(0)(t(141))},function(e,n,t){t(0)(t(142))},function(e,n,t){t(0)(t(143))},function(e,n,t){t(0)(t(144))},function(e,n,t){t(0)(t(145))},function(e,n,t){t(0)(t(146))},function(e,n,t){t(0)(t(147))},function(e,n,t){t(0)(t(148))},function(e,n,t){t(0)(t(149))},function(e,n,t){t(0)(t(150))},function(e,n,t){t(0)(t(151))},function(e,n,t){t(0)(t(152))},function(e,n,t){t(0)(t(153))},function(e,n,t){t(0)(t(154))},function(e,n,t){t(0)(t(155))},function(e,n,t){t(0)(t(156))},function(e,n,t){t(0)(t(157))},function(e,n,t){t(0)(t(158))},function(e,n,t){t(0)(t(159))},function(e,n,t){t(0)(t(160))},function(e,n){e.exports=require("babel-core")},function(e,n){e.exports=require("brace/ext/language_tools")},function(e,n){e.exports=require("brace/ext/searchbox")},function(e,n){e.exports=require("brace/mode/javascript")},function(e,n){e.exports=require("brace/mode/markdown")},function(e,n){e.exports=require("brace/mode/plain_text")},function(e,n){e.exports=require("brace/snippets/javascript")},function(e,n){e.exports=require("brace/theme/katzenmilch")},function(e,n){e.exports=require("brace/theme/monokai")},function(e,n){e.exports=require("brace/theme/solarized_light")},function(e,n){e.exports=require("brace/theme/tomorrow_night")},function(e,n){e.exports=require("brace/theme/tomorrow_night_eighties")},function(e,n){e.exports=require("buckets-js")},function(e,n){e.exports=require("chroma-js")},function(e,n){e.exports=require("classnames")},function(e,n){e.exports=require("electron")},function(e,n){e.exports=require("js-interpreter")},function(e,n){e.exports=require("lodash.pick")},function(e,n){e.exports=require("lodash.sample")},function(e,n){e.exports=require("lodash.union")},function(e,n){e.exports=require("lodash.without")},function(e,n){e.exports=require("material-ui/Dialog")},function(e,n){e.exports=require("material-ui/IconMenu")},function(e,n){e.exports=require("material-ui/LinearProgress")},function(e,n){e.exports=require("material-ui/RaisedButton")},function(e,n){e.exports=require("material-ui/Snackbar")},function(e,n){e.exports=require("material-ui/Table")},function(e,n){e.exports=require("material-ui/svg-icons/action/done")},function(e,n){e.exports=require("material-ui/svg-icons/av/fast-forward")},function(e,n){e.exports=require("material-ui/svg-icons/av/fast-rewind")},function(e,n){e.exports=require("material-ui/svg-icons/av/pause")},function(e,n){e.exports=require("material-ui/svg-icons/av/play-arrow")},function(e,n){e.exports=require("material-ui/svg-icons/av/skip-next")},function(e,n){e.exports=require("material-ui/svg-icons/av/skip-previous")},function(e,n){e.exports=require("material-ui/svg-icons/content/block")},function(e,n){e.exports=require("material-ui/svg-icons/hardware/keyboard-arrow-left")},function(e,n){e.exports=require("material-ui/svg-icons/hardware/keyboard-arrow-right")},function(e,n){e.exports=require("material-ui/svg-icons/navigation/arrow-back")},function(e,n){e.exports=require("material-ui/svg-icons/navigation/more-vert")},function(e,n){e.exports=require("material-ui/svg-icons/navigation/refresh")},function(e,n){e.exports=require("node-localstorage")},function(e,n){e.exports=require("path")},function(e,n){e.exports=require("react-ace")},function(e,n){e.exports=require("react-dom")},function(e,n){e.exports=require("react-hot-loader")},function(e,n){e.exports=require("react-markdown")},function(e,n){e.exports=require("react-promise")},function(e,n){e.exports=require("react-tap-event-plugin")},function(e,n,t){e.exports=t(36)}]);